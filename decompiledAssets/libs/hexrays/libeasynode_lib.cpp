/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_7120();
// void *memcpy(void *dest, const void *src, size_t n);
// FILE *fopen(const char *filename, const char *modes);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void *memchr(const void *s, int c, size_t n);
// __int64 __fastcall __FD_ISSET_chk(_QWORD, _QWORD, _QWORD); weak
__int64 maintest(void); // idb
__int64 mqtt_create();
void __fastcall mg_log(const char *a1);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
// char *strncpy(char *dest, const char *src, size_t n);
__int64 __fastcall mg_vprintf(__int64 a1, const char *a2, __int128 *a3);
// int usleep(__useconds_t useconds);
unsigned __int64 __fastcall mg_ws_send(__int64 a1, void *a2, unsigned __int64 a3, char a4);
void *__fastcall mg_mqtt_sub(__int64 a1, __int64 a2);
// void __fastcall operator delete(void *); idb
// int rename(const char *old, const char *new);
// int close(int fd);
__int64 __fastcall mg_url_port(char *s1);
// _QWORD __fastcall operator new[](unsigned __int64); idb
// _QWORD __fastcall std::logic_error::logic_error(std::logic_error *__hidden this, const char *); idb
// _QWORD __fastcall std::ios_base::clear(std::ios_base *__hidden this, unsigned int); idb
__int64 __fastcall mg_sntp_parse(__int64 a1, unsigned __int64 a2, __int64 *a3);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int pthread_join(pthread_t th, void **thread_return);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
__int64 __fastcall mg_printf(__int64 a1, const char *a2);
// void __cxa_end_catch(void);
// int fcntl(int fd, int cmd, ...);
// void *__fastcall __cxa_allocate_exception(size_t thrown_size);
// int pthread_setname_np(pthread_t target_thread, const char *name);
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
__int64 __fastcall mg_mqtt_pub(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall mg_log_prefix(int a1, const char *a2, unsigned int a3, const char *a4);
// void free(void *ptr);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
__int64 __fastcall mg_open_listener(char *a1);
// void *calloc(size_t nmemb, size_t size);
void __fastcall mg_sntp_send(__int64 a1, unsigned __int64 a2);
// _QWORD std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *__hidden this); idb
// void *malloc(size_t size);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
// int isxdigit(int);
__int64 __fastcall mqtt_sub_cb(unsigned int a1, const char *a2, __int64 a3);
__int64 __fastcall register_ctrl(__int64 a1);
// _QWORD std::mutex::unlock(std::mutex *__hidden this); idb
__int64 __fastcall register_esp32(__int64 a1);
// int rand(void);
// void __fastcall std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *__hidden this); idb
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
_QWORD *__fastcall mg_listen(_QWORD *a1, char *s1, __int64 a3, __int64 a4);
// void *memmove(void *dest, const void *src, size_t n);
__int64 __fastcall mg_sha1_transform(_DWORD *a1, unsigned int *a2);
char *__fastcall mg_url_host(char *a1);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// size_t strlen(const char *s);
// pthread_t pthread_self(void);
long double __fastcall mg_sha1_final(__int64 a1, __int64 a2);
__int64 __fastcall mqtt_pub(int a1, char *a2, __int64 a3, int a4);
// int fclose(FILE *stream);
// __int64 __fastcall g3::logLevel(_QWORD); weak
__int64 __fastcall mg_dns_send(__int64 a1, __int64 *a2, unsigned int a3, char a4);
// LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *); weak
void __fastcall mg_resolve(__int64 a1, __int64 a2, int a3);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int strncmp(const char *s1, const char *s2, size_t n);
__int64 __fastcall mg_base64_final(__int64 a1, int a2);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int listen(int fd, int n);
__int64 __fastcall mg_mqtt_connect(__int64 a1, char *a2, __int128 *a3, __int64 a4, __int64 a5);
// int remove(const char *filename);
unsigned __int64 __fastcall mg_http_parse_headers(unsigned __int64 result, unsigned __int64 a2, __int64 a3, int a4);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
__int64 __fastcall EspRecvParse::crc162(EspRecvParse *this, unsigned __int8 *a2);
__int64 easynode_init();
FILE *__fastcall mg_file_write(const char *a1, const void *a2, size_t a3);
void __fastcall mg_http_serve_file(__int64 a1, unsigned __int8 **a2, const char *a3);
void __fastcall mg_mgr_poll(__int64 *a1, int a2);
void __fastcall mg_http_reply(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall send_data(int a1, __int64 a2, int a3);
__int64 __fastcall EspRecvParse::send_callback(EspRecvParse *this); // idb
__int64 __fastcall mg_aton(unsigned __int8 *a1, unsigned __int64 a2, __int64 a3);
// std::__shared_weak_count *__usercall std::shared_ptr<EspRecvParse>::make_shared<>@<X0>(_QWORD *a1@<X8>);
void __fastcall EspRecvParse::EspRecvParse(EspRecvParse *this);
// struct tm *gmtime(const time_t *timer);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
char *__fastcall mg_ntoa(__int64 a1, char *s, size_t maxlen);
bool __fastcall mg_url_is_ssl(const char *a1);
char *__fastcall mg_str(char *s);
// void __fastcall LogCapture::~LogCapture(LogCapture *__hidden this); idb
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c);
__int64 __fastcall mg_mqtt_parse(_BYTE *a1, unsigned __int64 a2, __int64 a3);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// _QWORD *__fastcall std::to_string(_QWORD *__hidden __return_ptr, std::__ndk1 *__hidden this, int); idb
__int64 __fastcall mg_vasprintf(char **a1, size_t a2, const char *a3, __int128 *a4);
// void __fastcall operator delete[](void *); idb
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// char *strncat(char *dest, const char *src, size_t n);
// int system(const char *command);
// int isspace(int);
__int64 __fastcall mg_url_decode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, int a5);
__int64 __fastcall EspRecvParse::setCallBack(__int64 a1, __int64 a2);
char *__fastcall mg_hexdump(__int64 a1, unsigned __int64 a2);
// void *memset(void *s, int c, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
__int64 mg_str_n();
void __fastcall mg_connect_resolved(__int64 a1);
// int stat(const char *file, struct stat *buf);
long double __fastcall mg_mgr_init(__int64 a1);
// _QWORD std::__shared_weak_count::__release_weak(std::__shared_weak_count *__hidden this); idb
// void *__fastcall __cxa_begin_catch(void *);
__int64 *__fastcall EspRecvParse::parseData(__int64 *this, char *a2, int a3);
// void __fastcall __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (__fastcall *)(void *));
// int isprint(int);
// int __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
__int64 __fastcall mg_tls_init(__int64 a1);
// int atoi(const char *nptr);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __int64 __fastcall g3::logTag(_QWORD); weak
__int64 __fastcall mg_base64_decode(__int64 a1, int a2, __int64 a3);
// int printf(const char *format, ...);
// int memcmp(const void *s1, const void *s2, size_t n);
// __int64 __fastcall __errno(_QWORD); weak
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
// int tolower(int c);
__int64 __fastcall mg_http_parse(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *s);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
bool __fastcall mg_is_dir(const char *a1);
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
// _QWORD __fastcall operator new(unsigned __int64); idb
__int64 __fastcall register_lora(__int64 a1);
// __int64 __fastcall __FD_SET_chk(_QWORD, _QWORD, _QWORD); weak
// int __fastcall __cxa_finalize(void *);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
long double __fastcall mg_dns_parse(unsigned __int16 *a1, signed __int64 a2, __int64 a3);
__int64 __fastcall mg_base64_update(unsigned __int8 a1, __int64 a2, int a3);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
__int64 __fastcall mg_asprintf(char **a1, size_t a2, const char *a3);
void __fastcall mg_error(__int64 a1, const char *a2);
__int64 __fastcall mg_connect(__int64 a1, char *a2, __int64 a3, __int64 a4);
// char *realpath(const char *name, char *resolved);
// _QWORD *std::ios_base::getloc(_QWORD *__hidden __return_ptr, std::ios_base *__hidden this); idb
// int socket(int domain, int type, int protocol);
void __fastcall mg_mgr_free(__int64 *a1);
// time_t time(time_t *timer);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int puts(const char *s);
// void __fastcall std::mutex::~mutex(std::mutex *__hidden this); idb
__int64 __fastcall mg_mqtt_send_header(__int64 a1, char a2, char a3, unsigned int a4);
// _QWORD LogCapture::capturef(LogCapture *__hidden this, const char *, ...); idb
// void __noreturn std::terminate(void); idb
// void __fastcall std::locale::~locale(std::locale *__hidden this); idb
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
__int64 __fastcall mg_iobuf_resize(__int64 a1, size_t size);
// __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD); weak
__int64 __fastcall _JNIEnv::CallVoidMethod(__int64 a1, __int64 a2, __int64 a3);
// _QWORD std::uncaught_exception(void); idb
// _QWORD std::mutex::lock(std::mutex *__hidden this); idb
void __noreturn std::__basic_string_common<true>::__throw_length_error();
__int64 __fastcall mg_http_get_var(__int64 *a1, char *s, _BYTE *a3, int a4);
__int64 __fastcall send_cmd(const char *a1);
// char *strrchr(const char *s, int c);
__int64 start();
__int64 sub_7EE8();
__int64 sub_818C();
__int64 (*__fastcall sub_81A0(__int64 (*result)(void)))(void);
__int64 __fastcall sub_81AC(void *a1);
void __fastcall std::string::~string(__int64 a1);
void __fastcall LEVELS::~LEVELS(void **this);
__int64 __fastcall std::shared_ptr<EspRecvParse>::~shared_ptr(__int64 result);
__int64 threadServer(void); // idb
__int64 maintest(void); // idb
__int64 __fastcall initTheEasyNode(__int64 a1, __int64 a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
__int64 regUSBCtrl();
__int64 *setESP32Callback(void);
__int64 regESP32();
__int64 regLora();
__int64 __fastcall sendUsbCtrlData(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sendESP32Data(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sendLoraData(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall openUSB(__int64 a1, __int64 a2, int a3);
__int64 __fastcall closeUSB(__int64 a1, __int64 a2, int a3);
__int64 __fastcall setBacklight(__int64 a1, __int64 a2, unsigned int a3);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
__int64 __fastcall controlESP(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 resetESP();
__int64 loraDIS();
__int64 loraEN();
__int64 loraRST();
__int64 __fastcall setLoraMod(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall control4G(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall setESPChannel(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall registerNativeMethods(_JNIEnv *a1); // idb
jint JNI_OnLoad(JavaVM *vm, void *reserved);
void JNI_OnUnload(JavaVM *vm, void *reserved);
void __noreturn std::__basic_string_common<true>::__throw_length_error();
void __fastcall __noreturn sub_DCE4(const char *a1);
__int64 __fastcall sub_DD34(std::logic_error *a1, const char *a2);
__int64 __fastcall sub_DD64(__int64 a1, unsigned int a2);
__int64 _JNIEnv::CallVoidMethod(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_E1B4(char *a1, unsigned int a2);
__int64 __fastcall sub_E460(__int64 a1, unsigned int a2);
void __fastcall __noreturn sub_E814(void *a1);
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_E9C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
_QWORD *sub_ED40();
void __fastcall sub_ED64(__int64 a1, _QWORD *a2);
void __fastcall sub_ED7C(__int64 a1, __int64 *a2, unsigned int *a3);
__int64 __fastcall sub_F124(__int64 a1, __int64 a2);
void **sub_F140();
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
void __fastcall __noreturn sub_F4DC(const char *a1);
__int64 __fastcall sub_F52C(std::logic_error *a1, const char *a2);
// std::__shared_weak_count *__usercall std::shared_ptr<EspRecvParse>::make_shared<>@<X0>(_QWORD *a1@<X8>);
void __fastcall std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace(__int64 a1);
void __fastcall std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace(__int64 a1);
std::__shared_weak_count *__fastcall std::__shared_ptr_emplace<EspRecvParse>::__on_zero_shared(__int64 a1);
void __fastcall EspRecvParse::EspRecvParse(EspRecvParse *this);
__int64 __fastcall EspRecvParse::crc162(EspRecvParse *this, unsigned __int8 *a2);
__int64 __fastcall EspRecvParse::setCallBack(__int64 a1, __int64 a2);
__int64 __fastcall EspRecvParse::reset(__int64 this);
__int64 *__fastcall EspRecvParse::parseData(__int64 *this, char *a2, int a3);
__int64 __fastcall EspRecvParse::send_callback(EspRecvParse *this); // idb
_QWORD *__fastcall sub_10440(_QWORD *result, __int64 a2);
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c);
__int64 __fastcall mg_base64_update(unsigned __int8 a1, __int64 a2, int a3);
__int64 __fastcall mg_base64_final(__int64 a1, int a2);
__int64 __fastcall mg_base64_encode(unsigned __int8 *a1, int a2, __int64 a3);
__int64 __fastcall mg_base64_decode(__int64 a1, int a2, __int64 a3);
void __fastcall mg_resolve_cancel(__int64 a1);
__int64 __fastcall mg_dns_parse_name(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, size_t a5);
__int64 __fastcall sub_10D24(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, size_t a5, int a6);
__int64 __fastcall mg_dns_parse_rr(__int64 a1, signed __int64 a2, __int64 a3, char a4, __int64 a5);
long double __fastcall mg_dns_parse(unsigned __int16 *a1, signed __int64 a2, __int64 a3);
__int64 __fastcall mg_ntohs(unsigned int a1);
__int64 __fastcall mg_dns_send(__int64 a1, __int64 *a2, unsigned int a3, char a4);
__int64 __fastcall mg_send(__int64 a1, void *buf, size_t a3);
void __fastcall mg_resolve(__int64 a1, __int64 a2, int a3);
__int64 __fastcall mg_aton(unsigned __int8 *a1, unsigned __int64 a2, __int64 a3);
void __fastcall mg_connect_resolved(__int64 a1);
__int64 __fastcall mg_call(__int64 result, unsigned int a2, __int64 a3);
void mg_error(__int64 a1, const char *a2, ...);
__int64 __fastcall mg_vasprintf(char **a1, size_t a2, const char *a3, __int128 *a4);
__int64 __fastcall mg_log_prefix(int a1, const char *a2, unsigned int a3, const char *a4);
void mg_log(const char *a1, ...);
void __fastcall mg_http_bauth(_QWORD *a1, char *s, unsigned __int8 *a3);
char *__fastcall mg_str(char *s);
__int64 __fastcall mg_iobuf_resize(__int64 a1, size_t size);
__int64 __fastcall mg_http_get_var(__int64 *a1, char *s, _BYTE *a3, int a4);
__int64 __fastcall mg_ncasecmp(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall mg_url_decode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, int a5);
unsigned __int64 __fastcall mg_unhex(unsigned __int64 result, int a2, unsigned __int64 a3);
__int64 __fastcall mg_http_get_request_len(__int64 a1, unsigned __int64 a2);
__int64 __fastcall mg_http_get_header(__int64 a1, char *s);
unsigned __int64 __fastcall mg_http_parse_headers(unsigned __int64 result, unsigned __int64 a2, __int64 a3, int a4);
__int64 __fastcall mg_http_parse(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *s);
__int64 __fastcall mg_to64(__int64 a1, unsigned __int64 a2);
__int64 __fastcall mg_vcasecmp(unsigned __int8 **a1, char *s);
void mg_http_printf_chunk(__int64 a1, const char *a2, ...);
void *__fastcall mg_http_write_chunk(__int64 a1, void *a2, size_t a3);
__int64 mg_printf(__int64 a1, const char *a2, ...);
void mg_http_reply(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...);
char *__fastcall mg_http_etag(char *a1, size_t a2, __int64 a3);
__int64 __fastcall mg_http_upload(__int64 a1, __int64 a2, const char *a3);
void __fastcall mg_http_serve_file(__int64 a1, unsigned __int8 **a2, const char *a3);
void __fastcall sub_14184(_QWORD *a1, int a2, int a3, FILE *stream);
bool __fastcall mg_is_dir(const char *a1);
void __fastcall mg_http_serve_dir(__int64 a1, __int64 a2, const char **a3);
__int64 __fastcall mg_url_encode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall mg_hex(char *a1, int a2, __int64 a3);
__int64 __fastcall mg_http_creds(__int64 a1, char *a2, int a3, char *a4, int a5);
__int64 __fastcall mg_http_match_uri(__int64 a1, char *s);
__int64 __fastcall mg_globmatch(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall mg_http_connect(__int64 a1, char *a2, __int64 a3, __int64 a4);
__int64 __fastcall mg_connect(__int64 a1, char *a2, __int64 a3, __int64 a4);
void __fastcall sub_15070(__int64 a1, int a2);
_QWORD *__fastcall mg_http_listen(_QWORD *a1, char *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall mg_listen(_QWORD *a1, char *s1, __int64 a3, __int64 a4);
size_t __fastcall mg_iobuf_append(_QWORD *a1, void *src, size_t a3, unsigned __int64 a4);
unsigned __int64 __fastcall mg_iobuf_delete(char **a1, unsigned __int64 a2);
void __fastcall mg_iobuf_free(__int64 a1);
void __fastcall mg_log_set(void *a1);
bool __fastcall mg_next_comma_entry(__int64 *a1, _QWORD *a2, _QWORD *a3);
size_t (__fastcall *__fastcall mg_log_set_callback(size_t (__fastcall *result)(const void *a1, int a2), __int64 a2))(const void *a1, int a2);
__int64 __fastcall mg_mqtt_send_header(__int64 a1, char a2, char a3, unsigned int a4);
__int64 __fastcall mg_mqtt_pub(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall mg_mqtt_sub(__int64 a1, __int64 a2);
__int64 __fastcall mg_mqtt_parse(_BYTE *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall mg_mqtt_next_sub(__int64 a1, _QWORD *a2, _BYTE *a3, int a4);
__int64 __fastcall mg_mqtt_ping(__int64 a1);
__int64 __fastcall mg_mqtt_pong(__int64 a1);
__int64 __fastcall mg_mqtt_disconnect(__int64 a1);
__int64 __fastcall mg_mqtt_connect(__int64 a1, char *a2, __int128 *a3, __int64 a4, __int64 a5);
void __fastcall sub_16A54(__int64 a1, int a2);
_QWORD *__fastcall mg_mqtt_listen(_QWORD *a1, char *a2, __int64 a3, __int64 a4);
__int64 __fastcall mg_vprintf(__int64 a1, const char *a2, __int128 *a3);
char *__fastcall mg_straddr(__int64 a1, char *a2, size_t a3);
char *__fastcall mg_ntoa(__int64 a1, char *s, size_t maxlen);
void __fastcall mg_mgr_free(__int64 *a1);
void __fastcall mg_mgr_poll(__int64 *a1, int a2);
long double __fastcall mg_mgr_init(__int64 a1);
__int64 __fastcall mg_sha1_transform(_DWORD *a1, unsigned int *a2);
long double __fastcall mg_sha1_init(__int64 a1);
void *__fastcall mg_sha1_update(_DWORD *a1, char *src, unsigned __int64 a3);
long double __fastcall mg_sha1_final(__int64 a1, __int64 a2);
long double __fastcall mg_hmac_sha1(int8x16_t *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, char *a5);
__int64 __fastcall mg_sntp_parse(__int64 a1, unsigned __int64 a2, __int64 *a3);
__int64 __fastcall mg_ntohl(unsigned int a1);
void __fastcall mg_sntp_send(__int64 a1, unsigned __int64 a2);
__int64 __fastcall mg_sntp_connect(__int64 a1, char *a2, __int64 a3, __int64 a4);
void __fastcall sub_1994C(_QWORD *a1, int a2);
__int64 __fastcall sub_19A48(__int64 a1, void *buf, int a3, _DWORD *a4);
__int64 __fastcall mg_open_listener(char *a1);
__int64 __fastcall mg_url_port(char *s1);
char *__fastcall mg_url_host(char *a1);
__int64 __fastcall sub_1A09C(__int64 a1);
__int64 mg_millis();
unsigned __int64 __fastcall mg_timer_poll(unsigned __int64 result);
bool __fastcall mg_tls_handshake(__int64 a1);
__int64 mg_str_n(void); // weak
__int64 __fastcall mg_lower(unsigned __int8 *a1);
__int64 __fastcall mg_casecmp(__int64 a1, __int64 a2);
__int64 __fastcall mg_vcmp(__int64 a1, char *s);
_BYTE *__fastcall mg_strdup(const void *a1, size_t a2);
__int64 __fastcall mg_strcmp(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall mg_strstr(__int64 a1, unsigned __int64 a2, void *s2, size_t n);
unsigned __int8 *__fastcall mg_strstrip(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall mg_timer_init(__int64 result, int a2, int a3, __int64 (__fastcall *a4)(__int64), __int64 a5);
__int64 __fastcall mg_timer_free(__int64 result);
__int64 __fastcall mg_tls_init(__int64 a1);
bool __fastcall mg_tls_free(__int64 a1);
__int64 __fastcall mg_tls_recv(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4);
__int64 __fastcall mg_tls_send(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4);
bool __fastcall mg_url_is_ssl(const char *a1);
const char *__fastcall mg_url_uri(char *a1);
char *__fastcall mg_url_user(char *a1);
char *__fastcall mg_url_pass(char *a1);
__int64 __fastcall mg_file_size(const char *a1);
_BYTE *__fastcall mg_file_read(const char *a1);
FILE *__fastcall mg_file_write(const char *a1, const void *a2, size_t a3);
__int64 mg_file_printf(const char *a1, const char *a2, ...);
FILE *__fastcall mg_random(_BYTE *a1, size_t a2);
char *__fastcall mg_hexdump(__int64 a1, unsigned __int64 a2);
__int64 __fastcall mg_unhexn(__int64 a1, int a2);
__int64 mg_asprintf(char **a1, size_t a2, const char *a3, ...);
double mg_time();
unsigned __int64 __fastcall mg_ws_send(__int64 a1, void *a2, unsigned __int64 a3, char a4);
__int64 mg_ws_connect(__int64 a1, char *a2, __int64 a3, __int64 a4, const char *a5, ...);
void __fastcall sub_1BA80(__int64 a1, int a2);
void mg_ws_upgrade(__int64 a1, __int64 a2, const char *a3, ...);
void __fastcall sub_1CAF0(__int64 a1, int a2, unsigned __int64 *a3);
size_t __fastcall sub_1CE1C(const void *a1, int a2);
__int64 __fastcall sub_1CE34(const char *a1, int a2);
__int64 client_thread();
__int64 __fastcall send_data(int a1, __int64 a2, int a3);
__int64 __fastcall send_cmd(const char *a1);
__int64 __fastcall client_regeister(const char *a1, __int64 a2);
__int64 easynode_init();
__int64 __fastcall register_ctrl(__int64 a1);
__int64 __fastcall register_esp32(__int64 a1);
__int64 __fastcall register_lora(__int64 a1);
__int64 get_mqtt_connect_state();
void __fastcall __noreturn mqtt_thread(__int64 a1);
void __fastcall sub_1D1B0(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 mqtt_create();
__int64 __fastcall mqtt_del(int a1);
__int64 __fastcall mqtt_sub_cb(unsigned int a1, const char *a2, __int64 a3);
__int64 __fastcall mqtt_pub(int a1, char *a2, __int64 a3, int a4);
// void __fastcall std::out_of_range::~out_of_range(std::out_of_range *__hidden this); idb
// void __fastcall std::length_error::~length_error(std::length_error *__hidden this); idb
// void __fastcall std::mutex::~mutex(std::mutex *__hidden this); idb

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
__int64 qword_68 = 138968LL; // weak
__int128 xmmword_1DD09 = 0x88B1F000000000000DADA025E55AALL; // weak
_UNKNOWN unk_1DD19; // weak
__int128 xmmword_1DD29 = 0xCA4FCA2D62E332154C314D4CB1334F31LL; // weak
_UNKNOWN unk_1DD39; // weak
__int128 xmmword_1DD49 = 0x628A60754C62908C68123332B43032B7LL; // weak
_UNKNOWN unk_1DD59; // weak
_UNKNOWN unk_1DD63; // weak
__int128 xmmword_1DED0 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
_UNKNOWN unk_1DEE8; // weak
char aContentLength[15] = "Content-Length"; // weak
char byte_1DFAB = 'U'; // weak
char byte_1DFAF = 'O'; // weak
char byte_1DFB3 = '2'; // weak
char a0123456789abcd[17] = "0123456789abcdef"; // weak
char aSecWebsocketKe[18] = "Sec-WebSocket-Key"; // weak
char a258eafa5E91447[37] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"; // weak
__int64 (__fastcall *off_32278)() = &nullsub_1; // weak
void *`typeinfo for'setESP32Callback(void)::$_1 = &std::terminate; // weak
__int64 (__fastcall *off_32308[3])() =
{
  &std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace,
  &std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace,
  &std::__shared_ptr_emplace<EspRecvParse>::__on_zero_shared
}; // weak
void *off_32348 = (void *)0x1E160LL; // weak
void *off_33000 = &off_33000; // weak
void *TAG = (void *)0x1DC5ALL; // weak
int dword_33010 = 1; // weak
char *methods[2] = { "initTheEasyNode", "()I" }; // weak
char *RecvTAG = "EspRecvParse"; // weak
void *off_331D8 = (void *)0x1D984LL; // weak
size_t (__fastcall *off_331E0)(const void *a1, int a2) = &sub_1CE1C; // weak
char client_st[10] = "pd/usbres"; // weak
__int64 (__fastcall *off_33208)() = &sub_1CE34; // weak
int dword_33210; // weak
__int16 word_33218; // weak
_UNKNOWN unk_3321A; // weak
_UNKNOWN unk_33222; // weak
__int64 qword_33228; // weak
int dword_33230; // weak
__int16 word_33238; // weak
_UNKNOWN unk_3323A; // weak
_UNKNOWN unk_33242; // weak
__int64 qword_33248; // weak
int dword_33250; // weak
__int16 word_33258; // weak
_UNKNOWN unk_3325A; // weak
_UNKNOWN unk_33262; // weak
__int64 qword_33268; // weak
int dword_33270; // weak
__int16 word_33278; // weak
_UNKNOWN unk_3327A; // weak
_UNKNOWN unk_33282; // weak
__int64 qword_33288; // weak
int dword_33290; // weak
__int16 word_33298; // weak
_UNKNOWN unk_3329A; // weak
_UNKNOWN unk_332A2; // weak
__int64 qword_332A8; // weak
int dword_332B0; // weak
__int16 word_332B8; // weak
_UNKNOWN unk_332BA; // weak
_UNKNOWN unk_332C2; // weak
__int64 qword_332C8; // weak
int dword_332D0; // weak
char byte_332D8; // weak
_UNKNOWN unk_332D9; // weak
_UNKNOWN unk_332E1; // weak
__int64 qword_332E8; // weak
int dword_332F0; // weak
char byte_332F8; // weak
_UNKNOWN unk_332F9; // weak
_UNKNOWN unk_33301; // weak
_UNKNOWN unk_33305; // weak
_UNKNOWN unk_3330D; // weak
char byte_3330F; // weak
int dword_33310; // weak
char byte_33318; // weak
_BYTE algn_33319[7]; // weak
_UNKNOWN unk_33329; // weak
_UNKNOWN unk_3332D; // weak
char byte_3332F; // weak
__int64 qword_33330; // weak
_UNKNOWN unk_33338; // weak
__int64 qword_33340; // weak
__int64 qword_33348; // weak
_UNKNOWN unk_33350; // weak
__int64 qword_33358; // weak
__int64 glb_vm_; // weak
__int64 easynode_object_; // weak
__int64 usbcb_method_; // weak
__int64 esp32cb_method_; // weak
__int64 loracb_method_; // weak
__int64 esp_recv_parse_; // weak
__int64 qword_33390; // weak
_UNKNOWN esp32_send_mutex_; // weak
int dword_333C0; // weak
__int16 word_333C8; // weak
_UNKNOWN unk_333CA; // weak
_UNKNOWN unk_333D2; // weak
__int64 qword_333D8; // weak
int dword_333E0; // weak
__int16 word_333E8; // weak
_UNKNOWN unk_333EA; // weak
_UNKNOWN unk_333F2; // weak
__int64 qword_333F8; // weak
int dword_33400; // weak
__int16 word_33408; // weak
_UNKNOWN unk_3340A; // weak
_UNKNOWN unk_33412; // weak
__int64 qword_33418; // weak
int dword_33420; // weak
__int16 word_33428; // weak
_UNKNOWN unk_3342A; // weak
_UNKNOWN unk_33432; // weak
__int64 qword_33438; // weak
int dword_33440; // weak
__int16 word_33448; // weak
_UNKNOWN unk_3344A; // weak
_UNKNOWN unk_33452; // weak
__int64 qword_33458; // weak
int dword_33460; // weak
__int16 word_33468; // weak
_UNKNOWN unk_3346A; // weak
_UNKNOWN unk_33472; // weak
__int64 qword_33478; // weak
int dword_33480; // weak
char byte_33488; // weak
_UNKNOWN unk_33489; // weak
_UNKNOWN unk_33491; // weak
__int64 qword_33498; // weak
int dword_334A0; // weak
char byte_334A8; // weak
_UNKNOWN unk_334A9; // weak
_UNKNOWN unk_334B1; // weak
_UNKNOWN unk_334B5; // weak
_UNKNOWN unk_334BD; // weak
char byte_334BF; // weak
int dword_334C0; // weak
char byte_334C8; // weak
_BYTE algn_334C9[7]; // weak
_UNKNOWN unk_334D9; // weak
_UNKNOWN unk_334DD; // weak
char byte_334DF; // weak
__int64 qword_334E0; // weak
_UNKNOWN unk_334E8; // weak
__int64 qword_334F0; // weak
__int64 qword_334F8; // weak
_UNKNOWN unk_33500; // weak
__int64 qword_33508; // weak
__int64 qword_33510; // weak
__int64 qword_33518; // weak
__int16 word_33520; // weak
__int16 word_33524; // weak
__int64 qword_33528; // weak
__int64 qword_33530; // weak
int client_fd; // weak
__int64 mqtt_mid_head; // weak
__int64 g_timers; // weak
pthread_mutex_t mqtt_mutex; // weak
int state; // weak
// extern _UNKNOWN std::ctype<char>::id; weak
// extern _UNKNOWN `typeinfo for'std::out_of_range; weak
// extern _UNKNOWN _sF; weak
// extern _UNKNOWN std::num_put<char,std::ostreambuf_iterator<char>>::id; weak
// extern _UNKNOWN `typeinfo for'std::length_error; weak
// extern _UNKNOWN `vtable for'std::length_error; weak
// extern _UNKNOWN `vtable for'std::out_of_range; weak


//----- (0000000000007120) ----------------------------------------------------
void sub_7120()
{
  JUMPOUT(0LL);
}
// 7130: control flows out of bounds to 0

//----- (00000000000071A0) ----------------------------------------------------
// attributes: thunk
__int64 maintest(void)
{
  return _Z8maintestv();
}

//----- (00000000000071B0) ----------------------------------------------------
// attributes: thunk
__int64 mqtt_create()
{
  return mqtt_create();
}

//----- (00000000000071C0) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_log(const char *a1)
{
  mg_log(a1);
}

//----- (00000000000071D0) ----------------------------------------------------
// attributes: thunk
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  return _ZNSt6__ndk1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EEPKS6_RKS9_(a1, a2, a3);
}

//----- (00000000000071F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_vprintf(__int64 a1, const char *a2, __int128 *a3)
{
  return mg_vprintf(a1, a2, a3);
}

//----- (0000000000007210) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall mg_ws_send(__int64 a1, void *a2, unsigned __int64 a3, char a4)
{
  return mg_ws_send(a1, a2, a3, a4);
}

//----- (0000000000007220) ----------------------------------------------------
// attributes: thunk
void *__fastcall mg_mqtt_sub(__int64 a1, __int64 a2)
{
  return mg_mqtt_sub(a1, a2);
}

//----- (0000000000007260) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_url_port(char *s1)
{
  return mg_url_port(s1);
}

//----- (00000000000072A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_sntp_parse(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  return mg_sntp_parse(a1, a2, a3);
}

//----- (00000000000072E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_printf(__int64 a1, const char *a2)
{
  return mg_printf(a1, a2);
}

//----- (0000000000007330) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_out_of_rangeEv();
}

//----- (0000000000007350) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_mqtt_pub(__int64 a1, __int64 a2, __int64 a3)
{
  return mg_mqtt_pub(a1, a2, a3);
}

//----- (0000000000007360) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_log_prefix(int a1, const char *a2, unsigned int a3, const char *a4)
{
  return mg_log_prefix(a1, a2, a3, a4);
}

//----- (0000000000007390) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_open_listener(char *a1)
{
  return mg_open_listener(a1);
}

//----- (00000000000073B0) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_sntp_send(__int64 a1, unsigned __int64 a2)
{
  mg_sntp_send(a1, a2);
}

//----- (00000000000073E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev(result);
}

//----- (0000000000007400) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mqtt_sub_cb(unsigned int a1, const char *a2, __int64 a3)
{
  return mqtt_sub_cb(a1, a2, a3);
}

//----- (0000000000007410) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall register_ctrl(__int64 a1)
{
  return register_ctrl(a1);
}

//----- (0000000000007430) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall register_esp32(__int64 a1)
{
  return register_esp32(a1);
}

//----- (0000000000007460) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  return _ZNSt6__ndk124__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m(a1, a2, a3);
}

//----- (0000000000007480) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall mg_listen(_QWORD *a1, char *s1, __int64 a3, __int64 a4)
{
  return mg_listen(a1, s1, a3, a4);
}

//----- (00000000000074A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_sha1_transform(_DWORD *a1, unsigned int *a2)
{
  return mg_sha1_transform(a1, a2);
}

//----- (00000000000074B0) ----------------------------------------------------
// attributes: thunk
char *__fastcall mg_url_host(char *a1)
{
  return mg_url_host(a1);
}

//----- (0000000000007500) ----------------------------------------------------
// attributes: thunk
long double __fastcall mg_sha1_final(__int64 a1, __int64 a2)
{
  return mg_sha1_final(a1, a2);
}

//----- (0000000000007510) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mqtt_pub(int a1, char *a2, __int64 a3, int a4)
{
  return mqtt_pub(a1, a2, a3, a4);
}

//----- (0000000000007540) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_dns_send(__int64 a1, __int64 *a2, unsigned int a3, char a4)
{
  return mg_dns_send(a1, a2, a3, a4);
}

//----- (0000000000007560) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_resolve(__int64 a1, __int64 a2, int a3)
{
  mg_resolve(a1, a2, a3);
}

//----- (0000000000007570) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEi(a1);
}

//----- (00000000000075A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_base64_final(__int64 a1, int a2)
{
  return mg_base64_final(a1, a2);
}

//----- (00000000000075D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_mqtt_connect(__int64 a1, char *a2, __int128 *a3, __int64 a4, __int64 a5)
{
  return mg_mqtt_connect(a1, a2, a3, a4, a5);
}

//----- (00000000000075F0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall mg_http_parse_headers(unsigned __int64 result, unsigned __int64 a2, __int64 a3, int a4)
{
  return mg_http_parse_headers(result, a2, a3, a4);
}

//----- (0000000000007630) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall EspRecvParse::crc162(EspRecvParse *this, unsigned __int8 *a2)
{
  return _ZN12EspRecvParse6crc162EPhj(this, a2);
}

//----- (0000000000007640) ----------------------------------------------------
// attributes: thunk
__int64 easynode_init()
{
  return easynode_init();
}

//----- (0000000000007650) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall mg_file_write(const char *a1, const void *a2, size_t a3)
{
  return mg_file_write(a1, a2, a3);
}

//----- (0000000000007660) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_http_serve_file(__int64 a1, unsigned __int8 **a2, const char *a3)
{
  mg_http_serve_file(a1, a2, a3);
}

//----- (0000000000007670) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_mgr_poll(__int64 *a1, int a2)
{
  mg_mgr_poll(a1, a2);
}

//----- (0000000000007680) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_http_reply(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  mg_http_reply(a1, a2, a3, a4);
}

//----- (0000000000007690) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall send_data(int a1, __int64 a2, int a3)
{
  return send_data(a1, a2, a3);
}

//----- (00000000000076A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall EspRecvParse::send_callback(EspRecvParse *this)
{
  return _ZN12EspRecvParse13send_callbackEv(this);
}

//----- (00000000000076B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_aton(unsigned __int8 *a1, unsigned __int64 a2, __int64 a3)
{
  return mg_aton(a1, a2, a3);
}

//----- (00000000000076C0) ----------------------------------------------------
// attributes: thunk
std::__shared_weak_count *__usercall std::shared_ptr<EspRecvParse>::make_shared<>@<X0>(_QWORD *a1@<X8>)
{
  return _ZNSt6__ndk110shared_ptrI12EspRecvParseE11make_sharedIJEEES2_DpOT_(a1);
}

//----- (00000000000076D0) ----------------------------------------------------
// attributes: thunk
void __fastcall EspRecvParse::EspRecvParse(EspRecvParse *this)
{
  _ZN12EspRecvParseC2Ev(this);
}

//----- (0000000000007710) ----------------------------------------------------
// attributes: thunk
char *__fastcall mg_ntoa(__int64 a1, char *s, size_t maxlen)
{
  return mg_ntoa(a1, s, maxlen);
}

//----- (0000000000007720) ----------------------------------------------------
// attributes: thunk
bool __fastcall mg_url_is_ssl(const char *a1)
{
  return mg_url_is_ssl(a1);
}

//----- (0000000000007730) ----------------------------------------------------
// attributes: thunk
char *__fastcall mg_str(char *s)
{
  return mg_str(s);
}

//----- (0000000000007750) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc(a1, n, c);
}

//----- (0000000000007760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_mqtt_parse(_BYTE *a1, unsigned __int64 a2, __int64 a3)
{
  return mg_mqtt_parse(a1, a2, a3);
}

//----- (0000000000007790) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_vasprintf(char **a1, size_t a2, const char *a3, __int128 *a4)
{
  return mg_vasprintf(a1, a2, a3, a4);
}

//----- (00000000000077F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_url_decode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, int a5)
{
  return mg_url_decode(a1, a2, a3, a4, a5);
}

//----- (0000000000007800) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall EspRecvParse::setCallBack(__int64 a1, __int64 a2)
{
  return _ZN12EspRecvParse11setCallBackENSt6__ndk18functionIFvPhiEEE(a1, a2);
}

//----- (0000000000007810) ----------------------------------------------------
// attributes: thunk
char *__fastcall mg_hexdump(__int64 a1, unsigned __int64 a2)
{
  return mg_hexdump(a1, a2);
}

//----- (0000000000007850) ----------------------------------------------------
// attributes: thunk
__int64 mg_str_n()
{
  return mg_str_n();
}
// 1A2FC: using guessed type __int64 mg_str_n(void);

//----- (0000000000007860) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_connect_resolved(__int64 a1)
{
  mg_connect_resolved(a1);
}

//----- (0000000000007880) ----------------------------------------------------
// attributes: thunk
long double __fastcall mg_mgr_init(__int64 a1)
{
  return mg_mgr_init(a1);
}

//----- (00000000000078B0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall EspRecvParse::parseData(__int64 *this, char *a2, int a3)
{
  return _ZN12EspRecvParse9parseDataEPhi(this, a2, a3);
}

//----- (00000000000078F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_tls_init(__int64 a1)
{
  return mg_tls_init(a1);
}

//----- (0000000000007930) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_base64_decode(__int64 a1, int a2, __int64 a3)
{
  return mg_base64_decode(a1, a2, a3);
}

//----- (0000000000007980) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm(a1, src, n);
}

//----- (00000000000079A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_http_parse(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *s)
{
  return mg_http_parse(a1, a2, s);
}

//----- (00000000000079C0) ----------------------------------------------------
// attributes: thunk
bool __fastcall mg_is_dir(const char *a1)
{
  return mg_is_dir(a1);
}

//----- (00000000000079D0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKcm(a1, a2, src, n);
}

//----- (00000000000079F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall register_lora(__int64 a1)
{
  return register_lora(a1);
}

//----- (0000000000007A30) ----------------------------------------------------
// attributes: thunk
long double __fastcall mg_dns_parse(unsigned __int16 *a1, signed __int64 a2, __int64 a3)
{
  return mg_dns_parse(a1, a2, a3);
}

//----- (0000000000007A40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_base64_update(unsigned __int8 a1, __int64 a2, int a3)
{
  return mg_base64_update(a1, a2, a3);
}

//----- (0000000000007A60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_asprintf(char **a1, size_t a2, const char *a3)
{
  return mg_asprintf(a1, a2, a3);
}

//----- (0000000000007A70) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_error(__int64 a1, const char *a2)
{
  mg_error(a1, a2);
}

//----- (0000000000007A80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_connect(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  return mg_connect(a1, a2, a3, a4);
}

//----- (0000000000007AC0) ----------------------------------------------------
// attributes: thunk
void __fastcall mg_mgr_free(__int64 *a1)
{
  mg_mgr_free(a1);
}

//----- (0000000000007B20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_mqtt_send_header(__int64 a1, char a2, char a3, unsigned int a4)
{
  return mg_mqtt_send_header(a1, a2, a3, a4);
}

//----- (0000000000007B60) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE5flushEv(a1);
}

//----- (0000000000007B70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_iobuf_resize(__int64 a1, size_t size)
{
  return mg_iobuf_resize(a1, size);
}

//----- (0000000000007B90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _JNIEnv::CallVoidMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN7_JNIEnv14CallVoidMethodEP8_jobjectP10_jmethodIDz(a1, a2, a3);
}

//----- (0000000000007BC0) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_length_errorEv();
}

//----- (0000000000007BD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall mg_http_get_var(__int64 *a1, char *s, _BYTE *a3, int a4)
{
  return mg_http_get_var(a1, s, a3, a4);
}

//----- (0000000000007BF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall send_cmd(const char *a1)
{
  return send_cmd(a1);
}

//----- (0000000000007C10) ----------------------------------------------------
__int64 start()
{
  dword_33210 = 100;
  word_33218 = 17410;
  unk_33222 = 0LL;
  unk_3321A = 0LL;
  qword_33228 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33210, &off_33000);
  dword_33230 = 50;
  word_33238 = 22018;
  unk_33242 = 0LL;
  unk_3323A = 0LL;
  qword_33248 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33230, &off_33000);
  dword_33250 = 300;
  word_33258 = 18690;
  unk_33262 = 0LL;
  unk_3325A = 0LL;
  qword_33268 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33250, &off_33000);
  dword_33270 = 500;
  word_33278 = 22274;
  unk_33282 = 0LL;
  unk_3327A = 0LL;
  qword_33288 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33270, &off_33000);
  dword_33290 = 800;
  word_33298 = 17666;
  unk_332A2 = 0LL;
  unk_3329A = 0LL;
  qword_332A8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33290, &off_33000);
  dword_332B0 = 1000;
  word_332B8 = 17922;
  unk_332C2 = 0LL;
  unk_332BA = 0LL;
  qword_332C8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_332B0, &off_33000);
  dword_332D0 = 2000;
  byte_332D8 = 16;
  unk_332D9 = 0x54434152544E4F43LL;
  qword_332E8 = 0LL;
  unk_332E1 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_332D0, &off_33000);
  dword_332F0 = 2001;
  byte_332F8 = 24;
  unk_33301 = 1279348295;
  byte_3330F = 0;
  unk_3330D = 0;
  unk_332F9 = *(_QWORD *)"FATAL_SIGNAL";
  unk_33305 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_332F0, &off_33000);
  dword_33310 = 2002;
  byte_33318 = 30;
  byte_3332F = 0;
  unk_3332D = 0;
  strcpy(algn_33319, "FATAL_EXCEPTION");
  unk_33329 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33310, &off_33000);
  unk_33338 = 0LL;
  qword_33340 = 0LL;
  qword_33330 = 16LL;
  *(__int64 *)((char *)&qword_33330 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_33330, &off_33000);
  unk_33350 = 0x3366252000LL;
  qword_33358 = 0LL;
  qword_33348 = 24LL;
  *(__int64 *)((char *)&qword_33348 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_33348, &off_33000);
  esp_recv_parse_ = 0LL;
  qword_33390 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))std::shared_ptr<EspRecvParse>::~shared_ptr, &esp_recv_parse_, &off_33000);
  return __cxa_atexit((void (__fastcall *)(void *))&std::mutex::~mutex, &esp32_send_mutex_, &off_33000);
}
// 33000: using guessed type void *off_33000;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33230: using guessed type int dword_33230;
// 33238: using guessed type __int16 word_33238;
// 33248: using guessed type __int64 qword_33248;
// 33250: using guessed type int dword_33250;
// 33258: using guessed type __int16 word_33258;
// 33268: using guessed type __int64 qword_33268;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;
// 332B0: using guessed type int dword_332B0;
// 332B8: using guessed type __int16 word_332B8;
// 332C8: using guessed type __int64 qword_332C8;
// 332D0: using guessed type int dword_332D0;
// 332D8: using guessed type char byte_332D8;
// 332E8: using guessed type __int64 qword_332E8;
// 332F0: using guessed type int dword_332F0;
// 332F8: using guessed type char byte_332F8;
// 3330F: using guessed type char byte_3330F;
// 33310: using guessed type int dword_33310;
// 33318: using guessed type char byte_33318;
// 33319: using guessed type _BYTE algn_33319[7];
// 33320: using guessed type __int64 qword_33320;
// 33328: using guessed type char byte_33328;
// 3332F: using guessed type char byte_3332F;
// 33330: using guessed type __int64 qword_33330;
// 33340: using guessed type __int64 qword_33340;
// 33348: using guessed type __int64 qword_33348;
// 33358: using guessed type __int64 qword_33358;
// 33388: using guessed type __int64 esp_recv_parse_;
// 33390: using guessed type __int64 qword_33390;

//----- (0000000000007EE8) ----------------------------------------------------
__int64 sub_7EE8()
{
  dword_333C0 = 100;
  word_333C8 = 17410;
  unk_333D2 = 0LL;
  unk_333CA = 0LL;
  qword_333D8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_333C0, &off_33000);
  dword_333E0 = 50;
  word_333E8 = 22018;
  unk_333F2 = 0LL;
  unk_333EA = 0LL;
  qword_333F8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_333E0, &off_33000);
  dword_33400 = 300;
  word_33408 = 18690;
  unk_33412 = 0LL;
  unk_3340A = 0LL;
  qword_33418 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33400, &off_33000);
  dword_33420 = 500;
  word_33428 = 22274;
  unk_33432 = 0LL;
  unk_3342A = 0LL;
  qword_33438 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33420, &off_33000);
  dword_33440 = 800;
  word_33448 = 17666;
  unk_33452 = 0LL;
  unk_3344A = 0LL;
  qword_33458 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33440, &off_33000);
  dword_33460 = 1000;
  word_33468 = 17922;
  unk_33472 = 0LL;
  unk_3346A = 0LL;
  qword_33478 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33460, &off_33000);
  dword_33480 = 2000;
  byte_33488 = 16;
  unk_33489 = 0x54434152544E4F43LL;
  qword_33498 = 0LL;
  unk_33491 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_33480, &off_33000);
  dword_334A0 = 2001;
  byte_334A8 = 24;
  unk_334B1 = 1279348295;
  byte_334BF = 0;
  unk_334BD = 0;
  unk_334A9 = *(_QWORD *)"FATAL_SIGNAL";
  unk_334B5 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_334A0, &off_33000);
  dword_334C0 = 2002;
  byte_334C8 = 30;
  byte_334DF = 0;
  unk_334DD = 0;
  strcpy(algn_334C9, "FATAL_EXCEPTION");
  unk_334D9 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_334C0, &off_33000);
  unk_334E8 = 0LL;
  qword_334F0 = 0LL;
  qword_334E0 = 16LL;
  *(__int64 *)((char *)&qword_334E0 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_334E0, &off_33000);
  unk_33500 = 0x3366252000LL;
  qword_33508 = 0LL;
  qword_334F8 = 24LL;
  *(__int64 *)((char *)&qword_334F8 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_334F8, &off_33000);
}
// 33000: using guessed type void *off_33000;
// 333C0: using guessed type int dword_333C0;
// 333C8: using guessed type __int16 word_333C8;
// 333D8: using guessed type __int64 qword_333D8;
// 333E0: using guessed type int dword_333E0;
// 333E8: using guessed type __int16 word_333E8;
// 333F8: using guessed type __int64 qword_333F8;
// 33400: using guessed type int dword_33400;
// 33408: using guessed type __int16 word_33408;
// 33418: using guessed type __int64 qword_33418;
// 33420: using guessed type int dword_33420;
// 33428: using guessed type __int16 word_33428;
// 33438: using guessed type __int64 qword_33438;
// 33440: using guessed type int dword_33440;
// 33448: using guessed type __int16 word_33448;
// 33458: using guessed type __int64 qword_33458;
// 33460: using guessed type int dword_33460;
// 33468: using guessed type __int16 word_33468;
// 33478: using guessed type __int64 qword_33478;
// 33480: using guessed type int dword_33480;
// 33488: using guessed type char byte_33488;
// 33498: using guessed type __int64 qword_33498;
// 334A0: using guessed type int dword_334A0;
// 334A8: using guessed type char byte_334A8;
// 334BF: using guessed type char byte_334BF;
// 334C0: using guessed type int dword_334C0;
// 334C8: using guessed type char byte_334C8;
// 334C9: using guessed type _BYTE algn_334C9[7];
// 334D0: using guessed type __int64 qword_334D0;
// 334D8: using guessed type char byte_334D8;
// 334DF: using guessed type char byte_334DF;
// 334E0: using guessed type __int64 qword_334E0;
// 334F0: using guessed type __int64 qword_334F0;
// 334F8: using guessed type __int64 qword_334F8;
// 33508: using guessed type __int64 qword_33508;

//----- (000000000000818C) ----------------------------------------------------
__int64 sub_818C()
{
  return __cxa_finalize(&off_33000);
}
// 33000: using guessed type void *off_33000;

//----- (00000000000081A0) ----------------------------------------------------
__int64 (*__fastcall sub_81A0(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (00000000000081AC) ----------------------------------------------------
__int64 __fastcall sub_81AC(void *a1)
{
  return __cxa_atexit((void (__fastcall *)(void *))sub_81A0, a1, &off_33000);
}
// 33000: using guessed type void *off_33000;

//----- (00000000000081C8) ----------------------------------------------------
void __fastcall std::string::~string(__int64 a1)
{
  if ( (*(_BYTE *)a1 & 1) != 0 )
    operator delete(*(void **)(a1 + 16));
}

//----- (00000000000081DC) ----------------------------------------------------
void __fastcall LEVELS::~LEVELS(void **this)
{
  if ( ((_BYTE)this[1] & 1) != 0 )
    operator delete(this[3]);
}

//----- (00000000000081F0) ----------------------------------------------------
__int64 __fastcall std::shared_ptr<EspRecvParse>::~shared_ptr(__int64 result)
{
  std::__shared_weak_count *v1; // x19
  unsigned __int64 *v2; // x8
  unsigned __int64 v3; // x9

  v1 = *(std::__shared_weak_count **)(result + 8);
  if ( v1 )
  {
    v2 = (unsigned __int64 *)((char *)v1 + 8);
    do
      v3 = __ldaxr(v2);
    while ( __stlxr(v3 - 1, v2) );
    if ( !v3 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v1 + 16LL))(v1);
      return std::__shared_weak_count::__release_weak(v1);
    }
  }
  return result;
}

//----- (0000000000008248) ----------------------------------------------------
__int64 threadServer(void)
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  unsigned __int64 v12; // [xsp+8h] [xbp-1B8h] BYREF
  size_t v13; // [xsp+10h] [xbp-1B0h]
  void *v14; // [xsp+18h] [xbp-1A8h]
  int v15; // [xsp+20h] [xbp-1A0h] BYREF
  unsigned __int64 v16; // [xsp+28h] [xbp-198h] BYREF
  size_t v17; // [xsp+30h] [xbp-190h]
  void *v18; // [xsp+38h] [xbp-188h]
  char v19[8]; // [xsp+40h] [xbp-180h] BYREF
  _QWORD v20[41]; // [xsp+48h] [xbp-178h] BYREF

  v20[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v15 = dword_33210;
  v16 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v17 = v2;
    v18 = v3;
    v16 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v16 + 1;
  LOBYTE(v16) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v15) & 1) == 0 )
  {
    v9 = 0;
    if ( (v16 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v13 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v13 = v7;
    v14 = v8;
    v12 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v12 + 1;
  LOBYTE(v12) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v12);
  if ( (v12 & 1) != 0 )
  {
    operator delete(v14);
    if ( (v16 & 1) == 0 )
    {
LABEL_21:
      if ( (v9 & 1) == 0 )
        return system("su -c 'easynode_server'");
      goto LABEL_25;
    }
  }
  else if ( (v16 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_24:
  operator delete(v18);
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v19, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v20, (__int64)"start easynode server", 21LL);
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return system("su -c 'easynode_server'");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 8248: using guessed type char var_180[8];

//----- (00000000000084C8) ----------------------------------------------------
__int64 maintest(void)
{
  unsigned __int16 v0; // w0
  const char *v1; // x21
  unsigned __int16 v2; // w19
  size_t v3; // x0
  size_t v4; // x20
  char *v5; // x22
  unsigned __int64 v6; // x23
  const void *v7; // x20
  size_t v8; // x0
  size_t v9; // x21
  char *v10; // x22
  char v11; // w20
  unsigned __int64 v12; // x23
  const char *v13; // x21
  size_t v14; // x0
  size_t v15; // x20
  char *v16; // x22
  unsigned __int64 v17; // x23
  const void *v18; // x20
  size_t v19; // x0
  size_t v20; // x21
  char *v21; // x22
  char v22; // w20
  unsigned __int64 v23; // x23
  unsigned __int64 v25; // [xsp+8h] [xbp-278h] BYREF
  size_t v26; // [xsp+10h] [xbp-270h]
  void *v27; // [xsp+18h] [xbp-268h]
  int v28; // [xsp+20h] [xbp-260h] BYREF
  unsigned __int64 v29; // [xsp+28h] [xbp-258h] BYREF
  size_t v30; // [xsp+30h] [xbp-250h]
  void *v31; // [xsp+38h] [xbp-248h]
  unsigned __int64 v32; // [xsp+40h] [xbp-240h] BYREF
  size_t v33; // [xsp+48h] [xbp-238h]
  void *v34; // [xsp+50h] [xbp-230h]
  int v35; // [xsp+58h] [xbp-228h] BYREF
  unsigned __int64 v36; // [xsp+60h] [xbp-220h] BYREF
  size_t v37; // [xsp+68h] [xbp-218h]
  void *v38; // [xsp+70h] [xbp-210h]
  char v39[328]; // [xsp+78h] [xbp-208h] BYREF
  _OWORD v40[5]; // [xsp+1C0h] [xbp-C0h] BYREF
  _OWORD v41[3]; // [xsp+210h] [xbp-70h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v40[0] = xmmword_1DD09;
  v40[1] = unk_1DD19;
  *(_OWORD *)((char *)v41 + 10) = unk_1DD63;
  v40[4] = xmmword_1DD49;
  v41[0] = unk_1DD59;
  v40[2] = xmmword_1DD29;
  v40[3] = unk_1DD39;
  v0 = EspRecvParse::crc162((EspRecvParse *)v40, (unsigned __int8 *)((unsigned int)&qword_68 + 2));
  if ( (word_33218 & 1) != 0 )
    v1 = (const char *)qword_33228;
  else
    v1 = (char *)&word_33218 + 1;
  v2 = v0;
  v35 = dword_33210;
  v37 = 0LL;
  v38 = 0LL;
  v36 = 0LL;
  v3 = strlen(v1);
  if ( v3 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_52;
  v4 = v3;
  if ( v3 >= 0x17 )
  {
    v6 = (v3 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v5 = (char *)operator new(v6);
    v37 = v4;
    v38 = v5;
    v36 = v6 | 1;
    goto LABEL_9;
  }
  v5 = (char *)&v36 + 1;
  LOBYTE(v36) = 2 * v3;
  if ( v3 )
LABEL_9:
    memcpy(v5, v1, v4);
  v5[v4] = 0;
  if ( (g3::logLevel(&v35) & 1) == 0 )
  {
    v11 = 0;
    if ( (v36 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v33 = 0LL;
  v34 = 0LL;
  v32 = 0LL;
  v7 = TAG;
  v8 = strlen((const char *)TAG);
  if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v9 = v8;
  if ( v8 >= 0x17 )
  {
    v12 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = (char *)operator new(v12);
    v33 = v9;
    v34 = v10;
    v32 = v12 | 1;
    goto LABEL_18;
  }
  v10 = (char *)&v32 + 1;
  LOBYTE(v32) = 2 * v8;
  if ( v8 )
LABEL_18:
    memcpy(v10, v7, v9);
  v10[v9] = 0;
  v11 = g3::logTag(&v32);
  if ( (v32 & 1) == 0 )
  {
    if ( (v36 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v38);
    if ( (v11 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v34);
  if ( (v36 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v11 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v39, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v39, "main test crc_data=%#x", v2);
    LogCapture::~LogCapture((LogCapture *)v39);
  }
LABEL_26:
  if ( (word_33218 & 1) != 0 )
    v13 = (const char *)qword_33228;
  else
    v13 = (char *)&word_33218 + 1;
  v28 = dword_33210;
  v30 = 0LL;
  v31 = 0LL;
  v29 = 0LL;
  v14 = strlen(v13);
  if ( v14 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_52:
    std::__basic_string_common<true>::__throw_length_error();
  v15 = v14;
  if ( v14 >= 0x17 )
  {
    v17 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v16 = (char *)operator new(v17);
    v30 = v15;
    v31 = v16;
    v29 = v17 | 1;
    goto LABEL_34;
  }
  v16 = (char *)&v29 + 1;
  LOBYTE(v29) = 2 * v14;
  if ( v14 )
LABEL_34:
    memcpy(v16, v13, v15);
  v16[v15] = 0;
  if ( (g3::logLevel(&v28) & 1) == 0 )
  {
    v22 = 0;
    if ( (v29 & 1) == 0 )
      goto LABEL_46;
    goto LABEL_49;
  }
  v26 = 0LL;
  v27 = 0LL;
  v25 = 0LL;
  v18 = TAG;
  v19 = strlen((const char *)TAG);
  if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v20 = v19;
  if ( v19 >= 0x17 )
  {
    v23 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v21 = (char *)operator new(v23);
    v26 = v20;
    v27 = v21;
    v25 = v23 | 1;
    goto LABEL_43;
  }
  v21 = (char *)&v25 + 1;
  LOBYTE(v25) = 2 * v19;
  if ( v19 )
LABEL_43:
    memcpy(v21, v18, v20);
  v21[v20] = 0;
  v22 = g3::logTag(&v25);
  if ( (v25 & 1) != 0 )
  {
    operator delete(v27);
    if ( (v29 & 1) == 0 )
    {
LABEL_46:
      if ( (v22 & 1) == 0 )
        return 0LL;
      goto LABEL_50;
    }
  }
  else if ( (v29 & 1) == 0 )
  {
    goto LABEL_46;
  }
LABEL_49:
  operator delete(v31);
  if ( (v22 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)v39, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v39, "main test crc1=%#x crc2=%#x", (unsigned __int8)v2, HIBYTE(v2));
    LogCapture::~LogCapture((LogCapture *)v39);
  }
  return 0LL;
}
// 68: using guessed type __int64 qword_68;
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 1DD09: using guessed type __int128 xmmword_1DD09;
// 1DD29: using guessed type __int128 xmmword_1DD29;
// 1DD49: using guessed type __int128 xmmword_1DD49;
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 84C8: using guessed type _OWORD var_C0[5];
// 84C8: using guessed type _OWORD anonymous_0[3];

//----- (000000000000896C) ----------------------------------------------------
__int64 __fastcall initTheEasyNode(__int64 a1, __int64 a2)
{
  const char *v4; // x22
  size_t v5; // x0
  size_t v6; // x21
  char *v7; // x23
  unsigned __int64 v8; // x24
  const void *v9; // x21
  size_t v10; // x0
  size_t v11; // x22
  char *v12; // x23
  char v13; // w21
  unsigned __int64 v14; // x24
  const char *v15; // x22
  size_t v16; // x0
  size_t v17; // x21
  char *v18; // x23
  unsigned __int64 v19; // x24
  const void *v20; // x21
  size_t v21; // x0
  size_t v22; // x22
  char *v23; // x23
  char v24; // w21
  unsigned __int64 v25; // x24
  unsigned int v26; // w0
  const char *v27; // x21
  unsigned int v28; // w19
  size_t v29; // x0
  size_t v30; // x20
  char *v31; // x22
  unsigned __int64 v32; // x23
  const void *v33; // x20
  size_t v34; // x0
  size_t v35; // x21
  char *v36; // x22
  char v37; // w20
  unsigned __int64 v38; // x23
  _QWORD *v39; // x0
  unsigned __int64 v41; // [xsp+8h] [xbp-248h] BYREF
  size_t v42; // [xsp+10h] [xbp-240h]
  void *v43; // [xsp+18h] [xbp-238h]
  int v44; // [xsp+20h] [xbp-230h] BYREF
  unsigned __int64 v45; // [xsp+28h] [xbp-228h] BYREF
  size_t v46; // [xsp+30h] [xbp-220h]
  void *v47; // [xsp+38h] [xbp-218h]
  unsigned __int64 v48; // [xsp+40h] [xbp-210h] BYREF
  size_t v49; // [xsp+48h] [xbp-208h]
  void *v50; // [xsp+50h] [xbp-200h]
  int v51; // [xsp+58h] [xbp-1F8h] BYREF
  unsigned __int64 v52; // [xsp+60h] [xbp-1F0h] BYREF
  size_t v53; // [xsp+68h] [xbp-1E8h]
  void *v54; // [xsp+70h] [xbp-1E0h]
  unsigned __int64 v55; // [xsp+78h] [xbp-1D8h] BYREF
  size_t v56; // [xsp+80h] [xbp-1D0h]
  void *v57; // [xsp+88h] [xbp-1C8h]
  int v58; // [xsp+90h] [xbp-1C0h] BYREF
  unsigned __int64 v59; // [xsp+98h] [xbp-1B8h] BYREF
  size_t v60; // [xsp+A0h] [xbp-1B0h]
  void *v61; // [xsp+A8h] [xbp-1A8h]
  char v62[8]; // [xsp+B0h] [xbp-1A0h] BYREF
  _QWORD v63[41]; // [xsp+B8h] [xbp-198h] BYREF

  v63[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v58 = dword_33210;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v60 = 0LL;
  v61 = 0LL;
  v59 = 0LL;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_77;
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v60 = v6;
    v61 = v7;
    v59 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v59 + 1;
  LOBYTE(v59) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v58) & 1) == 0 )
  {
    v13 = 0;
    if ( (v59 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v56 = 0LL;
  v57 = 0LL;
  v55 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v56 = v11;
    v57 = v12;
    v55 = v14 | 1;
    goto LABEL_18;
  }
  v12 = (char *)&v55 + 1;
  LOBYTE(v55) = 2 * v10;
  if ( v10 )
LABEL_18:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v55);
  if ( (v55 & 1) == 0 )
  {
    if ( (v59 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v61);
    if ( (v13 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v57);
  if ( (v59 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v13 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v62, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v63, (__int64)"jni init easynodelib", 20LL);
    LogCapture::~LogCapture((LogCapture *)v62);
  }
LABEL_26:
  maintest();
  if ( (word_33218 & 1) != 0 )
    v15 = (const char *)qword_33228;
  else
    v15 = (char *)&word_33218 + 1;
  v51 = dword_33210;
  v53 = 0LL;
  v54 = 0LL;
  v52 = 0LL;
  v16 = strlen(v15);
  if ( v16 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_77:
    std::__basic_string_common<true>::__throw_length_error();
  v17 = v16;
  if ( v16 >= 0x17 )
  {
    v19 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v18 = (char *)operator new(v19);
    v53 = v17;
    v54 = v18;
    v52 = v19 | 1;
    goto LABEL_34;
  }
  v18 = (char *)&v52 + 1;
  LOBYTE(v52) = 2 * v16;
  if ( v16 )
LABEL_34:
    memcpy(v18, v15, v17);
  v18[v17] = 0;
  if ( (g3::logLevel(&v51) & 1) == 0 )
  {
    v24 = 0;
    if ( (v52 & 1) == 0 )
      goto LABEL_46;
    goto LABEL_49;
  }
  v49 = 0LL;
  v50 = 0LL;
  v48 = 0LL;
  v20 = TAG;
  v21 = strlen((const char *)TAG);
  if ( v21 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v22 = v21;
  if ( v21 >= 0x17 )
  {
    v25 = (v21 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v23 = (char *)operator new(v25);
    v49 = v22;
    v50 = v23;
    v48 = v25 | 1;
    goto LABEL_43;
  }
  v23 = (char *)&v48 + 1;
  LOBYTE(v48) = 2 * v21;
  if ( v21 )
LABEL_43:
    memcpy(v23, v20, v22);
  v23[v22] = 0;
  v24 = g3::logTag(&v48);
  if ( (v48 & 1) == 0 )
  {
    if ( (v52 & 1) == 0 )
      goto LABEL_46;
LABEL_49:
    operator delete(v54);
    if ( (v24 & 1) == 0 )
      goto LABEL_51;
    goto LABEL_50;
  }
  operator delete(v50);
  if ( (v52 & 1) != 0 )
    goto LABEL_49;
LABEL_46:
  if ( (v24 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)v62, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v63, (__int64)"init easynode", 13LL);
    LogCapture::~LogCapture((LogCapture *)v62);
  }
LABEL_51:
  easynode_object_ = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, a2);
  v26 = easynode_init();
  if ( (word_33218 & 1) != 0 )
    v27 = (const char *)qword_33228;
  else
    v27 = (char *)&word_33218 + 1;
  v28 = v26;
  v44 = dword_33210;
  v46 = 0LL;
  v47 = 0LL;
  v45 = 0LL;
  v29 = strlen(v27);
  if ( v29 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v30 = v29;
  if ( v29 >= 0x17 )
  {
    v32 = (v29 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v31 = (char *)operator new(v32);
    v46 = v30;
    v47 = v31;
    v45 = v32 | 1;
    goto LABEL_59;
  }
  v31 = (char *)&v45 + 1;
  LOBYTE(v45) = 2 * v29;
  if ( v29 )
LABEL_59:
    memcpy(v31, v27, v30);
  v31[v30] = 0;
  if ( (g3::logLevel(&v44) & 1) == 0 )
  {
    v37 = 0;
    if ( (v45 & 1) == 0 )
      goto LABEL_71;
    goto LABEL_74;
  }
  v42 = 0LL;
  v43 = 0LL;
  v41 = 0LL;
  v33 = TAG;
  v34 = strlen((const char *)TAG);
  if ( v34 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v35 = v34;
  if ( v34 >= 0x17 )
  {
    v38 = (v34 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v36 = (char *)operator new(v38);
    v42 = v35;
    v43 = v36;
    v41 = v38 | 1;
    goto LABEL_68;
  }
  v36 = (char *)&v41 + 1;
  LOBYTE(v41) = 2 * v34;
  if ( v34 )
LABEL_68:
    memcpy(v36, v33, v35);
  v36[v35] = 0;
  v37 = g3::logTag(&v41);
  if ( (v41 & 1) != 0 )
  {
    operator delete(v43);
    if ( (v45 & 1) == 0 )
    {
LABEL_71:
      if ( (v37 & 1) == 0 )
        return v28;
      goto LABEL_75;
    }
  }
  else if ( (v45 & 1) == 0 )
  {
    goto LABEL_71;
  }
LABEL_74:
  operator delete(v47);
  if ( (v37 & 1) != 0 )
  {
LABEL_75:
    LogCapture::LogCapture((LogCapture *)v62, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    v39 = std::__put_character_sequence<char,std::char_traits<char>>(v63, (__int64)"easynode_init", 13LL);
    std::ostream::operator<<(v39);
    LogCapture::~LogCapture((LogCapture *)v62);
  }
  return v28;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33368: using guessed type __int64 easynode_object_;
// 896C: using guessed type char var_1A0[8];

//----- (0000000000009018) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 7B80: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 9018: using guessed type char var_60[8];

//----- (0000000000009204) ----------------------------------------------------
__int64 regUSBCtrl()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  const char *v12; // x20
  size_t v13; // x0
  size_t v14; // x19
  char *v15; // x21
  unsigned __int64 v16; // x22
  const void *v17; // x19
  size_t v18; // x0
  size_t v19; // x20
  char *v20; // x21
  char v21; // w19
  unsigned __int64 v22; // x22
  unsigned __int64 v23; // [xsp+0h] [xbp-1F0h] BYREF
  size_t v24; // [xsp+8h] [xbp-1E8h]
  void *v25; // [xsp+10h] [xbp-1E0h]
  int v26; // [xsp+18h] [xbp-1D8h] BYREF
  unsigned __int64 v27; // [xsp+20h] [xbp-1D0h] BYREF
  size_t v28; // [xsp+28h] [xbp-1C8h]
  void *v29; // [xsp+30h] [xbp-1C0h]
  unsigned __int64 v30; // [xsp+38h] [xbp-1B8h] BYREF
  size_t v31; // [xsp+40h] [xbp-1B0h]
  void *v32; // [xsp+48h] [xbp-1A8h]
  int v33; // [xsp+50h] [xbp-1A0h] BYREF
  unsigned __int64 v34; // [xsp+58h] [xbp-198h] BYREF
  size_t v35; // [xsp+60h] [xbp-190h]
  void *v36; // [xsp+68h] [xbp-188h]
  char v37[8]; // [xsp+70h] [xbp-180h] BYREF
  _QWORD v38[41]; // [xsp+78h] [xbp-178h] BYREF

  v38[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v35 = 0LL;
  v36 = 0LL;
  v33 = dword_33210;
  v34 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_54;
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v35 = v2;
    v36 = v3;
    v34 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v34 + 1;
  LOBYTE(v34) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v33) & 1) == 0 )
  {
    v9 = 0;
    if ( (v34 & 1) == 0 )
      goto LABEL_22;
    goto LABEL_16;
  }
  v31 = 0LL;
  v32 = 0LL;
  v30 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v31 = v7;
    v32 = v8;
    v30 = v10 | 1;
    goto LABEL_19;
  }
  v8 = (char *)&v30 + 1;
  LOBYTE(v30) = 2 * v6;
  if ( v6 )
LABEL_19:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v30);
  if ( (v30 & 1) != 0 )
  {
    operator delete(v32);
    if ( (v34 & 1) == 0 )
    {
LABEL_22:
      if ( (v9 & 1) == 0 )
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  else if ( (v34 & 1) == 0 )
  {
    goto LABEL_22;
  }
LABEL_16:
  operator delete(v36);
  if ( (v9 & 1) == 0 )
    goto LABEL_24;
LABEL_23:
  LogCapture::LogCapture((LogCapture *)v37, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  std::__put_character_sequence<char,std::char_traits<char>>(v38, (__int64)"jni register usb control", 24LL);
  LogCapture::~LogCapture((LogCapture *)v37);
LABEL_24:
  if ( easynode_object_ )
    return register_ctrl((__int64)sub_DD64);
  if ( (word_33278 & 1) != 0 )
    v12 = (const char *)qword_33288;
  else
    v12 = (char *)&word_33278 + 1;
  v26 = dword_33270;
  v28 = 0LL;
  v29 = 0LL;
  v27 = 0LL;
  v13 = strlen(v12);
  if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_54:
    std::__basic_string_common<true>::__throw_length_error();
  v14 = v13;
  if ( v13 >= 0x17 )
  {
    v16 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v15 = (char *)operator new(v16);
    v28 = v14;
    v29 = v15;
    v27 = v16 | 1;
    goto LABEL_36;
  }
  v15 = (char *)&v27 + 1;
  LOBYTE(v27) = 2 * v13;
  if ( v13 )
LABEL_36:
    memcpy(v15, v12, v14);
  v15[v14] = 0;
  if ( (g3::logLevel(&v26) & 1) == 0 )
  {
    v21 = 0;
    if ( (v27 & 1) == 0 )
      goto LABEL_49;
    goto LABEL_43;
  }
  v24 = 0LL;
  v25 = 0LL;
  v23 = 0LL;
  v17 = TAG;
  v18 = strlen((const char *)TAG);
  if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v19 = v18;
  if ( v18 >= 0x17 )
  {
    v22 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v20 = (char *)operator new(v22);
    v24 = v19;
    v25 = v20;
    v23 = v22 | 1;
    goto LABEL_46;
  }
  v20 = (char *)&v23 + 1;
  LOBYTE(v23) = 2 * v18;
  if ( v18 )
LABEL_46:
    memcpy(v20, v17, v19);
  v20[v19] = 0;
  v21 = g3::logTag(&v23);
  if ( (v23 & 1) == 0 )
  {
    if ( (v27 & 1) == 0 )
      goto LABEL_49;
LABEL_43:
    operator delete(v29);
    if ( (v21 & 1) == 0 )
      return 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  operator delete(v25);
  if ( (v27 & 1) != 0 )
    goto LABEL_43;
LABEL_49:
  if ( (v21 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)v37, (const char *)TAG, (const LEVELS *)&dword_33270, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v38, (__int64)"jni easynode_object_ not init", 29LL);
    LogCapture::~LogCapture((LogCapture *)v37);
  }
  return 0xFFFFFFFFLL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33368: using guessed type __int64 easynode_object_;
// 9204: using guessed type char var_180[8];

//----- (0000000000009690) ----------------------------------------------------
__int64 *setESP32Callback(void)
{
  __int64 *result; // x0
  __int64 (*v1)(void); // x8
  __int64 v2[4]; // [xsp+0h] [xbp-50h] BYREF
  __int64 *v3; // [xsp+20h] [xbp-30h]
  __int64 v4; // [xsp+38h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2[0] = (__int64)&off_32278;
  v3 = v2;
  EspRecvParse::setCallBack(esp_recv_parse_, (__int64)v2);
  result = v3;
  if ( v2 == v3 )
  {
    v1 = *(__int64 (**)(void))(*v3 + 32);
  }
  else
  {
    if ( !v3 )
      return result;
    v1 = *(__int64 (**)(void))(*v3 + 40);
  }
  return (__int64 *)v1();
}
// 32278: using guessed type __int64 (__fastcall *off_32278)();
// 33388: using guessed type __int64 esp_recv_parse_;

//----- (0000000000009758) ----------------------------------------------------
__int64 regESP32()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  __int64 result; // x0
  const char *v12; // x20
  size_t v13; // x0
  size_t v14; // x19
  char *v15; // x21
  const char *v16; // x20
  size_t v17; // x0
  size_t v18; // x19
  char *v19; // x21
  unsigned __int64 v20; // x22
  const void *v21; // x19
  size_t v22; // x0
  size_t v23; // x20
  char *v24; // x21
  char v25; // w19
  unsigned __int64 v26; // x22
  const void *v27; // x19
  size_t v28; // x0
  size_t v29; // x20
  char *v30; // x21
  char v31; // w19
  unsigned __int64 v32; // x22
  unsigned __int64 v33; // x22
  void (*v34)(void); // x8
  unsigned __int64 v35; // [xsp+8h] [xbp-238h] BYREF
  size_t v36; // [xsp+10h] [xbp-230h]
  void *v37; // [xsp+18h] [xbp-228h]
  int v38; // [xsp+20h] [xbp-220h] BYREF
  unsigned __int64 v39; // [xsp+28h] [xbp-218h] BYREF
  size_t v40; // [xsp+30h] [xbp-210h]
  void *v41; // [xsp+38h] [xbp-208h]
  unsigned __int64 v42; // [xsp+40h] [xbp-200h] BYREF
  size_t v43; // [xsp+48h] [xbp-1F8h]
  void *v44; // [xsp+50h] [xbp-1F0h]
  int v45; // [xsp+58h] [xbp-1E8h] BYREF
  unsigned __int64 v46; // [xsp+60h] [xbp-1E0h] BYREF
  size_t v47; // [xsp+68h] [xbp-1D8h]
  void *v48; // [xsp+70h] [xbp-1D0h]
  unsigned __int64 v49; // [xsp+78h] [xbp-1C8h] BYREF
  size_t v50; // [xsp+80h] [xbp-1C0h]
  void *v51; // [xsp+88h] [xbp-1B8h]
  int v52; // [xsp+90h] [xbp-1B0h] BYREF
  unsigned __int64 v53; // [xsp+98h] [xbp-1A8h] BYREF
  size_t v54; // [xsp+A0h] [xbp-1A0h]
  void *v55; // [xsp+A8h] [xbp-198h]
  __int64 (__fastcall **v56)(); // [xsp+B0h] [xbp-190h] BYREF
  _QWORD v57[3]; // [xsp+B8h] [xbp-188h] BYREF
  __int64 *v58; // [xsp+D0h] [xbp-170h]
  __int64 v59; // [xsp+1F8h] [xbp-48h]

  v59 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v52 = dword_33210;
  v54 = 0LL;
  v55 = 0LL;
  v53 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_85;
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v54 = v2;
    v55 = v3;
    v53 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v53 + 1;
  LOBYTE(v53) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v52) & 1) == 0 )
  {
    v9 = 0;
    if ( (v53 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v50 = 0LL;
  v51 = 0LL;
  v49 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v50 = v7;
    v51 = v8;
    v49 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v49 + 1;
  LOBYTE(v49) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v49);
  if ( (v49 & 1) == 0 )
  {
    if ( (v53 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v55);
    if ( (v9 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v51);
  if ( (v53 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)&v56, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v57, (__int64)"jni register ESP32", 18LL);
    LogCapture::~LogCapture((LogCapture *)&v56);
  }
LABEL_26:
  if ( !easynode_object_ )
  {
    if ( (word_33278 & 1) != 0 )
      v16 = (const char *)qword_33288;
    else
      v16 = (char *)&word_33278 + 1;
    v45 = dword_33270;
    v47 = 0LL;
    v48 = 0LL;
    v46 = 0LL;
    v17 = strlen(v16);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      goto LABEL_85;
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v20 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)operator new(v20);
      v47 = v18;
      v48 = v19;
      v46 = v20 | 1;
    }
    else
    {
      v19 = (char *)&v46 + 1;
      LOBYTE(v46) = 2 * v17;
      if ( !v17 )
      {
LABEL_44:
        v19[v18] = 0;
        if ( (g3::logLevel(&v45) & 1) == 0 )
        {
          v25 = 0;
          if ( (v46 & 1) == 0 )
            goto LABEL_64;
          goto LABEL_67;
        }
        v43 = 0LL;
        v44 = 0LL;
        v42 = 0LL;
        v21 = TAG;
        v22 = strlen((const char *)TAG);
        if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v23 = v22;
        if ( v22 >= 0x17 )
        {
          v32 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v24 = (char *)operator new(v32);
          v43 = v23;
          v44 = v24;
          v42 = v32 | 1;
        }
        else
        {
          v24 = (char *)&v42 + 1;
          LOBYTE(v42) = 2 * v22;
          if ( !v22 )
          {
LABEL_62:
            v24[v23] = 0;
            v25 = g3::logTag(&v42);
            if ( (v42 & 1) != 0 )
            {
              operator delete(v44);
              if ( (v46 & 1) == 0 )
              {
LABEL_64:
                if ( (v25 & 1) != 0 )
                {
LABEL_65:
                  LogCapture::LogCapture(
                    (LogCapture *)&v56,
                    (const char *)TAG,
                    (const LEVELS *)&dword_33270,
                    "",
                    6,
                    0LL);
                  std::__put_character_sequence<char,std::char_traits<char>>(
                    v57,
                    (__int64)"jni easynode_object_ not init",
                    29LL);
                  LogCapture::~LogCapture((LogCapture *)&v56);
                  return 0xFFFFFFFFLL;
                }
                return 0xFFFFFFFFLL;
              }
            }
            else if ( (v46 & 1) == 0 )
            {
              goto LABEL_64;
            }
LABEL_67:
            operator delete(v48);
            if ( (v25 & 1) != 0 )
              goto LABEL_65;
            return 0xFFFFFFFFLL;
          }
        }
        memcpy(v24, v21, v23);
        goto LABEL_62;
      }
    }
    memcpy(v19, v16, v18);
    goto LABEL_44;
  }
  result = register_esp32((__int64)sub_E1B4);
  if ( (_DWORD)result )
    return result;
  if ( (word_33218 & 1) != 0 )
    v12 = (const char *)qword_33228;
  else
    v12 = (char *)&word_33218 + 1;
  v38 = dword_33210;
  v40 = 0LL;
  v41 = 0LL;
  v39 = 0LL;
  v13 = strlen(v12);
  if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_85:
    std::__basic_string_common<true>::__throw_length_error();
  v14 = v13;
  if ( v13 >= 0x17 )
  {
    v26 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v15 = (char *)operator new(v26);
    v40 = v14;
    v41 = v15;
    v39 = v26 | 1;
    goto LABEL_52;
  }
  v15 = (char *)&v39 + 1;
  LOBYTE(v39) = 2 * v13;
  if ( v13 )
LABEL_52:
    memcpy(v15, v12, v14);
  v15[v14] = 0;
  if ( (g3::logLevel(&v38) & 1) == 0 )
  {
    v31 = 0;
    if ( (v39 & 1) == 0 )
      goto LABEL_73;
    goto LABEL_76;
  }
  v36 = 0LL;
  v37 = 0LL;
  v35 = 0LL;
  v27 = TAG;
  v28 = strlen((const char *)TAG);
  if ( v28 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v29 = v28;
  if ( v28 >= 0x17 )
  {
    v33 = (v28 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v30 = (char *)operator new(v33);
    v36 = v29;
    v37 = v30;
    v35 = v33 | 1;
    goto LABEL_70;
  }
  v30 = (char *)&v35 + 1;
  LOBYTE(v35) = 2 * v28;
  if ( v28 )
LABEL_70:
    memcpy(v30, v27, v29);
  v30[v29] = 0;
  v31 = g3::logTag(&v35);
  if ( (v35 & 1) == 0 )
  {
    if ( (v39 & 1) == 0 )
      goto LABEL_73;
LABEL_76:
    operator delete(v41);
    if ( (v31 & 1) == 0 )
      goto LABEL_78;
    goto LABEL_77;
  }
  operator delete(v37);
  if ( (v39 & 1) != 0 )
    goto LABEL_76;
LABEL_73:
  if ( (v31 & 1) != 0 )
  {
LABEL_77:
    LogCapture::LogCapture((LogCapture *)&v56, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v57, (__int64)"set esp32 call back", 19LL);
    LogCapture::~LogCapture((LogCapture *)&v56);
  }
LABEL_78:
  v58 = (__int64 *)&v56;
  v56 = &off_32278;
  EspRecvParse::setCallBack(esp_recv_parse_, (__int64)&v56);
  if ( &v56 == (__int64 (__fastcall ***)())v58 )
  {
    v34 = *(void (**)(void))(*v58 + 32);
    goto LABEL_82;
  }
  if ( v58 )
  {
    v34 = *(void (**)(void))(*v58 + 40);
LABEL_82:
    v34();
  }
  return 0LL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 32278: using guessed type __int64 (__fastcall *off_32278)();
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33368: using guessed type __int64 easynode_object_;
// 33388: using guessed type __int64 esp_recv_parse_;

//----- (0000000000009E8C) ----------------------------------------------------
__int64 regLora()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  const char *v12; // x20
  size_t v13; // x0
  size_t v14; // x19
  char *v15; // x21
  unsigned __int64 v16; // x22
  const void *v17; // x19
  size_t v18; // x0
  size_t v19; // x20
  char *v20; // x21
  char v21; // w19
  unsigned __int64 v22; // x22
  unsigned __int64 v23; // [xsp+0h] [xbp-1F0h] BYREF
  size_t v24; // [xsp+8h] [xbp-1E8h]
  void *v25; // [xsp+10h] [xbp-1E0h]
  int v26; // [xsp+18h] [xbp-1D8h] BYREF
  unsigned __int64 v27; // [xsp+20h] [xbp-1D0h] BYREF
  size_t v28; // [xsp+28h] [xbp-1C8h]
  void *v29; // [xsp+30h] [xbp-1C0h]
  unsigned __int64 v30; // [xsp+38h] [xbp-1B8h] BYREF
  size_t v31; // [xsp+40h] [xbp-1B0h]
  void *v32; // [xsp+48h] [xbp-1A8h]
  int v33; // [xsp+50h] [xbp-1A0h] BYREF
  unsigned __int64 v34; // [xsp+58h] [xbp-198h] BYREF
  size_t v35; // [xsp+60h] [xbp-190h]
  void *v36; // [xsp+68h] [xbp-188h]
  char v37[8]; // [xsp+70h] [xbp-180h] BYREF
  _QWORD v38[41]; // [xsp+78h] [xbp-178h] BYREF

  v38[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v35 = 0LL;
  v36 = 0LL;
  v33 = dword_33210;
  v34 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_54;
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v35 = v2;
    v36 = v3;
    v34 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v34 + 1;
  LOBYTE(v34) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v33) & 1) == 0 )
  {
    v9 = 0;
    if ( (v34 & 1) == 0 )
      goto LABEL_22;
    goto LABEL_16;
  }
  v31 = 0LL;
  v32 = 0LL;
  v30 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v31 = v7;
    v32 = v8;
    v30 = v10 | 1;
    goto LABEL_19;
  }
  v8 = (char *)&v30 + 1;
  LOBYTE(v30) = 2 * v6;
  if ( v6 )
LABEL_19:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v30);
  if ( (v30 & 1) != 0 )
  {
    operator delete(v32);
    if ( (v34 & 1) == 0 )
    {
LABEL_22:
      if ( (v9 & 1) == 0 )
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  else if ( (v34 & 1) == 0 )
  {
    goto LABEL_22;
  }
LABEL_16:
  operator delete(v36);
  if ( (v9 & 1) == 0 )
    goto LABEL_24;
LABEL_23:
  LogCapture::LogCapture((LogCapture *)v37, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  std::__put_character_sequence<char,std::char_traits<char>>(v38, (__int64)"jni register lora", 17LL);
  LogCapture::~LogCapture((LogCapture *)v37);
LABEL_24:
  if ( easynode_object_ )
    return register_lora((__int64)sub_E460);
  if ( (word_33278 & 1) != 0 )
    v12 = (const char *)qword_33288;
  else
    v12 = (char *)&word_33278 + 1;
  v26 = dword_33270;
  v28 = 0LL;
  v29 = 0LL;
  v27 = 0LL;
  v13 = strlen(v12);
  if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_54:
    std::__basic_string_common<true>::__throw_length_error();
  v14 = v13;
  if ( v13 >= 0x17 )
  {
    v16 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v15 = (char *)operator new(v16);
    v28 = v14;
    v29 = v15;
    v27 = v16 | 1;
    goto LABEL_36;
  }
  v15 = (char *)&v27 + 1;
  LOBYTE(v27) = 2 * v13;
  if ( v13 )
LABEL_36:
    memcpy(v15, v12, v14);
  v15[v14] = 0;
  if ( (g3::logLevel(&v26) & 1) == 0 )
  {
    v21 = 0;
    if ( (v27 & 1) == 0 )
      goto LABEL_49;
    goto LABEL_43;
  }
  v24 = 0LL;
  v25 = 0LL;
  v23 = 0LL;
  v17 = TAG;
  v18 = strlen((const char *)TAG);
  if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v19 = v18;
  if ( v18 >= 0x17 )
  {
    v22 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v20 = (char *)operator new(v22);
    v24 = v19;
    v25 = v20;
    v23 = v22 | 1;
    goto LABEL_46;
  }
  v20 = (char *)&v23 + 1;
  LOBYTE(v23) = 2 * v18;
  if ( v18 )
LABEL_46:
    memcpy(v20, v17, v19);
  v20[v19] = 0;
  v21 = g3::logTag(&v23);
  if ( (v23 & 1) == 0 )
  {
    if ( (v27 & 1) == 0 )
      goto LABEL_49;
LABEL_43:
    operator delete(v29);
    if ( (v21 & 1) == 0 )
      return 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  operator delete(v25);
  if ( (v27 & 1) != 0 )
    goto LABEL_43;
LABEL_49:
  if ( (v21 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)v37, (const char *)TAG, (const LEVELS *)&dword_33270, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v38, (__int64)"jni easynode_object_ not init", 29LL);
    LogCapture::~LogCapture((LogCapture *)v37);
  }
  return 0xFFFFFFFFLL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33368: using guessed type __int64 easynode_object_;
// 9E8C: using guessed type char var_180[8];

//----- (000000000000A318) ----------------------------------------------------
__int64 __fastcall sendUsbCtrlData(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w21
  __int64 v6; // x22
  unsigned int v7; // w21

  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, a3, 0LL);
  v7 = send_data(1, v6, v5);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v6, 0LL);
  return v7;
}

//----- (000000000000A3A4) ----------------------------------------------------
__int64 __fastcall sendESP32Data(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w24
  int v6; // w23
  const void *v7; // x21
  _WORD *v8; // x22
  char v9; // w10
  __int16 v10; // w0
  const char *v11; // x25
  size_t v12; // x0
  size_t v13; // x24
  char *v14; // x26
  unsigned __int64 v15; // x27
  const void *v16; // x24
  size_t v17; // x0
  size_t v18; // x25
  char *v19; // x26
  char v20; // w24
  unsigned __int64 v21; // x27
  unsigned int v22; // w0
  const char *v23; // x25
  unsigned int v24; // w23
  size_t v25; // x0
  size_t v26; // x24
  char *v27; // x26
  unsigned __int64 v28; // x27
  const void *v29; // x24
  size_t v30; // x0
  size_t v31; // x25
  char *v32; // x26
  char v33; // w24
  unsigned __int64 v34; // x27
  _QWORD *v35; // x0
  _QWORD *v36; // x0
  _QWORD *v37; // x0
  unsigned __int64 v39; // [xsp+8h] [xbp-218h] BYREF
  size_t v40; // [xsp+10h] [xbp-210h]
  void *v41; // [xsp+18h] [xbp-208h]
  int v42; // [xsp+20h] [xbp-200h] BYREF
  unsigned __int64 v43; // [xsp+28h] [xbp-1F8h] BYREF
  size_t v44; // [xsp+30h] [xbp-1F0h]
  void *v45; // [xsp+38h] [xbp-1E8h]
  unsigned __int64 v46; // [xsp+40h] [xbp-1E0h] BYREF
  size_t v47; // [xsp+48h] [xbp-1D8h]
  void *v48; // [xsp+50h] [xbp-1D0h]
  int v49; // [xsp+58h] [xbp-1C8h] BYREF
  unsigned __int64 v50; // [xsp+60h] [xbp-1C0h] BYREF
  size_t v51; // [xsp+68h] [xbp-1B8h]
  void *v52; // [xsp+70h] [xbp-1B0h]
  char v53[8]; // [xsp+78h] [xbp-1A8h] BYREF
  _QWORD v54[42]; // [xsp+80h] [xbp-1A0h] BYREF

  v54[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  std::mutex::lock((std::mutex *)&esp32_send_mutex_);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  v6 = v5 + 12;
  v7 = (const void *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, a3, 0LL);
  v8 = (_WORD *)operator new[](v5 + 12);
  memset(v8, 0, v5 + 12);
  v9 = dword_33010;
  *((_BYTE *)v8 + 2) = v5;
  *v8 = 21930;
  v8[2] = -9510;
  *((_BYTE *)v8 + 3) = v9;
  *((_DWORD *)v8 + 2) = 0;
  memcpy(v8 + 6, v7, v5);
  v10 = EspRecvParse::crc162((EspRecvParse *)v8, (unsigned __int8 *)(unsigned int)(v5 + 12));
  *((_BYTE *)v8 + 7) = HIBYTE(v10);
  v49 = dword_33210;
  if ( (word_33218 & 1) != 0 )
    v11 = (const char *)qword_33228;
  else
    v11 = (char *)&word_33218 + 1;
  *((_BYTE *)v8 + 6) = v10;
  v51 = 0LL;
  v52 = 0LL;
  v50 = 0LL;
  v12 = strlen(v11);
  if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v13 = v12;
  if ( v12 >= 0x17 )
  {
    v15 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v14 = (char *)operator new(v15);
    v51 = v13;
    v52 = v14;
    v50 = v15 | 1;
    goto LABEL_9;
  }
  v14 = (char *)&v50 + 1;
  LOBYTE(v50) = 2 * v12;
  if ( v12 )
LABEL_9:
    memcpy(v14, v11, v13);
  v14[v13] = 0;
  if ( (g3::logLevel(&v49) & 1) == 0 )
  {
    v20 = 0;
    if ( (v50 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v47 = 0LL;
  v48 = 0LL;
  v46 = 0LL;
  v16 = TAG;
  v17 = strlen((const char *)TAG);
  if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v18 = v17;
  if ( v17 >= 0x17 )
  {
    v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v19 = (char *)operator new(v21);
    v47 = v18;
    v48 = v19;
    v46 = v21 | 1;
    goto LABEL_18;
  }
  v19 = (char *)&v46 + 1;
  LOBYTE(v46) = 2 * v17;
  if ( v17 )
LABEL_18:
    memcpy(v19, v16, v18);
  v19[v18] = 0;
  v20 = g3::logTag(&v46);
  if ( (v46 & 1) == 0 )
  {
    if ( (v50 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v52);
    if ( (v20 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v48);
  if ( (v50 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v20 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v53, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)v53,
      "sendESP32Data out[6]=%#x out[7]=%#x",
      *((unsigned __int8 *)v8 + 6),
      *((unsigned __int8 *)v8 + 7));
    LogCapture::~LogCapture((LogCapture *)v53);
  }
LABEL_26:
  v22 = send_data(2, (__int64)v8, v6);
  if ( (word_33218 & 1) != 0 )
    v23 = (const char *)qword_33228;
  else
    v23 = (char *)&word_33218 + 1;
  v24 = v22;
  v42 = dword_33210;
  v44 = 0LL;
  v45 = 0LL;
  v43 = 0LL;
  v25 = strlen(v23);
  if ( v25 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v26 = v25;
  if ( v25 >= 0x17 )
  {
    v28 = (v25 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v27 = (char *)operator new(v28);
    v44 = v26;
    v45 = v27;
    v43 = v28 | 1;
    goto LABEL_34;
  }
  v27 = (char *)&v43 + 1;
  LOBYTE(v43) = 2 * v25;
  if ( v25 )
LABEL_34:
    memcpy(v27, v23, v26);
  v27[v26] = 0;
  if ( (g3::logLevel(&v42) & 1) == 0 )
  {
    v33 = 0;
    if ( (v43 & 1) == 0 )
      goto LABEL_46;
    goto LABEL_49;
  }
  v40 = 0LL;
  v41 = 0LL;
  v39 = 0LL;
  v29 = TAG;
  v30 = strlen((const char *)TAG);
  if ( v30 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v31 = v30;
  if ( v30 >= 0x17 )
  {
    v34 = (v30 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v32 = (char *)operator new(v34);
    v40 = v31;
    v41 = v32;
    v39 = v34 | 1;
    goto LABEL_43;
  }
  v32 = (char *)&v39 + 1;
  LOBYTE(v39) = 2 * v30;
  if ( v30 )
LABEL_43:
    memcpy(v32, v29, v31);
  v32[v31] = 0;
  v33 = g3::logTag(&v39);
  if ( (v39 & 1) != 0 )
  {
    operator delete(v41);
    if ( (v43 & 1) == 0 )
    {
LABEL_46:
      if ( (v33 & 1) == 0 )
        goto LABEL_51;
      goto LABEL_50;
    }
  }
  else if ( (v43 & 1) == 0 )
  {
    goto LABEL_46;
  }
LABEL_49:
  operator delete(v45);
  if ( (v33 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)v53, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    v35 = std::__put_character_sequence<char,std::char_traits<char>>(v54, (__int64)"data send result", 16LL);
    v36 = std::ostream::operator<<(v35);
    v37 = std::__put_character_sequence<char,std::char_traits<char>>(v36, (__int64)"esp32Channel=", 13LL);
    std::ostream::operator<<(v37);
    LogCapture::~LogCapture((LogCapture *)v53);
  }
LABEL_51:
  (*(void (__fastcall **)(__int64, __int64, const void *, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v7, 0LL);
  operator delete[](v8);
  std::mutex::unlock((std::mutex *)&esp32_send_mutex_);
  return v24;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33010: using guessed type int dword_33010;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// A3A4: using guessed type char var_1A8[8];

//----- (000000000000A970) ----------------------------------------------------
__int64 __fastcall sendLoraData(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w21
  __int64 v6; // x22
  unsigned int v7; // w21

  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, a3, 0LL);
  v7 = send_data(3, v6, v5);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v6, 0LL);
  return v7;
}

//----- (000000000000A9FC) ----------------------------------------------------
__int64 __fastcall openUSB(__int64 a1, __int64 a2, int a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  const void *v9; // x20
  size_t v10; // x0
  size_t v11; // x21
  char *v12; // x22
  char v13; // w20
  unsigned __int64 v14; // x23
  _QWORD *v15; // x0
  const char *v16; // x20
  size_t v17; // x0
  size_t v18; // x19
  char *v19; // x21
  unsigned int v20; // w19
  unsigned __int64 v21; // x22
  const void *v22; // x19
  size_t v23; // x0
  size_t v24; // x20
  char *v25; // x21
  char v26; // w19
  unsigned __int64 v27; // x22
  unsigned __int64 v29; // [xsp+0h] [xbp-200h] BYREF
  size_t v30; // [xsp+8h] [xbp-1F8h]
  void *v31; // [xsp+10h] [xbp-1F0h]
  int v32; // [xsp+18h] [xbp-1E8h] BYREF
  unsigned __int64 v33; // [xsp+20h] [xbp-1E0h] BYREF
  size_t v34; // [xsp+28h] [xbp-1D8h]
  void *v35; // [xsp+30h] [xbp-1D0h]
  unsigned __int64 v36; // [xsp+38h] [xbp-1C8h] BYREF
  size_t v37; // [xsp+40h] [xbp-1C0h]
  void *v38; // [xsp+48h] [xbp-1B8h]
  int v39; // [xsp+50h] [xbp-1B0h] BYREF
  unsigned __int64 v40; // [xsp+58h] [xbp-1A8h] BYREF
  size_t v41; // [xsp+60h] [xbp-1A0h]
  void *v42; // [xsp+68h] [xbp-198h]
  char v43; // [xsp+70h] [xbp-190h] BYREF
  char v44[15]; // [xsp+71h] [xbp-18Fh] BYREF
  void *v45; // [xsp+80h] [xbp-180h]
  __int64 v46; // [xsp+1B8h] [xbp-48h]

  v46 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v39 = dword_33210;
  v41 = 0LL;
  v42 = 0LL;
  v40 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v41 = v6;
    v42 = v7;
    v40 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v40 + 1;
  LOBYTE(v40) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v39) & 1) == 0 )
  {
    v13 = 0;
    if ( (v40 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v37 = 0LL;
  v38 = 0LL;
  v36 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v37 = v11;
    v38 = v12;
    v36 = v14 | 1;
    goto LABEL_18;
  }
  v12 = (char *)&v36 + 1;
  LOBYTE(v36) = 2 * v10;
  if ( v10 )
LABEL_18:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v36);
  if ( (v36 & 1) == 0 )
  {
    if ( (v40 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v42);
    if ( (v13 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v38);
  if ( (v40 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v13 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)&v43, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    v15 = std::__put_character_sequence<char,std::char_traits<char>>(&v44[7], (__int64)"open usb ", 9LL);
    std::ostream::operator<<(v15);
    LogCapture::~LogCapture((LogCapture *)&v43);
  }
LABEL_26:
  if ( (unsigned int)(a3 - 1) >= 6 )
  {
    if ( (word_33298 & 1) != 0 )
      v16 = (const char *)qword_332A8;
    else
      v16 = (char *)&word_33298 + 1;
    v32 = dword_33290;
    v34 = 0LL;
    v35 = 0LL;
    v33 = 0LL;
    v17 = strlen(v16);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)operator new(v21);
      v34 = v18;
      v35 = v19;
      v33 = v21 | 1;
    }
    else
    {
      v19 = (char *)&v33 + 1;
      LOBYTE(v33) = 2 * v17;
      if ( !v17 )
      {
LABEL_38:
        v19[v18] = 0;
        if ( (g3::logLevel(&v32) & 1) == 0 )
        {
          v26 = 0;
          if ( (v33 & 1) == 0 )
            goto LABEL_49;
          goto LABEL_52;
        }
        v30 = 0LL;
        v31 = 0LL;
        v29 = 0LL;
        v22 = TAG;
        v23 = strlen((const char *)TAG);
        if ( v23 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v24 = v23;
        if ( v23 >= 0x17 )
        {
          v27 = (v23 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v25 = (char *)operator new(v27);
          v30 = v24;
          v31 = v25;
          v29 = v27 | 1;
        }
        else
        {
          v25 = (char *)&v29 + 1;
          LOBYTE(v29) = 2 * v23;
          if ( !v23 )
          {
LABEL_47:
            v25[v24] = 0;
            v26 = g3::logTag(&v29);
            if ( (v29 & 1) != 0 )
            {
              operator delete(v31);
              if ( (v33 & 1) == 0 )
              {
LABEL_49:
                if ( (v26 & 1) == 0 )
                  return (unsigned int)-1;
                goto LABEL_53;
              }
            }
            else if ( (v33 & 1) == 0 )
            {
              goto LABEL_49;
            }
LABEL_52:
            operator delete(v35);
            if ( (v26 & 1) == 0 )
              return (unsigned int)-1;
LABEL_53:
            LogCapture::LogCapture((LogCapture *)&v43, (const char *)TAG, (const LEVELS *)&dword_33290, "", 6, 0LL);
            std::__put_character_sequence<char,std::char_traits<char>>(
              &v44[7],
              (__int64)"usb index out of range!",
              23LL);
            LogCapture::~LogCapture((LogCapture *)&v43);
            return (unsigned int)-1;
          }
        }
        memcpy(v25, v22, v24);
        goto LABEL_47;
      }
    }
    memcpy(v19, v16, v18);
    goto LABEL_38;
  }
  *(_QWORD *)&v44[7] = 0LL;
  v45 = 0LL;
  v43 = 12;
  strcpy(v44, "USBxON");
  v44[3] = a3 + 48;
  v20 = send_cmd(v44);
  if ( (v43 & 1) != 0 )
    operator delete(v45);
  return v20;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;

//----- (000000000000AEF8) ----------------------------------------------------
__int64 __fastcall closeUSB(__int64 a1, __int64 a2, int a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  const void *v9; // x20
  size_t v10; // x0
  size_t v11; // x21
  char *v12; // x22
  char v13; // w20
  unsigned __int64 v14; // x23
  _QWORD *v15; // x0
  const char *v16; // x20
  size_t v17; // x0
  size_t v18; // x19
  char *v19; // x21
  unsigned int v20; // w19
  unsigned __int64 v21; // x22
  const void *v22; // x19
  size_t v23; // x0
  size_t v24; // x20
  char *v25; // x21
  char v26; // w19
  unsigned __int64 v27; // x22
  unsigned __int64 v29; // [xsp+0h] [xbp-200h] BYREF
  size_t v30; // [xsp+8h] [xbp-1F8h]
  void *v31; // [xsp+10h] [xbp-1F0h]
  int v32; // [xsp+18h] [xbp-1E8h] BYREF
  unsigned __int64 v33; // [xsp+20h] [xbp-1E0h] BYREF
  size_t v34; // [xsp+28h] [xbp-1D8h]
  void *v35; // [xsp+30h] [xbp-1D0h]
  unsigned __int64 v36; // [xsp+38h] [xbp-1C8h] BYREF
  size_t v37; // [xsp+40h] [xbp-1C0h]
  void *v38; // [xsp+48h] [xbp-1B8h]
  int v39; // [xsp+50h] [xbp-1B0h] BYREF
  unsigned __int64 v40; // [xsp+58h] [xbp-1A8h] BYREF
  size_t v41; // [xsp+60h] [xbp-1A0h]
  void *v42; // [xsp+68h] [xbp-198h]
  char v43; // [xsp+70h] [xbp-190h] BYREF
  _BYTE v44[15]; // [xsp+71h] [xbp-18Fh] BYREF
  void *v45; // [xsp+80h] [xbp-180h]
  __int64 v46; // [xsp+1B8h] [xbp-48h]

  v46 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v39 = dword_33210;
  v41 = 0LL;
  v42 = 0LL;
  v40 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v41 = v6;
    v42 = v7;
    v40 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v40 + 1;
  LOBYTE(v40) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v39) & 1) == 0 )
  {
    v13 = 0;
    if ( (v40 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v37 = 0LL;
  v38 = 0LL;
  v36 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v37 = v11;
    v38 = v12;
    v36 = v14 | 1;
    goto LABEL_18;
  }
  v12 = (char *)&v36 + 1;
  LOBYTE(v36) = 2 * v10;
  if ( v10 )
LABEL_18:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v36);
  if ( (v36 & 1) == 0 )
  {
    if ( (v40 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v42);
    if ( (v13 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v38);
  if ( (v40 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v13 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)&v43, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    v15 = std::__put_character_sequence<char,std::char_traits<char>>(&v44[7], (__int64)"close usb ", 10LL);
    std::ostream::operator<<(v15);
    LogCapture::~LogCapture((LogCapture *)&v43);
  }
LABEL_26:
  if ( (unsigned int)(a3 - 1) >= 6 )
  {
    if ( (word_33298 & 1) != 0 )
      v16 = (const char *)qword_332A8;
    else
      v16 = (char *)&word_33298 + 1;
    v32 = dword_33290;
    v34 = 0LL;
    v35 = 0LL;
    v33 = 0LL;
    v17 = strlen(v16);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)operator new(v21);
      v34 = v18;
      v35 = v19;
      v33 = v21 | 1;
    }
    else
    {
      v19 = (char *)&v33 + 1;
      LOBYTE(v33) = 2 * v17;
      if ( !v17 )
      {
LABEL_38:
        v19[v18] = 0;
        if ( (g3::logLevel(&v32) & 1) == 0 )
        {
          v26 = 0;
          if ( (v33 & 1) == 0 )
            goto LABEL_49;
          goto LABEL_52;
        }
        v30 = 0LL;
        v31 = 0LL;
        v29 = 0LL;
        v22 = TAG;
        v23 = strlen((const char *)TAG);
        if ( v23 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v24 = v23;
        if ( v23 >= 0x17 )
        {
          v27 = (v23 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v25 = (char *)operator new(v27);
          v30 = v24;
          v31 = v25;
          v29 = v27 | 1;
        }
        else
        {
          v25 = (char *)&v29 + 1;
          LOBYTE(v29) = 2 * v23;
          if ( !v23 )
          {
LABEL_47:
            v25[v24] = 0;
            v26 = g3::logTag(&v29);
            if ( (v29 & 1) != 0 )
            {
              operator delete(v31);
              if ( (v33 & 1) == 0 )
              {
LABEL_49:
                if ( (v26 & 1) == 0 )
                  return (unsigned int)-1;
                goto LABEL_53;
              }
            }
            else if ( (v33 & 1) == 0 )
            {
              goto LABEL_49;
            }
LABEL_52:
            operator delete(v35);
            if ( (v26 & 1) == 0 )
              return (unsigned int)-1;
LABEL_53:
            LogCapture::LogCapture((LogCapture *)&v43, (const char *)TAG, (const LEVELS *)&dword_33290, "", 6, 0LL);
            std::__put_character_sequence<char,std::char_traits<char>>(
              &v44[7],
              (__int64)"usb index out of range!",
              23LL);
            LogCapture::~LogCapture((LogCapture *)&v43);
            return (unsigned int)-1;
          }
        }
        memcpy(v25, v22, v24);
        goto LABEL_47;
      }
    }
    memcpy(v19, v16, v18);
    goto LABEL_38;
  }
  *(_QWORD *)&v44[7] = 0LL;
  v45 = 0LL;
  v43 = 14;
  *(_QWORD *)v44 = 0x46464F78425355LL;
  v44[3] = a3 + 48;
  v20 = send_cmd(v44);
  if ( (v43 & 1) != 0 )
    operator delete(v45);
  return v20;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;

//----- (000000000000B3F4) ----------------------------------------------------
__int64 __fastcall setBacklight(__int64 a1, __int64 a2, unsigned int a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  int v9; // w1
  const void *v10; // x20
  size_t v11; // x0
  size_t v12; // x21
  char *v13; // x22
  char v14; // w20
  unsigned __int64 v15; // x23
  const char *v16; // x20
  size_t v17; // x0
  size_t v18; // x19
  char *v19; // x21
  _QWORD *v20; // x0
  const char *v21; // x20
  size_t v22; // x0
  size_t v23; // x19
  char *v24; // x21
  unsigned __int64 v25; // x22
  const void *v26; // x19
  size_t v27; // x0
  size_t v28; // x20
  char *v29; // x21
  unsigned __int64 v30; // x22
  const void *v31; // x19
  size_t v32; // x0
  size_t v33; // x20
  char *v34; // x21
  char v35; // w19
  char v36; // w19
  unsigned __int64 v37; // x22
  unsigned __int64 v38; // x22
  char *v39; // x1
  __int64 v40; // x2
  unsigned int v41; // w19
  const char *v42; // x0
  unsigned __int64 v44; // [xsp+8h] [xbp-268h] BYREF
  size_t v45; // [xsp+10h] [xbp-260h]
  void *v46; // [xsp+18h] [xbp-258h]
  int v47; // [xsp+20h] [xbp-250h] BYREF
  unsigned __int64 v48; // [xsp+28h] [xbp-248h] BYREF
  size_t v49; // [xsp+30h] [xbp-240h]
  void *v50; // [xsp+38h] [xbp-238h]
  __int64 v51[2]; // [xsp+40h] [xbp-230h] BYREF
  void *v52; // [xsp+50h] [xbp-220h]
  void *v53[3]; // [xsp+58h] [xbp-218h] BYREF
  unsigned __int64 v54; // [xsp+70h] [xbp-200h] BYREF
  size_t v55; // [xsp+78h] [xbp-1F8h]
  void *v56; // [xsp+80h] [xbp-1F0h]
  int v57; // [xsp+88h] [xbp-1E8h] BYREF
  unsigned __int64 v58; // [xsp+90h] [xbp-1E0h] BYREF
  size_t v59; // [xsp+98h] [xbp-1D8h]
  void *v60; // [xsp+A0h] [xbp-1D0h]
  unsigned __int64 v61; // [xsp+A8h] [xbp-1C8h] BYREF
  size_t v62; // [xsp+B0h] [xbp-1C0h]
  void *v63; // [xsp+B8h] [xbp-1B8h]
  int v64; // [xsp+C0h] [xbp-1B0h] BYREF
  unsigned __int64 v65; // [xsp+C8h] [xbp-1A8h] BYREF
  size_t v66; // [xsp+D0h] [xbp-1A0h]
  void *v67; // [xsp+D8h] [xbp-198h]
  char v68[8]; // [xsp+E0h] [xbp-190h] BYREF
  _QWORD v69[41]; // [xsp+E8h] [xbp-188h] BYREF

  v69[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v64 = dword_33210;
  v66 = 0LL;
  v67 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v65 = 0LL;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v66 = v6;
    v67 = v7;
    v65 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v65 + 1;
  LOBYTE(v65) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v64) & 1) == 0 )
  {
    v14 = 0;
    if ( (v65 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_31;
  }
  v62 = 0LL;
  v63 = 0LL;
  v61 = 0LL;
  v10 = TAG;
  v11 = strlen((const char *)TAG);
  if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v12 = v11;
  if ( v11 >= 0x17 )
  {
    v15 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v13 = (char *)operator new(v15);
    v62 = v12;
    v63 = v13;
    v61 = v15 | 1;
    goto LABEL_18;
  }
  v13 = (char *)&v61 + 1;
  LOBYTE(v61) = 2 * v11;
  if ( v11 )
LABEL_18:
    memcpy(v13, v10, v12);
  v13[v12] = 0;
  v14 = g3::logTag(&v61);
  if ( (v61 & 1) != 0 )
  {
    operator delete(v63);
    if ( (v65 & 1) == 0 )
    {
LABEL_21:
      if ( (v14 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_32;
    }
  }
  else if ( (v65 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_31:
  operator delete(v67);
  if ( (v14 & 1) == 0 )
  {
LABEL_22:
    if ( a3 >= 0x65 )
      goto LABEL_23;
    goto LABEL_33;
  }
LABEL_32:
  LogCapture::LogCapture((LogCapture *)v68, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  v20 = std::__put_character_sequence<char,std::char_traits<char>>(v69, (__int64)"set blacklight ", 15LL);
  std::ostream::operator<<(v20);
  LogCapture::~LogCapture((LogCapture *)v68);
  if ( a3 >= 0x65 )
  {
LABEL_23:
    if ( (word_33298 & 1) != 0 )
      v16 = (const char *)qword_332A8;
    else
      v16 = (char *)&word_33298 + 1;
    v57 = dword_33290;
    v59 = 0LL;
    v60 = 0LL;
    v58 = 0LL;
    v17 = strlen(v16);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v25 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)operator new(v25);
      v59 = v18;
      v60 = v19;
      v58 = v25 | 1;
    }
    else
    {
      v19 = (char *)&v58 + 1;
      LOBYTE(v58) = 2 * v17;
      if ( !v17 )
      {
LABEL_42:
        v19[v18] = 0;
        if ( (g3::logLevel(&v57) & 1) == 0 )
        {
          v35 = 0;
          if ( (v58 & 1) == 0 )
            goto LABEL_62;
          goto LABEL_77;
        }
        v55 = 0LL;
        v56 = 0LL;
        v54 = 0LL;
        v26 = TAG;
        v27 = strlen((const char *)TAG);
        if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v28 = v27;
        if ( v27 >= 0x17 )
        {
          v37 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v29 = (char *)operator new(v37);
          v55 = v28;
          v56 = v29;
          v54 = v37 | 1;
        }
        else
        {
          v29 = (char *)&v54 + 1;
          LOBYTE(v54) = 2 * v27;
          if ( !v27 )
          {
LABEL_60:
            v29[v28] = 0;
            v35 = g3::logTag(&v54);
            if ( (v54 & 1) != 0 )
            {
              operator delete(v56);
              if ( (v58 & 1) == 0 )
              {
LABEL_62:
                if ( (v35 & 1) == 0 )
                  return (unsigned int)-1;
                goto LABEL_78;
              }
            }
            else if ( (v58 & 1) == 0 )
            {
              goto LABEL_62;
            }
LABEL_77:
            operator delete(v60);
            if ( (v35 & 1) == 0 )
              return (unsigned int)-1;
LABEL_78:
            LogCapture::LogCapture((LogCapture *)v68, (const char *)TAG, (const LEVELS *)&dword_33290, "", 6, 0LL);
            std::__put_character_sequence<char,std::char_traits<char>>(
              v69,
              (__int64)"backlight luminance out of range!",
              33LL);
            LogCapture::~LogCapture((LogCapture *)v68);
            return (unsigned int)-1;
          }
        }
        memcpy(v29, v26, v28);
        goto LABEL_60;
      }
    }
    memcpy(v19, v16, v18);
    goto LABEL_42;
  }
LABEL_33:
  std::to_string(v53, (std::__ndk1 *)a3, v9);
  std::operator+<char>("BKL", (unsigned __int8 *)v53, v51);
  if ( (word_33218 & 1) != 0 )
    v21 = (const char *)qword_33228;
  else
    v21 = (char *)&word_33218 + 1;
  v47 = dword_33210;
  v49 = 0LL;
  v50 = 0LL;
  v48 = 0LL;
  v22 = strlen(v21);
  if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v23 = v22;
  if ( v22 >= 0x17 )
  {
    v30 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v24 = (char *)operator new(v30);
    v49 = v23;
    v50 = v24;
    v48 = v30 | 1;
    goto LABEL_48;
  }
  v24 = (char *)&v48 + 1;
  LOBYTE(v48) = 2 * v22;
  if ( v22 )
LABEL_48:
    memcpy(v24, v21, v23);
  v24[v23] = 0;
  if ( (g3::logLevel(&v47) & 1) == 0 )
  {
    v36 = 0;
    if ( (v48 & 1) == 0 )
      goto LABEL_68;
    goto LABEL_81;
  }
  v45 = 0LL;
  v46 = 0LL;
  v44 = 0LL;
  v31 = TAG;
  v32 = strlen((const char *)TAG);
  if ( v32 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v33 = v32;
  if ( v32 >= 0x17 )
  {
    v38 = (v32 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v34 = (char *)operator new(v38);
    v45 = v33;
    v46 = v34;
    v44 = v38 | 1;
    goto LABEL_65;
  }
  v34 = (char *)&v44 + 1;
  LOBYTE(v44) = 2 * v32;
  if ( v32 )
LABEL_65:
    memcpy(v34, v31, v33);
  v34[v33] = 0;
  v36 = g3::logTag(&v44);
  if ( (v44 & 1) == 0 )
  {
    if ( (v48 & 1) == 0 )
      goto LABEL_68;
LABEL_81:
    operator delete(v50);
    if ( (v36 & 1) != 0 )
      goto LABEL_69;
    goto LABEL_82;
  }
  operator delete(v46);
  if ( (v48 & 1) != 0 )
    goto LABEL_81;
LABEL_68:
  if ( (v36 & 1) != 0 )
  {
LABEL_69:
    LogCapture::LogCapture((LogCapture *)v68, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    if ( (v51[0] & 1) != 0 )
      v39 = (char *)v52;
    else
      v39 = (char *)v51 + 1;
    if ( (v51[0] & 1) != 0 )
      v40 = v51[1];
    else
      v40 = (unsigned __int64)LOBYTE(v51[0]) >> 1;
    std::__put_character_sequence<char,std::char_traits<char>>(v69, (__int64)v39, v40);
    LogCapture::~LogCapture((LogCapture *)v68);
  }
LABEL_82:
  if ( (v51[0] & 1) != 0 )
    v42 = (const char *)v52;
  else
    v42 = (char *)v51 + 1;
  v41 = send_cmd(v42);
  if ( (v51[0] & 1) != 0 )
    operator delete(v52);
  if ( ((__int64)v53[0] & 1) != 0 )
    operator delete(v53[2]);
  return v41;
}
// B65C: variable 'v9' is possibly undefined
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;
// B3F4: using guessed type char var_190[8];

//----- (000000000000BB74) ----------------------------------------------------
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  size_t v6; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x22
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24
  void *v12; // x1
  unsigned __int64 v14; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v6 = strlen(a1);
  v7 = *a2;
  if ( (v7 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v7 >> 1;
  v9 = v8 + v6;
  if ( v8 + v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v10 = v6;
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * v6;
    v11 = (char *)a3 + 1;
    if ( !v6 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v14 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v11 = (void *)operator new(v14);
  a3[1] = v10;
  a3[2] = (__int64)v11;
  *a3 = v14 | 1;
  if ( v10 )
LABEL_7:
    memcpy(v11, a1, v10);
LABEL_8:
  *((_BYTE *)v11 + v10) = 0;
  if ( (v7 & 1) != 0 )
    v12 = (void *)*((_QWORD *)a2 + 2);
  else
    v12 = a2 + 1;
  return std::string::append(a3, v12, v8);
}

//----- (000000000000BC70) ----------------------------------------------------
__int64 __fastcall controlESP(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  const void *v9; // x20
  size_t v10; // x0
  size_t v11; // x21
  char *v12; // x22
  char v13; // w20
  unsigned __int64 v14; // x23
  _QWORD *v15; // x20
  int v16; // w1
  char *v17; // x1
  void *v18; // x2
  const char *v19; // x0
  void *v21[2]; // [xsp+0h] [xbp-1E0h] BYREF
  void *v22; // [xsp+10h] [xbp-1D0h]
  unsigned __int64 v23; // [xsp+18h] [xbp-1C8h] BYREF
  size_t v24; // [xsp+20h] [xbp-1C0h]
  void *v25; // [xsp+28h] [xbp-1B8h]
  int v26; // [xsp+30h] [xbp-1B0h] BYREF
  unsigned __int64 v27; // [xsp+38h] [xbp-1A8h] BYREF
  size_t v28; // [xsp+40h] [xbp-1A0h]
  void *v29; // [xsp+48h] [xbp-198h]
  char v30[8]; // [xsp+50h] [xbp-190h] BYREF
  _QWORD v31[41]; // [xsp+58h] [xbp-188h] BYREF

  v31[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v26 = dword_33210;
  v28 = 0LL;
  v29 = 0LL;
  v27 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v28 = v6;
    v29 = v7;
    v27 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v27 + 1;
  LOBYTE(v27) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v26) & 1) == 0 )
  {
    v13 = 0;
    if ( (v27 & 1) == 0 )
      goto LABEL_22;
    goto LABEL_16;
  }
  v24 = 0LL;
  v25 = 0LL;
  v23 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v24 = v11;
    v25 = v12;
    v23 = v14 | 1;
    goto LABEL_19;
  }
  v12 = (char *)&v23 + 1;
  LOBYTE(v23) = 2 * v10;
  if ( v10 )
LABEL_19:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v23);
  if ( (v23 & 1) != 0 )
  {
    operator delete(v25);
    if ( (v27 & 1) == 0 )
    {
LABEL_22:
      if ( (v13 & 1) == 0 )
        goto LABEL_32;
      goto LABEL_23;
    }
  }
  else if ( (v27 & 1) == 0 )
  {
    goto LABEL_22;
  }
LABEL_16:
  operator delete(v29);
  if ( (v13 & 1) == 0 )
    goto LABEL_32;
LABEL_23:
  LogCapture::LogCapture((LogCapture *)v30, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  v15 = std::__put_character_sequence<char,std::char_traits<char>>(v31, (__int64)"constrol ESP ", 13LL);
  std::to_string(v21, (std::__ndk1 *)a3, v16);
  if ( ((__int64)v21[0] & 1) != 0 )
    v17 = (char *)v22;
  else
    v17 = (char *)v21 + 1;
  if ( ((__int64)v21[0] & 1) != 0 )
    v18 = v21[1];
  else
    v18 = (void *)((unsigned __int64)LOBYTE(v21[0]) >> 1);
  std::__put_character_sequence<char,std::char_traits<char>>(v15, (__int64)v17, (__int64)v18);
  if ( ((__int64)v21[0] & 1) != 0 )
    operator delete(v22);
  LogCapture::~LogCapture((LogCapture *)v30);
LABEL_32:
  if ( a3 )
    v19 = "ESPON";
  else
    v19 = "ESPOFF";
  return send_cmd(v19);
}
// BE4C: variable 'v16' is possibly undefined
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// BC70: using guessed type char var_190[8];

//----- (000000000000BF6C) ----------------------------------------------------
__int64 resetESP()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  unsigned __int64 v12; // [xsp+8h] [xbp-1B8h] BYREF
  size_t v13; // [xsp+10h] [xbp-1B0h]
  void *v14; // [xsp+18h] [xbp-1A8h]
  int v15; // [xsp+20h] [xbp-1A0h] BYREF
  unsigned __int64 v16; // [xsp+28h] [xbp-198h] BYREF
  size_t v17; // [xsp+30h] [xbp-190h]
  void *v18; // [xsp+38h] [xbp-188h]
  char v19[8]; // [xsp+40h] [xbp-180h] BYREF
  _QWORD v20[41]; // [xsp+48h] [xbp-178h] BYREF

  v20[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v15 = dword_33210;
  v16 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v17 = v2;
    v18 = v3;
    v16 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v16 + 1;
  LOBYTE(v16) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v15) & 1) == 0 )
  {
    v9 = 0;
    if ( (v16 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v13 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v13 = v7;
    v14 = v8;
    v12 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v12 + 1;
  LOBYTE(v12) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v12);
  if ( (v12 & 1) != 0 )
  {
    operator delete(v14);
    if ( (v16 & 1) == 0 )
    {
LABEL_21:
      if ( (v9 & 1) == 0 )
        return send_cmd("ESPRST");
      goto LABEL_25;
    }
  }
  else if ( (v16 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_24:
  operator delete(v18);
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v19, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v20, (__int64)"reset ESP", 9LL);
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return send_cmd("ESPRST");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// BF6C: using guessed type char var_180[8];

//----- (000000000000C1EC) ----------------------------------------------------
__int64 loraDIS()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  unsigned __int64 v12; // [xsp+8h] [xbp-1B8h] BYREF
  size_t v13; // [xsp+10h] [xbp-1B0h]
  void *v14; // [xsp+18h] [xbp-1A8h]
  int v15; // [xsp+20h] [xbp-1A0h] BYREF
  unsigned __int64 v16; // [xsp+28h] [xbp-198h] BYREF
  size_t v17; // [xsp+30h] [xbp-190h]
  void *v18; // [xsp+38h] [xbp-188h]
  char v19[8]; // [xsp+40h] [xbp-180h] BYREF
  _QWORD v20[41]; // [xsp+48h] [xbp-178h] BYREF

  v20[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v15 = dword_33210;
  v16 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v17 = v2;
    v18 = v3;
    v16 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v16 + 1;
  LOBYTE(v16) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v15) & 1) == 0 )
  {
    v9 = 0;
    if ( (v16 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v13 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v13 = v7;
    v14 = v8;
    v12 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v12 + 1;
  LOBYTE(v12) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v12);
  if ( (v12 & 1) != 0 )
  {
    operator delete(v14);
    if ( (v16 & 1) == 0 )
    {
LABEL_21:
      if ( (v9 & 1) == 0 )
        return send_cmd("LORADIS");
      goto LABEL_25;
    }
  }
  else if ( (v16 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_24:
  operator delete(v18);
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v19, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v20, (__int64)"lora dis", 8LL);
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return send_cmd("LORADIS");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// C1EC: using guessed type char var_180[8];

//----- (000000000000C46C) ----------------------------------------------------
__int64 loraEN()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  unsigned __int64 v12; // [xsp+8h] [xbp-1B8h] BYREF
  size_t v13; // [xsp+10h] [xbp-1B0h]
  void *v14; // [xsp+18h] [xbp-1A8h]
  int v15; // [xsp+20h] [xbp-1A0h] BYREF
  unsigned __int64 v16; // [xsp+28h] [xbp-198h] BYREF
  size_t v17; // [xsp+30h] [xbp-190h]
  void *v18; // [xsp+38h] [xbp-188h]
  char v19[8]; // [xsp+40h] [xbp-180h] BYREF
  _QWORD v20[41]; // [xsp+48h] [xbp-178h] BYREF

  v20[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v15 = dword_33210;
  v16 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v17 = v2;
    v18 = v3;
    v16 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v16 + 1;
  LOBYTE(v16) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v15) & 1) == 0 )
  {
    v9 = 0;
    if ( (v16 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v13 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v13 = v7;
    v14 = v8;
    v12 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v12 + 1;
  LOBYTE(v12) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v12);
  if ( (v12 & 1) != 0 )
  {
    operator delete(v14);
    if ( (v16 & 1) == 0 )
    {
LABEL_21:
      if ( (v9 & 1) == 0 )
        return send_cmd("LORAEN");
      goto LABEL_25;
    }
  }
  else if ( (v16 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_24:
  operator delete(v18);
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v19, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v20, (__int64)"lora EN", 7LL);
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return send_cmd("LORAEN");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// C46C: using guessed type char var_180[8];

//----- (000000000000C6EC) ----------------------------------------------------
__int64 loraRST()
{
  const char *v0; // x20
  size_t v1; // x0
  size_t v2; // x19
  char *v3; // x21
  unsigned __int64 v4; // x22
  const void *v5; // x19
  size_t v6; // x0
  size_t v7; // x20
  char *v8; // x21
  char v9; // w19
  unsigned __int64 v10; // x22
  unsigned __int64 v12; // [xsp+8h] [xbp-1B8h] BYREF
  size_t v13; // [xsp+10h] [xbp-1B0h]
  void *v14; // [xsp+18h] [xbp-1A8h]
  int v15; // [xsp+20h] [xbp-1A0h] BYREF
  unsigned __int64 v16; // [xsp+28h] [xbp-198h] BYREF
  size_t v17; // [xsp+30h] [xbp-190h]
  void *v18; // [xsp+38h] [xbp-188h]
  char v19[8]; // [xsp+40h] [xbp-180h] BYREF
  _QWORD v20[41]; // [xsp+48h] [xbp-178h] BYREF

  v20[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v15 = dword_33210;
  v16 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v0 = (const char *)qword_33228;
  else
    v0 = (char *)&word_33218 + 1;
  v1 = strlen(v0);
  if ( v1 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v2 = v1;
  if ( v1 >= 0x17 )
  {
    v4 = (v1 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = (char *)operator new(v4);
    v17 = v2;
    v18 = v3;
    v16 = v4 | 1;
    goto LABEL_9;
  }
  v3 = (char *)&v16 + 1;
  LOBYTE(v16) = 2 * v1;
  if ( v1 )
LABEL_9:
    memcpy(v3, v0, v2);
  v3[v2] = 0;
  if ( (g3::logLevel(&v15) & 1) == 0 )
  {
    v9 = 0;
    if ( (v16 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v13 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  v5 = TAG;
  v6 = strlen((const char *)TAG);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v10 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v10);
    v13 = v7;
    v14 = v8;
    v12 = v10 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v12 + 1;
  LOBYTE(v12) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  v9 = g3::logTag(&v12);
  if ( (v12 & 1) != 0 )
  {
    operator delete(v14);
    if ( (v16 & 1) == 0 )
    {
LABEL_21:
      if ( (v9 & 1) == 0 )
        return send_cmd("LORARST");
      goto LABEL_25;
    }
  }
  else if ( (v16 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_24:
  operator delete(v18);
  if ( (v9 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)v19, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v20, (__int64)"lora reset", 10LL);
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return send_cmd("LORARST");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// C6EC: using guessed type char var_180[8];

//----- (000000000000C96C) ----------------------------------------------------
__int64 __fastcall setLoraMod(__int64 a1, __int64 a2, unsigned int a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  int v9; // w1
  const void *v10; // x20
  size_t v11; // x0
  size_t v12; // x21
  char *v13; // x22
  char v14; // w20
  unsigned __int64 v15; // x23
  _QWORD *v16; // x0
  const char *v17; // x20
  size_t v18; // x0
  size_t v19; // x19
  char *v20; // x21
  __int64 *v21; // x0
  __int128 v22; // q0
  const char *v23; // x0
  unsigned int v24; // w19
  unsigned __int64 v25; // x22
  const void *v26; // x19
  size_t v27; // x0
  size_t v28; // x20
  char *v29; // x21
  char v30; // w19
  unsigned __int64 v31; // x22
  __int64 v33[3]; // [xsp+8h] [xbp-218h] BYREF
  unsigned __int64 v34; // [xsp+20h] [xbp-200h] BYREF
  size_t v35; // [xsp+28h] [xbp-1F8h]
  void *v36; // [xsp+30h] [xbp-1F0h]
  int v37; // [xsp+38h] [xbp-1E8h] BYREF
  unsigned __int64 v38; // [xsp+40h] [xbp-1E0h] BYREF
  size_t v39; // [xsp+48h] [xbp-1D8h]
  void *v40; // [xsp+50h] [xbp-1D0h]
  unsigned __int64 v41; // [xsp+58h] [xbp-1C8h] BYREF
  size_t v42; // [xsp+60h] [xbp-1C0h]
  void *v43; // [xsp+68h] [xbp-1B8h]
  int v44; // [xsp+70h] [xbp-1B0h] BYREF
  unsigned __int64 v45; // [xsp+78h] [xbp-1A8h] BYREF
  size_t v46; // [xsp+80h] [xbp-1A0h]
  void *v47; // [xsp+88h] [xbp-198h]
  __int128 v48; // [xsp+90h] [xbp-190h] BYREF
  void *v49; // [xsp+A0h] [xbp-180h]
  __int64 v50; // [xsp+1D8h] [xbp-48h]

  v50 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v44 = dword_33210;
  v46 = 0LL;
  v47 = 0LL;
  v45 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v46 = v6;
    v47 = v7;
    v45 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v45 + 1;
  LOBYTE(v45) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v44) & 1) == 0 )
  {
    v14 = 0;
    if ( (v45 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_24;
  }
  v42 = 0LL;
  v43 = 0LL;
  v41 = 0LL;
  v10 = TAG;
  v11 = strlen((const char *)TAG);
  if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v12 = v11;
  if ( v11 >= 0x17 )
  {
    v15 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v13 = (char *)operator new(v15);
    v42 = v12;
    v43 = v13;
    v41 = v15 | 1;
    goto LABEL_18;
  }
  v13 = (char *)&v41 + 1;
  LOBYTE(v41) = 2 * v11;
  if ( v11 )
LABEL_18:
    memcpy(v13, v10, v12);
  v13[v12] = 0;
  v14 = g3::logTag(&v41);
  if ( (v41 & 1) == 0 )
  {
    if ( (v45 & 1) == 0 )
      goto LABEL_21;
LABEL_24:
    operator delete(v47);
    if ( (v14 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v43);
  if ( (v45 & 1) != 0 )
    goto LABEL_24;
LABEL_21:
  if ( (v14 & 1) != 0 )
  {
LABEL_25:
    LogCapture::LogCapture((LogCapture *)&v48, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
    v16 = std::__put_character_sequence<char,std::char_traits<char>>((_QWORD *)&v48 + 1, (__int64)"set lora mod", 12LL);
    std::ostream::operator<<(v16);
    LogCapture::~LogCapture((LogCapture *)&v48);
  }
LABEL_26:
  if ( a3 - 1 >= 2 )
  {
    if ( (word_33298 & 1) != 0 )
      v17 = (const char *)qword_332A8;
    else
      v17 = (char *)&word_33298 + 1;
    v37 = dword_33290;
    v39 = 0LL;
    v40 = 0LL;
    v38 = 0LL;
    v18 = strlen(v17);
    if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v19 = v18;
    if ( v18 >= 0x17 )
    {
      v25 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v20 = (char *)operator new(v25);
      v39 = v19;
      v40 = v20;
      v38 = v25 | 1;
    }
    else
    {
      v20 = (char *)&v38 + 1;
      LOBYTE(v38) = 2 * v18;
      if ( !v18 )
      {
LABEL_43:
        v20[v19] = 0;
        if ( (g3::logLevel(&v37) & 1) == 0 )
        {
          v30 = 0;
          if ( (v38 & 1) == 0 )
            goto LABEL_54;
          goto LABEL_57;
        }
        v35 = 0LL;
        v36 = 0LL;
        v34 = 0LL;
        v26 = TAG;
        v27 = strlen((const char *)TAG);
        if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v28 = v27;
        if ( v27 >= 0x17 )
        {
          v31 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v29 = (char *)operator new(v31);
          v35 = v28;
          v36 = v29;
          v34 = v31 | 1;
        }
        else
        {
          v29 = (char *)&v34 + 1;
          LOBYTE(v34) = 2 * v27;
          if ( !v27 )
          {
LABEL_52:
            v29[v28] = 0;
            v30 = g3::logTag(&v34);
            if ( (v34 & 1) != 0 )
            {
              operator delete(v36);
              if ( (v38 & 1) == 0 )
              {
LABEL_54:
                if ( (v30 & 1) == 0 )
                  return (unsigned int)-1;
                goto LABEL_58;
              }
            }
            else if ( (v38 & 1) == 0 )
            {
              goto LABEL_54;
            }
LABEL_57:
            operator delete(v40);
            if ( (v30 & 1) == 0 )
              return (unsigned int)-1;
LABEL_58:
            LogCapture::LogCapture((LogCapture *)&v48, (const char *)TAG, (const LEVELS *)&dword_33290, "", 6, 0LL);
            std::__put_character_sequence<char,std::char_traits<char>>(
              (_QWORD *)&v48 + 1,
              (__int64)"set lora mod out of range!",
              26LL);
            LogCapture::~LogCapture((LogCapture *)&v48);
            return (unsigned int)-1;
          }
        }
        memcpy(v29, v26, v28);
        goto LABEL_52;
      }
    }
    memcpy(v20, v17, v19);
    goto LABEL_43;
  }
  std::to_string(v33, (std::__ndk1 *)a3, v9);
  v21 = std::string::insert(v33, 0LL, "LORAMOD", 7uLL);
  v22 = *(_OWORD *)v21;
  v49 = (void *)v21[2];
  v48 = v22;
  v21[1] = 0LL;
  v21[2] = 0LL;
  *v21 = 0LL;
  if ( (v33[0] & 1) != 0 )
    operator delete((void *)v33[2]);
  if ( (v48 & 1) != 0 )
    v23 = (const char *)v49;
  else
    v23 = (char *)&v48 + 1;
  v24 = send_cmd(v23);
  if ( (v48 & 1) != 0 )
    operator delete(v49);
  return v24;
}
// CBD4: variable 'v9' is possibly undefined
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;

//----- (000000000000CEAC) ----------------------------------------------------
__int64 __fastcall control4G(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  const void *v9; // x20
  size_t v10; // x0
  size_t v11; // x21
  char *v12; // x22
  char v13; // w20
  unsigned __int64 v14; // x23
  _QWORD *v15; // x20
  int v16; // w1
  char *v17; // x1
  void *v18; // x2
  const char *v19; // x0
  void *v21[2]; // [xsp+0h] [xbp-1E0h] BYREF
  void *v22; // [xsp+10h] [xbp-1D0h]
  unsigned __int64 v23; // [xsp+18h] [xbp-1C8h] BYREF
  size_t v24; // [xsp+20h] [xbp-1C0h]
  void *v25; // [xsp+28h] [xbp-1B8h]
  int v26; // [xsp+30h] [xbp-1B0h] BYREF
  unsigned __int64 v27; // [xsp+38h] [xbp-1A8h] BYREF
  size_t v28; // [xsp+40h] [xbp-1A0h]
  void *v29; // [xsp+48h] [xbp-198h]
  char v30[8]; // [xsp+50h] [xbp-190h] BYREF
  _QWORD v31[41]; // [xsp+58h] [xbp-188h] BYREF

  v31[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v26 = dword_33210;
  v28 = 0LL;
  v29 = 0LL;
  v27 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v28 = v6;
    v29 = v7;
    v27 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v27 + 1;
  LOBYTE(v27) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v26) & 1) == 0 )
  {
    v13 = 0;
    if ( (v27 & 1) == 0 )
      goto LABEL_22;
    goto LABEL_16;
  }
  v24 = 0LL;
  v25 = 0LL;
  v23 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v24 = v11;
    v25 = v12;
    v23 = v14 | 1;
    goto LABEL_19;
  }
  v12 = (char *)&v23 + 1;
  LOBYTE(v23) = 2 * v10;
  if ( v10 )
LABEL_19:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v23);
  if ( (v23 & 1) != 0 )
  {
    operator delete(v25);
    if ( (v27 & 1) == 0 )
    {
LABEL_22:
      if ( (v13 & 1) == 0 )
        goto LABEL_32;
      goto LABEL_23;
    }
  }
  else if ( (v27 & 1) == 0 )
  {
    goto LABEL_22;
  }
LABEL_16:
  operator delete(v29);
  if ( (v13 & 1) == 0 )
    goto LABEL_32;
LABEL_23:
  LogCapture::LogCapture((LogCapture *)v30, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  v15 = std::__put_character_sequence<char,std::char_traits<char>>(v31, (__int64)"set 4G control ", 15LL);
  std::to_string(v21, (std::__ndk1 *)a3, v16);
  if ( ((__int64)v21[0] & 1) != 0 )
    v17 = (char *)v22;
  else
    v17 = (char *)v21 + 1;
  if ( ((__int64)v21[0] & 1) != 0 )
    v18 = v21[1];
  else
    v18 = (void *)((unsigned __int64)LOBYTE(v21[0]) >> 1);
  std::__put_character_sequence<char,std::char_traits<char>>(v15, (__int64)v17, (__int64)v18);
  if ( ((__int64)v21[0] & 1) != 0 )
    operator delete(v22);
  LogCapture::~LogCapture((LogCapture *)v30);
LABEL_32:
  if ( a3 )
    v19 = "4GON";
  else
    v19 = "4GOFF";
  return send_cmd(v19);
}
// D088: variable 'v16' is possibly undefined
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// CEAC: using guessed type char var_190[8];

//----- (000000000000D1A8) ----------------------------------------------------
__int64 __fastcall setESPChannel(__int64 a1, __int64 a2, unsigned int a3)
{
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x20
  char *v7; // x22
  unsigned __int64 v8; // x23
  int v9; // w1
  const void *v10; // x20
  size_t v11; // x0
  size_t v12; // x21
  char *v13; // x22
  char v14; // w20
  unsigned __int64 v15; // x23
  const char *v16; // x20
  size_t v17; // x0
  size_t v18; // x19
  char *v19; // x21
  _QWORD *v20; // x0
  __int64 *v21; // x0
  __int128 v22; // q0
  const char *v23; // x0
  unsigned int v24; // w20
  const char *v25; // x21
  size_t v26; // x0
  size_t v27; // x19
  char *v28; // x22
  unsigned __int64 v29; // x22
  const void *v30; // x19
  size_t v31; // x0
  size_t v32; // x20
  char *v33; // x21
  char v34; // w19
  unsigned __int64 v35; // x23
  const void *v36; // x19
  size_t v37; // x0
  size_t v38; // x21
  char *v39; // x22
  char v40; // w19
  unsigned __int64 v41; // x22
  unsigned __int64 v42; // x23
  _QWORD *v44; // x0
  unsigned __int64 v45; // [xsp+8h] [xbp-258h] BYREF
  size_t v46; // [xsp+10h] [xbp-250h]
  void *v47; // [xsp+18h] [xbp-248h]
  int v48; // [xsp+20h] [xbp-240h] BYREF
  unsigned __int64 v49; // [xsp+28h] [xbp-238h] BYREF
  size_t v50; // [xsp+30h] [xbp-230h]
  void *v51; // [xsp+38h] [xbp-228h]
  __int128 v52; // [xsp+40h] [xbp-220h] BYREF
  void *v53; // [xsp+50h] [xbp-210h]
  unsigned __int64 v54; // [xsp+60h] [xbp-200h] BYREF
  size_t v55; // [xsp+68h] [xbp-1F8h]
  void *v56; // [xsp+70h] [xbp-1F0h]
  int v57; // [xsp+78h] [xbp-1E8h] BYREF
  unsigned __int64 v58; // [xsp+80h] [xbp-1E0h] BYREF
  size_t v59; // [xsp+88h] [xbp-1D8h]
  void *v60; // [xsp+90h] [xbp-1D0h]
  unsigned __int64 v61; // [xsp+98h] [xbp-1C8h] BYREF
  size_t v62; // [xsp+A0h] [xbp-1C0h]
  void *v63; // [xsp+A8h] [xbp-1B8h]
  int v64; // [xsp+B0h] [xbp-1B0h] BYREF
  unsigned __int64 v65; // [xsp+B8h] [xbp-1A8h] BYREF
  size_t v66; // [xsp+C0h] [xbp-1A0h]
  void *v67; // [xsp+C8h] [xbp-198h]
  __int64 v68; // [xsp+D0h] [xbp-190h] BYREF
  void *v69[41]; // [xsp+D8h] [xbp-188h] BYREF

  v69[40] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v64 = dword_33210;
  v66 = 0LL;
  v67 = 0LL;
  if ( (word_33218 & 1) != 0 )
    v4 = (const char *)qword_33228;
  else
    v4 = (char *)&word_33218 + 1;
  v65 = 0LL;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v66 = v6;
    v67 = v7;
    v65 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v65 + 1;
  LOBYTE(v65) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v64) & 1) == 0 )
  {
    v14 = 0;
    if ( (v65 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_31;
  }
  v62 = 0LL;
  v63 = 0LL;
  v61 = 0LL;
  v10 = TAG;
  v11 = strlen((const char *)TAG);
  if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v12 = v11;
  if ( v11 >= 0x17 )
  {
    v15 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v13 = (char *)operator new(v15);
    v62 = v12;
    v63 = v13;
    v61 = v15 | 1;
    goto LABEL_18;
  }
  v13 = (char *)&v61 + 1;
  LOBYTE(v61) = 2 * v11;
  if ( v11 )
LABEL_18:
    memcpy(v13, v10, v12);
  v13[v12] = 0;
  v14 = g3::logTag(&v61);
  if ( (v61 & 1) != 0 )
  {
    operator delete(v63);
    if ( (v65 & 1) == 0 )
    {
LABEL_21:
      if ( (v14 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_32;
    }
  }
  else if ( (v65 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_31:
  operator delete(v67);
  if ( (v14 & 1) == 0 )
  {
LABEL_22:
    if ( a3 >= 9 )
      goto LABEL_23;
LABEL_33:
    std::to_string(&v68, (std::__ndk1 *)a3, v9);
    v21 = std::string::insert(&v68, 0LL, "ESPCH", 5uLL);
    v22 = *(_OWORD *)v21;
    v53 = (void *)v21[2];
    v52 = v22;
    v21[1] = 0LL;
    v21[2] = 0LL;
    *v21 = 0LL;
    if ( (v68 & 1) != 0 )
      operator delete(v69[1]);
    if ( (v52 & 1) != 0 )
      v23 = (const char *)v53;
    else
      v23 = (char *)&v52 + 1;
    v24 = send_cmd(v23);
    if ( !v24 )
      dword_33010 = a3;
    if ( (word_33218 & 1) != 0 )
      v25 = (const char *)qword_33228;
    else
      v25 = (char *)&word_33218 + 1;
    v48 = dword_33210;
    v50 = 0LL;
    v51 = 0LL;
    v49 = 0LL;
    v26 = strlen(v25);
    if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v27 = v26;
    if ( v26 >= 0x17 )
    {
      v35 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v28 = (char *)operator new(v35);
      v50 = v27;
      v51 = v28;
      v49 = v35 | 1;
    }
    else
    {
      v28 = (char *)&v49 + 1;
      LOBYTE(v49) = 2 * v26;
      if ( !v26 )
      {
LABEL_58:
        v28[v27] = 0;
        if ( (g3::logLevel(&v48) & 1) == 0 )
        {
          v40 = 0;
          if ( (v49 & 1) == 0 )
            goto LABEL_79;
          goto LABEL_84;
        }
        v46 = 0LL;
        v47 = 0LL;
        v45 = 0LL;
        v36 = TAG;
        v37 = strlen((const char *)TAG);
        if ( v37 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v38 = v37;
        if ( v37 >= 0x17 )
        {
          v42 = (v37 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v39 = (char *)operator new(v42);
          v46 = v38;
          v47 = v39;
          v45 = v42 | 1;
        }
        else
        {
          v39 = (char *)&v45 + 1;
          LOBYTE(v45) = 2 * v37;
          if ( !v37 )
          {
LABEL_77:
            v39[v38] = 0;
            v40 = g3::logTag(&v45);
            if ( (v45 & 1) != 0 )
            {
              operator delete(v47);
              if ( (v49 & 1) == 0 )
              {
LABEL_79:
                if ( (v40 & 1) == 0 )
                  goto LABEL_80;
                goto LABEL_85;
              }
            }
            else if ( (v49 & 1) == 0 )
            {
              goto LABEL_79;
            }
LABEL_84:
            operator delete(v51);
            if ( (v40 & 1) == 0 )
            {
LABEL_80:
              if ( (v52 & 1) == 0 )
                return v24;
LABEL_81:
              operator delete(v53);
              return v24;
            }
LABEL_85:
            LogCapture::LogCapture((LogCapture *)&v68, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
            v44 = std::__put_character_sequence<char,std::char_traits<char>>(v69, (__int64)"setESPChannel result", 20LL);
            std::ostream::operator<<(v44);
            LogCapture::~LogCapture((LogCapture *)&v68);
            if ( (v52 & 1) == 0 )
              return v24;
            goto LABEL_81;
          }
        }
        memcpy(v39, v36, v38);
        goto LABEL_77;
      }
    }
    memcpy(v28, v25, v27);
    goto LABEL_58;
  }
LABEL_32:
  LogCapture::LogCapture((LogCapture *)&v68, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
  v20 = std::__put_character_sequence<char,std::char_traits<char>>(v69, (__int64)"set ESP channel ", 16LL);
  std::ostream::operator<<(v20);
  LogCapture::~LogCapture((LogCapture *)&v68);
  if ( a3 < 9 )
    goto LABEL_33;
LABEL_23:
  if ( (word_33298 & 1) != 0 )
    v16 = (const char *)qword_332A8;
  else
    v16 = (char *)&word_33298 + 1;
  v57 = dword_33290;
  v59 = 0LL;
  v60 = 0LL;
  v58 = 0LL;
  v17 = strlen(v16);
  if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v18 = v17;
  if ( v17 >= 0x17 )
  {
    v29 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v19 = (char *)operator new(v29);
    v59 = v18;
    v60 = v19;
    v58 = v29 | 1;
    goto LABEL_48;
  }
  v19 = (char *)&v58 + 1;
  LOBYTE(v58) = 2 * v17;
  if ( v17 )
LABEL_48:
    memcpy(v19, v16, v18);
  v19[v18] = 0;
  if ( (g3::logLevel(&v57) & 1) == 0 )
  {
    v34 = 0;
    if ( (v58 & 1) == 0 )
      goto LABEL_69;
    goto LABEL_72;
  }
  v55 = 0LL;
  v56 = 0LL;
  v54 = 0LL;
  v30 = TAG;
  v31 = strlen((const char *)TAG);
  if ( v31 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v32 = v31;
  if ( v31 >= 0x17 )
  {
    v41 = (v31 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v33 = (char *)operator new(v41);
    v55 = v32;
    v56 = v33;
    v54 = v41 | 1;
    goto LABEL_66;
  }
  v33 = (char *)&v54 + 1;
  LOBYTE(v54) = 2 * v31;
  if ( v31 )
LABEL_66:
    memcpy(v33, v30, v32);
  v33[v32] = 0;
  v34 = g3::logTag(&v54);
  if ( (v54 & 1) != 0 )
  {
    operator delete(v56);
    if ( (v58 & 1) == 0 )
    {
LABEL_69:
      if ( (v34 & 1) == 0 )
        return (unsigned int)-1;
      goto LABEL_73;
    }
  }
  else if ( (v58 & 1) == 0 )
  {
    goto LABEL_69;
  }
LABEL_72:
  operator delete(v60);
  if ( (v34 & 1) != 0 )
  {
LABEL_73:
    LogCapture::LogCapture((LogCapture *)&v68, (const char *)TAG, (const LEVELS *)&dword_33290, "", 6, 0LL);
    std::__put_character_sequence<char,std::char_traits<char>>(v69, (__int64)"vaild ESP channel", 17LL);
    LogCapture::~LogCapture((LogCapture *)&v68);
  }
  return (unsigned int)-1;
}
// D410: variable 'v9' is possibly undefined
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33010: using guessed type int dword_33010;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33290: using guessed type int dword_33290;
// 33298: using guessed type __int16 word_33298;
// 332A8: using guessed type __int64 qword_332A8;

//----- (000000000000D938) ----------------------------------------------------
__int64 __fastcall registerNativeMethods(_JNIEnv *a1)
{
  jclass v2; // x20

  v2 = a1->functions->FindClass(a1, "com/pudutech/easynodelib/EasyNode");
  a1->functions->RegisterNatives((JNIEnv *)a1, v2, (const JNINativeMethod *)methods, 18LL);
  usbcb_method_ = (__int64)a1->functions->GetMethodID(a1, v2, "usbCtrlCallback", "([B)V");
  esp32cb_method_ = (__int64)a1->functions->GetMethodID(a1, v2, "esp32Callback", "([B)V");
  loracb_method_ = (__int64)a1->functions->GetMethodID(a1, v2, "loraCallback", "([B)V");
  return ((__int64 (__fastcall *)(_JNIEnv *, jclass))a1->functions->DeleteLocalRef)(a1, v2);
}
// 33018: using guessed type char *methods[2];
// 33370: using guessed type __int64 usbcb_method_;
// 33378: using guessed type __int64 esp32cb_method_;
// 33380: using guessed type __int64 loracb_method_;

//----- (000000000000DA30) ----------------------------------------------------
jint JNI_OnLoad(JavaVM *vm, void *reserved)
{
  jint v2; // w19
  __int64 v3; // x8
  __int64 v4; // x9
  std::__shared_weak_count *v5; // x20
  unsigned __int64 *v6; // x8
  unsigned __int64 v7; // x9
  std::__shared_weak_count *v8; // x20
  unsigned __int64 *v9; // x8
  unsigned __int64 v10; // x9
  __int64 v11; // x20
  __int64 v12; // x21
  __int64 v14; // [xsp+0h] [xbp-50h] BYREF
  unsigned __int64 *v15; // [xsp+8h] [xbp-48h]
  __int64 v16[2]; // [xsp+10h] [xbp-40h] BYREF

  v16[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  glb_vm_ = (__int64)vm;
  v2 = 65542;
  if ( (*vm)->GetEnv(vm, (void **)v16, 65542LL) )
    return -1;
  std::shared_ptr<EspRecvParse>::make_shared<>(&v14);
  v3 = v14;
  v4 = (__int64)v15;
  v14 = 0LL;
  v15 = 0LL;
  v5 = (std::__shared_weak_count *)qword_33390;
  esp_recv_parse_ = v3;
  qword_33390 = v4;
  if ( v5 )
  {
    v6 = (unsigned __int64 *)((char *)v5 + 8);
    do
      v7 = __ldaxr(v6);
    while ( __stlxr(v7 - 1, v6) );
    if ( !v7 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v5 + 16LL))(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = (std::__shared_weak_count *)v15;
  if ( v15 )
  {
    v9 = v15 + 1;
    do
      v10 = __ldaxr(v9);
    while ( __stlxr(v10 - 1, v9) );
    if ( !v10 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v8 + 16LL))(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v16[0];
  v12 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v16[0] + 48LL))(
          v16[0],
          "com/pudutech/easynodelib/EasyNode");
  (*(void (__fastcall **)(__int64, __int64, char **, __int64))(*(_QWORD *)v11 + 1720LL))(v11, v12, methods, 18LL);
  usbcb_method_ = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)v11 + 264LL))(
                    v11,
                    v12,
                    "usbCtrlCallback",
                    "([B)V");
  esp32cb_method_ = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)v11 + 264LL))(
                      v11,
                      v12,
                      "esp32Callback",
                      "([B)V");
  loracb_method_ = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)v11 + 264LL))(
                     v11,
                     v12,
                     "loraCallback",
                     "([B)V");
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 184LL))(v11, v12);
  return v2;
}
// 33018: using guessed type char *methods[2];
// 33360: using guessed type __int64 glb_vm_;
// 33370: using guessed type __int64 usbcb_method_;
// 33378: using guessed type __int64 esp32cb_method_;
// 33380: using guessed type __int64 loracb_method_;
// 33388: using guessed type __int64 esp_recv_parse_;
// 33390: using guessed type __int64 qword_33390;

//----- (000000000000DC28) ----------------------------------------------------
void JNI_OnUnload(JavaVM *vm, void *reserved)
{
  __int64 v2; // x19
  _QWORD *v3[2]; // [xsp+0h] [xbp-20h] BYREF

  v3[1] = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(*vm)->GetEnv(vm, (void **)v3, 65542LL) )
  {
    v2 = (*(__int64 (__fastcall **)(_QWORD *, const char *))(*v3[0] + 48LL))(v3[0], "com/pudutech/easynodelib/EasyNode");
    if ( ((unsigned int)(*(_QWORD *(__fastcall **)(_QWORD *, _QWORD *, __int64))(*v3[0] + 1728LL))(v3[0], v3[0], v2) & 0x80000000) == 0 )
      (*(void (__fastcall **)(_QWORD *, __int64))(*v3[0] + 184LL))(v3[0], v2);
  }
}

//----- (000000000000DCD0) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  sub_DCE4("basic_string");
}

//----- (000000000000DCE4) ----------------------------------------------------
void __fastcall __noreturn sub_DCE4(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_DD34(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::length_error,
    (void (__fastcall *)(void *))&std::length_error::~length_error);
}

//----- (000000000000DD34) ----------------------------------------------------
__int64 __fastcall sub_DD34(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::length_error + 16;
  return result;
}

//----- (000000000000DD64) ----------------------------------------------------
__int64 __fastcall sub_DD64(__int64 a1, unsigned int a2)
{
  unsigned int v4; // w0
  int v5; // w23
  const char *v6; // x21
  size_t v7; // x0
  size_t v8; // x20
  char *v9; // x22
  __int64 v10; // x19
  _QWORD *v11; // x20
  __int64 v12; // x0
  pthread_t v13; // x0
  unsigned __int64 v15; // x23
  const void *v16; // x20
  size_t v17; // x0
  size_t v18; // x21
  char *v19; // x22
  char v20; // w20
  unsigned __int64 v21; // x23
  _QWORD *v22; // x0
  unsigned __int64 v23; // [xsp+0h] [xbp-1D0h] BYREF
  size_t v24; // [xsp+8h] [xbp-1C8h]
  void *v25; // [xsp+10h] [xbp-1C0h]
  int v26; // [xsp+18h] [xbp-1B8h] BYREF
  unsigned __int64 v27; // [xsp+20h] [xbp-1B0h] BYREF
  size_t v28; // [xsp+28h] [xbp-1A8h]
  void *v29; // [xsp+30h] [xbp-1A0h]
  _QWORD *v30; // [xsp+38h] [xbp-198h] BYREF
  char v31[8]; // [xsp+40h] [xbp-190h] BYREF
  _QWORD v32[41]; // [xsp+48h] [xbp-188h] BYREF

  v32[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (unsigned int)(*(_QWORD *(__fastcall **)(__int64, __int64, _QWORD **, __int64))(*(_QWORD *)glb_vm_ + 48LL))(
                       glb_vm_,
                       glb_vm_,
                       &v30,
                       65542LL);
  if ( v4 == -2 )
  {
    v5 = 1;
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD **, _QWORD))(*(_QWORD *)glb_vm_ + 32LL))(glb_vm_, &v30, 0LL) )
      goto LABEL_3;
  }
  else
  {
    v5 = 0;
    if ( v4 )
    {
LABEL_3:
      if ( (word_33278 & 1) != 0 )
        v6 = (const char *)qword_33288;
      else
        v6 = (char *)&word_33278 + 1;
      v26 = dword_33270;
      v28 = 0LL;
      v29 = 0LL;
      v27 = 0LL;
      v7 = strlen(v6);
      if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v8 = v7;
      if ( v7 >= 0x17 )
      {
        v15 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v9 = (char *)operator new(v15);
        v28 = v8;
        v29 = v9;
        v27 = v15 | 1;
      }
      else
      {
        v9 = (char *)&v27 + 1;
        LOBYTE(v27) = 2 * v7;
        if ( !v7 )
        {
LABEL_16:
          v9[v8] = 0;
          if ( (g3::logLevel(&v26) & 1) == 0 )
          {
            v20 = 0;
            if ( (v27 & 1) == 0 )
              goto LABEL_27;
            goto LABEL_30;
          }
          v24 = 0LL;
          v25 = 0LL;
          v23 = 0LL;
          v16 = TAG;
          v17 = strlen((const char *)TAG);
          if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v18 = v17;
          if ( v17 >= 0x17 )
          {
            v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v19 = (char *)operator new(v21);
            v24 = v18;
            v25 = v19;
            v23 = v21 | 1;
          }
          else
          {
            v19 = (char *)&v23 + 1;
            LOBYTE(v23) = 2 * v17;
            if ( !v17 )
            {
LABEL_25:
              v19[v18] = 0;
              v20 = g3::logTag(&v23);
              if ( (v23 & 1) != 0 )
              {
                operator delete(v25);
                if ( (v27 & 1) == 0 )
                {
LABEL_27:
                  if ( (v20 & 1) == 0 )
                    return 0xFFFFFFFFLL;
                  goto LABEL_31;
                }
              }
              else if ( (v27 & 1) == 0 )
              {
                goto LABEL_27;
              }
LABEL_30:
              operator delete(v29);
              if ( (v20 & 1) == 0 )
                return 0xFFFFFFFFLL;
LABEL_31:
              LogCapture::LogCapture((LogCapture *)v31, (const char *)TAG, (const LEVELS *)&dword_33270, "", 6, 0LL);
              v22 = std::__put_character_sequence<char,std::char_traits<char>>(
                      v32,
                      (__int64)"get jni env failed when get exposure ",
                      37LL);
              std::ostream::operator<<(v22);
              LogCapture::~LogCapture((LogCapture *)v31);
              return 0xFFFFFFFFLL;
            }
          }
          memcpy(v19, v16, v18);
          goto LABEL_25;
        }
      }
      memcpy(v9, v6, v8);
      goto LABEL_16;
    }
  }
  v10 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v30 + 1408LL))(v30, a2);
  (*(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD, _QWORD, __int64))(*v30 + 1664LL))(
    v30,
    v30,
    v10,
    0LL,
    a2,
    a1);
  _JNIEnv::CallVoidMethod((__int64)v30, easynode_object_, usbcb_method_);
  v11 = v30;
  v12 = (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD))(*v30 + 1472LL))(v30, v10, 0LL);
  (*(void (__fastcall **)(_QWORD *, __int64, __int64, _QWORD))(*v11 + 1536LL))(v11, v10, v12, 0LL);
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)glb_vm_ + 40LL))(glb_vm_);
  v13 = pthread_self();
  pthread_setname_np(v13, "easynode_usb_callback");
  return 0LL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33360: using guessed type __int64 glb_vm_;
// 33368: using guessed type __int64 easynode_object_;
// 33370: using guessed type __int64 usbcb_method_;
// DD64: using guessed type char var_190[8];

//----- (000000000000E118) ----------------------------------------------------
__int64 _JNIEnv::CallVoidMethod(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __va_list_tag *); // x8
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __va_list_tag *))(*(_QWORD *)a1 + 496LL);
  va_copy(va1, va);
  return v3(a1, a2, a3, va1);
}

//----- (000000000000E1B4) ----------------------------------------------------
__int64 __fastcall sub_E1B4(char *a1, unsigned int a2)
{
  const char *v2; // x22
  size_t v5; // x0
  size_t v6; // x21
  char *v7; // x23
  unsigned __int64 v8; // x24
  const void *v9; // x21
  size_t v10; // x0
  size_t v11; // x22
  char *v12; // x23
  char v13; // w21
  unsigned __int64 v14; // x24
  unsigned __int64 v16; // [xsp+8h] [xbp-1D8h] BYREF
  size_t v17; // [xsp+10h] [xbp-1D0h]
  void *v18; // [xsp+18h] [xbp-1C8h]
  int v19; // [xsp+20h] [xbp-1C0h] BYREF
  unsigned __int64 v20; // [xsp+28h] [xbp-1B8h] BYREF
  size_t v21; // [xsp+30h] [xbp-1B0h]
  void *v22; // [xsp+38h] [xbp-1A8h]
  char v23[328]; // [xsp+40h] [xbp-1A0h] BYREF
  __int64 v24; // [xsp+188h] [xbp-58h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( esp_recv_parse_ )
  {
    if ( (word_33218 & 1) != 0 )
      v2 = (const char *)qword_33228;
    else
      v2 = (char *)&word_33218 + 1;
    v19 = dword_33210;
    v21 = 0LL;
    v22 = 0LL;
    v20 = 0LL;
    v5 = strlen(v2);
    if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v6 = v5;
    if ( v5 >= 0x17 )
    {
      v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v7 = (char *)operator new(v8);
      v21 = v6;
      v22 = v7;
      v20 = v8 | 1;
    }
    else
    {
      v7 = (char *)&v20 + 1;
      LOBYTE(v20) = 2 * v5;
      if ( !v5 )
      {
LABEL_11:
        v7[v6] = 0;
        if ( (g3::logLevel(&v19) & 1) == 0 )
        {
          v13 = 0;
          if ( (v20 & 1) == 0 )
            goto LABEL_22;
          goto LABEL_25;
        }
        v17 = 0LL;
        v18 = 0LL;
        v16 = 0LL;
        v9 = TAG;
        v10 = strlen((const char *)TAG);
        if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v11 = v10;
        if ( v10 >= 0x17 )
        {
          v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v12 = (char *)operator new(v14);
          v17 = v11;
          v18 = v12;
          v16 = v14 | 1;
        }
        else
        {
          v12 = (char *)&v16 + 1;
          LOBYTE(v16) = 2 * v10;
          if ( !v10 )
          {
LABEL_20:
            v12[v11] = 0;
            v13 = g3::logTag(&v16);
            if ( (v16 & 1) != 0 )
            {
              operator delete(v18);
              if ( (v20 & 1) == 0 )
              {
LABEL_22:
                if ( (v13 & 1) == 0 )
                  goto LABEL_27;
                goto LABEL_26;
              }
            }
            else if ( (v20 & 1) == 0 )
            {
              goto LABEL_22;
            }
LABEL_25:
            operator delete(v22);
            if ( (v13 & 1) == 0 )
            {
LABEL_27:
              EspRecvParse::parseData((__int64 *)esp_recv_parse_, a1, a2);
              return 0xFFFFFFFFLL;
            }
LABEL_26:
            LogCapture::LogCapture((LogCapture *)v23, (const char *)TAG, (const LEVELS *)&dword_33210, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)v23, "esp32_cb callback %d", a2);
            LogCapture::~LogCapture((LogCapture *)v23);
            goto LABEL_27;
          }
        }
        memcpy(v12, v9, v11);
        goto LABEL_20;
      }
    }
    memcpy(v7, v2, v6);
    goto LABEL_11;
  }
  return 0xFFFFFFFFLL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33210: using guessed type int dword_33210;
// 33218: using guessed type __int16 word_33218;
// 33228: using guessed type __int64 qword_33228;
// 33388: using guessed type __int64 esp_recv_parse_;

//----- (000000000000E460) ----------------------------------------------------
__int64 __fastcall sub_E460(__int64 a1, unsigned int a2)
{
  unsigned int v4; // w0
  int v5; // w23
  const char *v6; // x21
  size_t v7; // x0
  size_t v8; // x20
  char *v9; // x22
  __int64 v10; // x19
  _QWORD *v11; // x20
  __int64 v12; // x0
  pthread_t v13; // x0
  unsigned __int64 v15; // x23
  const void *v16; // x20
  size_t v17; // x0
  size_t v18; // x21
  char *v19; // x22
  char v20; // w20
  unsigned __int64 v21; // x23
  _QWORD *v22; // x0
  unsigned __int64 v23; // [xsp+0h] [xbp-1D0h] BYREF
  size_t v24; // [xsp+8h] [xbp-1C8h]
  void *v25; // [xsp+10h] [xbp-1C0h]
  int v26; // [xsp+18h] [xbp-1B8h] BYREF
  unsigned __int64 v27; // [xsp+20h] [xbp-1B0h] BYREF
  size_t v28; // [xsp+28h] [xbp-1A8h]
  void *v29; // [xsp+30h] [xbp-1A0h]
  _QWORD *v30; // [xsp+38h] [xbp-198h] BYREF
  char v31[8]; // [xsp+40h] [xbp-190h] BYREF
  _QWORD v32[41]; // [xsp+48h] [xbp-188h] BYREF

  v32[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (unsigned int)(*(_QWORD *(__fastcall **)(__int64, __int64, _QWORD **, __int64))(*(_QWORD *)glb_vm_ + 48LL))(
                       glb_vm_,
                       glb_vm_,
                       &v30,
                       65542LL);
  if ( v4 == -2 )
  {
    v5 = 1;
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD **, _QWORD))(*(_QWORD *)glb_vm_ + 32LL))(glb_vm_, &v30, 0LL) )
      goto LABEL_3;
  }
  else
  {
    v5 = 0;
    if ( v4 )
    {
LABEL_3:
      if ( (word_33278 & 1) != 0 )
        v6 = (const char *)qword_33288;
      else
        v6 = (char *)&word_33278 + 1;
      v26 = dword_33270;
      v28 = 0LL;
      v29 = 0LL;
      v27 = 0LL;
      v7 = strlen(v6);
      if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v8 = v7;
      if ( v7 >= 0x17 )
      {
        v15 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v9 = (char *)operator new(v15);
        v28 = v8;
        v29 = v9;
        v27 = v15 | 1;
      }
      else
      {
        v9 = (char *)&v27 + 1;
        LOBYTE(v27) = 2 * v7;
        if ( !v7 )
        {
LABEL_16:
          v9[v8] = 0;
          if ( (g3::logLevel(&v26) & 1) == 0 )
          {
            v20 = 0;
            if ( (v27 & 1) == 0 )
              goto LABEL_27;
            goto LABEL_30;
          }
          v24 = 0LL;
          v25 = 0LL;
          v23 = 0LL;
          v16 = TAG;
          v17 = strlen((const char *)TAG);
          if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v18 = v17;
          if ( v17 >= 0x17 )
          {
            v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v19 = (char *)operator new(v21);
            v24 = v18;
            v25 = v19;
            v23 = v21 | 1;
          }
          else
          {
            v19 = (char *)&v23 + 1;
            LOBYTE(v23) = 2 * v17;
            if ( !v17 )
            {
LABEL_25:
              v19[v18] = 0;
              v20 = g3::logTag(&v23);
              if ( (v23 & 1) != 0 )
              {
                operator delete(v25);
                if ( (v27 & 1) == 0 )
                {
LABEL_27:
                  if ( (v20 & 1) == 0 )
                    return 0xFFFFFFFFLL;
                  goto LABEL_31;
                }
              }
              else if ( (v27 & 1) == 0 )
              {
                goto LABEL_27;
              }
LABEL_30:
              operator delete(v29);
              if ( (v20 & 1) == 0 )
                return 0xFFFFFFFFLL;
LABEL_31:
              LogCapture::LogCapture((LogCapture *)v31, (const char *)TAG, (const LEVELS *)&dword_33270, "", 6, 0LL);
              v22 = std::__put_character_sequence<char,std::char_traits<char>>(
                      v32,
                      (__int64)"get jni env failed when get exposure ",
                      37LL);
              std::ostream::operator<<(v22);
              LogCapture::~LogCapture((LogCapture *)v31);
              return 0xFFFFFFFFLL;
            }
          }
          memcpy(v19, v16, v18);
          goto LABEL_25;
        }
      }
      memcpy(v9, v6, v8);
      goto LABEL_16;
    }
  }
  v10 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v30 + 1408LL))(v30, a2);
  (*(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD, _QWORD, __int64))(*v30 + 1664LL))(
    v30,
    v30,
    v10,
    0LL,
    a2,
    a1);
  _JNIEnv::CallVoidMethod((__int64)v30, easynode_object_, loracb_method_);
  v11 = v30;
  v12 = (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD))(*v30 + 1472LL))(v30, v10, 0LL);
  (*(void (__fastcall **)(_QWORD *, __int64, __int64, _QWORD))(*v11 + 1536LL))(v11, v10, v12, 0LL);
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)glb_vm_ + 40LL))(glb_vm_);
  v13 = pthread_self();
  pthread_setname_np(v13, "easynode_lora_callback");
  return 0LL;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33360: using guessed type __int64 glb_vm_;
// 33368: using guessed type __int64 easynode_object_;
// 33380: using guessed type __int64 loracb_method_;
// E460: using guessed type char var_190[8];

//----- (000000000000E814) ----------------------------------------------------
void __fastcall __noreturn sub_E814(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (000000000000E820) ----------------------------------------------------
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x8
  char *v5; // x9
  _QWORD *v6; // x0
  __int64 v9; // x22
  int v10; // w5
  __int64 v11; // x23
  int v12; // w26
  __int64 v13; // x0
  unsigned __int8 v14; // w24
  __int64 v15; // x2
  char v17[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v18; // [xsp+8h] [xbp-58h]
  _QWORD v19[2]; // [xsp+10h] [xbp-50h] BYREF

  v19[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17[0] = 0;
  v18 = a1;
  v4 = (_QWORD *)(*a1 - 24LL);
  v5 = (char *)a1 + *v4;
  if ( !*((_DWORD *)v5 + 8) )
  {
    v6 = (_QWORD *)*((_QWORD *)v5 + 17);
    if ( v6 )
    {
      std::ostream::flush(v6);
      v4 = (_QWORD *)(*a1 - 24LL);
    }
    v17[0] = 1;
    v9 = (__int64)a1 + *v4;
    v10 = *(_DWORD *)(v9 + 144);
    v11 = *(_QWORD *)(v9 + 40);
    v12 = *(_DWORD *)(v9 + 8);
    if ( v10 == -1 )
    {
      std::ios_base::getloc(v19, (std::ios_base *)v9);
      v13 = std::locale::use_facet(v19, &std::ctype<char>::id);
      v14 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 56LL))(v13, 32LL);
      std::locale::~locale((std::locale *)v19);
      v10 = v14;
      *(_DWORD *)(v9 + 144) = v14;
    }
    if ( (v12 & 0xB0) == 32 )
      v15 = a2 + a3;
    else
      v15 = a2;
    if ( !sub_E9C4(v11, a2, v15, a2 + a3, v9, v10) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v17);
  return a1;
}
// 7B80: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// E820: using guessed type char var_60[8];

//----- (000000000000E9C4) ----------------------------------------------------
__int64 __fastcall sub_E9C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c)
{
  __int64 v6; // x19
  __int64 v7; // x8
  __int64 v8; // x25
  bool v10; // cc
  signed __int64 v11; // x8
  signed __int64 v15; // x23
  char *v16; // x25
  void *v17; // x1
  __int64 v18; // x24
  __int64 v19; // x22
  unsigned __int64 v21; // [xsp+0h] [xbp-70h] BYREF
  __int64 v22; // [xsp+8h] [xbp-68h]
  void *v23; // [xsp+10h] [xbp-60h]
  __int64 v24; // [xsp+18h] [xbp-58h]

  v6 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v7 = *(_QWORD *)(a5 + 24);
    v8 = a3 - a2;
    v10 = v7 <= a4 - a2;
    v11 = v7 - (a4 - a2);
    if ( v10 )
      v15 = 0LL;
    else
      v15 = v11;
    if ( v8 >= 1 && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96LL))(a1) != v8 )
      return 0LL;
    if ( v15 >= 1 )
    {
      v21 = 0LL;
      v22 = 0LL;
      v23 = 0LL;
      if ( (unsigned __int64)v15 >= 0x17 )
      {
        v16 = (char *)operator new((v15 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v22 = v15;
        v23 = v16;
        v21 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)&v21 + 1;
        LOBYTE(v21) = 2 * v15;
      }
      memset(v16, c, v15);
      v16[v15] = 0;
      v17 = (v21 & 1) != 0 ? v23 : (char *)&v21 + 1;
      v18 = (*(__int64 (__fastcall **)(__int64, void *, signed __int64))(*(_QWORD *)v6 + 96LL))(v6, v17, v15);
      if ( (v21 & 1) != 0 )
        operator delete(v23);
      if ( v18 != v15 )
        return 0LL;
    }
    v19 = a4 - a3;
    if ( v19 < 1 || (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 96LL))(v6, a3, v19) == v19 )
      *(_QWORD *)(a5 + 24) = 0LL;
    else
      return 0LL;
  }
  return v6;
}

//----- (000000000000EB78) ----------------------------------------------------
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  __int64 v1; // x8
  __int64 v2; // x19
  __int64 v3; // x0
  std::ios_base *v4; // x0

  v1 = *(_QWORD *)(result + 8) + *(_QWORD *)(**(_QWORD **)(result + 8) - 24LL);
  if ( *(_QWORD *)(v1 + 40) )
  {
    if ( !*(_DWORD *)(v1 + 32) && (*(_BYTE *)(v1 + 9) & 0x20) != 0 )
    {
      v2 = result;
      result = std::uncaught_exception();
      if ( (result & 1) == 0 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL) + 40LL);
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
        if ( (_DWORD)result == -1 )
        {
          v4 = (std::ios_base *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL));
          return std::ios_base::clear(v4, *((_DWORD *)v4 + 8) | 1u);
        }
      }
    }
  }
  return result;
}

//----- (000000000000EC18) ----------------------------------------------------
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  char v6[8]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD *v7; // [xsp+10h] [xbp-30h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (_QWORD *)(*a1 - 24LL);
  if ( *(_QWORD *)((char *)a1 + *v2 + 40) )
  {
    v6[0] = 0;
    v7 = a1;
    v3 = (char *)a1 + *v2;
    if ( !*((_DWORD *)v3 + 8) )
    {
      v4 = (_QWORD *)*((_QWORD *)v3 + 17);
      if ( v4 )
      {
        std::ostream::flush(v4);
        v2 = (_QWORD *)(*a1 - 24LL);
      }
      v6[0] = 1;
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)((char *)a1 + *v2 + 40) + 48LL))(*(_QWORD *)((char *)a1 + *v2 + 40)) == -1 )
        std::ios_base::clear(
          (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
          *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 1);
    }
    std::ostream::sentry::~sentry((__int64)v6);
  }
  return a1;
}
// EC18: using guessed type char var_38[8];

//----- (000000000000ED40) ----------------------------------------------------
_QWORD *sub_ED40()
{
  _QWORD *result; // x0

  result = (_QWORD *)operator new(0x10uLL);
  *result = &off_32278;
  return result;
}
// 32278: using guessed type __int64 (__fastcall *off_32278)();

//----- (000000000000ED64) ----------------------------------------------------
void __fastcall sub_ED64(__int64 a1, _QWORD *a2)
{
  *a2 = &off_32278;
}
// 32278: using guessed type __int64 (__fastcall *off_32278)();

//----- (000000000000ED7C) ----------------------------------------------------
void __fastcall sub_ED7C(__int64 a1, __int64 *a2, unsigned int *a3)
{
  __int64 v3; // x20
  unsigned int v4; // w21
  int v5; // w0
  int v6; // w23
  const char *v7; // x21
  size_t v8; // x0
  size_t v9; // x20
  char *v10; // x22
  __int64 v11; // x19
  _QWORD *v12; // x20
  __int64 v13; // x0
  pthread_t v14; // x0
  unsigned __int64 v15; // x23
  const void *v16; // x20
  size_t v17; // x0
  size_t v18; // x21
  char *v19; // x22
  char v20; // w20
  unsigned __int64 v21; // x23
  _QWORD *v22; // x0
  unsigned __int64 v23; // [xsp+0h] [xbp-1D0h] BYREF
  size_t v24; // [xsp+8h] [xbp-1C8h]
  void *v25; // [xsp+10h] [xbp-1C0h]
  int v26; // [xsp+18h] [xbp-1B8h] BYREF
  unsigned __int64 v27; // [xsp+20h] [xbp-1B0h] BYREF
  size_t v28; // [xsp+28h] [xbp-1A8h]
  void *v29; // [xsp+30h] [xbp-1A0h]
  _QWORD *v30; // [xsp+38h] [xbp-198h] BYREF
  char v31[8]; // [xsp+40h] [xbp-190h] BYREF
  _QWORD v32[41]; // [xsp+48h] [xbp-188h] BYREF

  v32[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *a2;
  v4 = *a3;
  v5 = (*(__int64 (__fastcall **)(__int64, _QWORD **, __int64))(*(_QWORD *)glb_vm_ + 48LL))(glb_vm_, &v30, 65542LL);
  if ( v5 == -2 )
  {
    v6 = 1;
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD **, _QWORD))(*(_QWORD *)glb_vm_ + 32LL))(glb_vm_, &v30, 0LL) )
      goto LABEL_3;
  }
  else
  {
    v6 = 0;
    if ( v5 )
    {
LABEL_3:
      if ( (word_33278 & 1) != 0 )
        v7 = (const char *)qword_33288;
      else
        v7 = (char *)&word_33278 + 1;
      v26 = dword_33270;
      v28 = 0LL;
      v29 = 0LL;
      v27 = 0LL;
      v8 = strlen(v7);
      if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v9 = v8;
      if ( v8 >= 0x17 )
      {
        v15 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v10 = (char *)operator new(v15);
        v28 = v9;
        v29 = v10;
        v27 = v15 | 1;
      }
      else
      {
        v10 = (char *)&v27 + 1;
        LOBYTE(v27) = 2 * v8;
        if ( !v8 )
        {
LABEL_16:
          v10[v9] = 0;
          if ( (g3::logLevel(&v26) & 1) == 0 )
          {
            v20 = 0;
            if ( (v27 & 1) == 0 )
              goto LABEL_27;
            goto LABEL_30;
          }
          v24 = 0LL;
          v25 = 0LL;
          v23 = 0LL;
          v16 = TAG;
          v17 = strlen((const char *)TAG);
          if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v18 = v17;
          if ( v17 >= 0x17 )
          {
            v21 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v19 = (char *)operator new(v21);
            v24 = v18;
            v25 = v19;
            v23 = v21 | 1;
          }
          else
          {
            v19 = (char *)&v23 + 1;
            LOBYTE(v23) = 2 * v17;
            if ( !v17 )
            {
LABEL_25:
              v19[v18] = 0;
              v20 = g3::logTag(&v23);
              if ( (v23 & 1) != 0 )
              {
                operator delete(v25);
                if ( (v27 & 1) == 0 )
                {
LABEL_27:
                  if ( (v20 & 1) == 0 )
                    return;
LABEL_31:
                  LogCapture::LogCapture((LogCapture *)v31, (const char *)TAG, (const LEVELS *)&dword_33270, "", 6, 0LL);
                  v22 = std::__put_character_sequence<char,std::char_traits<char>>(
                          v32,
                          (__int64)"get jni env failed when get exposure ",
                          37LL);
                  std::ostream::operator<<(v22);
                  LogCapture::~LogCapture((LogCapture *)v31);
                  return;
                }
              }
              else if ( (v27 & 1) == 0 )
              {
                goto LABEL_27;
              }
LABEL_30:
              operator delete(v29);
              if ( (v20 & 1) == 0 )
                return;
              goto LABEL_31;
            }
          }
          memcpy(v19, v16, v18);
          goto LABEL_25;
        }
      }
      memcpy(v10, v7, v9);
      goto LABEL_16;
    }
  }
  v11 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v30 + 1408LL))(v30, v4);
  (*(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD, _QWORD, __int64))(*v30 + 1664LL))(
    v30,
    v30,
    v11,
    0LL,
    v4,
    v3);
  _JNIEnv::CallVoidMethod((__int64)v30, easynode_object_, esp32cb_method_);
  v12 = v30;
  v13 = (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD))(*v30 + 1472LL))(v30, v11, 0LL);
  (*(void (__fastcall **)(_QWORD *, __int64, __int64, _QWORD))(*v12 + 1536LL))(v12, v11, v13, 0LL);
  if ( v6 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)glb_vm_ + 40LL))(glb_vm_);
  v14 = pthread_self();
  pthread_setname_np(v14, "easynode_usb_callback");
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 33008: using guessed type void *TAG;
// 33270: using guessed type int dword_33270;
// 33278: using guessed type __int16 word_33278;
// 33288: using guessed type __int64 qword_33288;
// 33360: using guessed type __int64 glb_vm_;
// 33368: using guessed type __int64 easynode_object_;
// 33378: using guessed type __int64 esp32cb_method_;
// ED7C: using guessed type char var_190[8];

//----- (000000000000F124) ----------------------------------------------------
__int64 __fastcall sub_F124(__int64 a1, __int64 a2)
{
  if ( *(char **)(a2 + 8) == "Z16setESP32CallbackvE3$_1" )
    return a1 + 8;
  else
    return 0LL;
}

//----- (000000000000F140) ----------------------------------------------------
void **sub_F140()
{
  return &`typeinfo for'setESP32Callback(void)::$_1;
}
// 322E8: using guessed type void *`typeinfo for'setESP32Callback(void)::$_1;

//----- (000000000000F14C) ----------------------------------------------------
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  unsigned __int64 v3; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  void *v10; // x23
  char *v11; // x23
  unsigned __int64 v12; // x8
  __int64 v13; // x24
  __int64 v14; // x8
  char *v15; // x8
  char *v16; // x0
  char *v17; // x25

  v3 = *(unsigned __int8 *)a1;
  if ( (v3 & 1) != 0 )
  {
    v7 = a1[1];
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v7 = v3 >> 1;
    v8 = 22LL;
  }
  if ( v8 - v7 < n )
  {
    v9 = v7 + n;
    if ( -18LL - v8 < v7 + n - v8 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v3 & 1) != 0 )
      v10 = (void *)a1[2];
    else
      v10 = (char *)a1 + 1;
    if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v13 = -17LL;
    }
    else
    {
      v12 = 2 * v8;
      if ( v9 >= 2 * v8 )
        v12 = v7 + n;
      if ( v12 >= 0x17 )
        v13 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v13 = 23LL;
    }
    v16 = (char *)operator new(v13);
    v17 = v16;
    if ( v7 )
      memcpy(v16, v10, v7);
    memcpy(&v17[v7], src, n);
    if ( v8 != 22 )
      operator delete(v10);
    *a1 = v13 | 1;
    v15 = &v17[v9];
    a1[1] = v9;
    a1[2] = (__int64)v17;
    goto LABEL_29;
  }
  if ( n )
  {
    if ( (v3 & 1) != 0 )
      v11 = (char *)a1[2];
    else
      v11 = (char *)a1 + 1;
    memcpy(&v11[v7], src, n);
    v14 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v14;
    else
      *(_BYTE *)a1 = 2 * v14;
    v15 = &v11[v14];
LABEL_29:
    *v15 = 0;
  }
  return a1;
}

//----- (000000000000F2CC) ----------------------------------------------------
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  unsigned __int64 v4; // x8
  char *v6; // x21
  size_t v9; // x27
  unsigned __int64 v10; // x28
  unsigned __int64 v11; // x23
  char *v12; // x8
  char *v13; // x23
  unsigned __int64 v14; // x8
  __int64 v15; // x24
  char *v16; // x22
  __int64 v18; // x8
  char *v19; // x8
  char *v20; // x0
  char *v21; // x25
  char *srca; // [xsp+8h] [xbp-58h]

  v4 = *(unsigned __int8 *)a1;
  v6 = src;
  if ( (v4 & 1) != 0 )
  {
    v9 = a1[1];
    if ( v9 < a2 )
      goto LABEL_44;
  }
  else
  {
    v9 = v4 >> 1;
    if ( v4 >> 1 < a2 )
LABEL_44:
      std::__basic_string_common<true>::__throw_out_of_range();
  }
  if ( (v4 & 1) != 0 )
    v10 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v10 = 22LL;
  if ( v10 - v9 < n )
  {
    v11 = v9 + n;
    if ( -18LL - v10 < v9 + n - v10 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v4 & 1) != 0 )
      v12 = (char *)a1[2];
    else
      v12 = (char *)a1 + 1;
    srca = v12;
    if ( v10 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v15 = -17LL;
    }
    else
    {
      v14 = 2 * v10;
      if ( v11 >= 2 * v10 )
        v14 = v9 + n;
      if ( v14 >= 0x17 )
        v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v15 = 23LL;
    }
    v20 = (char *)operator new(v15);
    v21 = v20;
    if ( a2 )
      memcpy(v20, srca, a2);
    memcpy(&v21[a2], v6, n);
    if ( v9 != a2 )
      memcpy(&v21[a2 + n], &srca[a2], v9 - a2);
    if ( v10 != 22 )
      operator delete(srca);
    *a1 = v15 | 1;
    v19 = &v21[v11];
    a1[1] = v11;
    a1[2] = (__int64)v21;
LABEL_42:
    *v19 = 0;
    return a1;
  }
  if ( n )
  {
    if ( (v4 & 1) != 0 )
      v13 = (char *)a1[2];
    else
      v13 = (char *)a1 + 1;
    v16 = &v13[a2];
    if ( v9 != a2 )
    {
      if ( &v13[v9] > src && v16 <= src )
        v6 = &src[n];
      memmove(&v16[n], v16, v9 - a2);
    }
    memmove(v16, v6, n);
    v18 = v9 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v18;
    else
      *(_BYTE *)a1 = 2 * v18;
    v19 = &v13[v18];
    goto LABEL_42;
  }
  return a1;
}

//----- (000000000000F4C8) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  sub_F4DC("basic_string");
}

//----- (000000000000F4DC) ----------------------------------------------------
void __fastcall __noreturn sub_F4DC(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_F52C(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::out_of_range,
    (void (__fastcall *)(void *))&std::out_of_range::~out_of_range);
}

//----- (000000000000F52C) ----------------------------------------------------
__int64 __fastcall sub_F52C(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::out_of_range + 16;
  return result;
}

//----- (000000000000F55C) ----------------------------------------------------
std::__shared_weak_count *__usercall std::shared_ptr<EspRecvParse>::make_shared<>@<X0>(_QWORD *a1@<X8>)
{
  std::__shared_weak_count *v2; // x19
  unsigned __int64 *v3; // x22
  unsigned __int64 *v4; // x23
  std::__shared_weak_count *result; // x0
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x8

  v2 = (std::__shared_weak_count *)operator new(0xB0uLL);
  *((_QWORD *)v2 + 1) = 0LL;
  v3 = (unsigned __int64 *)((char *)v2 + 8);
  *((_QWORD *)v2 + 2) = 0LL;
  v4 = (unsigned __int64 *)((char *)v2 + 16);
  *(_QWORD *)v2 = off_32308;
  EspRecvParse::EspRecvParse((std::__shared_weak_count *)((char *)v2 + 32));
  result = (std::__shared_weak_count *)*((_QWORD *)v2 + 5);
  *a1 = (char *)v2 + 32;
  a1[1] = v2;
  if ( !result || *((_QWORD *)result + 1) == -1LL )
  {
    do
      v6 = __ldxr(v3);
    while ( __stxr(v6 + 1, v3) );
    do
      v7 = __ldxr(v4);
    while ( __stxr(v7 + 1, v4) );
    *((_QWORD *)v2 + 4) = (char *)v2 + 32;
    *((_QWORD *)v2 + 5) = v2;
    if ( result )
      result = (std::__shared_weak_count *)std::__shared_weak_count::__release_weak(result);
    do
      v8 = __ldaxr(v3);
    while ( __stlxr(v8 - 1, v3) );
    if ( !v8 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v2 + 16LL))(v2);
      return (std::__shared_weak_count *)std::__shared_weak_count::__release_weak(v2);
    }
  }
  return result;
}
// 32308: using guessed type __int64 (__fastcall *off_32308[3])();

//----- (000000000000F65C) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace(__int64 a1)
{
  __int64 v2; // x0
  void (*v3)(void); // x8
  std::__shared_weak_count *v4; // x0

  v2 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)a1 = off_32308;
  if ( a1 + 128 == v2 )
  {
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 32LL);
  }
  else
  {
    if ( !v2 )
      goto LABEL_6;
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 40LL);
  }
  v3();
LABEL_6:
  if ( (*(_BYTE *)(a1 + 96) & 1) != 0 )
    operator delete(*(void **)(a1 + 112));
  std::mutex::~mutex((std::mutex *)(a1 + 48));
  v4 = *(std::__shared_weak_count **)(a1 + 40);
  if ( v4 )
    std::__shared_weak_count::__release_weak(v4);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)a1);
}
// 32308: using guessed type __int64 (__fastcall *[3])();

//----- (000000000000F6DC) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<EspRecvParse>::~__shared_ptr_emplace(__int64 a1)
{
  __int64 v2; // x0
  void (*v3)(void); // x8
  std::__shared_weak_count *v4; // x0

  v2 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)a1 = off_32308;
  if ( a1 + 128 == v2 )
  {
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 32LL);
  }
  else
  {
    if ( !v2 )
      goto LABEL_6;
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 40LL);
  }
  v3();
LABEL_6:
  if ( (*(_BYTE *)(a1 + 96) & 1) != 0 )
    operator delete(*(void **)(a1 + 112));
  std::mutex::~mutex((std::mutex *)(a1 + 48));
  v4 = *(std::__shared_weak_count **)(a1 + 40);
  if ( v4 )
    std::__shared_weak_count::__release_weak(v4);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)a1);
  operator delete((void *)a1);
}
// 32308: using guessed type __int64 (__fastcall *off_32308[3])();

//----- (000000000000F764) ----------------------------------------------------
std::__shared_weak_count *__fastcall std::__shared_ptr_emplace<EspRecvParse>::__on_zero_shared(__int64 a1)
{
  __int64 v2; // x0
  void (*v3)(void); // x8
  std::__shared_weak_count *result; // x0

  v2 = *(_QWORD *)(a1 + 160);
  if ( a1 + 128 == v2 )
  {
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 32LL);
  }
  else
  {
    if ( !v2 )
      goto LABEL_6;
    v3 = *(void (**)(void))(*(_QWORD *)v2 + 40LL);
  }
  v3();
LABEL_6:
  if ( (*(_BYTE *)(a1 + 96) & 1) != 0 )
    operator delete(*(void **)(a1 + 112));
  std::mutex::~mutex((std::mutex *)(a1 + 48));
  result = *(std::__shared_weak_count **)(a1 + 40);
  if ( result )
    return (std::__shared_weak_count *)std::__shared_weak_count::__release_weak(result);
  return result;
}

//----- (000000000000F7DC) ----------------------------------------------------
void __fastcall EspRecvParse::EspRecvParse(EspRecvParse *this)
{
  *((_QWORD *)this + 10) = 0LL;
  *((_DWORD *)this + 22) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_BYTE *)this + 65) = 0;
  *((_QWORD *)this + 16) = 0LL;
}

//----- (000000000000F800) ----------------------------------------------------
__int64 __fastcall EspRecvParse::crc162(EspRecvParse *this, unsigned __int8 *a2)
{
  unsigned int v2; // w8
  __int16 v3; // t1
  __int16 v4; // w8
  __int16 v5; // w10
  bool v6; // zf
  __int16 v7; // w8
  __int16 v8; // w10
  __int16 v9; // w8
  __int16 v10; // w10
  __int16 v11; // w8
  __int16 v12; // w10
  __int16 v13; // w8
  __int16 v14; // w10
  __int16 v15; // w8
  __int16 v16; // w10
  __int16 v17; // w8
  unsigned __int16 v18; // w10
  unsigned __int16 v19; // w8

  v2 = 0xFFFF;
  while ( (_DWORD)a2 )
  {
    v3 = *(unsigned __int8 *)this;
    this = (EspRecvParse *)((char *)this + 1);
    LODWORD(a2) = (_DWORD)a2 - 1;
    v4 = v2 ^ (v3 << 8);
    v5 = 2 * v4;
    v6 = (v4 & 0x8000) == 0;
    v7 = (2 * v4) ^ 0x1021;
    if ( v6 )
      v7 = v5;
    v8 = 2 * v7;
    v6 = (v7 & 0x8000) == 0;
    v9 = (2 * v7) ^ 0x1021;
    if ( v6 )
      v9 = v8;
    v10 = 2 * v9;
    v6 = (v9 & 0x8000) == 0;
    v11 = (2 * v9) ^ 0x1021;
    if ( v6 )
      v11 = v10;
    v12 = 2 * v11;
    v6 = (v11 & 0x8000) == 0;
    v13 = (2 * v11) ^ 0x1021;
    if ( v6 )
      v13 = v12;
    v14 = 2 * v13;
    v6 = (v13 & 0x8000) == 0;
    v15 = (2 * v13) ^ 0x1021;
    if ( v6 )
      v15 = v14;
    v16 = 2 * v15;
    v6 = (v15 & 0x8000) == 0;
    v17 = (2 * v15) ^ 0x1021;
    if ( v6 )
      v17 = v16;
    v18 = 2 * v17;
    v6 = (v17 & 0x8000) == 0;
    v19 = (2 * v17) ^ 0x1021;
    if ( v6 )
      v19 = v18;
    if ( (v19 & 0x8000) != 0 )
      v2 = (2 * v19) ^ 0x1021;
    else
      v2 = 2 * v19;
  }
  return v2;
}

//----- (000000000000F8A4) ----------------------------------------------------
__int64 __fastcall EspRecvParse::setCallBack(__int64 a1, __int64 a2)
{
  std::mutex *v2; // x19
  __int64 v5; // x0
  void (*v6)(void); // x8
  _QWORD v8[4]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v9; // [xsp+20h] [xbp-40h]
  __int64 v10; // [xsp+38h] [xbp-28h]

  v2 = (std::mutex *)(a1 + 16);
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  std::mutex::lock((std::mutex *)(a1 + 16));
  v5 = *(_QWORD *)(a2 + 32);
  if ( v5 )
  {
    if ( a2 == v5 )
    {
      v9 = v8;
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v5 + 24LL))(v5, v8);
    }
    else
    {
      v9 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
    }
    sub_10440(v8, a1 + 96);
    if ( v8 == v9 )
    {
      v6 = *(void (**)(void))(*v9 + 32LL);
      goto LABEL_9;
    }
    if ( v9 )
    {
      v6 = *(void (**)(void))(*v9 + 40LL);
LABEL_9:
      v6();
    }
  }
  return std::mutex::unlock(v2);
}

//----- (000000000000F990) ----------------------------------------------------
__int64 __fastcall EspRecvParse::reset(__int64 this)
{
  *(_QWORD *)(this + 56) = 0LL;
  *(_DWORD *)(this + 88) = 0;
  return this;
}

//----- (000000000000F99C) ----------------------------------------------------
__int64 *__fastcall EspRecvParse::parseData(__int64 *this, char *a2, int a3)
{
  unsigned __int64 v3; // x9
  _BYTE *v4; // x22
  __int64 v5; // x21
  __int64 v7; // x19
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x10
  int v10; // w8
  _BYTE *v11; // x22
  __int64 v12; // x8
  char v13; // w10
  _BYTE *v14; // x9
  __int64 v15; // x8
  char v16; // w10
  _BYTE *v17; // x9
  __int64 v18; // x8
  char v19; // w11
  char v20; // w9
  _BYTE *v21; // x10
  unsigned int v22; // w9
  __int64 v23; // x8
  char v24; // w11
  char v25; // w9
  _BYTE *v26; // x10

  v4 = this + 8;
  v3 = *((unsigned __int8 *)this + 64);
  LODWORD(v5) = a3;
  v7 = (__int64)this;
  v8 = (unsigned int)(*((_DWORD *)this + 14) + a3);
  if ( (v3 & 1) == 0 )
  {
    v9 = v3 >> 1;
    if ( v3 >> 1 >= v8 )
      goto LABEL_3;
LABEL_7:
    this = std::string::append(this + 8, v8 - v9, 0);
    if ( (int)v5 <= 0 )
      goto LABEL_33;
    goto LABEL_10;
  }
  v9 = this[9];
  if ( v9 < v8 )
    goto LABEL_7;
LABEL_3:
  if ( (v3 & 1) != 0 )
  {
    *(_BYTE *)(this[10] + v8) = 0;
    this[9] = v8;
    if ( a3 <= 0 )
      goto LABEL_33;
  }
  else
  {
    v4[v8 + 1] = 0;
    *v4 = 2 * v8;
    if ( a3 <= 0 )
      goto LABEL_33;
  }
LABEL_10:
  v10 = *(_DWORD *)(v7 + 88);
  v11 = v4 + 1;
  v5 = (unsigned int)v5;
  do
  {
    switch ( v10 )
    {
      case 0:
        if ( (unsigned __int8)*a2 != 170 )
          goto LABEL_30;
        v12 = *(unsigned int *)(v7 + 56);
        v13 = *(_BYTE *)(v7 + 64);
        *(_DWORD *)(v7 + 56) = v12 + 1;
        v14 = v11;
        if ( (v13 & 1) != 0 )
          v14 = *(_BYTE **)(v7 + 80);
        v14[v12] = -86;
        v10 = 1;
        break;
      case 1:
        if ( *a2 != 85 )
          goto LABEL_30;
        v15 = *(unsigned int *)(v7 + 56);
        v16 = *(_BYTE *)(v7 + 64);
        *(_DWORD *)(v7 + 56) = v15 + 1;
        v17 = v11;
        if ( (v16 & 1) != 0 )
          v17 = *(_BYTE **)(v7 + 80);
        v17[v15] = 85;
        v10 = 2;
        break;
      case 2:
        v18 = *(unsigned int *)(v7 + 56);
        v19 = *(_BYTE *)(v7 + 64);
        v20 = *a2;
        *(_DWORD *)(v7 + 56) = v18 + 1;
        v21 = v11;
        if ( (v19 & 1) != 0 )
          v21 = *(_BYTE **)(v7 + 80);
        v21[v18] = v20;
        *(_DWORD *)(v7 + 60) = (unsigned __int8)*a2 + 12;
        goto LABEL_28;
      case 3:
        v22 = *(_DWORD *)(v7 + 60);
        if ( !v22 )
          goto LABEL_30;
        v23 = *(unsigned int *)(v7 + 56);
        if ( (unsigned int)v23 >= v22 )
        {
          this = (__int64 *)EspRecvParse::send_callback((EspRecvParse *)v7);
LABEL_30:
          v10 = 0;
          *(_QWORD *)(v7 + 56) = 0LL;
        }
        else
        {
          v24 = *(_BYTE *)(v7 + 64);
          v25 = *a2;
          *(_DWORD *)(v7 + 56) = v23 + 1;
          v26 = v11;
          if ( (v24 & 1) != 0 )
            v26 = *(_BYTE **)(v7 + 80);
          v26[v23] = v25;
LABEL_28:
          v10 = 3;
        }
        break;
      default:
        goto LABEL_32;
    }
    *(_DWORD *)(v7 + 88) = v10;
LABEL_32:
    --v5;
    ++a2;
  }
  while ( v5 );
LABEL_33:
  if ( (unsigned int)(*(_DWORD *)(v7 + 60) - 1) < *(_DWORD *)(v7 + 56) )
  {
    this = (__int64 *)EspRecvParse::send_callback((EspRecvParse *)v7);
    *(_QWORD *)(v7 + 56) = 0LL;
    *(_DWORD *)(v7 + 88) = 0;
  }
  return this;
}

//----- (000000000000FBA4) ----------------------------------------------------
__int64 __fastcall EspRecvParse::send_callback(EspRecvParse *this)
{
  const char *v2; // x21
  size_t v3; // x0
  size_t v4; // x20
  char *v5; // x22
  unsigned __int64 v6; // x23
  char *v7; // x20
  size_t v8; // x0
  size_t v9; // x21
  char *v10; // x22
  char v11; // w20
  unsigned __int64 v12; // x23
  _QWORD *v13; // x0
  _BYTE *v14; // x19
  char *v15; // x8
  _BYTE *v16; // x8
  unsigned __int8 *v17; // x9
  __int64 v18; // x9
  unsigned int v19; // w21
  unsigned int v20; // w20
  _BYTE *v21; // x8
  unsigned __int64 v22; // x8
  EspRecvParse *v23; // x0
  unsigned __int8 *v24; // x1
  unsigned __int16 v25; // w0
  const char *v26; // x24
  unsigned __int16 v27; // w22
  size_t v28; // x0
  size_t v29; // x23
  char *v30; // x25
  unsigned __int64 v31; // x26
  char *v32; // x23
  size_t v33; // x0
  size_t v34; // x24
  char *v35; // x25
  char v36; // w24
  unsigned __int64 v37; // x26
  unsigned int v38; // w23
  const char *v39; // x21
  size_t v40; // x0
  size_t v41; // x20
  char *v42; // x22
  _BYTE *v43; // x8
  _BYTE *v44; // x8
  int v45; // w8
  unsigned __int64 v46; // x9
  unsigned __int64 v47; // x10
  int v48; // w23
  _BYTE *v49; // x19
  size_t v50; // x20
  char *v51; // x21
  unsigned __int64 v52; // x23
  char *v53; // x20
  size_t v54; // x0
  size_t v55; // x21
  char *v56; // x22
  __int64 v57; // x0
  char *v58; // x8
  unsigned int v59; // w19
  char v60; // w20
  unsigned __int64 v61; // x23
  unsigned __int64 v63; // [xsp+10h] [xbp-260h] BYREF
  size_t v64; // [xsp+18h] [xbp-258h]
  void *v65; // [xsp+20h] [xbp-250h]
  int v66; // [xsp+28h] [xbp-248h] BYREF
  unsigned __int64 v67; // [xsp+30h] [xbp-240h] BYREF
  size_t v68; // [xsp+38h] [xbp-238h]
  void *v69; // [xsp+40h] [xbp-230h]
  unsigned __int64 v70; // [xsp+48h] [xbp-228h] BYREF
  size_t v71; // [xsp+50h] [xbp-220h]
  void *v72; // [xsp+58h] [xbp-218h]
  int v73; // [xsp+60h] [xbp-210h] BYREF
  unsigned __int64 v74; // [xsp+68h] [xbp-208h] BYREF
  size_t v75; // [xsp+70h] [xbp-200h]
  void *v76; // [xsp+78h] [xbp-1F8h]
  unsigned __int64 v77; // [xsp+80h] [xbp-1F0h] BYREF
  size_t v78; // [xsp+88h] [xbp-1E8h]
  void *v79; // [xsp+90h] [xbp-1E0h]
  int v80; // [xsp+98h] [xbp-1D8h] BYREF
  unsigned __int64 v81; // [xsp+A0h] [xbp-1D0h] BYREF
  size_t v82; // [xsp+A8h] [xbp-1C8h]
  void *v83; // [xsp+B0h] [xbp-1C0h]
  int v84; // [xsp+BCh] [xbp-1B4h] BYREF
  char *v85; // [xsp+C0h] [xbp-1B0h] BYREF
  unsigned __int64 v86; // [xsp+C8h] [xbp-1A8h] BYREF
  size_t v87; // [xsp+D0h] [xbp-1A0h] BYREF
  void *v88; // [xsp+D8h] [xbp-198h]
  __int64 v89; // [xsp+210h] [xbp-60h]

  v89 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v80 = dword_333C0;
  v82 = 0LL;
  v83 = 0LL;
  if ( (word_333C8 & 1) != 0 )
    v2 = (const char *)qword_333D8;
  else
    v2 = (char *)&word_333C8 + 1;
  v81 = 0LL;
  v3 = strlen(v2);
  if ( v3 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_118;
  v4 = v3;
  if ( v3 >= 0x17 )
  {
    v6 = (v3 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v5 = (char *)operator new(v6);
    v82 = v4;
    v83 = v5;
    v81 = v6 | 1;
    goto LABEL_9;
  }
  v5 = (char *)&v81 + 1;
  LOBYTE(v81) = 2 * v3;
  if ( v3 )
LABEL_9:
    memcpy(v5, v2, v4);
  v5[v4] = 0;
  if ( (g3::logLevel(&v80) & 1) == 0 )
  {
    v11 = 0;
    if ( (v81 & 1) == 0 )
      goto LABEL_21;
    goto LABEL_25;
  }
  v78 = 0LL;
  v79 = 0LL;
  v77 = 0LL;
  v7 = RecvTAG;
  v8 = strlen(RecvTAG);
  if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v9 = v8;
  if ( v8 >= 0x17 )
  {
    v12 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = (char *)operator new(v12);
    v78 = v9;
    v79 = v10;
    v77 = v12 | 1;
    goto LABEL_18;
  }
  v10 = (char *)&v77 + 1;
  LOBYTE(v77) = 2 * v8;
  if ( v8 )
LABEL_18:
    memcpy(v10, v7, v9);
  v10[v9] = 0;
  v11 = g3::logTag(&v77);
  if ( (v77 & 1) != 0 )
  {
    operator delete(v79);
    if ( (v81 & 1) == 0 )
    {
LABEL_21:
      if ( (v11 & 1) != 0 )
        goto LABEL_22;
      goto LABEL_26;
    }
  }
  else if ( (v81 & 1) == 0 )
  {
    goto LABEL_21;
  }
LABEL_25:
  operator delete(v83);
  if ( (v11 & 1) != 0 )
  {
LABEL_22:
    LogCapture::LogCapture((LogCapture *)&v86, RecvTAG, (const LEVELS *)&dword_333C0, "", 6, 0LL);
    v13 = std::__put_character_sequence<char,std::char_traits<char>>(&v87, (__int64)"channel", 7LL);
    v14 = (char *)this + 64;
    if ( (*((_BYTE *)this + 64) & 1) != 0 )
      v15 = (char *)*((_QWORD *)this + 10);
    else
      v15 = (char *)this + 65;
    LOBYTE(v85) = v15[3];
    std::__put_character_sequence<char,std::char_traits<char>>(v13, (__int64)&v85, 1LL);
    LogCapture::~LogCapture((LogCapture *)&v86);
    if ( (*v14 & 1) != 0 )
      goto LABEL_30;
LABEL_27:
    v16 = v14 + 7;
    v17 = (unsigned __int8 *)this + 72;
    goto LABEL_31;
  }
LABEL_26:
  v14 = (char *)this + 64;
  if ( (*((_BYTE *)this + 64) & 1) == 0 )
    goto LABEL_27;
LABEL_30:
  v18 = *((_QWORD *)this + 10);
  v16 = (_BYTE *)(v18 + 6);
  v17 = (unsigned __int8 *)(v18 + 7);
LABEL_31:
  v19 = (unsigned __int8)*v16;
  v20 = *v17;
  *v16 = 0;
  if ( (*v14 & 1) != 0 )
    v21 = (_BYTE *)*((_QWORD *)this + 10);
  else
    v21 = v14 + 1;
  v21[7] = 0;
  v22 = (unsigned __int8)*v14;
  if ( (v22 & 1) != 0 )
  {
    v24 = (unsigned __int8 *)*((_QWORD *)this + 9);
    v23 = (EspRecvParse *)*((_QWORD *)this + 10);
  }
  else
  {
    v23 = (EspRecvParse *)(v14 + 1);
    v24 = (unsigned __int8 *)(v22 >> 1);
  }
  v25 = EspRecvParse::crc162(v23, v24);
  if ( (word_333C8 & 1) != 0 )
    v26 = (const char *)qword_333D8;
  else
    v26 = (char *)&word_333C8 + 1;
  v27 = v25;
  v73 = dword_333C0;
  v75 = 0LL;
  v76 = 0LL;
  v74 = 0LL;
  v28 = strlen(v26);
  if ( v28 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v29 = v28;
  if ( v28 >= 0x17 )
  {
    v31 = (v28 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v30 = (char *)operator new(v31);
    v75 = v29;
    v76 = v30;
    v74 = v31 | 1;
    goto LABEL_45;
  }
  v30 = (char *)&v74 + 1;
  LOBYTE(v74) = 2 * v28;
  if ( v28 )
LABEL_45:
    memcpy(v30, v26, v29);
  v30[v29] = 0;
  if ( (g3::logLevel(&v73) & 1) != 0 )
  {
    v71 = 0LL;
    v72 = 0LL;
    v70 = 0LL;
    v32 = RecvTAG;
    v33 = strlen(RecvTAG);
    if ( v33 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v34 = v33;
    if ( v33 >= 0x17 )
    {
      v37 = (v33 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v35 = (char *)operator new(v37);
      v71 = v34;
      v72 = v35;
      v70 = v37 | 1;
    }
    else
    {
      v35 = (char *)&v70 + 1;
      LOBYTE(v70) = 2 * v33;
      if ( !v33 )
      {
LABEL_55:
        v35[v34] = 0;
        v36 = g3::logTag(&v70);
        if ( (v70 & 1) != 0 )
          operator delete(v72);
        if ( (v74 & 1) != 0 )
          goto LABEL_58;
        goto LABEL_59;
      }
    }
    memcpy(v35, v32, v34);
    goto LABEL_55;
  }
  v36 = 0;
  if ( (v74 & 1) != 0 )
LABEL_58:
    operator delete(v76);
LABEL_59:
  v38 = v19 & 0xFFFF00FF | ((unsigned __int8)v20 << 8);
  if ( (v36 & 1) != 0 )
  {
    LogCapture::LogCapture((LogCapture *)&v86, RecvTAG, (const LEVELS *)&dword_333C0, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)&v86,
      "calCrc=%x,crc=%x,crc1=%x,crc2=%x,espDataLen=%d,mParseIndex=%d",
      v38,
      v27,
      v19,
      v20,
      *((unsigned int *)this + 15),
      *((unsigned int *)this + 14));
    LogCapture::~LogCapture((LogCapture *)&v86);
    if ( v38 != v27 )
      goto LABEL_61;
  }
  else if ( v38 != v27 )
  {
LABEL_61:
    if ( (word_333C8 & 1) != 0 )
      v39 = (const char *)qword_333D8;
    else
      v39 = (char *)&word_333C8 + 1;
    v66 = dword_333C0;
    v68 = 0LL;
    v69 = 0LL;
    v67 = 0LL;
    v40 = strlen(v39);
    if ( v40 < 0xFFFFFFFFFFFFFFF0LL )
    {
      v41 = v40;
      if ( v40 >= 0x17 )
      {
        v52 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v42 = (char *)operator new(v52);
        v68 = v41;
        v69 = v42;
        v67 = v52 | 1;
      }
      else
      {
        v42 = (char *)&v67 + 1;
        LOBYTE(v67) = 2 * v40;
        if ( !v40 )
        {
LABEL_90:
          v42[v41] = 0;
          if ( (g3::logLevel(&v66) & 1) == 0 )
          {
            v60 = 0;
            if ( (v67 & 1) == 0 )
              goto LABEL_111;
            goto LABEL_114;
          }
          v64 = 0LL;
          v65 = 0LL;
          v63 = 0LL;
          v53 = RecvTAG;
          v54 = strlen(RecvTAG);
          if ( v54 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v55 = v54;
          if ( v54 >= 0x17 )
          {
            v61 = (v54 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v56 = (char *)operator new(v61);
            v64 = v55;
            v65 = v56;
            v63 = v61 | 1;
          }
          else
          {
            v56 = (char *)&v63 + 1;
            LOBYTE(v63) = 2 * v54;
            if ( !v54 )
            {
LABEL_109:
              v56[v55] = 0;
              v60 = g3::logTag(&v63);
              if ( (v63 & 1) != 0 )
              {
                operator delete(v65);
                if ( (v67 & 1) == 0 )
                {
LABEL_111:
                  if ( (v60 & 1) == 0 )
                    goto LABEL_116;
                  goto LABEL_115;
                }
              }
              else if ( (v67 & 1) == 0 )
              {
                goto LABEL_111;
              }
LABEL_114:
              operator delete(v69);
              if ( (v60 & 1) == 0 )
              {
LABEL_116:
                v59 = -1;
                *((_QWORD *)this + 7) = 0LL;
                *((_DWORD *)this + 22) = 0;
                return v59;
              }
LABEL_115:
              LogCapture::LogCapture((LogCapture *)&v86, RecvTAG, (const LEVELS *)&dword_333C0, "", 6, 0LL);
              std::__put_character_sequence<char,std::char_traits<char>>(
                &v87,
                (__int64)"crc not correct, not callback",
                29LL);
              LogCapture::~LogCapture((LogCapture *)&v86);
              goto LABEL_116;
            }
          }
          memcpy(v56, v53, v55);
          goto LABEL_109;
        }
      }
      memcpy(v42, v39, v41);
      goto LABEL_90;
    }
LABEL_118:
    std::__basic_string_common<true>::__throw_length_error();
  }
  if ( (*v14 & 1) != 0 )
    v43 = (_BYTE *)*((_QWORD *)this + 10);
  else
    v43 = v14 + 1;
  v43[6] = v19;
  if ( (*v14 & 1) != 0 )
    v44 = (_BYTE *)*((_QWORD *)this + 10);
  else
    v44 = v14 + 1;
  v44[7] = v20;
  v45 = *((_DWORD *)this + 15);
  v86 = 0LL;
  v87 = 0LL;
  v88 = 0LL;
  v46 = *((unsigned __int8 *)this + 64);
  v47 = *((_QWORD *)this + 9);
  if ( (v46 & 1) == 0 )
    v47 = v46 >> 1;
  if ( v47 <= 0xB )
    std::__basic_string_common<true>::__throw_out_of_range();
  v48 = v45 - 12;
  if ( (v46 & 1) != 0 )
    v49 = (_BYTE *)*((_QWORD *)this + 10);
  else
    v49 = v14 + 1;
  if ( v47 - 12 >= v48 )
    v50 = v48;
  else
    v50 = v47 - 12;
  if ( v50 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  if ( v50 >= 0x17 )
  {
    v51 = (char *)operator new((v50 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    v87 = v50;
    v88 = v51;
    v86 = (v50 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    goto LABEL_96;
  }
  v51 = (char *)&v86 + 1;
  LOBYTE(v86) = 2 * v50;
  if ( v50 )
LABEL_96:
    memcpy(v51, v49 + 12, v50);
  v51[v50] = 0;
  v57 = *((_QWORD *)this + 16);
  if ( !v57 )
  {
    v59 = -1;
    if ( (v86 & 1) == 0 )
      return v59;
LABEL_106:
    operator delete(v88);
    return v59;
  }
  if ( (v86 & 1) != 0 )
    v58 = (char *)v88;
  else
    v58 = (char *)&v86 + 1;
  v85 = v58;
  v84 = v48;
  (*(void (__fastcall **)(__int64, char **, int *))(*(_QWORD *)v57 + 48LL))(v57, &v85, &v84);
  v59 = 0;
  if ( (v86 & 1) != 0 )
    goto LABEL_106;
  return v59;
}
// 7530: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 7550: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7920: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 331D0: using guessed type char *RecvTAG;
// 333C0: using guessed type int dword_333C0;
// 333C8: using guessed type __int16 word_333C8;
// 333D8: using guessed type __int64 qword_333D8;

//----- (0000000000010440) ----------------------------------------------------
_QWORD *__fastcall sub_10440(_QWORD *result, __int64 a2)
{
  _QWORD *v2; // x20
  __int64 v4; // x8
  __int64 v5[6]; // [xsp+0h] [xbp-50h] BYREF

  v5[5] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (_QWORD *)a2 != result )
  {
    v2 = result;
    result = (_QWORD *)result[4];
    if ( result == v2 )
    {
      if ( *(_QWORD *)(a2 + 32) == a2 )
      {
        (*(void (__fastcall **)(_QWORD *, __int64 *))(*result + 24LL))(result, v5);
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = 0LL;
        (*(void (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 32) + 24LL))(*(_QWORD *)(a2 + 32), v2);
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        *(_QWORD *)(a2 + 32) = 0LL;
        v2[4] = v2;
        (*(void (__fastcall **)(__int64 *, __int64))(v5[0] + 24))(v5, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(__int64 *))(v5[0] + 32))(v5);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD *, __int64))(*result + 24LL))(result, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = *(_QWORD *)(a2 + 32);
      }
      *(_QWORD *)(a2 + 32) = a2;
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 32);
      if ( a2 == v4 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 24LL))(*(_QWORD *)(a2 + 32), v2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        *(_QWORD *)(a2 + 32) = v2[4];
        v2[4] = v2;
      }
      else
      {
        v2[4] = v4;
        *(_QWORD *)(a2 + 32) = result;
      }
    }
  }
  return result;
}

//----- (00000000000105A8) ----------------------------------------------------
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c)
{
  unsigned __int64 v4; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  __int64 v9; // x9
  void *v10; // x23
  unsigned __int64 v11; // x8
  __int64 v12; // x24
  void *v13; // x0
  __int64 v14; // x25
  char *v15; // x23
  __int64 v16; // x8

  if ( n )
  {
    v4 = *(unsigned __int8 *)a1;
    if ( (v4 & 1) != 0 )
    {
      v9 = *a1;
      v7 = a1[1];
      v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    }
    else
    {
      v7 = v4 >> 1;
      v8 = 22LL;
      LOBYTE(v9) = *(_BYTE *)a1;
    }
    if ( v8 - v7 < n )
    {
      if ( -17LL - v8 < v7 + n - v8 )
        std::__basic_string_common<true>::__throw_length_error();
      if ( (v4 & 1) != 0 )
        v10 = (void *)a1[2];
      else
        v10 = (char *)a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
        v12 = -17LL;
      }
      else
      {
        v11 = 2 * v8;
        if ( v7 + n >= 2 * v8 )
          v11 = v7 + n;
        if ( v11 >= 0x17 )
          v12 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        else
          v12 = 23LL;
      }
      v13 = (void *)operator new(v12);
      v14 = (__int64)v13;
      if ( v7 )
        memcpy(v13, v10, v7);
      if ( v8 != 22 )
        operator delete(v10);
      LOBYTE(v9) = v12 | 1;
      a1[2] = v14;
      *a1 = v12 | 1;
    }
    if ( (v9 & 1) != 0 )
      v15 = (char *)a1[2];
    else
      v15 = (char *)a1 + 1;
    memset(&v15[v7], c, n);
    v16 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v16;
    else
      *(_BYTE *)a1 = 2 * v16;
    v15[v16] = 0;
  }
  return a1;
}

//----- (0000000000010704) ----------------------------------------------------
__int64 __fastcall mg_base64_update(unsigned __int8 a1, __int64 a2, int a3)
{
  int v3; // w10
  unsigned int v4; // w9
  char v5; // w9
  int v6; // w8
  char v7; // w8
  unsigned int v8; // w10
  char v9; // w10
  char v10; // w10
  __int64 result; // x0
  char v12; // w9
  unsigned int v13; // w9
  char v14; // w9

  if ( (a3 & 3) == (((a3 & 3u) / 3) & 0xFFFFFFFD | (2 * (((a3 & 3u) / 3) & 1))) )
  {
    v6 = a1 >> 2;
    if ( a1 > 0x67u )
    {
      if ( a1 > 0xCFu )
      {
        if ( a1 > 0xF7u )
        {
          if ( v6 == 62 )
            v7 = 43;
          else
            v7 = 47;
        }
        else
        {
          v7 = v6 - 4;
        }
      }
      else
      {
        v7 = v6 + 71;
      }
    }
    else
    {
      v7 = v6 + 65;
    }
    v10 = 16 * (a1 & 3);
    result = a3 + 1LL;
    *(_BYTE *)(a2 + a3) = v7;
    *(_BYTE *)(a2 + result) = v10;
  }
  else
  {
    v3 = *(unsigned __int8 *)(a2 + a3);
    if ( (unsigned __int8)((a3 & 3) - (((a3 & 3u) / 3) & 0xFD | (2 * (((a3 & 3u) / 3) & 1)))) == 1 )
    {
      v4 = v3 | (a1 >> 4);
      if ( v4 > 0x19 )
      {
        if ( v4 > 0x33 )
        {
          if ( v4 > 0x3D )
          {
            if ( v4 == 62 )
              v5 = 43;
            else
              v5 = 47;
          }
          else
          {
            v5 = v4 - 4;
          }
        }
        else
        {
          v5 = v4 + 71;
        }
      }
      else
      {
        v5 = v4 + 65;
      }
      *(_BYTE *)(a2 + a3) = v5;
      v12 = 4 * (a1 & 0xF);
      result = a3 + 1LL;
      *(_BYTE *)(a2 + result) = v12;
    }
    else
    {
      v8 = v3 | (a1 >> 6);
      if ( v8 > 0x19 )
      {
        if ( v8 > 0x33 )
        {
          if ( v8 > 0x3D )
          {
            if ( v8 == 62 )
              v9 = 43;
            else
              v9 = 47;
          }
          else
          {
            v9 = v8 - 4;
          }
        }
        else
        {
          v9 = v8 + 71;
        }
      }
      else
      {
        v9 = v8 + 65;
      }
      v13 = a1 & 0x3F;
      *(_BYTE *)(a2 + a3) = v9;
      if ( v13 > 0x19 )
      {
        if ( v13 > 0x33 )
        {
          if ( v13 > 0x3D )
          {
            if ( v13 == 62 )
              v14 = 43;
            else
              v14 = 47;
          }
          else
          {
            v14 = v13 - 4;
          }
        }
        else
        {
          v14 = v13 + 71;
        }
      }
      else
      {
        v14 = v13 + 65;
      }
      result = (unsigned int)(a3 + 2);
      *(_BYTE *)(a2 + a3 + 1) = v14;
    }
  }
  return result;
}

//----- (0000000000010894) ----------------------------------------------------
__int64 __fastcall mg_base64_final(__int64 a1, int a2)
{
  int v2; // w8
  unsigned int v4; // w10
  char v5; // w11
  __int64 v6; // x9
  unsigned int v7; // w10
  char v8; // w10
  char v9; // w10
  char *v10; // x9
  unsigned int v11; // w20
  char v12; // w8
  __int64 v13; // x21

  v2 = a2 & 3;
  if ( (a2 & 3) != 0 )
  {
    v4 = ((a2 & 3u) / 3) & 0xFFFFFFFD | (2 * (((a2 & 3u) / 3) & 1));
    v5 = (a2 & 3) - v4;
    if ( (a2 & 3) == v4 )
    {
      *(_WORD *)(a1 + a2++) = 65;
    }
    else
    {
      v6 = a2;
      v7 = *(unsigned __int8 *)(a1 + a2);
      if ( v5 == 1 )
      {
        if ( v7 > 0x19 )
        {
          if ( v7 > 0x33 )
          {
            if ( v7 > 0x3D )
            {
              if ( v7 == 62 )
                v8 = 43;
              else
                v8 = 47;
            }
            else
            {
              v8 = v7 - 4;
            }
          }
          else
          {
            v8 = v7 + 71;
          }
        }
        else
        {
          v8 = v7 + 65;
        }
        ++a2;
        *(_BYTE *)(a1 + v6) = v8;
        *(_BYTE *)(a1 + v6 + 1) = 0;
      }
      else
      {
        if ( v7 > 0x19 )
        {
          if ( v7 > 0x33 )
          {
            if ( v7 > 0x3D )
            {
              if ( v7 == 62 )
                v9 = 43;
              else
                v9 = 47;
            }
            else
            {
              v9 = v7 - 4;
            }
          }
          else
          {
            v9 = v7 + 71;
          }
        }
        else
        {
          v9 = v7 + 65;
        }
        v10 = (char *)(a1 + a2);
        a2 += 2;
        *v10 = v9;
        v10[1] = 65;
      }
    }
  }
  v11 = a2 - (v2 == 2);
  if ( (v11 & 3) != 0 )
  {
    if ( v2 == 2 )
      v12 = 0;
    else
      v12 = -1;
    v13 = (v12 - (_BYTE)a2) & 3;
    memset((void *)(a1 + (int)v11), 61, v13 + 1);
    v11 += v13 + 1;
  }
  *(_BYTE *)(a1 + (int)v11) = 0;
  return v11;
}

//----- (00000000000109EC) ----------------------------------------------------
__int64 __fastcall mg_base64_encode(unsigned __int8 *a1, int a2, __int64 a3)
{
  int v5; // w2
  __int64 v6; // x21
  unsigned __int8 v7; // t1

  if ( a2 < 1 )
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = (unsigned int)a2;
    do
    {
      v7 = *a1++;
      --v6;
      v5 = mg_base64_update(v7, a3, v5);
    }
    while ( v6 );
  }
  return mg_base64_final(a3, v5);
}

//----- (0000000000010A4C) ----------------------------------------------------
__int64 __fastcall mg_base64_decode(__int64 a1, int a2, __int64 a3)
{
  int v3; // w10
  unsigned __int64 v4; // x8
  _BYTE *v5; // x9
  int v6; // w12
  int v7; // w11
  int v8; // w13
  unsigned int v9; // w12
  int v10; // w14
  unsigned int v11; // w13
  int v12; // w15
  int v13; // w14
  __int64 result; // x0
  __int64 v15; // x11

  if ( a2 < 4 )
  {
    result = 0LL;
LABEL_61:
    *(_BYTE *)(a3 + (int)result) = 0;
  }
  else
  {
    v3 = 0;
    v4 = a1 + a2;
    v5 = (_BYTE *)(a1 + 3);
    while ( 1 )
    {
      v6 = (unsigned __int8)*(v5 - 3);
      v7 = v6 - 65;
      if ( (unsigned int)(v6 - 65) >= 0x1A )
      {
        if ( (unsigned int)(v6 - 97) > 0x19 )
        {
          if ( (unsigned int)(v6 - 48) > 9 )
          {
            switch ( v6 )
            {
              case '+':
                v7 = 62;
                break;
              case '=':
                v7 = 64;
                break;
              case '/':
                v7 = 63;
                break;
              default:
                v7 = -1;
                break;
            }
          }
          else
          {
            v7 = v6 + 4;
          }
        }
        else
        {
          v7 = v6 - 71;
        }
      }
      v8 = (unsigned __int8)*(v5 - 2);
      v9 = v8 - 65;
      if ( (unsigned int)(v8 - 65) >= 0x1A )
      {
        if ( (unsigned int)(v8 - 97) > 0x19 )
        {
          if ( (unsigned int)(v8 - 48) > 9 )
          {
            switch ( v8 )
            {
              case '+':
                v9 = 62;
                break;
              case '=':
                v9 = 64;
                break;
              case '/':
                v9 = 63;
                break;
              default:
                v9 = -1;
                break;
            }
          }
          else
          {
            v9 = v8 + 4;
          }
        }
        else
        {
          v9 = v8 - 71;
        }
      }
      v10 = (unsigned __int8)*(v5 - 1);
      v11 = v10 - 65;
      if ( (unsigned int)(v10 - 65) >= 0x1A )
      {
        if ( (unsigned int)(v10 - 97) > 0x19 )
        {
          if ( (unsigned int)(v10 - 48) > 9 )
          {
            switch ( v10 )
            {
              case '+':
                v11 = 62;
                break;
              case '=':
                v11 = 64;
                break;
              case '/':
                v11 = 63;
                break;
              default:
                v11 = -1;
                break;
            }
          }
          else
          {
            v11 = v10 + 4;
          }
        }
        else
        {
          v11 = v10 - 71;
        }
      }
      v12 = (unsigned __int8)*v5;
      v13 = v12 - 65;
      if ( (unsigned int)(v12 - 65) >= 0x1A )
      {
        if ( (unsigned int)(v12 - 97) > 0x19 )
        {
          if ( (unsigned int)(v12 - 48) > 9 )
          {
            switch ( v12 )
            {
              case '+':
                v13 = 62;
                break;
              case '=':
                v13 = 64;
                break;
              case '/':
                v13 = 63;
                break;
              default:
                v13 = -1;
                break;
            }
          }
          else
          {
            v13 = v12 + 4;
          }
        }
        else
        {
          v13 = v12 - 71;
        }
      }
      result = 0LL;
      if ( v7 == 64 || v7 < 0 || v9 == 64 || ((v11 | v9 | v13) & 0x80000000) != 0 )
        break;
      *(_BYTE *)(a3 + v3) = (v9 >> 4) | (4 * v7);
      result = v3 + 1LL;
      if ( *(v5 - 1) != 61 )
      {
        *(_BYTE *)(a3 + result) = (v11 >> 2) | (16 * v9);
        v15 = v3 + 2LL;
        result = (unsigned int)v15;
        if ( *v5 != 61 )
        {
          result = (unsigned int)(v3 + 3);
          *(_BYTE *)(a3 + v15) = v13 | ((_BYTE)v11 << 6);
        }
      }
      v5 += 4;
      v3 = result;
      if ( (unsigned __int64)v5 >= v4 )
        goto LABEL_61;
    }
  }
  return result;
}

//----- (0000000000010CA0) ----------------------------------------------------
void __fastcall mg_resolve_cancel(__int64 a1)
{
  __int64 *v1; // x8
  __int64 *v3; // x21
  __int64 *v4; // x10
  __int64 *v5; // x9

  v1 = (__int64 *)qword_33510;
  if ( qword_33510 )
  {
    do
    {
      while ( 1 )
      {
        v3 = (__int64 *)*v1;
        if ( v1[1] == a1 )
          break;
        v1 = (__int64 *)*v1;
        if ( !v3 )
          return;
      }
      v4 = &qword_33510;
      do
      {
        v5 = v4;
        v4 = (__int64 *)*v4;
      }
      while ( v4 != v1 );
      *v5 = *v1;
      free(v1);
      v1 = v3;
    }
    while ( v3 );
  }
}
// 33510: using guessed type __int64 qword_33510;

//----- (0000000000010D1C) ----------------------------------------------------
__int64 __fastcall mg_dns_parse_name(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, size_t a5)
{
  return sub_10D24(a1, a2, a3, a4, a5, 0);
}

//----- (0000000000010D24) ----------------------------------------------------
__int64 __fastcall sub_10D24(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, size_t a5, int a6)
{
  __int64 v11; // x21
  unsigned __int64 v12; // x8
  size_t v13; // x28
  __int64 v14; // x9
  size_t v15; // x26
  size_t v16; // x9
  size_t v18; // x2

  if ( a5 )
    *a4 = 0;
  if ( a6 > 5 )
    return 0LL;
  v12 = a3 + 1;
  if ( a3 + 1 >= a2 )
  {
    v11 = 0LL;
LABEL_20:
    if ( a5 )
LABEL_21:
      a4[a5 - 1] = 0;
  }
  else
  {
    v11 = 0LL;
    v13 = 0LL;
    v14 = a3;
    while ( 1 )
    {
      v15 = *(unsigned __int8 *)(a1 + v14);
      if ( !*(_BYTE *)(a1 + v14) )
      {
        ++v11;
        if ( a5 )
          goto LABEL_21;
        return v11;
      }
      if ( (v15 & 0xC0) != 0 )
        break;
      if ( v14 + v15 + 1 >= a2 )
        return 0LL;
      if ( v13 )
      {
        if ( v13 < a5 )
          a4[v13] = 46;
        v16 = v13 + 1;
      }
      else
      {
        v16 = 0LL;
      }
      v13 = v16 + v15;
      if ( v16 + v15 < a5 )
      {
        memcpy(&a4[v16], (const void *)(a1 + v12), v15);
        a4[v13] = 0;
      }
      v11 += v15 + 1;
      v14 = v11 + a3;
      v12 = v11 + a3 + 1;
      if ( v12 >= a2 )
        goto LABEL_20;
    }
    v18 = *(unsigned __int8 *)(a1 + v12) | ((v15 & 0x3F) << 8);
    if ( v18 + 1 < a2 && *(unsigned __int8 *)(a1 + v18) <= 0x3Fu && !sub_10D24(a1, a2) )
      return 0LL;
    v11 += 2LL;
    if ( a5 )
      goto LABEL_21;
  }
  return v11;
}

//----- (0000000000010E88) ----------------------------------------------------
__int64 __fastcall mg_dns_parse_rr(__int64 a1, signed __int64 a2, __int64 a3, char a4, __int64 a5)
{
  __int64 result; // x0
  unsigned __int16 v11; // w0
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x9
  unsigned __int64 v15; // x10

  result = 0LL;
  *(_QWORD *)a5 = 0LL;
  if ( (unsigned __int64)(a2 - 12) <= 0x1F4 && a3 < a2 )
  {
    v11 = sub_10D24(a1, a2, a3, 0LL, 0LL, 0);
    *(_WORD *)a5 = v11;
    if ( !v11 )
      return 0LL;
    v12 = a1 + a2;
    v13 = a1 + a3 + (unsigned int)v11 + 4;
    if ( v13 > a1 + a2 )
      return 0LL;
    *(_WORD *)(a5 + 2) = bswap32(*(unsigned __int16 *)(v13 - 4)) >> 16;
    *(_WORD *)(a5 + 4) = bswap32(*(unsigned __int16 *)(v13 - 2)) >> 16;
    if ( (a4 & 1) != 0 )
      return v11 + 4LL;
    v14 = v13 + 6;
    if ( v14 <= v12
      && (v15 = *(unsigned __int8 *)(v14 - 1) | ((unsigned __int64)*(unsigned __int8 *)(v14 - 2) << 8),
          *(_WORD *)(a5 + 6) = _byteswap_ushort(*(_WORD *)(v14 - 2)),
          v14 + v15 <= v12) )
    {
      return v15 + v11 + 10;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (0000000000010F88) ----------------------------------------------------
long double __fastcall mg_dns_parse(unsigned __int16 *a1, signed __int64 a2, __int64 a3)
{
  long double result; // q0
  unsigned __int64 v4; // x25
  unsigned int v5; // w9
  unsigned int v7; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x24
  __int64 v12; // x22
  unsigned __int16 v13; // w0
  unsigned __int64 v14; // x26
  unsigned __int64 v15; // x27
  unsigned __int16 v16; // w0
  unsigned __int16 v17; // w24
  char *v18; // x8
  unsigned __int64 v19; // x28
  unsigned int v20; // w23
  int v21; // w8
  unsigned int v22; // [xsp+Ch] [xbp-54h]

  *(_OWORD *)&result = 0uLL;
  v4 = a2 - 12;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if ( (unsigned __int64)a2 >= 0xC )
  {
    v5 = a1[2];
    if ( __rev16(v5) <= 1 )
    {
      v7 = a1[3];
      if ( __rev16(v7) <= 0xA )
      {
        *(_WORD *)a3 = bswap32(*a1) >> 16;
        if ( v5 )
        {
          v10 = 0LL;
          v11 = (unsigned __int64)a1 + a2;
          v12 = 12LL;
          while ( v4 <= 0x1F4 )
          {
            if ( v12 >= a2 )
              break;
            v13 = sub_10D24((__int64)a1, a2, v12, 0LL, 0LL, 0);
            if ( !v13 || (unsigned __int64)a1 + v12 + v13 + 4 > v11 )
              break;
            ++v10;
            v12 += v13 + 4LL;
            if ( v10 >= bswap32(a1[2]) >> 16 )
            {
              if ( a1[3] )
                goto LABEL_15;
              return result;
            }
          }
        }
        else
        {
          v12 = 12LL;
          if ( v7 )
          {
LABEL_15:
            v14 = 0LL;
            v15 = (unsigned __int64)a1 + a2;
            do
            {
              if ( v4 > 0x1F4 )
                break;
              if ( v12 >= a2 )
                break;
              v16 = sub_10D24((__int64)a1, a2, v12, 0LL, 0LL, 0);
              v17 = v16;
              if ( !v16 )
                break;
              v18 = (char *)a1 + v12 + v16 + 4;
              if ( (unsigned __int64)v18 > v15 )
                break;
              if ( (unsigned __int64)(v18 + 6) > v15 )
                break;
              v19 = (unsigned __int8)v18[5] | ((unsigned __int64)(unsigned __int8)v18[4] << 8);
              if ( (unsigned __int64)&v18[v19 + 6] > v15 )
                break;
              v20 = bswap32(*((unsigned __int16 *)v18 - 2)) >> 16;
              v22 = bswap32(*((unsigned __int16 *)v18 - 1)) >> 16;
              sub_10D24((__int64)a1, a2, v12, (_BYTE *)(a3 + 32), 0x100uLL, 0);
              v12 += v17 + v19 + 10;
              if ( (_DWORD)v19 == 16 )
              {
                if ( v20 == 28 && v22 == 1 )
                {
                  *(_BYTE *)(a3 + 28) = 1;
                  result = *(long double *)((char *)a1 + v12 - 16);
                  *(_BYTE *)(a3 + 2) = 1;
                  *(long double *)(a3 + 12) = result;
                  return result;
                }
              }
              else if ( (_DWORD)v19 == 4 && v20 == 1 && v22 == 1 )
              {
                *(_BYTE *)(a3 + 28) = 0;
                v21 = *(_DWORD *)((char *)a1 + v12 - 4);
                *(_BYTE *)(a3 + 2) = 1;
                *(_DWORD *)(a3 + 8) = v21;
                return result;
              }
              ++v14;
            }
            while ( v14 < bswap32(a1[3]) >> 16 );
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000011228) ----------------------------------------------------
__int64 __fastcall mg_ntohs(unsigned int a1)
{
  return bswap32(a1) >> 16;
}

//----- (0000000000011234) ----------------------------------------------------
__int64 __fastcall mg_dns_send(__int64 a1, __int64 *a2, unsigned int a3, char a4)
{
  __int64 v4; // x24
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x25
  unsigned __int64 v10; // x26
  unsigned __int64 v11; // x9
  char *v12; // x9
  size_t v13; // x20
  __int64 v14; // x9
  __int64 v15; // x8
  unsigned __int64 v16; // x21
  unsigned __int64 v17; // x8
  __int64 result; // x0
  size_t v19; // x21
  int v20; // [xsp+Ch] [xbp-174h] BYREF
  __int128 src[17]; // [xsp+10h] [xbp-170h] BYREF
  __int64 v22; // [xsp+128h] [xbp-58h]

  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  memset(src, 0, 268);
  LOWORD(src[0]) = bswap32(a3) >> 16;
  *(_DWORD *)((char *)src + 2) = 16777217;
  v4 = *a2;
  v8 = 0LL;
  v9 = 0LL;
  do
  {
    v10 = a2[1];
    if ( *(_BYTE *)(v4 + v9) == 46 || v9 >= v10 )
    {
      *((_BYTE *)src + v8 + 12) = v9 - v8;
      memcpy((char *)src + v8 + 13, (const void *)(v4 + v8), v9 - v8);
      v11 = v9 + 1;
      v8 = v9 + 1;
      if ( v9 >= v10 )
        break;
    }
    else
    {
      v11 = v9 + 1;
    }
    v9 = v11;
  }
  while ( v11 < 0xFB );
  v12 = (char *)src + v8;
  v12[16] = 1;
  *((_DWORD *)v12 + 3) = 0x10000;
  if ( (a4 & 1) != 0 )
    v12[14] = 28;
  v13 = v8 + 17;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    result = sub_19A48(a1, src, v13, &v20);
    LODWORD(v19) = result;
    if ( !v13 )
      return result;
    goto LABEL_13;
  }
  v14 = *(_QWORD *)(a1 + 104);
  v15 = v8 + v14 + 529;
  v16 = v15 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v15 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v17 = v15 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v15 & 0xFFFFFFFFFFFFFE00LL);
    v17 = *(_QWORD *)(a1 + 96);
    v14 = *(_QWORD *)(a1 + 104);
  }
  if ( v16 == v17 )
    v19 = v13;
  else
    v19 = 0LL;
  result = (__int64)memmove((void *)(*(_QWORD *)(a1 + 88) + v14), src, v19);
  *(_QWORD *)(a1 + 104) += v19;
  if ( v13 )
  {
LABEL_13:
    if ( !(_DWORD)v19 )
      v20 = 1;
  }
  return result;
}

//----- (0000000000011404) ----------------------------------------------------
__int64 __fastcall mg_send(__int64 a1, void *buf, size_t a3)
{
  __int64 v6; // x8
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x8
  size_t v9; // x22
  int v11; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v12; // [xsp+8h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v9) = sub_19A48(a1, buf, a3, &v11);
    if ( !a3 )
      return (unsigned int)v9;
    goto LABEL_5;
  }
  v6 = a3 + *(_QWORD *)(a1 + 104) + 512;
  v7 = v6 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v6 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v8 = v6 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v6 & 0xFFFFFFFFFFFFFE00LL);
    v8 = *(_QWORD *)(a1 + 96);
  }
  if ( v7 == v8 )
    v9 = a3;
  else
    v9 = 0LL;
  if ( buf )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), buf, v9);
  *(_QWORD *)(a1 + 104) += v9;
  if ( a3 )
  {
LABEL_5:
    if ( !(_DWORD)v9 )
      v11 = 1;
  }
  return (unsigned int)v9;
}

//----- (00000000000114FC) ----------------------------------------------------
void __fastcall mg_resolve(__int64 a1, __int64 a2, int a3)
{
  __int64 v6; // x22
  char *v7; // x1
  __int64 *v8; // x24
  __int64 v9; // x0
  const char *v10; // x1
  _WORD *v11; // x0
  __int64 v12; // x9
  _WORD *v13; // x22
  __int16 v14; // w10
  __int64 v15; // x8
  __int64 v16; // [xsp+8h] [xbp-48h] BYREF
  __int64 v17; // [xsp+10h] [xbp-40h]
  __int64 v18; // [xsp+18h] [xbp-38h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (mg_aton(*(unsigned __int8 **)a2, *(_QWORD *)(a2 + 8), a1 + 16) & 1) != 0 )
  {
    mg_connect_resolved(a1);
    return;
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(char **)(v6 + 8);
  if ( v7 )
  {
    v8 = (__int64 *)(v6 + 16);
    if ( !*(_QWORD *)(v6 + 16) )
    {
      v9 = mg_connect(*(_QWORD *)(a1 + 8), v7, 0LL, 0LL);
      *(_QWORD *)(v6 + 16) = v9;
      if ( !v9 )
        goto LABEL_7;
      *(_QWORD *)(v9 + 128) = sub_1CAF0;
      *(_DWORD *)(v9 + 144) = 5459524;
      if ( !*v8 )
        goto LABEL_7;
    }
  }
  else
  {
    mg_error(a1, "DNS server URL is NULL. Call mg_mgr_init()");
    v8 = (__int64 *)(v6 + 16);
    if ( !*(_QWORD *)(v6 + 16) )
    {
LABEL_7:
      v10 = "resolver";
LABEL_13:
      mg_error(a1, v10);
      return;
    }
  }
  v11 = calloc(1uLL, 0x20uLL);
  if ( !v11 )
  {
    v10 = "resolve OOM";
    goto LABEL_13;
  }
  v12 = qword_33510;
  v13 = v11;
  if ( qword_33510 )
    v14 = *(_WORD *)(qword_33510 + 24) + 1;
  else
    v14 = 1;
  v11[12] = v14;
  *(_QWORD *)v11 = v12;
  qword_33510 = (__int64)v11;
  clock_gettime(0, (struct timespec *)&v16);
  v15 = 1000 * v16 + a3 + v17 / 1000000;
  *((_QWORD *)v13 + 1) = a1;
  *((_QWORD *)v13 + 2) = v15;
  *(_WORD *)(a1 + 208) |= 8u;
  if ( (mg_log_prefix(
          4,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x17Au,
          "mg_sendnsreq") & 1) != 0 )
    mg_log("%lu resolving %.*s, txnid %hu");
  mg_dns_send(*v8, (__int64 *)a2, (unsigned __int16)v13[12], 0);
}
// 33510: using guessed type __int64 qword_33510;

//----- (00000000000116DC) ----------------------------------------------------
__int64 __fastcall mg_aton(unsigned __int8 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // x8
  __int64 v7; // x8
  __int64 v8; // x24
  const char *v9; // x25
  unsigned __int8 *v10; // x26
  int v11; // w22
  int v12; // t1
  int v13; // w0
  int v14; // t1
  int v15; // w8
  __int64 result; // x0
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x8
  int v19; // w12
  int v20; // w12
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x14
  unsigned __int64 v23; // x10
  __int64 v24; // x9
  int v25; // w15
  __int64 v26; // x15
  unsigned __int64 v27; // x15
  __int64 v28; // x0
  int v29; // w2
  int v30; // w1
  int v31; // w1
  __int64 v32; // x16
  size_t v33; // x20
  void *v34; // x21
  int v35; // [xsp+Ch] [xbp-44h]

  v3 = 9LL;
  if ( a2 < 9 )
    v3 = a2;
  if ( v3 )
  {
    if ( a2 != 9 && ~a2 >= 0xFFFFFFFFFFFFFFF6LL )
      v7 = ~a2;
    else
      v7 = -10LL;
    v8 = v7 + 1;
    v9 = "localhost";
    v10 = a1;
    while ( 1 )
    {
      v12 = *v10++;
      v11 = v12;
      v13 = tolower(v12);
      v14 = *(unsigned __int8 *)v9++;
      if ( v13 != tolower(v14) )
        break;
      if ( v11 )
      {
        if ( ++v8 )
          continue;
      }
      goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    if ( (_DWORD)a2 == 9 )
    {
      v15 = 16777343;
LABEL_13:
      *(_BYTE *)(a3 + 24) = 0;
      *(_DWORD *)(a3 + 4) = v15;
      return 1LL;
    }
  }
  v35 = 0;
  if ( a2 )
  {
    v17 = 0LL;
    v18 = 0LL;
    do
    {
      v19 = a1[v18];
      if ( (unsigned int)(v19 - 48) > 9 )
      {
        if ( v19 != 46 || v17 > 2 || !v18 || a1[v18 - 1] == 46 )
          goto LABEL_27;
        ++v17;
      }
      else
      {
        v20 = v19 + 10 * *((unsigned __int8 *)&v35 + v17) - 48;
        if ( v20 > 255 )
          goto LABEL_27;
        *((_BYTE *)&v35 + v17) = v20;
      }
      ++v18;
    }
    while ( v18 < a2 );
    if ( v17 != 3 || a1[v18 - 1] == 46 )
    {
LABEL_27:
      v21 = 0LL;
      v22 = 0LL;
      v23 = 0LL;
      v24 = 42LL;
      while ( 1 )
      {
        while ( 1 )
        {
          v25 = a1[v23];
          if ( (unsigned int)(v25 - 48) >= 0xA )
          {
            v26 = (unsigned int)(v25 - 58);
            result = 0LL;
            if ( (unsigned int)v26 > 0x2C )
              return result;
            if ( ((1LL << v26) & 0x1F8000001F80LL) == 0 )
              break;
          }
          if ( v23 > v22 + 3 )
            return 0LL;
          if ( (_DWORD)v23 - (_DWORD)v22 == -1 )
          {
            LOWORD(v28) = 0;
          }
          else
          {
            v27 = 0LL;
            v28 = 0LL;
            do
            {
              v29 = a1[v22 + v27];
              if ( v27 )
                v28 *= 16LL;
              v30 = v29 - 48;
              if ( (unsigned int)(v29 - 48) > 9 )
              {
                if ( (unsigned int)(v29 - 65) >= 6 )
                  v31 = -87;
                else
                  v31 = -55;
                v30 = v31 + v29;
              }
              ++v27;
              v28 |= v30;
            }
            while ( v27 < (int)v23 - (int)v22 + 1 );
          }
          v32 = a3 + v21;
          *(_BYTE *)(v32 + 8) = BYTE1(v28);
          *(_BYTE *)(v32 + 9) = v28;
          if ( ++v23 >= a2 )
            goto LABEL_59;
        }
        if ( v26 )
          return result;
        if ( !v23 || a1[v23 - 1] != 58 )
          break;
        if ( v23 >= 2 )
        {
          v24 = v21;
          if ( a1[v23 - 2] == 58 )
            return 0LL;
LABEL_54:
          if ( v21 > 0xE )
            return 0LL;
          goto LABEL_55;
        }
        v24 = v21;
LABEL_55:
        ++v23;
        *(_WORD *)(a3 + v21 + 8) = 0;
        v22 = v23;
        if ( v23 >= a2 )
          goto LABEL_59;
      }
      if ( v23 )
        v21 += 2LL;
      goto LABEL_54;
    }
    v15 = v35;
    goto LABEL_13;
  }
  v21 = 0LL;
  v24 = 42LL;
LABEL_59:
  if ( v21 <= 0xD && v24 == 42 )
    return 0LL;
  if ( v21 <= 0xD )
  {
    v33 = 14 - v21;
    v34 = (void *)(a3 + 8 + v24);
    memmove((void *)(a3 + 8 + v24 + 14 - v21), v34, v21 + 2 - v24);
    memset(v34, 0, v33);
  }
  result = 1LL;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}
// 1195C: conditional instruction was optimized away because x8.8<Fu

//----- (00000000000119F0) ----------------------------------------------------
void __fastcall mg_connect_resolved(__int64 a1)
{
  __int16 v2; // w23
  int v3; // w10
  __int64 v4; // x0
  int v5; // w20
  const char *v6; // x21
  __int64 v7; // x0
  int v8; // w20
  int v9; // w0
  void (__fastcall *v10)(__int64, __int64, _QWORD, _QWORD); // x8
  void (__fastcall *v11)(__int64, __int64, _QWORD, _QWORD); // x8
  __int64 v12; // x0
  int v13; // w2
  char s[40]; // [xsp+8h] [xbp-C8h] BYREF
  struct sockaddr addr; // [xsp+30h] [xbp-A0h] BYREF
  __int64 v16; // [xsp+98h] [xbp-38h]

  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *(_WORD *)(a1 + 208);
  v3 = *(unsigned __int8 *)(a1 + 40);
  v4 = a1 + 16;
  if ( (v2 & 0x80) != 0 )
    v5 = 2;
  else
    v5 = 1;
  if ( v3 )
    v6 = "[%s]:%d";
  else
    v6 = "%s:%d";
  mg_ntoa(v4, (char *)&addr, 0x64uLL);
  snprintf(s, 0x28uLL, v6, &addr, bswap32(*(unsigned __int16 *)(a1 + 16)) >> 16);
  v7 = socket(2, v5, 0);
  v8 = v7;
  *(_QWORD *)(a1 + 48) = (int)v7;
  if ( (_DWORD)v7 == -1 )
  {
    __errno(v7);
    mg_error(a1, "socket(): %d");
  }
  else
  {
    v9 = fcntl(v7, 3, 0LL);
    fcntl(v8, 4, v9 | 0x800u);
    v10 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(a1 + 128);
    if ( v10 )
      v10(a1, 2LL, 0LL, *(_QWORD *)(a1 + 136));
    v11 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(a1 + 112);
    if ( v11 )
      v11(a1, 2LL, 0LL, *(_QWORD *)(a1 + 120));
    if ( (v2 & 0x80) == 0 )
    {
      *(_QWORD *)&addr.sa_family = ((unsigned __int64)*(unsigned int *)(a1 + 20) << 32) | ((unsigned __int64)*(unsigned __int16 *)(a1 + 16) << 16) | 2;
      *(_QWORD *)&addr.sa_data[6] = 0LL;
      v12 = connect(*(_DWORD *)(a1 + 48), &addr, 0x10u);
      if ( (v12 & 0x80000000) != 0 )
      {
        v13 = *(_DWORD *)__errno(v12);
        if ( v13 == 11 || v13 == 115 || (v13 | 4) == 4 )
          sub_1A09C(a1);
        else
          mg_error(a1, "connect: %d");
        *(_WORD *)(a1 + 208) |= 0x10u;
      }
      else
      {
        sub_1A09C(a1);
      }
    }
  }
}
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);
// 119F0: using guessed type char s[40];

//----- (0000000000011BC0) ----------------------------------------------------
__int64 __fastcall mg_call(__int64 result, unsigned int a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, _QWORD, __int64, _QWORD); // x8
  __int64 v5; // x20
  __int64 (__fastcall *v7)(__int64, _QWORD, __int64, _QWORD); // x4

  v3 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(result + 128);
  v5 = result;
  if ( v3 )
    result = v3(result, a2, a3, *(_QWORD *)(result + 136));
  v7 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(v5 + 112);
  if ( v7 )
    return v7(v5, a2, a3, *(_QWORD *)(v5 + 120));
  return result;
}

//----- (0000000000011C30) ----------------------------------------------------
void mg_error(__int64 a1, const char *a2, ...)
{
  char *v3; // x20
  void (__fastcall *v4)(__int64, _QWORD, char *, _QWORD); // x8
  void (__fastcall *v5)(__int64, _QWORD, char *, _QWORD); // x8
  gcc_va_list va1; // [xsp+B0h] [xbp-170h] BYREF
  gcc_va_list va; // [xsp+D0h] [xbp-150h] BYREF
  char *v8; // [xsp+F0h] [xbp-130h] BYREF
  char v9[256]; // [xsp+F8h] [xbp-128h] BYREF
  __int64 v10; // [xsp+1F8h] [xbp-28h]

  va_start(va, a2);
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = v9;
  va_copy(va1, va);
  mg_vasprintf(&v8, 0x100uLL, a2, (__int128 *)va1);
  if ( (mg_log_prefix(
          1,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x19Cu,
          "mg_error") & 1) == 0 )
  {
    v3 = v8;
    v4 = *(void (__fastcall **)(__int64, _QWORD, char *, _QWORD))(a1 + 128);
    if ( !v4 )
      goto LABEL_6;
    goto LABEL_5;
  }
  v3 = v8;
  mg_log("%lu %s");
  v4 = *(void (__fastcall **)(__int64, _QWORD, char *, _QWORD))(a1 + 128);
  if ( v4 )
LABEL_5:
    v4(a1, 0LL, v3, *(_QWORD *)(a1 + 136));
LABEL_6:
  v5 = *(void (__fastcall **)(__int64, _QWORD, char *, _QWORD))(a1 + 112);
  if ( v5 )
    v5(a1, 0LL, v3, *(_QWORD *)(a1 + 120));
  if ( v3 != v9 )
    free(v3);
  *(_WORD *)(a1 + 208) |= 0x800u;
}

//----- (0000000000011D84) ----------------------------------------------------
__int64 __fastcall mg_vasprintf(char **a1, size_t a2, const char *a3, __int128 *a4)
{
  __int128 v7; // q0
  size_t v8; // x22
  char *v9; // x0
  __int64 result; // x0
  size_t v11; // x22
  char *v12; // x0
  __int128 v13; // q0
  char *v14; // x0
  char *v15; // x8
  char *v16; // x0
  __int128 v17; // q0
  char *v18; // x0
  __int128 v19[2]; // [xsp+0h] [xbp-C0h] BYREF
  __int128 v20[2]; // [xsp+20h] [xbp-A0h] BYREF
  __int128 arg[2]; // [xsp+40h] [xbp-80h] BYREF
  __int128 v22; // [xsp+60h] [xbp-60h]
  __int128 v23; // [xsp+70h] [xbp-50h]
  __int64 v24; // [xsp+88h] [xbp-38h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a4[1];
  v8 = a2;
  v22 = *a4;
  v23 = v7;
  v9 = *a1;
  arg[0] = v22;
  arg[1] = v7;
  result = vsnprintf(v9, a2, a3, arg);
  if ( (result & 0x80000000) != 0 )
  {
    v15 = 0LL;
    *a1 = 0LL;
    while ( 1 )
    {
      free(v15);
      if ( v8 )
        v8 *= 2LL;
      else
        v8 = 10LL;
      v16 = (char *)malloc(v8);
      *a1 = v16;
      if ( !v16 )
        break;
      v17 = a4[1];
      v22 = *a4;
      v23 = v17;
      v18 = *a1;
      v20[0] = v22;
      v20[1] = v17;
      result = vsnprintf(v18, v8 - 1, a3, v20);
      v15 = *a1;
      if ( (result & 0x80000000) == 0 )
      {
        if ( v15 )
          v15[(int)result] = 0;
        return result;
      }
    }
  }
  else
  {
    if ( (int)result < (int)v8 )
      return result;
    v11 = (int)result + 1;
    v12 = (char *)malloc(v11);
    *a1 = v12;
    if ( v12 )
    {
      v13 = a4[1];
      v22 = *a4;
      v23 = v13;
      v14 = *a1;
      v19[0] = v22;
      v19[1] = v13;
      return vsnprintf(v14, v11, a3, v19);
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000011EB0) ----------------------------------------------------
__int64 __fastcall mg_log_prefix(int a1, const char *a2, unsigned int a3, const char *a4)
{
  const char *v7; // x26
  int v9; // w23
  char *v10; // x0
  int v11; // w24
  const char *v12; // x25
  __int64 v13; // x8
  __int64 v14; // x19
  unsigned __int64 v15; // x9
  __int64 v16; // x10
  __int64 v17; // x10
  int v18; // w8
  struct tm *v20; // x0
  unsigned int v21; // w8
  __int64 v22; // x4
  unsigned int v23; // w0
  int v24; // w8
  char *v25; // x8
  int v26; // w9
  const char *v27; // [xsp+0h] [xbp-C0h]
  time_t timer; // [xsp+8h] [xbp-B8h] BYREF
  char v29[16]; // [xsp+10h] [xbp-B0h] BYREF
  __int128 v30; // [xsp+20h] [xbp-A0h]
  __int128 v31; // [xsp+30h] [xbp-90h]
  __int16 v32; // [xsp+40h] [xbp-80h]
  char s[24]; // [xsp+50h] [xbp-70h] BYREF
  __int64 v34; // [xsp+68h] [xbp-58h]

  v34 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = (const char *)off_331D8;
  if ( off_331D8 )
    v9 = strlen((const char *)off_331D8);
  else
    v9 = 0;
  v10 = strrchr(a2, 47);
  if ( v10 )
    a2 = v10 + 1;
  if ( !off_331E0 )
    return 0LL;
  v11 = 2;
  v27 = a4;
  while ( 1 )
  {
    v12 = v7;
    if ( v9 < 1 )
    {
      v14 = 0LL;
      LODWORD(v13) = 0;
LABEL_22:
      LODWORD(v15) = 0;
LABEL_23:
      v17 = 0LL;
    }
    else
    {
      v13 = 0LL;
      while ( v7[v13] != 44 )
      {
        if ( ++v13 >= v9 )
          goto LABEL_16;
      }
      if ( !(_DWORD)v13 )
      {
        v14 = 0LL;
        goto LABEL_22;
      }
LABEL_16:
      v15 = 0LL;
      v16 = 0x100000000LL;
      while ( v7[v15] != 61 )
      {
        ++v15;
        v16 += 0x100000000LL;
        if ( v15 >= (unsigned int)v13 )
        {
          v14 = 0LL;
          goto LABEL_23;
        }
      }
      v14 = v16 >> 32;
      v17 = (int)v13 - 1 - (int)v15;
    }
    v18 = v9 >= 1 ? v13 + 1 : v9;
    if ( v18 < 1 )
      break;
    v7 += v18;
    v9 -= v18;
    if ( !v17 )
      goto LABEL_8;
    if ( !strncmp(a2, v12, (int)v15) )
    {
      v12 += v14;
LABEL_8:
      v11 = atoi(v12);
    }
  }
  if ( v11 < a1 )
    return 0LL;
  v32 = 0;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)v29 = 0u;
  timer = time(0LL);
  v20 = gmtime(&timer);
  strftime(s, 0x15uLL, "%Y-%m-%d %H:%M:%S", v20);
  if ( a1 == 2 )
    v21 = 73;
  else
    v21 = 32;
  if ( a1 == 1 )
    v22 = 69LL;
  else
    v22 = v21;
  v23 = snprintf(v29, 0x32uLL, "%s  %c %s:%d:%s", s, v22, a2, a3, v27);
  if ( v23 >= 0x30 )
    v24 = 48;
  else
    v24 = v23;
  v25 = &v29[v24];
  if ( v23 >= 0x30 )
    v26 = 48;
  else
    v26 = v23;
  memset(v25, 32, (unsigned int)(49 - v26));
  off_331E0(v29, 49);
  return 1LL;
}
// 120B4: conditional instruction was optimized away because w8.4<31u
// 331D8: using guessed type void *off_331D8;
// 331E0: using guessed type size_t (__fastcall *off_331E0)(const void *a1, int a2);
// 33518: using guessed type __int64 qword_33518;

//----- (000000000001212C) ----------------------------------------------------
void mg_log(const char *a1, ...)
{
  int v1; // w0
  char *v2; // x19
  gcc_va_list va1; // [xsp+C0h] [xbp-180h] BYREF
  gcc_va_list va; // [xsp+E0h] [xbp-160h] BYREF
  char *v5; // [xsp+100h] [xbp-140h] BYREF
  char v6[256]; // [xsp+108h] [xbp-138h] BYREF
  __int64 v7; // [xsp+208h] [xbp-38h]

  va_start(va, a1);
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = v6;
  va_copy(va1, va);
  v1 = mg_vasprintf(&v5, 0x100uLL, a1, (__int128 *)va1);
  v2 = v5;
  off_331E0(v5, v1);
  off_331E0("\n", 1);
  if ( v2 != v6 )
    free(v2);
}
// 331E0: using guessed type size_t (__fastcall *off_331E0)(const void *a1, int a2);
// 33518: using guessed type __int64 qword_33518;

//----- (0000000000012230) ----------------------------------------------------
void __fastcall mg_http_bauth(_QWORD *a1, char *s, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // x20
  unsigned __int8 *v4; // x23
  size_t v6; // x24
  size_t v7; // x21
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x22
  void *v10; // x8
  __int64 v11; // x22
  int v12; // w2
  unsigned __int8 v13; // t1
  __int64 v14; // x1
  unsigned int v15; // w8
  unsigned int v16; // w8
  char v17; // w8
  __int64 v18; // x2
  char v19; // w8
  unsigned __int8 v20; // t1
  int v21; // w0
  __int64 v22; // x9
  __int64 v23; // x8

  v3 = a3;
  v4 = (unsigned __int8 *)s;
  if ( s )
  {
    v6 = strlen(s);
    if ( v3 )
    {
LABEL_3:
      v7 = strlen((const char *)v3);
      goto LABEL_6;
    }
  }
  else
  {
    v6 = 0LL;
    if ( a3 )
      goto LABEL_3;
  }
  v7 = 0LL;
LABEL_6:
  v8 = a1[12];
  v9 = a1[13] + 2 * (v7 + v6) + 36;
  if ( v8 < v9 )
  {
    mg_iobuf_resize((__int64)(a1 + 11), a1[13] + 2 * (v7 + v6) + 36);
    v8 = a1[12];
  }
  if ( v8 >= v9 )
  {
    v10 = (void *)(a1[11] + a1[13]);
    v11 = (__int64)v10 + 21;
    qmemcpy(v10, "Authorization: Basic ", 21);
    if ( v6 )
    {
      v12 = 0;
      do
      {
        v13 = *v4++;
        --v6;
        v12 = mg_base64_update(v13, v11, v12);
      }
      while ( v6 );
      v14 = v12;
      if ( !v7 )
        goto LABEL_40;
    }
    else
    {
      v14 = 0LL;
      if ( !v7 )
      {
LABEL_40:
        v21 = mg_base64_final(v11, v14);
        v22 = a1[11];
        v23 = a1[13] + v21 + 23LL;
        a1[13] = v23;
        *(_WORD *)(v22 + v23 - 2) = 2573;
        return;
      }
    }
    if ( (v14 & 3) == ((((unsigned __int8)v14 & 3u) / 3) & 0xFFFFFFFD | (2 * ((((unsigned __int8)v14 & 3u) / 3) & 1))) )
    {
      *(_BYTE *)(v11 + v14) = 79;
      v18 = (int)v14 + 1LL;
      *(_BYTE *)(v11 + v18) = 32;
    }
    else
    {
      v15 = *(unsigned __int8 *)(v11 + v14);
      if ( (unsigned __int8)((v14 & 3)
                           - ((((unsigned __int8)v14 & 3u) / 3) & 0xFD | (2 * ((((unsigned __int8)v14 & 3u) / 3) & 1)))) == 1 )
      {
        v16 = v15 | 3;
        if ( v16 > 0x19 )
        {
          if ( v16 > 0x33 )
          {
            if ( v16 >= 0x3E )
              v17 = 47;
            else
              v17 = v16 - 4;
          }
          else
          {
            v17 = v16 + 71;
          }
        }
        else
        {
          v17 = v16 + 65;
        }
        *(_BYTE *)(v11 + v14) = v17;
        v18 = (int)v14 + 1LL;
        *(_BYTE *)(v11 + v18) = 40;
      }
      else
      {
        if ( v15 > 0x19 )
        {
          if ( v15 > 0x33 )
          {
            if ( v15 > 0x3D )
            {
              if ( v15 == 62 )
                v19 = 43;
              else
                v19 = 47;
            }
            else
            {
              v19 = v15 - 4;
            }
          }
          else
          {
            v19 = v15 + 71;
          }
        }
        else
        {
          v19 = v15 + 65;
        }
        *(_BYTE *)(v11 + v14) = v19;
        LODWORD(v18) = v14 + 2;
        *(_BYTE *)(v11 + (((v14 << 32) + 0x100000000LL) >> 32)) = 54;
      }
    }
    do
    {
      v20 = *v3++;
      --v7;
      LODWORD(v18) = mg_base64_update(v20, v11, v18);
    }
    while ( v7 );
    LODWORD(v14) = v18;
    goto LABEL_40;
  }
  if ( (mg_log_prefix(
          1,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x1C6u,
          "mg_http_bauth") & 1) != 0 )
    mg_log("%lu %s cannot resize iobuf %d->%d ");
}

//----- (00000000000124A4) ----------------------------------------------------
char *__fastcall mg_str(char *s)
{
  if ( s )
    strlen(s);
  return s;
}

//----- (00000000000124DC) ----------------------------------------------------
__int64 __fastcall mg_iobuf_resize(__int64 a1, size_t size)
{
  size_t v3; // x23
  void *v6; // x0
  void *v7; // x22
  size_t v8; // x2
  void *v9; // x21

  if ( size )
  {
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 == size )
    {
      return 1LL;
    }
    else
    {
      v6 = malloc(size);
      if ( v6 )
      {
        v7 = *(void **)a1;
        if ( v3 >= size )
          v8 = size;
        else
          v8 = v3;
        v9 = v6;
        memcpy(v6, *(const void **)a1, v8);
        free(v7);
        *(_QWORD *)a1 = v9;
        *(_QWORD *)(a1 + 8) = size;
        return 1LL;
      }
      else
      {
        if ( (mg_log_prefix(
                1,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0x4FDu,
                "mg_iobuf_resize") & 1) != 0 )
          mg_log("%lu->%lu");
        return 0LL;
      }
    }
  }
  else
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    return 1LL;
  }
}

//----- (00000000000125AC) ----------------------------------------------------
__int64 __fastcall mg_http_get_var(__int64 *a1, char *s, _BYTE *a3, int a4)
{
  __int64 result; // x0
  __int64 v9; // x24
  __int64 v10; // x25
  size_t v11; // x0
  __int64 v12; // x26
  unsigned __int64 v13; // x25
  _BYTE *v14; // x8
  size_t v15; // x22
  __int64 v16; // x27
  __int64 v17; // x28
  int v18; // w23
  int v19; // w24
  const void *v20; // x21
  _BYTE *v21; // x0
  _BYTE *v22; // x8

  result = 4294967294LL;
  if ( !a3 || !a4 )
    return result;
  if ( !s || (v9 = *a1) == 0 || (v10 = a1[1]) == 0 )
  {
    *a3 = 0;
    return 0xFFFFFFFFLL;
  }
  v11 = strlen(s);
  *a3 = 0;
  v12 = *a1;
  v13 = v9 + v10;
  v14 = (_BYTE *)(*a1 + v11);
  if ( (unsigned __int64)v14 >= v13 )
    return 4294967292LL;
  v15 = v11;
  v16 = *a1;
  while ( v16 != v12 && *(_BYTE *)(v16 - 1) != 38 || *v14 != 61 )
  {
LABEL_17:
    v14 = (_BYTE *)(++v16 + v15);
    result = 4294967292LL;
    if ( v16 + v15 >= v13 )
      return result;
  }
  if ( v15 )
  {
    v17 = 0LL;
    while ( 1 )
    {
      v18 = (unsigned __int8)s[v17];
      v19 = tolower(v18);
      if ( v19 != tolower(*(unsigned __int8 *)(v16 + v17)) )
        goto LABEL_17;
      if ( v18 )
      {
        if ( v15 != ++v17 )
          continue;
      }
      break;
    }
  }
  v20 = (const void *)(v16 + v15 + 1);
  v21 = memchr(v20, 38, v13 - (_QWORD)v20);
  if ( v21 )
    v22 = v21;
  else
    v22 = (_BYTE *)v13;
  LODWORD(result) = mg_url_decode(v16 + v15 + 1, v22 - (_BYTE *)v20, (__int64)a3, a4, 1);
  if ( (int)result >= 0 )
    return (unsigned int)result;
  else
    return 4294967293LL;
}

//----- (000000000001270C) ----------------------------------------------------
__int64 __fastcall mg_ncasecmp(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // x19
  int v6; // w22
  int v7; // t1
  int v8; // w0
  int v9; // t1
  __int64 result; // x0

  if ( !a3 )
    return 0LL;
  v3 = a3;
  while ( 1 )
  {
    v7 = *a1++;
    v6 = v7;
    v8 = tolower(v7);
    v9 = *a2++;
    result = (unsigned int)(v8 - tolower(v9));
    if ( (_DWORD)result )
      break;
    if ( v6 )
    {
      if ( --v3 )
        continue;
    }
    return 0LL;
  }
  return result;
}

//----- (0000000000012778) ----------------------------------------------------
__int64 __fastcall mg_url_decode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, int a5)
{
  unsigned __int64 v10; // x26
  unsigned __int64 v11; // x27
  unsigned __int64 v12; // x28
  __int64 v13; // x24
  int v14; // w8
  int v15; // w25
  int v16; // w24
  char v17; // w8
  char v18; // w8
  char v19; // w9
  char v20; // w8
  char v21; // w9
  char v22; // w8

  if ( a2 )
  {
    v10 = 0LL;
    v11 = 0LL;
    while ( 1 )
    {
      v12 = v10++;
      if ( v10 >= a4 )
        break;
      v13 = a1 + v11;
      v14 = *(unsigned __int8 *)(a1 + v11);
      if ( v14 == 37 )
      {
        v11 += 2LL;
        if ( v11 >= a2 )
          return 0xFFFFFFFFLL;
        v15 = *(unsigned __int8 *)(v13 + 1);
        if ( !isxdigit(v15) )
          return 0xFFFFFFFFLL;
        v16 = *(unsigned __int8 *)(v13 + 2);
        if ( !isxdigit(v16) )
          return 0xFFFFFFFFLL;
        v17 = v15 - 48;
        if ( (unsigned int)(v15 - 48) >= 0xA )
        {
          if ( (unsigned int)(v15 - 65) >= 6 )
            v18 = -87;
          else
            v18 = -55;
          v17 = v18 + v15;
        }
        v19 = v16 - 48;
        v20 = 16 * v17;
        if ( (unsigned int)(v16 - 48) >= 0xA )
        {
          if ( (unsigned int)(v16 - 65) >= 6 )
            v21 = -87;
          else
            v21 = -55;
          v19 = v21 + v16;
        }
        LOBYTE(v14) = v19 | v20;
      }
      else if ( a5 && v14 == 43 )
      {
        LOBYTE(v14) = 32;
      }
      ++v11;
      *(_BYTE *)(a3 + v12) = v14;
      if ( v11 >= a2 )
      {
        v22 = 0;
        v12 = v10;
        if ( v10 < a4 )
          goto LABEL_26;
        goto LABEL_27;
      }
    }
    v22 = 1;
    if ( v12 < a4 )
      goto LABEL_26;
  }
  else
  {
    v12 = 0LL;
    v22 = 0;
    if ( a4 )
LABEL_26:
      *(_BYTE *)(a3 + v12) = 0;
  }
LABEL_27:
  if ( (v22 & 1) != 0 )
    return 0xFFFFFFFFLL;
  if ( v12 >= a4 )
    return 0xFFFFFFFFLL;
  return (unsigned int)v12;
}

//----- (00000000000128DC) ----------------------------------------------------
unsigned __int64 __fastcall mg_unhex(unsigned __int64 result, int a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x9
  _BYTE *v6; // x10
  int v7; // w14
  char v8; // w13
  char v9; // w13
  int v10; // w15
  char v11; // w13
  char v12; // w14
  char v13; // w14
  unsigned __int64 v14; // x11
  __int64 v15; // x12
  int8x16_t v16; // q0
  uint8x16_t v17; // q1
  int8x16_t v18; // q2
  int8x16_t v19; // q3
  uint8x16_t v20; // q4
  int8x16_t v21; // q5
  int8x16_t v22; // q6
  const char *v23; // x13
  __int64 v24; // x14
  int8x16x2_t v25; // 0:q16.16,16:q17.16

  if ( a2 >= 1 )
  {
    v3 = a2 - 1LL;
    v4 = (v3 >> 1) + 1;
    if ( v4 >= 0x10 && (result + ((a2 + 1LL) & 0xFFFFFFFFFFFFFFFELL) <= a3 || a3 + (v3 >> 1) + 1 <= result) )
    {
      v14 = v4 & 0xFFFFFFFFFFFFFFF0LL;
      v15 = 0LL;
      v16.n128_u64[0] = 0xD0D0D0D0D0D0D0D0LL;
      v16.n128_u64[1] = 0xD0D0D0D0D0D0D0D0LL;
      v17.n128_u64[0] = 0xA0A0A0A0A0A0A0ALL;
      v17.n128_u64[1] = 0xA0A0A0A0A0A0A0ALL;
      v18.n128_u64[0] = 0x909090909090909LL;
      v18.n128_u64[1] = 0x909090909090909LL;
      v19.n128_u64[0] = 0xBFBFBFBFBFBFBFBFLL;
      v19.n128_u64[1] = 0xBFBFBFBFBFBFBFBFLL;
      v20.n128_u64[0] = 0x606060606060606LL;
      v20.n128_u64[1] = 0x606060606060606LL;
      v21.n128_u64[0] = 0xA9A9A9A9A9A9A9A9LL;
      v21.n128_u64[1] = 0xA9A9A9A9A9A9A9A9LL;
      v5 = 2 * (v4 & 0xFFFFFFFFFFFFFFF0LL);
      v22.n128_u64[0] = 0xC9C9C9C9C9C9C9C9LL;
      v22.n128_u64[1] = 0xC9C9C9C9C9C9C9C9LL;
      v23 = (const char *)result;
      do
      {
        v25 = vld2q_s8(v23);
        v23 += 32;
        v24 = v15 & 0x7FFFFFFFFFFFFFF0LL;
        v15 += 16LL;
        *(int8x16_t *)(a3 + v24) = vorrq_s8(
                                     vshlq_n_s8(
                                       vaddq_s8(v25.val[0], vbicq_s8(v18, vcgtq_u8(v17, vaddq_s8(v25.val[0], v16)))),
                                       4uLL),
                                     vaddq_s8(
                                       v25.val[1],
                                       vbslq_s8(
                                         vcgtq_u8(vaddq_s8(v25.val[1], v16), v18),
                                         vbslq_s8(vcgtq_u8(v20, vaddq_s8(v25.val[1], v19)), v22, v21),
                                         v16)));
      }
      while ( v14 != v15 );
      if ( v4 == v14 )
        return result;
    }
    else
    {
      v5 = 0LL;
    }
    v6 = (_BYTE *)(a3 + (v5 >> 1));
    do
    {
      v7 = *(unsigned __int8 *)(result + v5);
      v8 = v7 - 48;
      if ( (unsigned int)(v7 - 48) > 9 )
      {
        if ( (unsigned int)(v7 - 65) >= 6 )
          v9 = -87;
        else
          v9 = -55;
        v8 = v9 + v7;
      }
      v10 = *(unsigned __int8 *)(result + v5 + 1);
      v11 = 16 * v8;
      v12 = v10 - 48;
      if ( (unsigned int)(v10 - 48) >= 0xA )
      {
        if ( (unsigned int)(v10 - 65) >= 6 )
          v13 = -87;
        else
          v13 = -55;
        v12 = v13 + v10;
      }
      v5 += 2LL;
      *v6++ = v11 | v12;
    }
    while ( (__int64)v5 < a2 );
  }
  return result;
}

//----- (0000000000012A14) ----------------------------------------------------
__int64 __fastcall mg_http_get_request_len(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // x21
  int v5; // w22
  int v6; // w0

  if ( !a2 )
    return 0LL;
  v4 = 0LL;
  while ( 1 )
  {
    v5 = *(char *)(a1 + v4);
    v6 = isprint(*(unsigned __int8 *)(a1 + v4));
    if ( (v5 & 0x80000000) == 0 && v5 != 10 && v5 != 13 && !v6 )
      return 0xFFFFFFFFLL;
    if ( v4
      && v5 == 10
      && (*(_BYTE *)(a1 + v4 - 1) == 10 || v4 >= 4 && *(_BYTE *)(a1 + v4 - 1) == 13 && *(_BYTE *)(a1 + v4 - 2) == 10) )
    {
      break;
    }
    if ( ++v4 >= a2 )
      return 0LL;
  }
  return (unsigned int)(v4 + 1);
}
// 12A80: conditional instruction was optimized away because w22.4==A

//----- (0000000000012AD0) ----------------------------------------------------
__int64 __fastcall mg_http_get_header(__int64 a1, char *s)
{
  size_t v4; // x21
  __int64 v5; // x24
  __int64 v6; // x8
  unsigned __int8 *v7; // x25
  char *v8; // x26
  size_t v9; // x27
  int v10; // w22
  int v11; // t1
  int v12; // w0
  int v13; // t1

  v4 = strlen(s);
  v5 = 0LL;
  while ( 1 )
  {
    v6 = *(_QWORD *)(a1 + 32 * v5 + 72);
    if ( !v6 )
      return 0LL;
    if ( v4 == v6 )
      break;
LABEL_10:
    if ( (unsigned __int64)++v5 >= 0x28 )
      return 0LL;
  }
  if ( v4 )
  {
    v7 = *(unsigned __int8 **)(a1 + 32 * v5 + 64);
    v8 = s;
    v9 = v4;
    while ( 1 )
    {
      v11 = *v7++;
      v10 = v11;
      v12 = tolower(v11);
      v13 = (unsigned __int8)*v8++;
      if ( v12 != tolower(v13) )
        break;
      if ( v10 )
      {
        if ( --v9 )
          continue;
      }
      return a1 + 32 * v5 + 80;
    }
    goto LABEL_10;
  }
  return a1 + 32 * v5 + 80;
}

//----- (0000000000012B98) ----------------------------------------------------
unsigned __int64 __fastcall mg_http_parse_headers(unsigned __int64 result, unsigned __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  __int64 v5; // x10
  unsigned __int8 *v6; // x14
  unsigned __int8 *v7; // x15
  unsigned int v8; // w15
  unsigned __int64 v9; // x16
  unsigned __int8 *v10; // x17
  unsigned __int8 *v11; // x16
  __int64 v12; // x16
  unsigned __int64 v13; // x3
  unsigned __int8 *v14; // x3
  unsigned __int8 *v15; // x4
  unsigned int v16; // w4
  unsigned __int8 *v17; // x17
  unsigned __int8 *i; // x14
  unsigned __int64 v19; // x5
  unsigned __int64 v20; // x15
  unsigned __int64 v21; // x14
  unsigned __int64 *v23; // x15

  if ( a4 >= 1 )
  {
    v4 = 0LL;
    v5 = a4;
    while ( 1 )
    {
      v6 = (unsigned __int8 *)result;
      v7 = (unsigned __int8 *)result;
      if ( result >= a2 )
        goto LABEL_12;
      v6 = (unsigned __int8 *)result;
      do
      {
        v8 = *v6;
        if ( v8 == 10 || v8 <= 0xF && ((1 << v8) & 0x401) != 0 )
          break;
        ++v6;
      }
      while ( (unsigned __int64)v6 < a2 );
      v7 = v6;
      if ( (unsigned __int64)v6 < a2 )
        break;
LABEL_15:
      v10 = (unsigned __int8 *)result;
      v11 = (unsigned __int8 *)result;
      if ( result >= (unsigned __int64)v7 )
        goto LABEL_24;
      v10 = (unsigned __int8 *)result;
      do
      {
        v12 = *v10;
        if ( v12 == 10 || (unsigned int)v12 <= 0x3F && ((1LL << v12) & 0x400000100002401LL) != 0 )
          break;
        ++v10;
      }
      while ( v10 < v7 );
      v11 = v10;
      while ( v11 < v7 )
      {
        v13 = *v11;
        if ( v13 > 0x3F || ((1LL << v13) & 0x400000100002401LL) == 0 )
          break;
        ++v11;
LABEL_24:
        ;
      }
      v14 = v11;
      v15 = v11;
      if ( v11 < v7 )
      {
        v14 = v11;
        do
        {
          v16 = *v14;
          if ( v16 == 10 || v16 <= 0xF && ((1 << v16) & 0x2401) != 0 )
            break;
          ++v14;
        }
        while ( v14 < v7 );
        v15 = v14;
      }
      v17 = &v10[-result];
      for ( i = &v6[-result]; v15 < v7; ++v15 )
      {
        v19 = *v15;
        if ( v19 > 0xF )
          break;
        if ( ((1 << v19) & 0x2401) == 0 )
          break;
      }
      if ( v17 != i )
      {
        v20 = v14 - v11;
        do
        {
          v21 = v20;
          if ( !v20 )
            break;
        }
        while ( v11[--v20] == 32 );
        if ( !v17 )
          return result;
        v23 = (unsigned __int64 *)(a3 + 32 * v4);
        *v23 = result;
        v23[1] = (unsigned __int64)v17;
        v23[2] = (unsigned __int64)v11;
        v23[3] = v21;
      }
      ++v4;
      result = (unsigned __int64)v15;
      if ( v4 >= v5 )
        return result;
    }
    while ( 1 )
    {
      v9 = *v7;
      if ( v9 > 0xF || ((1 << v9) & 0x401) == 0 )
        goto LABEL_15;
      ++v7;
LABEL_12:
      if ( (unsigned __int64)v7 >= a2 )
        goto LABEL_15;
    }
  }
  return result;
}

//----- (0000000000012D6C) ----------------------------------------------------
__int64 __fastcall mg_http_parse(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *s)
{
  unsigned __int64 v6; // x21
  int v7; // w23
  int v8; // w0
  int v9; // w8
  unsigned int v10; // w24
  unsigned int v12; // w25
  unsigned __int64 v13; // x27
  unsigned __int64 v14; // x20
  unsigned __int8 *v15; // x21
  __int64 v16; // x9
  unsigned __int8 *v17; // x8
  unsigned __int64 v18; // x10
  unsigned __int8 *v19; // x9
  __int64 v20; // x11
  size_t v21; // x22
  unsigned __int64 v22; // x11
  unsigned __int8 *v23; // x23
  unsigned int v24; // w12
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x12
  _BYTE *v27; // x0
  unsigned __int64 i; // x22
  char *v29; // x9
  __int64 v30; // x8
  __int64 v31; // x24
  __int64 v32; // x26
  int v33; // w20
  int v34; // w21
  unsigned __int64 v35; // x8
  unsigned __int64 v36; // x9
  unsigned __int64 v37; // x11
  __int64 v38; // x10
  int v39; // w12
  __int64 v40; // x12
  __int64 v41; // x14
  unsigned __int8 *v42; // x23
  int v43; // w20
  int v44; // w21
  int v45; // w21
  int v46; // w22
  int v47; // w21
  int v48; // w22
  int v49; // w21
  int v50; // w22
  int v51; // w21
  unsigned __int64 v52; // x22
  __int64 v53; // x8
  unsigned __int8 *v54; // x23
  __int64 v55; // x8
  __int64 v56; // x24
  char *v57; // x26
  int v58; // w20
  int v59; // t1
  int v60; // w0
  int v61; // t1
  unsigned __int64 v62; // x24
  __int64 v63; // x8
  int v64; // w21
  __int64 v65; // x8
  unsigned __int8 *v66; // x27
  __int64 v67; // x28
  char *v68; // x26
  char v69; // w21
  int v70; // t1
  int v71; // w0
  int v72; // t1
  __int64 v73; // x8
  int v74; // w21
  __int64 v75; // x8
  unsigned __int8 *v76; // x22
  __int64 v77; // x23
  char *v78; // x26
  int v79; // t1
  int v80; // w0
  int v81; // t1

  if ( a2 )
  {
    v6 = 0LL;
    while ( 1 )
    {
      v7 = (char)a1[v6];
      v8 = isprint(a1[v6]);
      if ( (v7 & 0x80000000) == 0 && v7 != 10 && v7 != 13 && !v8 )
      {
        v10 = -1;
        goto LABEL_16;
      }
      if ( v6 )
      {
        if ( v7 == 10 )
        {
          v9 = a1[v6 - 1];
          if ( v9 == 10 || v6 >= 4 && v9 == 13 && a1[v6 - 2] == 10 )
            break;
        }
      }
      if ( ++v6 >= a2 )
        goto LABEL_14;
    }
    v12 = v6 + 1;
    memset(s, 0, 0x580uLL);
    if ( (v6 & 0x80000000) != 0 )
      return v12;
    v13 = (int)v12;
    v14 = (unsigned __int64)&a1[v12];
    s[169] = -1LL;
    s[175] = -1LL;
    v15 = a1;
    s[170] = (unsigned __int64)a1;
    s[174] = (unsigned __int64)a1;
    *s = (unsigned __int64)a1;
    s[171] = (int)v12;
    s[168] = v14;
    s[172] = v14;
    do
    {
      v16 = *v15;
      if ( v16 == 10 || (unsigned int)v16 <= 0x3F && ((1LL << v16) & 0x100000001LL) != 0 )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < v14 );
    v17 = (unsigned __int8 *)(v15 - a1);
    for ( s[1] = v15 - a1; (unsigned __int64)v15 < v14; ++v15 )
    {
      v18 = *v15;
      if ( v18 > 0x3F )
        break;
      if ( ((1LL << v18) & 0x100000001LL) == 0 )
        break;
    }
    v19 = v15;
    s[2] = (unsigned __int64)v15;
    if ( (unsigned __int64)v15 < v14 )
    {
      v19 = v15;
      do
      {
        v20 = *v19;
        if ( v20 == 10 || (unsigned int)v20 <= 0x3F && ((1LL << v20) & 0x100000001LL) != 0 )
          break;
        ++v19;
      }
      while ( (unsigned __int64)v19 < v14 );
    }
    v21 = v19 - v15;
    for ( s[3] = v19 - v15; (unsigned __int64)v19 < v14; ++v19 )
    {
      v22 = *v19;
      if ( v22 > 0x3F )
        break;
      if ( ((1LL << v22) & 0x100000001LL) == 0 )
        break;
    }
    v23 = v19;
    s[6] = (unsigned __int64)v19;
    if ( (unsigned __int64)v19 < v14 )
    {
      v23 = v19;
      do
      {
        v24 = *v23;
        if ( v24 == 10 || v24 <= 0xF && ((1 << v24) & 0x2401) != 0 )
          break;
        ++v23;
      }
      while ( (unsigned __int64)v23 < v14 );
    }
    v25 = v23 - v19;
    for ( s[7] = v25; (unsigned __int64)v23 < v14; ++v23 )
    {
      v26 = *v23;
      if ( v26 > 0xF )
        break;
      if ( ((1 << v26) & 0x2401) == 0 )
        break;
    }
    v10 = -1;
    if ( v17 && v21 && v25 )
    {
      v27 = memchr(v15, 63, v21);
      if ( v27 )
      {
        s[3] = v27 - v15;
        s[4] = (unsigned __int64)(v27 + 1);
        s[5] = &v15[v21] - (v27 + 1);
      }
      mg_http_parse_headers((unsigned __int64)v23, v14, (__int64)(s + 8), 40);
      for ( i = 0LL; i < 0x28; ++i )
      {
        v29 = (char *)&s[4 * i];
        v30 = *((_QWORD *)v29 + 9);
        if ( v30 == 14 )
        {
          v31 = *((_QWORD *)v29 + 8);
          v32 = 0LL;
          while ( 1 )
          {
            v33 = *(unsigned __int8 *)(v31 + v32);
            v34 = tolower(v33);
            if ( v34 != tolower((unsigned __int8)aContentLength[v32]) )
              break;
            if ( v33 )
            {
              if ( ++v32 != 14 )
                continue;
            }
            v36 = s[4 * i + 10];
            v35 = s[4 * i + 11];
            v37 = 0LL;
            v38 = 1LL;
            if ( v35 )
            {
              while ( 1 )
              {
                v39 = *(unsigned __int8 *)(v36 + v37);
                if ( v39 != 32 && v39 != 9 )
                  break;
                if ( ++v37 >= v35 )
                  goto LABEL_72;
              }
              v38 = -1LL;
              if ( v39 == 45 )
                ++v37;
              else
                v38 = 1LL;
            }
LABEL_72:
            if ( v37 >= v35 )
            {
              v40 = 0LL;
            }
            else
            {
              v40 = 0LL;
              do
              {
                v41 = *(unsigned __int8 *)(v36 + v37);
                if ( (unsigned __int8)(v41 - 48) > 9u )
                  break;
                ++v37;
                v40 = v41 + 10 * v40 - 48;
              }
              while ( v37 < v35 );
            }
            s[169] = v40 * v38;
            s[175] = v40 * v38 + (int)v12;
            goto LABEL_79;
          }
        }
        else if ( !v30 )
        {
          break;
        }
      }
LABEL_79:
      v42 = (unsigned __int8 *)*s;
      v43 = *(unsigned __int8 *)*s;
      v44 = tolower(v43);
      if ( v44 == tolower(72) )
      {
        if ( !v43
          || (v45 = v42[1], v46 = tolower(v45), v46 == tolower(84))
          && (!v45
           || (v47 = v42[2], v48 = tolower(v47), v48 == tolower(84))
           && (!v47
            || (v49 = v42[3], v50 = tolower(v49), v50 == tolower(80))
            && (!v49 || (v51 = tolower(v42[4]), v51 == tolower(47))))) )
        {
          if ( s[169] != -1LL )
            return v12;
          v52 = s[3];
          v53 = 3LL;
          if ( v52 < 3 )
            v53 = s[3];
          if ( v53 )
          {
            v54 = (unsigned __int8 *)s[2];
            if ( v52 != 3 && ~v52 >= 0xFFFFFFFFFFFFFFFCLL )
              v55 = ~v52;
            else
              v55 = -4LL;
            v56 = v55 + 1;
            v57 = &byte_1DFB3;
            while ( 1 )
            {
              v59 = *v54++;
              v58 = v59;
              v60 = tolower(v59);
              v61 = (unsigned __int8)*v57++;
              if ( v60 != tolower(v61) )
                return v12;
              if ( v58 )
              {
                if ( ++v56 )
                  continue;
              }
              break;
            }
          }
          if ( (_DWORD)v52 != 3 )
            return v12;
          goto LABEL_128;
        }
      }
      if ( s[169] != -1LL )
        return v12;
      v62 = s[1];
      v63 = 3LL;
      if ( v62 < 3 )
        v63 = s[1];
      if ( v63 )
      {
        v64 = tolower(v43);
        if ( v64 != tolower(80) )
        {
LABEL_115:
          v13 = (int)v12;
          v73 = 4LL;
          if ( v62 < 4 )
            v73 = v62;
          if ( v73 )
          {
            v74 = tolower(v43);
            if ( v74 != tolower(80) )
              goto LABEL_128;
            if ( v62 != 4 && ~v62 >= 0xFFFFFFFFFFFFFFFBLL )
              v75 = ~v62;
            else
              v75 = -5LL;
            v76 = v42 + 1;
            v77 = v75 + 2;
            v78 = &byte_1DFAF;
            while ( (_BYTE)v43 && v77 )
            {
              v79 = *v76++;
              LOBYTE(v43) = v79;
              v80 = tolower(v79);
              v81 = (unsigned __int8)*v78++;
              ++v77;
              if ( v80 != tolower(v81) )
                goto LABEL_128;
            }
          }
          if ( (_DWORD)v62 == 4 )
            return v12;
LABEL_128:
          s[169] = 0LL;
          s[175] = v13;
          return v12;
        }
        if ( v62 != 3 && ~v62 >= 0xFFFFFFFFFFFFFFFCLL )
          v65 = ~v62;
        else
          v65 = -4LL;
        v66 = v42 + 1;
        v67 = v65 + 2;
        v68 = &byte_1DFAB;
        v69 = v43;
        while ( v69 && v67 )
        {
          v70 = *v66++;
          v69 = v70;
          v71 = tolower(v70);
          v72 = (unsigned __int8)*v68++;
          ++v67;
          if ( v71 != tolower(v72) )
            goto LABEL_115;
        }
      }
      if ( (_DWORD)v62 == 3 )
        return v12;
      goto LABEL_115;
    }
  }
  else
  {
LABEL_14:
    v10 = 0;
LABEL_16:
    memset(s, 0, 0x580uLL);
  }
  return v10;
}
// 1DFAB: using guessed type char byte_1DFAB;
// 1DFAF: using guessed type char byte_1DFAF;
// 1DFB3: using guessed type char byte_1DFB3;

//----- (00000000000133C8) ----------------------------------------------------
__int64 __fastcall mg_to64(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  int v4; // w10
  __int64 v5; // x10
  __int64 v6; // x12

  v2 = 0LL;
  v3 = 1LL;
  if ( a2 )
  {
    while ( 1 )
    {
      v4 = *(unsigned __int8 *)(a1 + v2);
      if ( v4 != 32 && v4 != 9 )
        break;
      if ( ++v2 >= a2 )
        goto LABEL_5;
    }
    v3 = -1LL;
    if ( v4 == 45 )
      ++v2;
    else
      v3 = 1LL;
    if ( v2 >= a2 )
      return 0LL;
  }
  else
  {
LABEL_5:
    if ( v2 >= a2 )
      return 0LL;
  }
  v5 = 0LL;
  do
  {
    v6 = *(unsigned __int8 *)(a1 + v2);
    if ( (unsigned __int8)(v6 - 48) > 9u )
      break;
    ++v2;
    v5 = v6 + 10 * v5 - 48;
  }
  while ( v2 < a2 );
  return v5 * v3;
}

//----- (0000000000013454) ----------------------------------------------------
__int64 __fastcall mg_vcasecmp(unsigned __int8 **a1, char *s)
{
  char *v3; // x19
  size_t v4; // x0
  size_t v5; // x23
  int v6; // w20
  size_t v7; // x8
  unsigned __int8 *v8; // x24
  size_t v9; // x8
  size_t v10; // x25
  int v11; // w21
  int v12; // t1
  int v13; // w0
  int v14; // t1
  __int64 result; // x0

  v3 = s;
  v4 = strlen(s);
  v5 = (size_t)a1[1];
  v6 = v4;
  if ( v5 >= v4 )
    v7 = v4;
  else
    v7 = (size_t)a1[1];
  if ( !v7 )
    return (unsigned int)(v5 - v6);
  v8 = *a1;
  if ( ~v5 > ~v4 )
    v9 = ~v5;
  else
    v9 = ~v4;
  v10 = v9 + 1;
  while ( 1 )
  {
    v12 = *v8++;
    v11 = v12;
    v13 = tolower(v12);
    v14 = (unsigned __int8)*v3++;
    result = (unsigned int)(v13 - tolower(v14));
    if ( (_DWORD)result )
      break;
    if ( v11 )
    {
      if ( ++v10 )
        continue;
    }
    return (unsigned int)(v5 - v6);
  }
  return result;
}

//----- (00000000000134F4) ----------------------------------------------------
void mg_http_printf_chunk(__int64 a1, const char *a2, ...)
{
  int v3; // w21
  char *v4; // x20
  __int64 v5; // x8
  unsigned __int64 v6; // x22
  unsigned __int64 v7; // x8
  size_t v8; // x22
  __int64 v9; // x8
  unsigned __int64 v10; // x21
  unsigned __int64 v11; // x9
  size_t v12; // x21
  gcc_va_list va; // [xsp+B0h] [xbp-190h] BYREF
  gcc_va_list va1; // [xsp+D0h] [xbp-170h] BYREF
  void *src; // [xsp+F8h] [xbp-148h] BYREF
  int v16; // [xsp+104h] [xbp-13Ch] BYREF
  char v17[256]; // [xsp+108h] [xbp-138h] BYREF
  __int64 v18; // [xsp+208h] [xbp-38h]

  va_start(va, a2);
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  src = v17;
  va_copy(va1, va);
  v3 = mg_vasprintf((char **)&src, 0x100uLL, a2, (__int128 *)va1);
  mg_printf(a1, "%X\r\n");
  v4 = (char *)src;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v8) = sub_19A48(a1, src, v3, &v16);
    if ( !v3 )
      goto LABEL_7;
    goto LABEL_5;
  }
  v5 = v3 + *(_QWORD *)(a1 + 104) + 512LL;
  v6 = v5 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v5 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v7 = v5 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v5 & 0xFFFFFFFFFFFFFE00LL);
    v7 = *(_QWORD *)(a1 + 96);
  }
  if ( v6 == v7 )
    v8 = v3;
  else
    v8 = 0LL;
  if ( v4 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v4, v8);
  *(_QWORD *)(a1 + 104) += v8;
  if ( v3 )
  {
LABEL_5:
    if ( !(_DWORD)v8 )
      v16 = 1;
  }
LABEL_7:
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(a1, "\r\n", 2, &v16) )
      goto LABEL_23;
    goto LABEL_22;
  }
  v9 = *(_QWORD *)(a1 + 104);
  v10 = (v9 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v10 == *(_QWORD *)(a1 + 96) )
  {
    v11 = (v9 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v9 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v11 = *(_QWORD *)(a1 + 96);
    v9 = *(_QWORD *)(a1 + 104);
  }
  v12 = 2LL * (v10 == v11);
  memcpy((void *)(*(_QWORD *)(a1 + 88) + v9), "\r\n", v12);
  *(_QWORD *)(a1 + 104) += v12;
  if ( !(_DWORD)v12 )
LABEL_22:
    v16 = 1;
LABEL_23:
  if ( v4 != v17 )
    free(v4);
}

//----- (0000000000013710) ----------------------------------------------------
void *__fastcall mg_http_write_chunk(__int64 a1, void *a2, size_t a3)
{
  __int64 v6; // x8
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x8
  size_t v9; // x22
  __int64 v10; // x8
  unsigned __int64 v11; // x20
  unsigned __int64 v12; // x9
  void *result; // x0
  size_t v14; // x20
  int v15; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v16; // [xsp+8h] [xbp-38h]

  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  mg_printf(a1, "%X\r\n");
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v9) = sub_19A48(a1, a2, a3, &v15);
    if ( !a3 )
      goto LABEL_7;
    goto LABEL_5;
  }
  v6 = a3 + *(_QWORD *)(a1 + 104) + 512;
  v7 = v6 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v6 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v8 = v6 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v6 & 0xFFFFFFFFFFFFFE00LL);
    v8 = *(_QWORD *)(a1 + 96);
  }
  if ( v7 == v8 )
    v9 = a3;
  else
    v9 = 0LL;
  if ( a2 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), a2, v9);
  *(_QWORD *)(a1 + 104) += v9;
  if ( a3 )
  {
LABEL_5:
    if ( !(_DWORD)v9 )
      v15 = 1;
  }
LABEL_7:
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
    return (void *)sub_19A48(a1, "\r\n", 2, &v15);
  v10 = *(_QWORD *)(a1 + 104);
  v11 = (v10 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v11 == *(_QWORD *)(a1 + 96) )
  {
    v12 = (v10 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v10 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v12 = *(_QWORD *)(a1 + 96);
    v10 = *(_QWORD *)(a1 + 104);
  }
  v14 = 2LL * (v11 == v12);
  result = memcpy((void *)(*(_QWORD *)(a1 + 88) + v10), "\r\n", v14);
  *(_QWORD *)(a1 + 104) += v14;
  return result;
}

//----- (00000000000138A4) ----------------------------------------------------
__int64 mg_printf(__int64 a1, const char *a2, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a2);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  va_copy(va1, va);
  return mg_vprintf(a1, a2, (__int128 *)va1);
}

//----- (0000000000013938) ----------------------------------------------------
void mg_http_reply(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  int v5; // w22
  char *v6; // x20
  size_t v7; // x21
  __int64 v8; // x8
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x8
  size_t v11; // x22
  gcc_va_list va1; // [xsp+B0h] [xbp-F0h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-C8h] BYREF
  char *v14; // [xsp+F8h] [xbp-A8h] BYREF
  int v15; // [xsp+100h] [xbp-A0h] BYREF
  char v16[108]; // [xsp+104h] [xbp-9Ch] BYREF

  va_start(va, a4);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v14 = v16;
  va_copy(va1, va);
  v5 = mg_vasprintf(&v14, 0x64uLL, a4, (__int128 *)va1);
  mg_printf(a1, "HTTP/1.1 %d OK\r\n%sContent-Length: %d\r\n\r\n");
  v6 = v14;
  v7 = v5;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v11) = sub_19A48(a1, v14, v5, &v15);
    if ( !(_DWORD)v7 )
      goto LABEL_7;
    goto LABEL_5;
  }
  v8 = v5 + *(_QWORD *)(a1 + 104) + 512LL;
  v9 = v8 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v8 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v10 = v8 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v8 & 0xFFFFFFFFFFFFFE00LL);
    v10 = *(_QWORD *)(a1 + 96);
  }
  if ( v9 == v10 )
    v11 = v7;
  else
    v11 = 0LL;
  if ( v6 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v6, v11);
  *(_QWORD *)(a1 + 104) += v11;
  if ( (_DWORD)v7 )
  {
LABEL_5:
    if ( !(_DWORD)v11 )
      v15 = 1;
  }
LABEL_7:
  if ( v6 != v16 )
    free(v6);
}

//----- (0000000000013AE0) ----------------------------------------------------
char *__fastcall mg_http_etag(char *a1, size_t a2, __int64 a3)
{
  snprintf(a1, a2, "\"%lx.%ld\"", *(_QWORD *)(a3 + 88), *(_QWORD *)(a3 + 48));
  return a1;
}

//----- (0000000000013B14) ----------------------------------------------------
__int64 __fastcall mg_http_upload(__int64 a1, __int64 a2, const char *a3)
{
  __int64 *v4; // x22
  unsigned __int64 v7; // x22
  const char *v8; // x1
  FILE *v9; // x0
  FILE *v10; // x21
  char v12[256]; // [xsp+0h] [xbp-230h] BYREF
  __int128 v13[12]; // [xsp+100h] [xbp-130h] BYREF
  __int64 v14; // [xsp+1C0h] [xbp-70h]
  char nptr[16]; // [xsp+1D0h] [xbp-60h] BYREF
  __int128 v16; // [xsp+1E0h] [xbp-50h]
  __int64 v17; // [xsp+1F0h] [xbp-40h]
  __int64 v18; // [xsp+1F8h] [xbp-38h]

  v4 = (__int64 *)(a2 + 32);
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  *(_OWORD *)nptr = 0u;
  v16 = 0u;
  v14 = 0LL;
  memset(v13, 0, sizeof(v13));
  mg_http_get_var((__int64 *)(a2 + 32), "offset", nptr, 40);
  mg_http_get_var(v4, "name", v13, 200);
  if ( LOBYTE(v13[0]) )
  {
    v7 = strtoul(nptr, 0LL, 0);
    snprintf(v12, 0x100uLL, "%s%c%s", a3, 47LL, (const char *)v13);
    if ( (mg_log_prefix(
            3,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x2B2u,
            "mg_http_upload") & 1) != 0 )
      mg_log("%p %d bytes @ %d [%s]");
    if ( v7 )
      v8 = "ab";
    else
      v8 = "wb";
    v9 = fopen(v12, v8);
    if ( v9 )
    {
      v10 = v9;
      fwrite(*(const void **)(a2 + 1344), 1uLL, *(_QWORD *)(a2 + 1352), v9);
      fclose(v10);
      mg_http_reply(a1, 200LL, (__int64)"", "");
      return *(unsigned int *)(a2 + 1352);
    }
    else
    {
      __errno(0LL);
      mg_http_reply(a1, 400LL, (__int64)"", "fopen(%s): %d");
      return 4294967294LL;
    }
  }
  else
  {
    mg_http_reply(a1, 400LL, (__int64)"", "%s");
    return 0xFFFFFFFFLL;
  }
}
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);

//----- (0000000000013D04) ----------------------------------------------------
void __fastcall mg_http_serve_file(__int64 a1, unsigned __int8 **a2, const char *a3)
{
  unsigned __int64 v6; // x27
  unsigned __int8 **v7; // x26
  __int64 v8; // x8
  unsigned __int8 *v9; // x21
  int v10; // w24
  int v11; // w25
  int v12; // w24
  int v13; // w25
  int v14; // w24
  int v15; // w25
  int v16; // w24
  int v17; // w25
  int v18; // w24
  int v19; // w25
  int v20; // w24
  int v21; // w25
  int v22; // w24
  int v23; // w25
  int v24; // w24
  int v25; // w25
  int v26; // w24
  int v27; // w25
  int v28; // w24
  int v29; // w25
  int v30; // w24
  int v31; // w25
  int v32; // w24
  int v33; // w25
  int v34; // w24
  FILE *v35; // x24
  size_t v36; // x0
  size_t v37; // x21
  int v38; // w25
  size_t v39; // x8
  unsigned __int8 *v40; // x19
  size_t v41; // x8
  char *v42; // x22
  size_t v43; // x28
  int v44; // w26
  int v45; // t1
  int v46; // w0
  int v47; // t1
  unsigned __int64 v48; // x22
  __int64 v49; // x8
  unsigned __int8 *v50; // x23
  __int64 v51; // x8
  __int64 v52; // x19
  const char *v53; // x25
  int v54; // w20
  int v55; // t1
  int v56; // w0
  int v57; // t1
  __int64 v58; // [xsp+8h] [xbp-138h]
  char v59[48]; // [xsp+20h] [xbp-120h] BYREF
  __int64 v60; // [xsp+50h] [xbp-F0h]
  __int64 v61; // [xsp+78h] [xbp-C8h]
  char s[64]; // [xsp+A0h] [xbp-A0h] BYREF
  __int64 v63; // [xsp+E0h] [xbp-60h]

  v6 = 0LL;
  v7 = a2 + 10;
  v63 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  do
  {
    v8 = (__int64)*(v7 - 1);
    if ( v8 == 13 )
    {
      v9 = *(v7 - 2);
      v10 = *v9;
      v11 = tolower(v10);
      if ( v11 == tolower(73) )
      {
        if ( !v10 )
          goto LABEL_32;
        v12 = v9[1];
        v13 = tolower(v12);
        if ( v13 == tolower(102) )
        {
          if ( !v12 )
            goto LABEL_32;
          v14 = v9[2];
          v15 = tolower(v14);
          if ( v15 == tolower(45) )
          {
            if ( !v14 )
              goto LABEL_32;
            v16 = v9[3];
            v17 = tolower(v16);
            if ( v17 == tolower(78) )
            {
              if ( !v16 )
                goto LABEL_32;
              v18 = v9[4];
              v19 = tolower(v18);
              if ( v19 == tolower(111) )
              {
                if ( !v18 )
                  goto LABEL_32;
                v20 = v9[5];
                v21 = tolower(v20);
                if ( v21 == tolower(110) )
                {
                  if ( !v20 )
                    goto LABEL_32;
                  v22 = v9[6];
                  v23 = tolower(v22);
                  if ( v23 == tolower(101) )
                  {
                    if ( !v22 )
                      goto LABEL_32;
                    v24 = v9[7];
                    v25 = tolower(v24);
                    if ( v25 == tolower(45) )
                    {
                      if ( !v24 )
                        goto LABEL_32;
                      v26 = v9[8];
                      v27 = tolower(v26);
                      if ( v27 == tolower(77) )
                      {
                        if ( !v26 )
                          goto LABEL_32;
                        v28 = v9[9];
                        v29 = tolower(v28);
                        if ( v29 == tolower(97) )
                        {
                          if ( !v28 )
                            goto LABEL_32;
                          v30 = v9[10];
                          v31 = tolower(v30);
                          if ( v31 == tolower(116) )
                          {
                            if ( !v30 )
                              goto LABEL_32;
                            v32 = v9[11];
                            v33 = tolower(v32);
                            if ( v33 == tolower(99) )
                            {
                              if ( !v32 )
                                goto LABEL_32;
                              v34 = tolower(v9[12]);
                              if ( v34 == tolower(104) )
                                goto LABEL_32;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ( !v8 )
    {
      break;
    }
    ++v6;
    v7 += 4;
  }
  while ( v6 < 0x28 );
  v7 = 0LL;
LABEL_32:
  v35 = fopen(a3, "rb");
  if ( v35 && !stat(a3, (struct stat *)v59) )
  {
    v58 = a1;
    snprintf(s, 0x40uLL, "\"%lx.%ld\"", v61, v60);
    if ( v7 )
    {
      v36 = strlen(s);
      v37 = (size_t)v7[1];
      v38 = v36;
      if ( v37 >= v36 )
        v39 = v36;
      else
        v39 = (size_t)v7[1];
      if ( v39 )
      {
        v40 = *v7;
        if ( ~v37 > ~v36 )
          v41 = ~v37;
        else
          v41 = ~v36;
        v42 = s;
        v43 = v41 + 1;
        while ( 1 )
        {
          v45 = *v40++;
          v44 = v45;
          v46 = tolower(v45);
          v47 = (unsigned __int8)*v42++;
          if ( v46 != tolower(v47) )
            break;
          if ( v44 )
          {
            if ( ++v43 )
              continue;
          }
          goto LABEL_50;
        }
      }
      else
      {
LABEL_50:
        if ( (_DWORD)v37 == v38 )
        {
          fclose(v35);
          mg_printf(v58, "HTTP/1.1 304 Not Modified\r\nContent-Length: 0\r\n\r\n");
          return;
        }
      }
    }
    mg_printf(v58, "HTTP/1.1 200 OK\r\nContent-Type: %s\r\nEtag: %s\r\nContent-Length: %ld\r\n%s\r\n");
    v48 = (unsigned __int64)a2[1];
    v49 = 4LL;
    if ( v48 < 4 )
      v49 = (__int64)a2[1];
    if ( v49 )
    {
      v50 = *a2;
      if ( v48 != 4 && ~v48 >= 0xFFFFFFFFFFFFFFFBLL )
        v51 = ~v48;
      else
        v51 = -5LL;
      v52 = v51 + 1;
      v53 = "HEAD";
      while ( 1 )
      {
        v55 = *v50++;
        v54 = v55;
        v56 = tolower(v55);
        v57 = *(unsigned __int8 *)v53++;
        if ( v56 != tolower(v57) )
          break;
        if ( v54 )
        {
          if ( ++v52 )
            continue;
        }
        goto LABEL_61;
      }
    }
    else
    {
LABEL_61:
      if ( (_DWORD)v48 == 4 )
      {
LABEL_37:
        fclose(v35);
        return;
      }
    }
    *(_QWORD *)(v58 + 128) = sub_14184;
    *(_QWORD *)(v58 + 136) = v35;
  }
  else
  {
    if ( (mg_log_prefix(
            3,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x317u,
            "mg_http_serve_file") & 1) != 0 )
      mg_log("404 [%.*s] [%s] %p");
    mg_http_reply(a1, 404LL, (__int64)"", "%s");
    if ( v35 )
      goto LABEL_37;
  }
}
// 13D04: using guessed type char var_120[48];

//----- (0000000000014184) ----------------------------------------------------
void __fastcall sub_14184(_QWORD *a1, int a2, int a3, FILE *stream)
{
  size_t v6; // x21
  void *v7; // x0
  void *v8; // x23
  void *v9; // x22
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  size_t v12; // x0
  unsigned __int64 v13; // x8
  FILE *v14; // x0

  if ( a2 != 1 )
  {
    if ( a2 == 7 )
    {
LABEL_13:
      v14 = (FILE *)a1[17];
      if ( v14 )
        fclose(v14);
      a1[16] = sub_15070;
      a1[17] = 0LL;
      return;
    }
    if ( a2 != 6 )
      return;
  }
  v6 = a1[12];
  if ( v6 <= 0x3FF )
  {
    v7 = malloc(0x400uLL);
    if ( v7 )
    {
      v8 = (void *)a1[11];
      v9 = v7;
      memcpy(v7, v8, v6);
      free(v8);
      a1[11] = v9;
      a1[12] = 1024LL;
    }
    else if ( (mg_log_prefix(
                 1,
                 "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                 0x4FDu,
                 "mg_iobuf_resize") & 1) != 0 )
    {
      mg_log("%lu->%lu");
    }
  }
  v11 = a1[12];
  v10 = a1[13];
  if ( v11 > v10 )
  {
    v12 = fread((void *)(a1[11] + v10), 1uLL, v11 - v10, stream);
    v13 = a1[13];
    if ( v12 )
    {
      v13 += v12;
      a1[13] = v13;
    }
    if ( v13 < a1[12] )
      goto LABEL_13;
  }
}

//----- (0000000000014294) ----------------------------------------------------
bool __fastcall mg_is_dir(const char *a1)
{
  char v2[16]; // [xsp+8h] [xbp-98h] BYREF
  int v3; // [xsp+18h] [xbp-88h]
  __int64 v4; // [xsp+88h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return !stat(a1, (struct stat *)v2) && (v3 & 0xF000) == 0x4000;
}
// 14294: using guessed type char var_98[16];

//----- (00000000000142F8) ----------------------------------------------------
void __fastcall mg_http_serve_dir(__int64 a1, __int64 a2, const char **a3)
{
  size_t v5; // x21
  size_t i; // x0
  char *v7; // x9
  size_t v8; // x0
  int v9; // w22
  __int64 v10; // x0
  const char *v11; // x3
  __int64 v12; // x0
  const char *v13; // x3
  FILE *v14; // x23
  size_t v15; // x22
  _BYTE *v16; // x27
  char *v17; // x23
  __int64 v18; // x8
  __int64 v19; // x21
  int v20; // w24
  int v21; // t1
  int v22; // w25
  char *v23; // t1
  FILE *v24; // [xsp+8h] [xbp-2478h]
  char resolved[4096]; // [xsp+18h] [xbp-2468h] BYREF
  char v26[4096]; // [xsp+1018h] [xbp-1468h] BYREF
  _BYTE v27[1048]; // [xsp+2018h] [xbp-468h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  resolved[0] = 0;
  v26[0] = 0;
  if ( !realpath(*a3, v26) )
  {
    v10 = mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x422u,
            "mg_http_serve_dir");
    if ( (v10 & 1) != 0 )
    {
      __errno(v10);
      mg_log("realpath(%s): %d");
    }
    v11 = "Bad web root [%s]\n";
    goto LABEL_13;
  }
  if ( !mg_is_dir(v26) )
  {
    v11 = "Invalid web root [%s]\n";
LABEL_13:
    mg_http_reply(a1, 400LL, (__int64)"", v11);
    return;
  }
  v5 = strlen(v26);
  mg_url_decode(*(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), (__int64)&v26[v5], 4096 - v5, 0);
  v26[4095] = 0;
  for ( i = strlen(v26); i; *(v7 - 1) = 0 )
  {
    v7 = &v26[i];
    if ( v26[i - 1] != 47 )
      break;
    --i;
  }
  if ( !realpath(v26, resolved) )
  {
    v12 = mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x432u,
            "mg_http_serve_dir");
    if ( (v12 & 1) != 0 )
    {
      __errno(v12);
      mg_log("realpath(%s): %d");
    }
    v13 = "Not found [%.*s]\n";
    goto LABEL_21;
  }
  if ( mg_is_dir(resolved) )
  {
    v8 = strlen(resolved);
    strncat(resolved, "/index.html", 4095 - v8);
    v9 = 1;
    resolved[4095] = 0;
  }
  else
  {
    v9 = 0;
  }
  if ( strlen(resolved) < v5 || memcmp(v26, resolved, v5) )
  {
    v13 = "Invalid URI [%.*s]\n";
LABEL_21:
    mg_http_reply(a1, 404LL, (__int64)"", v13);
    return;
  }
  v14 = fopen(resolved, "r");
  if ( !((v9 ^ 1) & 1 | (v14 != 0LL)) )
  {
    mg_http_reply(a1, 403LL, (__int64)"", "%s");
    if ( !v14 )
      return;
LABEL_36:
    fclose(v14);
    return;
  }
  v24 = v14;
  v15 = strlen(resolved);
  v16 = v27;
  memcpy(v27, &off_32348, 0x408uLL);
  v17 = "html";
  do
  {
    v18 = *((_QWORD *)v16 + 1);
    if ( v15 >= v18 + 2 )
    {
      if ( !v18 )
        break;
      v19 = -v18;
      while ( 1 )
      {
        v21 = (unsigned __int8)*v17++;
        v20 = v21;
        v22 = tolower(v21);
        if ( v22 != tolower((unsigned __int8)resolved[v15 + v19]) )
          break;
        if ( v20 )
        {
          if ( ++v19 )
            continue;
        }
        goto LABEL_35;
      }
    }
    v23 = (char *)*((_QWORD *)v16 + 3);
    v16 += 24;
    v17 = v23;
  }
  while ( v23 );
LABEL_35:
  mg_http_serve_file(a1, (unsigned __int8 **)a2, resolved);
  v14 = v24;
  if ( v24 )
    goto LABEL_36;
}
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);
// 32348: using guessed type void *off_32348;
// 142F8: using guessed type char resolved[4096];

//----- (00000000000146A0) ----------------------------------------------------
__int64 __fastcall mg_url_encode(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x12
  unsigned __int64 v5; // x9
  int v6; // w13
  __int64 v7; // x8
  _BYTE *v8; // x8
  char v9; // w13

  if ( !a2 )
    return 0LL;
  v4 = 0LL;
  v5 = 0LL;
  while ( v4 + 4 < a4 )
  {
    v6 = *(unsigned __int8 *)(a1 + v5);
    if ( (unsigned int)(v6 - 48) < 0xA
      || (v6 & 0xFFFFFFDF) - 65 < 0x1A
      || (unsigned int)(v6 - 45) < 2
      || v6 == 126
      || v6 == 95 )
    {
      v7 = v4 + 1;
      *(_BYTE *)(a3 + v4) = v6;
    }
    else
    {
      v8 = (_BYTE *)(a3 + v4);
      *v8 = 37;
      v8[1] = a0123456789abcd[(unsigned __int64)*(unsigned __int8 *)(a1 + v5) >> 4];
      v9 = *(_BYTE *)(a1 + v5);
      v8[3] = 0;
      v8[2] = a0123456789abcd[v9 & 0xF];
      v7 = v4 + 3;
    }
    ++v5;
    v4 = v7;
    if ( v5 >= a2 )
      return (unsigned int)v7;
  }
  return 0LL;
}

//----- (0000000000014770) ----------------------------------------------------
__int64 __fastcall mg_hex(char *a1, int a2, __int64 a3)
{
  __int64 v3; // x8
  _BYTE *v4; // x9
  char v5; // t1
  __int64 result; // x0

  if ( a2 )
  {
    LODWORD(v3) = 2 * a2;
    v4 = (_BYTE *)(a3 + 1);
    do
    {
      --a2;
      *(v4 - 1) = a0123456789abcd[(unsigned __int64)(unsigned __int8)*a1 >> 4];
      v5 = *a1++;
      *v4 = a0123456789abcd[v5 & 0xF];
      v4 += 2;
    }
    while ( a2 );
    v3 = (unsigned int)v3;
  }
  else
  {
    v3 = 0LL;
  }
  result = a3;
  *(_BYTE *)(a3 + v3) = 0;
  return result;
}

//----- (00000000000147C4) ----------------------------------------------------
__int64 __fastcall mg_http_creds(__int64 a1, char *a2, int a3, char *a4, int a5)
{
  unsigned __int64 v9; // x28
  unsigned __int64 *v10; // x27
  __int64 v11; // x8
  unsigned __int8 *v12; // x23
  int v13; // w24
  int v14; // w25
  int v15; // w24
  int v16; // w25
  int v17; // w24
  int v18; // w25
  int v19; // w24
  int v20; // w25
  int v21; // w24
  int v22; // w25
  int v23; // w24
  int v24; // w25
  int v25; // w24
  int v26; // w25
  int v27; // w24
  int v28; // w25
  int v29; // w24
  int v30; // w25
  int v31; // w24
  int v32; // w25
  int v33; // w24
  int v34; // w25
  int v35; // w24
  int v36; // w25
  int v37; // w24
  unsigned __int64 v38; // x25
  __int64 *v39; // x24
  __int64 v40; // x8
  unsigned __int8 *v41; // x27
  int v42; // w22
  int v43; // w23
  __int64 result; // x0
  int v45; // w22
  int v46; // w23
  int v47; // w22
  int v48; // w23
  int v49; // w22
  int v50; // w23
  int v51; // w22
  int v52; // w23
  int v53; // w22
  unsigned __int64 v54; // x23
  char *v55; // x24
  size_t v56; // x1
  __int64 v57; // x3
  char *v58; // x4
  __int64 v59; // x23
  unsigned __int64 v60; // x25
  __int64 v61; // x24
  __int64 v62; // x27
  __int64 v63; // x22
  unsigned __int8 *v64; // x8
  int v65; // w10
  int v66; // w21
  __int64 v67; // x24
  int v68; // w23
  char s[256]; // [xsp+10h] [xbp-160h] BYREF
  __int64 v71; // [xsp+110h] [xbp-60h]

  v9 = 0LL;
  v10 = (unsigned __int64 *)(a1 + 88);
  v71 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  while ( 1 )
  {
    v11 = *(v10 - 2);
    if ( v11 != 13 )
    {
      if ( !v11 )
        goto LABEL_31;
      goto LABEL_30;
    }
    v12 = (unsigned __int8 *)*(v10 - 3);
    v13 = *v12;
    v14 = tolower(v13);
    if ( v14 == tolower(65) )
    {
      if ( !v13 )
        break;
      v15 = v12[1];
      v16 = tolower(v15);
      if ( v16 == tolower(117) )
      {
        if ( !v15 )
          break;
        v17 = v12[2];
        v18 = tolower(v17);
        if ( v18 == tolower(116) )
        {
          if ( !v17 )
            break;
          v19 = v12[3];
          v20 = tolower(v19);
          if ( v20 == tolower(104) )
          {
            if ( !v19 )
              break;
            v21 = v12[4];
            v22 = tolower(v21);
            if ( v22 == tolower(111) )
            {
              if ( !v21 )
                break;
              v23 = v12[5];
              v24 = tolower(v23);
              if ( v24 == tolower(114) )
              {
                if ( !v23 )
                  break;
                v25 = v12[6];
                v26 = tolower(v25);
                if ( v26 == tolower(105) )
                {
                  if ( !v25 )
                    break;
                  v27 = v12[7];
                  v28 = tolower(v27);
                  if ( v28 == tolower(122) )
                  {
                    if ( !v27 )
                      break;
                    v29 = v12[8];
                    v30 = tolower(v29);
                    if ( v30 == tolower(97) )
                    {
                      if ( !v29 )
                        break;
                      v31 = v12[9];
                      v32 = tolower(v31);
                      if ( v32 == tolower(116) )
                      {
                        if ( !v31 )
                          break;
                        v33 = v12[10];
                        v34 = tolower(v33);
                        if ( v34 == tolower(105) )
                        {
                          if ( !v33 )
                            break;
                          v35 = v12[11];
                          v36 = tolower(v35);
                          if ( v36 == tolower(111) )
                          {
                            if ( !v35 )
                              break;
                            v37 = tolower(v12[12]);
                            if ( v37 == tolower(110) )
                              break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_30:
    ++v9;
    v10 += 4;
    if ( v9 >= 0x28 )
    {
LABEL_31:
      *a4 = 0;
      *a2 = 0;
      goto LABEL_32;
    }
  }
  *a4 = 0;
  *a2 = 0;
  v54 = *v10;
  if ( *v10 >= 7 )
  {
    v55 = (char *)*(v10 - 1);
    if ( !memcmp(v55, "Basic ", 6uLL) )
    {
      v66 = mg_base64_decode((__int64)(v55 + 6), (int)v54 - 6, (__int64)s);
      result = (__int64)memchr(s, 58, v66);
      if ( result )
      {
        v67 = result;
        v68 = result - (unsigned int)s;
        snprintf(a2, a3, "%.*s", v68, s);
        return snprintf(a4, a5, "%.*s", (unsigned int)(v66 + ~v68), v67 + 1);
      }
      return result;
    }
    if ( v54 > 7 && !memcmp(v55, "Bearer ", 7uLL) )
    {
      v56 = a5;
      v57 = (unsigned int)(v54 - 7);
      v58 = v55 + 7;
      return snprintf(a4, v56, "%.*s", v57, v58);
    }
  }
LABEL_32:
  v38 = 0LL;
  v39 = (__int64 *)(a1 + 88);
  while ( 2 )
  {
    v40 = *(v39 - 2);
    if ( v40 != 6 )
    {
      if ( !v40 )
        return mg_http_get_var((__int64 *)(a1 + 32), "access_token", a4, a5);
LABEL_47:
      ++v38;
      v39 += 4;
      if ( v38 >= 0x28 )
        return mg_http_get_var((__int64 *)(a1 + 32), "access_token", a4, a5);
      continue;
    }
    break;
  }
  v41 = (unsigned __int8 *)*(v39 - 3);
  v42 = *v41;
  v43 = tolower(v42);
  result = tolower(67);
  if ( v43 != (_DWORD)result )
    goto LABEL_47;
  if ( v42 )
  {
    v45 = v41[1];
    v46 = tolower(v45);
    result = tolower(111);
    if ( v46 != (_DWORD)result )
      goto LABEL_47;
    if ( v45 )
    {
      v47 = v41[2];
      v48 = tolower(v47);
      result = tolower(111);
      if ( v48 != (_DWORD)result )
        goto LABEL_47;
      if ( v47 )
      {
        v49 = v41[3];
        v50 = tolower(v49);
        result = tolower(107);
        if ( v50 != (_DWORD)result )
          goto LABEL_47;
        if ( v49 )
        {
          v51 = v41[4];
          v52 = tolower(v51);
          result = tolower(105);
          if ( v52 != (_DWORD)result )
            goto LABEL_47;
          if ( v51 )
          {
            v53 = tolower(v41[5]);
            result = tolower(101);
            if ( v53 != (_DWORD)result )
              goto LABEL_47;
          }
        }
      }
    }
  }
  v59 = *v39;
  v60 = *v39 - 13;
  if ( *v39 != 13 )
  {
    v61 = *(v39 - 1);
    v62 = 0LL;
    while ( 1 )
    {
      v63 = v61 + v62;
      result = memcmp((const void *)(v61 + v62), "access_token=", 0xDuLL);
      if ( !(_DWORD)result )
        break;
      if ( ++v62 >= v60 )
        return result;
    }
    v58 = (char *)(v63 + 13);
    LODWORD(v64) = v63 + 13;
    if ( v63 + 13 < (unsigned __int64)(v61 + v59) )
    {
      v64 = (unsigned __int8 *)(v63 + 13);
      do
      {
        v65 = *v64;
        if ( v65 == 32 )
          break;
        if ( v65 == 59 )
          break;
        ++v64;
      }
      while ( (unsigned __int64)v64 < v61 + v59 );
    }
    v56 = a5;
    v57 = (unsigned int)((_DWORD)v64 - (_DWORD)v58);
    return snprintf(a4, v56, "%.*s", v57, v58);
  }
  return result;
}

//----- (0000000000014CC0) ----------------------------------------------------
__int64 __fastcall mg_http_match_uri(__int64 a1, char *s)
{
  int v4; // w0
  int v5; // w9
  __int64 v6; // x10
  bool v7; // w15
  bool v8; // w8
  int v9; // w11
  int v10; // w1
  int v11; // w12
  int v12; // w13
  int v13; // w14
  int v14; // w13
  int v15; // w8
  unsigned int v16; // w8
  int v17; // w8

  v4 = strlen(s);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = v5 > 0;
  v8 = v4 > 0;
  if ( v4 > 0 || v5 >= 1 )
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = v12;
      if ( v7 && v8 && ((v14 = (unsigned __int8)s[v12], v14 == 63) || *(unsigned __int8 *)(v6 + v11) == v14) )
      {
        v12 = v13 + 1;
        ++v11;
      }
      else if ( v8 && ((v15 = (unsigned __int8)s[v13], v15 == 42) || v15 == 35) )
      {
        v9 = v11 + 1;
        v12 = v13 + 1;
        v10 = v13;
      }
      else
      {
        v16 = 0;
        if ( v9 < 1 || v9 > v5 )
          return v16;
        if ( s[v13 - 1] == 35 )
        {
          v12 = v10;
          v11 = v9;
        }
        else
        {
          v17 = *(unsigned __int8 *)(v6 + v11);
          v12 = v10;
          v11 = v9;
          if ( v17 == 47 )
            return 0;
        }
      }
      v7 = v11 < v5;
      v8 = v12 < v4;
    }
    while ( v12 < v4 || v11 < v5 );
  }
  return 1;
}

//----- (0000000000014DE4) ----------------------------------------------------
__int64 __fastcall mg_globmatch(__int64 a1, int a2, __int64 a3, int a4)
{
  bool v4; // w13
  bool v5; // w8
  int v6; // w9
  int v7; // w4
  int v8; // w10
  int v9; // w11
  int v10; // w12
  int v11; // w11
  int v12; // w8
  int v13; // w8

  v4 = a4 > 0;
  v5 = a2 > 0;
  if ( a2 <= 0 && a4 < 1 )
    return 1LL;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = v9;
    if ( v5 && v4 )
    {
      v11 = *(unsigned __int8 *)(a1 + v9);
      if ( v11 == 63 || *(unsigned __int8 *)(a3 + v8) == v11 )
      {
        v9 = v10 + 1;
        ++v8;
        goto LABEL_18;
      }
    }
    if ( v5 )
    {
      v12 = *(unsigned __int8 *)(a1 + v10);
      if ( v12 == 42 || v12 == 35 )
      {
        v6 = v8 + 1;
        v9 = v10 + 1;
        v7 = v10;
        goto LABEL_18;
      }
    }
    if ( v6 < 1 || v6 > a4 )
      return 0LL;
    if ( *(_BYTE *)(a1 + v10 - 1) == 35 )
    {
      v9 = v7;
      v8 = v6;
    }
    else
    {
      v13 = *(unsigned __int8 *)(a3 + v8);
      v9 = v7;
      v8 = v6;
      if ( v13 == 47 )
        return 0LL;
    }
LABEL_18:
    v4 = v8 < a4;
    v5 = v9 < a2;
    if ( v9 >= a2 && v8 >= a4 )
      return 1LL;
  }
}

//----- (0000000000014EE0) ----------------------------------------------------
__int64 __fastcall mg_http_connect(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0

  result = mg_connect(a1, a2, a3, a4);
  if ( result )
    *(_QWORD *)(result + 128) = sub_15070;
  return result;
}

//----- (0000000000014F04) ----------------------------------------------------
__int64 __fastcall mg_connect(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  _QWORD *v8; // x0
  __int64 v9; // x19
  __int64 v10; // x8
  __int64 v11; // x1
  __int64 v13[3]; // [xsp+8h] [xbp-58h] BYREF

  v13[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = calloc(1uLL, 0xD8uLL);
  v9 = (__int64)v8;
  if ( v8 )
  {
    v8[1] = a1;
    *((_WORD *)v8 + 104) = 2;
    v8[6] = -1LL;
    v10 = *(_QWORD *)(a1 + 48) + 1LL;
    *(_QWORD *)(a1 + 48) = v10;
    v8[7] = v10;
    v13[0] = (__int64)mg_url_host(a2);
    v13[1] = v11;
    *(_QWORD *)v9 = *(_QWORD *)a1;
    *(_QWORD *)a1 = v9;
    *(_WORD *)(v9 + 208) = ((strncmp(a2, "udp:", 4uLL) == 0) << 7) | 2;
    *(_WORD *)(v9 + 16) = bswap32(mg_url_port(a2)) >> 16;
    *(_QWORD *)(v9 + 112) = a3;
    *(_QWORD *)(v9 + 120) = a4;
    if ( (mg_log_prefix(
            3,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0xB4Fu,
            "mg_connect") & 1) != 0 )
      mg_log("%lu -> %s");
    mg_resolve(v9, (__int64)v13, *(_DWORD *)(a1 + 40));
  }
  else if ( (mg_log_prefix(
               1,
               "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
               0xB47u,
               "mg_connect") & 1) != 0 )
  {
    mg_log("OOM");
  }
  return v9;
}
// 14F7C: variable 'v11' is possibly undefined

//----- (0000000000015070) ----------------------------------------------------
void __fastcall sub_15070(__int64 a1, int a2)
{
  unsigned __int64 i; // x1
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x22
  int v7; // w0
  void (__fastcall *v8)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v9)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  unsigned __int64 s[175]; // [xsp+8h] [xbp-5B8h] BYREF
  unsigned __int64 v11; // [xsp+580h] [xbp-40h]
  __int64 v12; // [xsp+588h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (a2 | 2) == 7 )
  {
    for ( i = *(_QWORD *)(a1 + 80); ; *(_QWORD *)(a1 + 80) = i )
    {
      v7 = mg_http_parse(*(unsigned __int8 **)(a1 + 64), i, s);
      if ( a2 == 7 )
      {
        v11 = *(_QWORD *)(a1 + 80);
        s[169] = v11 - s[168] + s[174];
      }
      if ( a2 == 5 && v7 < 0 )
        break;
      if ( v7 < 1 || *(_QWORD *)(a1 + 80) < v11 )
        return;
      v8 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 128);
      if ( v8 )
        v8(a1, 8LL, s, *(_QWORD *)(a1 + 136));
      v9 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 112);
      if ( v9 )
        v9(a1, 8LL, s, *(_QWORD *)(a1 + 120));
      v5 = *(_QWORD *)(a1 + 80);
      if ( v5 >= v11 )
        v6 = v11;
      else
        v6 = 0LL;
      memmove(*(void **)(a1 + 64), (const void *)(*(_QWORD *)(a1 + 64) + v6), v5 - v6);
      i = *(_QWORD *)(a1 + 80) - v6;
    }
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x4A7u,
            "http_cb") & 1) != 0 )
      mg_log("%lu HTTP parse error");
    *(_WORD *)(a1 + 208) |= 0x800u;
  }
}

//----- (00000000000151D4) ----------------------------------------------------
_QWORD *__fastcall mg_http_listen(_QWORD *a1, char *a2, __int64 a3, __int64 a4)
{
  _QWORD *result; // x0

  result = mg_listen(a1, a2, a3, a4);
  if ( result )
    result[16] = sub_15070;
  return result;
}

//----- (00000000000151F8) ----------------------------------------------------
_QWORD *__fastcall mg_listen(_QWORD *a1, char *s1, __int64 a3, __int64 a4)
{
  int v8; // w25
  int v9; // w0
  int v10; // w24
  _QWORD *v11; // x0
  __int64 v12; // x8
  _QWORD *v13; // x20

  v8 = strncmp(s1, "udp:", 4uLL);
  v9 = mg_open_listener(s1);
  if ( v9 == -1 )
    return 0LL;
  v10 = v9;
  v11 = calloc(1uLL, 0xD8uLL);
  if ( !v11 )
  {
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0xBAFu,
            "mg_listen") & 1) != 0 )
      mg_log("OOM %s");
    close(v10);
    return 0LL;
  }
  v11[1] = a1;
  v12 = a1[6] + 1LL;
  v13 = v11;
  a1[6] = v12;
  v11[6] = v10;
  v11[7] = v12;
  *((_WORD *)v11 + 104) = ((v8 == 0) << 7) | 1;
  sub_1A09C((__int64)v11);
  *v13 = *a1;
  *a1 = v13;
  v13[14] = a3;
  v13[15] = a4;
  if ( (mg_log_prefix(
          2,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0xBB9u,
          "mg_listen") & 1) != 0 )
    mg_log("%lu accepting on %s");
  return v13;
}

//----- (0000000000015334) ----------------------------------------------------
size_t __fastcall mg_iobuf_append(_QWORD *a1, void *src, size_t a3, unsigned __int64 a4)
{
  size_t v4; // x20
  size_t v6; // x8
  size_t v7; // x22
  size_t v9; // x8
  size_t result; // x0

  v4 = a3;
  v6 = (a4 + a3 + a1[2]) / a4;
  v7 = v6 * a4;
  if ( v6 * a4 == a1[1] )
  {
    v9 = v6 * a4;
  }
  else
  {
    mg_iobuf_resize((__int64)a1, v6 * a4);
    v9 = a1[1];
  }
  if ( v7 != v9 )
    v4 = 0LL;
  if ( src )
    memmove((void *)(*a1 + a1[2]), src, v4);
  result = v4;
  a1[2] += v4;
  return result;
}

//----- (00000000000153C8) ----------------------------------------------------
unsigned __int64 __fastcall mg_iobuf_delete(char **a1, unsigned __int64 a2)
{
  char *v2; // x8
  char *v4; // x0
  unsigned __int64 v5; // x20
  unsigned __int64 result; // x0

  v2 = a1[2];
  v4 = *a1;
  if ( (unsigned __int64)v2 >= a2 )
    v5 = a2;
  else
    v5 = 0LL;
  memmove(v4, &v4[v5], (size_t)&v2[-v5]);
  result = v5;
  a1[2] -= v5;
  return result;
}

//----- (0000000000015410) ----------------------------------------------------
void __fastcall mg_iobuf_free(__int64 a1)
{
  free(*(void **)a1);
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
}

//----- (000000000001543C) ----------------------------------------------------
void __fastcall mg_log_set(void *a1)
{
  if ( (mg_log_prefix(
          3,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x530u,
          "mg_log_set") & 1) != 0 )
    mg_log("Setting log level to %s");
  off_331D8 = a1;
}
// 331D8: using guessed type void *off_331D8;

//----- (0000000000015490) ----------------------------------------------------
bool __fastcall mg_next_comma_entry(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x10
  __int64 v6; // x12
  unsigned __int64 v7; // x11
  __int64 v8; // x13
  __int64 v9; // x13
  __int64 v10; // x12

  v3 = *a1;
  v4 = a1[1];
  if ( (int)v4 < 1 )
  {
    v6 = 0LL;
    LODWORD(v5) = 0;
LABEL_14:
    LODWORD(v7) = 0;
LABEL_15:
    v9 = 0LL;
  }
  else
  {
    v5 = 0LL;
    while ( *(_BYTE *)(v3 + v5) != 44 )
    {
      if ( ++v5 >= (int)v4 )
        goto LABEL_8;
    }
    if ( !(_DWORD)v5 )
    {
      v6 = 0LL;
      goto LABEL_14;
    }
LABEL_8:
    v7 = 0LL;
    v8 = 0x100000000LL;
    while ( *(_BYTE *)(v3 + v7) != 61 )
    {
      ++v7;
      v8 += 0x100000000LL;
      if ( v7 >= (unsigned int)v5 )
      {
        v6 = 0LL;
        goto LABEL_15;
      }
    }
    v6 = v8 >> 32;
    v9 = (int)v5 - 1 - (int)v7;
  }
  if ( (int)v4 >= 1 )
    LODWORD(v4) = v5 + 1;
  if ( a2 )
  {
    *a2 = v3;
    a2[1] = (int)v7;
  }
  if ( a3 )
  {
    *a3 = *a1 + v6;
    a3[1] = v9;
  }
  v10 = a1[1];
  *a1 += (int)v4;
  a1[1] = v10 - (int)v4;
  return (int)v4 > 0;
}

//----- (000000000001556C) ----------------------------------------------------
size_t (__fastcall *__fastcall mg_log_set_callback(
        size_t (__fastcall *result)(const void *a1, int a2),
        __int64 a2))(const void *a1, int a2)
{
  off_331E0 = result;
  qword_33518 = a2;
  return result;
}
// 331E0: using guessed type size_t (__fastcall *off_331E0)(const void *a1, int a2);
// 33518: using guessed type __int64 qword_33518;

//----- (0000000000015580) ----------------------------------------------------
__int64 __fastcall mg_mqtt_send_header(__int64 a1, char a2, char a3, unsigned int a4)
{
  _BYTE *v5; // x8
  char v6; // w11
  size_t v7; // x20
  __int64 v8; // x8
  unsigned __int64 v9; // x21
  unsigned __int64 v10; // x9
  __int64 result; // x0
  size_t v12; // x21
  int v13; // [xsp+Ch] [xbp-34h] BYREF
  char src; // [xsp+10h] [xbp-30h] BYREF
  _BYTE v15[15]; // [xsp+11h] [xbp-2Fh] BYREF

  v5 = v15;
  *(_QWORD *)&v15[7] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  src = a3 | (16 * a2);
  do
  {
    v6 = a4 & 0x7F;
    if ( a4 >> 7 )
      v6 = a4 | 0x80;
    *v5++ = v6;
    if ( !(a4 >> 7) )
      break;
    a4 >>= 7;
  }
  while ( v5 < &v15[4] );
  v7 = v5 - &src;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    result = sub_19A48(a1, &src, v7, &v13);
    LODWORD(v12) = result;
    if ( !v7 )
      return result;
    goto LABEL_10;
  }
  v8 = *(_QWORD *)(a1 + 104);
  v9 = (v7 + v8 + 512) & 0xFFFFFFFFFFFFFE00LL;
  if ( v9 == *(_QWORD *)(a1 + 96) )
  {
    v10 = (v7 + v8 + 512) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v7 + v8 + 512) & 0xFFFFFFFFFFFFFE00LL);
    v10 = *(_QWORD *)(a1 + 96);
    v8 = *(_QWORD *)(a1 + 104);
  }
  if ( v9 == v10 )
    v12 = v7;
  else
    v12 = 0LL;
  result = (__int64)memmove((void *)(*(_QWORD *)(a1 + 88) + v8), &src, v12);
  *(_QWORD *)(a1 + 104) += v12;
  if ( v7 )
  {
LABEL_10:
    if ( !(_DWORD)v12 )
      v13 = 1;
  }
  return result;
}

//----- (00000000000156A0) ----------------------------------------------------
__int64 __fastcall mg_mqtt_pub(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w22
  int v6; // w23
  __int64 v8; // x8
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x9
  size_t v11; // x22
  size_t v12; // x21
  void *v13; // x22
  __int64 v14; // x8
  unsigned __int64 v15; // x23
  unsigned __int64 v16; // x8
  size_t v17; // x23
  unsigned int v18; // w9
  __int64 v19; // x8
  unsigned __int64 v20; // x21
  unsigned __int64 v21; // x9
  __int64 result; // x0
  size_t v23; // x21
  size_t v24; // x20
  void *v25; // x21
  __int64 v26; // x8
  unsigned __int64 v27; // x22
  unsigned __int64 v28; // x8
  size_t v29; // x22
  __int16 v30[2]; // [xsp+0h] [xbp-40h] BYREF
  int v31; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v32; // [xsp+8h] [xbp-38h]

  v32 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a3 + 8);
  if ( (mg_log_prefix(
          3,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x754u,
          "mg_mqtt_pub") & 1) != 0 )
    mg_log("%lu [%.*s] -> [%.*s]");
  mg_mqtt_send_header(a1, 3, 2, v5 + v6 + 4);
  v30[0] = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(a1, v30, 2, &v31) )
      goto LABEL_11;
    goto LABEL_10;
  }
  v8 = *(_QWORD *)(a1 + 104);
  v9 = (v8 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v9 == *(_QWORD *)(a1 + 96) )
  {
    v10 = (v8 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v8 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v10 = *(_QWORD *)(a1 + 96);
    v8 = *(_QWORD *)(a1 + 104);
  }
  v11 = 2LL * (v9 == v10);
  memmove((void *)(*(_QWORD *)(a1 + 88) + v8), v30, v11);
  *(_QWORD *)(a1 + 104) += v11;
  if ( !(_DWORD)v11 )
LABEL_10:
    v31 = 1;
LABEL_11:
  v13 = *(void **)a2;
  v12 = *(_QWORD *)(a2 + 8);
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v17) = sub_19A48(a1, v13, v12, &v31);
    if ( !v12 )
      goto LABEL_17;
    goto LABEL_15;
  }
  v14 = v12 + *(_QWORD *)(a1 + 104) + 512;
  v15 = v14 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v14 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v16 = v14 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v14 & 0xFFFFFFFFFFFFFE00LL);
    v16 = *(_QWORD *)(a1 + 96);
  }
  if ( v15 == v16 )
    v17 = v12;
  else
    v17 = 0LL;
  if ( v13 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v13, v17);
  *(_QWORD *)(a1 + 104) += v17;
  if ( v12 )
  {
LABEL_15:
    if ( !(_DWORD)v17 )
      v31 = 1;
  }
LABEL_17:
  if ( word_33520 == -1 )
    v18 = 65537;
  else
    v18 = (unsigned __int16)word_33520 + 1;
  word_33520 = v18;
  v30[0] = bswap32(v18) >> 16;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    result = sub_19A48(a1, v30, 2, &v31);
    if ( (_DWORD)result )
      goto LABEL_36;
    goto LABEL_35;
  }
  v19 = *(_QWORD *)(a1 + 104);
  v20 = (v19 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v20 == *(_QWORD *)(a1 + 96) )
  {
    v21 = (v19 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v19 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v21 = *(_QWORD *)(a1 + 96);
    v19 = *(_QWORD *)(a1 + 104);
  }
  v23 = 2LL * (v20 == v21);
  result = (__int64)memmove((void *)(*(_QWORD *)(a1 + 88) + v19), v30, v23);
  *(_QWORD *)(a1 + 104) += v23;
  if ( !(_DWORD)v23 )
LABEL_35:
    v31 = 1;
LABEL_36:
  v25 = *(void **)a3;
  v24 = *(_QWORD *)(a3 + 8);
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    result = sub_19A48(a1, v25, v24, &v31);
    LODWORD(v29) = result;
    if ( !v24 )
      return result;
    goto LABEL_40;
  }
  v26 = v24 + *(_QWORD *)(a1 + 104) + 512;
  v27 = v26 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v26 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v28 = v26 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    result = mg_iobuf_resize(a1 + 88, v26 & 0xFFFFFFFFFFFFFE00LL);
    v28 = *(_QWORD *)(a1 + 96);
  }
  if ( v27 == v28 )
    v29 = v24;
  else
    v29 = 0LL;
  if ( v25 )
    result = (__int64)memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v25, v29);
  *(_QWORD *)(a1 + 104) += v29;
  if ( v24 )
  {
LABEL_40:
    if ( !(_DWORD)v29 )
      v31 = 1;
  }
  return result;
}
// 33520: using guessed type __int16 word_33520;

//----- (00000000000159E4) ----------------------------------------------------
void *__fastcall mg_mqtt_sub(__int64 a1, __int64 a2)
{
  unsigned int v4; // w9
  __int64 v5; // x8
  unsigned __int64 v6; // x21
  unsigned __int64 v7; // x9
  size_t v8; // x21
  __int64 v9; // x8
  unsigned __int64 v10; // x21
  unsigned __int64 v11; // x9
  size_t v12; // x21
  size_t v13; // x20
  void *v14; // x21
  __int64 v15; // x8
  unsigned __int64 v16; // x22
  unsigned __int64 v17; // x8
  size_t v18; // x22
  __int64 v19; // x8
  unsigned __int64 v20; // x20
  unsigned __int64 v21; // x22
  void *result; // x0
  __int64 v23; // x8
  char buf[4]; // [xsp+Ch] [xbp-44h] BYREF
  __int16 src[2]; // [xsp+10h] [xbp-40h] BYREF
  int v26; // [xsp+14h] [xbp-3Ch] BYREF
  __int64 v27; // [xsp+18h] [xbp-38h]

  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  buf[0] = 1;
  mg_mqtt_send_header(a1, 8, 2, *(_DWORD *)(a2 + 8) + 5);
  if ( word_33524 == -1 )
    v4 = 65537;
  else
    v4 = (unsigned __int16)word_33524 + 1;
  word_33524 = v4;
  src[0] = bswap32(v4) >> 16;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(a1, src, 2, &v26) )
      goto LABEL_12;
    goto LABEL_11;
  }
  v5 = *(_QWORD *)(a1 + 104);
  v6 = (v5 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v6 == *(_QWORD *)(a1 + 96) )
  {
    v7 = (v5 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v5 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v7 = *(_QWORD *)(a1 + 96);
    v5 = *(_QWORD *)(a1 + 104);
  }
  v8 = 2LL * (v6 == v7);
  memmove((void *)(*(_QWORD *)(a1 + 88) + v5), src, v8);
  *(_QWORD *)(a1 + 104) += v8;
  if ( !(_DWORD)v8 )
LABEL_11:
    v26 = 1;
LABEL_12:
  src[0] = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(a1, src, 2, &v26) )
      goto LABEL_20;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a1 + 104);
  v10 = (v9 + 514) & 0xFFFFFFFFFFFFFE00LL;
  if ( v10 == *(_QWORD *)(a1 + 96) )
  {
    v11 = (v9 + 514) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v9 + 514) & 0xFFFFFFFFFFFFFE00LL);
    v11 = *(_QWORD *)(a1 + 96);
    v9 = *(_QWORD *)(a1 + 104);
  }
  v12 = 2LL * (v10 == v11);
  memmove((void *)(*(_QWORD *)(a1 + 88) + v9), src, v12);
  *(_QWORD *)(a1 + 104) += v12;
  if ( !(_DWORD)v12 )
LABEL_19:
    v26 = 1;
LABEL_20:
  v14 = *(void **)a2;
  v13 = *(_QWORD *)(a2 + 8);
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v18) = sub_19A48(a1, v14, v13, &v26);
    if ( !v13 )
      goto LABEL_26;
    goto LABEL_24;
  }
  v15 = v13 + *(_QWORD *)(a1 + 104) + 512;
  v16 = v15 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v15 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v17 = v15 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v15 & 0xFFFFFFFFFFFFFE00LL);
    v17 = *(_QWORD *)(a1 + 96);
  }
  if ( v16 == v17 )
    v18 = v13;
  else
    v18 = 0LL;
  if ( v14 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v14, v18);
  *(_QWORD *)(a1 + 104) += v18;
  if ( v13 )
  {
LABEL_24:
    if ( !(_DWORD)v18 )
      v26 = 1;
  }
LABEL_26:
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
    return (void *)sub_19A48(a1, buf, 1, &v26);
  v19 = *(_QWORD *)(a1 + 104);
  v20 = (v19 + 513) & 0xFFFFFFFFFFFFFE00LL;
  if ( v20 == *(_QWORD *)(a1 + 96) )
  {
    v21 = (v19 + 513) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v19 + 513) & 0xFFFFFFFFFFFFFE00LL);
    v21 = *(_QWORD *)(a1 + 96);
    v19 = *(_QWORD *)(a1 + 104);
  }
  result = memmove((void *)(*(_QWORD *)(a1 + 88) + v19), buf, v20 == v21);
  v23 = *(_QWORD *)(a1 + 104);
  if ( v20 == v21 )
    ++v23;
  *(_QWORD *)(a1 + 104) = v23;
  return result;
}
// 33524: using guessed type __int16 word_33524;

//----- (0000000000015CD0) ----------------------------------------------------
__int64 __fastcall mg_mqtt_parse(_BYTE *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // x0
  char v4; // w8
  __int64 v5; // x13
  unsigned int v6; // w11
  int v7; // w14
  int v8; // w10
  _BYTE *v9; // x12
  char v10; // w15
  __int64 v11; // x9
  unsigned int v12; // w8
  unsigned __int64 v13; // x13
  unsigned __int8 v14; // w9
  char v15; // w9
  unsigned __int64 v16; // x8
  _BYTE *v17; // x11
  _BYTE *v18; // x8
  _BYTE *v19; // x9

  *(_QWORD *)(a3 + 48) = 0LL;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_QWORD *)(a3 + 32) = a1;
  if ( a2 < 2 )
    return 1LL;
  v4 = 0;
  v5 = 0LL;
  v6 = 0;
  v7 = (unsigned __int8)*a1 >> 4;
  *(_BYTE *)(a3 + 50) = *a1 >> 4;
  v8 = ((unsigned __int8)*a1 >> 1) & 3;
  *(_BYTE *)(a3 + 51) = (*a1 >> 1) & 3;
  do
  {
    v9 = &a1[v5];
    v10 = a1[v5 + 1];
    v11 = v5;
    v6 += (v10 & 0x7F) << v4;
    if ( (v10 & 0x80) == 0 )
      break;
    if ( (unsigned int)v5 > 2 )
      return 2LL;
    ++v5;
    v4 += 7;
  }
  while ( v9 + 2 - a1 < a2 );
  v12 = 1;
  if ( v10 < 0 )
    return v12;
  v13 = (unsigned __int64)&a1[v6 + 2 + v11];
  if ( v13 > (unsigned __int64)&a1[a2] )
    return v12;
  *(_QWORD *)(a3 + 40) = v6 + v11 + 2;
  switch ( v7 )
  {
    case 2:
      if ( v6 < 2 )
        return 2LL;
      v15 = a1[v11 + 3];
      result = 0LL;
      *(_BYTE *)(a3 + 52) = v15;
      return result;
    case 3:
      if ( v6 < 2 )
        return 2LL;
      v16 = (unsigned __int8)a1[v11 + 3] | ((unsigned __int64)(unsigned __int8)v9[2] << 8);
      *(_QWORD *)a3 = &a1[v11 + 4];
      *(_QWORD *)(a3 + 8) = v16;
      if ( v16 + 2 > v6 )
        return 2LL;
      v17 = &a1[v16 + v11];
      if ( v8 )
      {
        v18 = &a1[v16 + v11];
        v19 = v18 + 6;
        if ( (unsigned __int64)(v18 + 6) > v13 )
          return 2LL;
        *(_WORD *)(a3 + 48) = (unsigned __int8)v18[5] | ((unsigned __int8)v17[4] << 8);
LABEL_31:
        v12 = 0;
        *(_QWORD *)(a3 + 16) = v19;
        *(_QWORD *)(a3 + 24) = v13 - (_QWORD)v19;
        return v12;
      }
      v19 = v17 + 4;
      if ( (unsigned __int64)(v17 + 4) <= v13 )
        goto LABEL_31;
      result = 2LL;
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
      if ( v6 >= 2 )
        goto LABEL_20;
      return 2LL;
    case 8:
      if ( v6 < 2 )
        return 2LL;
LABEL_20:
      v14 = a1[v11 + 3];
      result = 0LL;
      *(_WORD *)(a3 + 48) = v14 | ((unsigned __int8)v9[2] << 8);
      return result;
    default:
      return 0LL;
  }
  return result;
}

//----- (0000000000015EE4) ----------------------------------------------------
__int64 __fastcall mg_mqtt_next_sub(__int64 a1, _QWORD *a2, _BYTE *a3, int a4)
{
  unsigned __int8 *v4; // x8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x10
  __int64 result; // x0

  if ( *(_QWORD *)(a1 + 40) <= (unsigned __int64)a4 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int8 *)(*(_QWORD *)(a1 + 32) + a4);
  v5 = v4[1] | ((unsigned __int64)*v4 << 8);
  *a2 = v4 + 2;
  a2[1] = v5;
  v6 = *(_QWORD *)(a1 + 40);
  result = (unsigned int)(a4 + v5 + 3);
  if ( v6 < (int)result )
    return 0xFFFFFFFFLL;
  *a3 = v4[v5 + 2];
  return result;
}

//----- (0000000000015F44) ----------------------------------------------------
__int64 __fastcall mg_mqtt_ping(__int64 a1)
{
  return mg_mqtt_send_header(a1, 12, 0, 0);
}

//----- (0000000000015F54) ----------------------------------------------------
__int64 __fastcall mg_mqtt_pong(__int64 a1)
{
  return mg_mqtt_send_header(a1, 13, 0, 0);
}

//----- (0000000000015F64) ----------------------------------------------------
__int64 __fastcall mg_mqtt_disconnect(__int64 a1)
{
  return mg_mqtt_send_header(a1, 14, 0, 0);
}

//----- (0000000000015F74) ----------------------------------------------------
__int64 __fastcall mg_mqtt_connect(__int64 a1, char *a2, __int128 *a3, __int64 a4, __int64 a5)
{
  __int64 v7; // x19
  __int128 *v8; // x28
  __int16 v9; // w8
  char v10; // w10
  int v11; // w12
  int v12; // w13
  int v13; // w11
  int v14; // w15
  int v15; // w0
  __int64 v16; // x14
  char *v17; // x9
  char v18; // w16
  char *v19; // x16
  size_t v20; // x23
  int v21; // w20
  size_t v22; // x21
  int v23; // w22
  int v24; // w9
  char *v25; // x13
  __int64 v26; // x11
  __int64 v27; // x10
  int v28; // w11
  int v29; // w12
  int v30; // w14
  __int64 v31; // x13
  __int64 v32; // x8
  unsigned __int64 v33; // x24
  unsigned __int64 v34; // x9
  size_t v35; // x24
  __int64 v36; // x8
  unsigned __int64 v37; // x24
  unsigned __int64 v38; // x26
  __int64 v39; // x8
  __int64 v40; // x8
  unsigned __int64 v41; // x24
  unsigned __int64 v42; // x9
  size_t v43; // x24
  __int64 v44; // x8
  unsigned __int64 v45; // x24
  unsigned __int64 v46; // x9
  size_t v47; // x24
  size_t v48; // x24
  const void *v49; // x25
  __int64 v50; // x8
  unsigned __int64 v51; // x26
  unsigned __int64 v52; // x8
  size_t v53; // x26
  __int64 v54; // x8
  unsigned __int64 v55; // x24
  unsigned __int64 v56; // x9
  size_t v57; // x24
  size_t v58; // x24
  const void *v59; // x25
  __int64 v60; // x8
  unsigned __int64 v61; // x26
  unsigned __int64 v62; // x8
  size_t v63; // x26
  __int64 v64; // x8
  unsigned __int64 v65; // x24
  unsigned __int64 v66; // x9
  size_t v67; // x24
  size_t v68; // x24
  const void *v69; // x25
  __int64 v70; // x8
  unsigned __int64 v71; // x26
  unsigned __int64 v72; // x8
  size_t v73; // x26
  __int64 v74; // x8
  unsigned __int64 v75; // x24
  unsigned __int64 v76; // x9
  size_t v77; // x24
  __int64 v78; // x8
  unsigned __int64 v79; // x24
  unsigned __int64 v80; // x8
  __int64 v81; // x8
  unsigned __int64 v82; // x22
  unsigned __int64 v83; // x9
  size_t v84; // x22
  __int64 v85; // x8
  unsigned __int64 v86; // x22
  unsigned __int64 v87; // x8
  char *v89; // [xsp+0h] [xbp-B0h]
  char *v90; // [xsp+8h] [xbp-A8h]
  __int128 v91[3]; // [xsp+10h] [xbp-A0h] BYREF
  __int64 v92; // [xsp+40h] [xbp-70h]
  __int16 src[2]; // [xsp+4Ch] [xbp-64h] BYREF
  __int16 buf[2]; // [xsp+50h] [xbp-60h] BYREF
  int v95; // [xsp+54h] [xbp-5Ch] BYREF
  __int64 v96; // [xsp+58h] [xbp-58h]

  v96 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = mg_connect(a1, a2, a4, a5);
  if ( !v7 )
    return v7;
  v92 = 0LL;
  memset(v91, 0, sizeof(v91));
  if ( a3 )
    v8 = a3;
  else
    v8 = v91;
  v9 = 8 * (v8[3] & 3);
  src[0] = v9;
  v10 = *a2;
  if ( !*a2 )
  {
    v19 = "";
    v21 = 0;
    v20 = 0LL;
    v22 = 0LL;
    v23 = 0;
    v24 = 12;
    v25 = "";
    v26 = *((_QWORD *)v8 + 3);
    if ( !v26 )
      goto LABEL_45;
    goto LABEL_23;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0LL;
  v17 = a2 - 1;
  v18 = *a2;
  do
  {
    if ( v16 && v18 == 47 && v17[v16] == 47 )
    {
      v11 = v16 + 1;
      v14 = 0;
      v15 = v16 + 1;
      goto LABEL_17;
    }
    switch ( v18 )
    {
      case ']':
        goto LABEL_16;
      case '@':
        v11 = v16 + 1;
        v12 = v14;
        v13 = v15;
        v15 = v16 + 1;
LABEL_16:
        v14 = 0;
        break;
      case ':':
        v14 = v16 + 1;
        break;
    }
LABEL_17:
    v18 = a2[(unsigned int)++v16];
  }
  while ( v18 );
  if ( v13 && (v12 || (v12 = v11) != 0) )
  {
    v19 = &a2[v13];
    v20 = v12 + ~v13;
  }
  else
  {
    v20 = 0LL;
    v19 = "";
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0LL;
  while ( 2 )
  {
    if ( v31 && v10 == 47 && v17[v31] == 47 )
    {
      v30 = 0;
      v28 = v31 + 1;
      goto LABEL_38;
    }
    switch ( v10 )
    {
      case ']':
        goto LABEL_37;
      case '@':
        v28 = v31 + 1;
        v29 = v30;
LABEL_37:
        v30 = 0;
        break;
      case ':':
        v30 = v31 + 1;
        break;
    }
LABEL_38:
    v10 = a2[(unsigned int)++v31];
    if ( v10 )
      continue;
    break;
  }
  v22 = 0LL;
  v25 = "";
  if ( v28 && v29 )
  {
    v25 = &a2[v29];
    v22 = v28 + ~v29;
  }
  if ( !v20 )
  {
    v23 = 0;
    v24 = 12;
    if ( !v22 )
      goto LABEL_108;
LABEL_44:
    v9 |= 0x40u;
    v24 += v22 + 2;
    v21 = 1;
    src[0] = v9;
    v26 = *((_QWORD *)v8 + 3);
    if ( v26 )
      goto LABEL_23;
LABEL_45:
    if ( !*((_BYTE *)v8 + 50) )
      goto LABEL_47;
    goto LABEL_46;
  }
  v24 = v20 + 14;
  v9 |= 0x80u;
  v23 = 1;
  src[0] = v9;
  if ( v22 )
    goto LABEL_44;
LABEL_108:
  v21 = 0;
  v26 = *((_QWORD *)v8 + 3);
  if ( !v26 )
    goto LABEL_45;
LABEL_23:
  v27 = *((_QWORD *)v8 + 5);
  if ( !v27 )
    goto LABEL_45;
  v9 |= 4u;
  v24 += v26 + v27 + 4;
  src[0] = v9;
  if ( *((_BYTE *)v8 + 50) )
  {
LABEL_46:
    v9 |= 2u;
    src[0] = v9;
    goto LABEL_48;
  }
LABEL_47:
  if ( !*((_QWORD *)v8 + 1) )
    goto LABEL_46;
LABEL_48:
  v89 = v19;
  v90 = v25;
  if ( *((_BYTE *)v8 + 49) )
    src[0] = v9 | 0x20;
  mg_mqtt_send_header(v7, 1, 0, v24 + *((_DWORD *)v8 + 2));
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(v7, &unk_1DEE8, 7, &v95) )
      goto LABEL_60;
  }
  else
  {
    v32 = *(_QWORD *)(v7 + 104);
    v33 = (v32 + 519) & 0xFFFFFFFFFFFFFE00LL;
    if ( v33 == *(_QWORD *)(v7 + 96) )
    {
      v34 = (v32 + 519) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v32 + 519) & 0xFFFFFFFFFFFFFE00LL);
      v34 = *(_QWORD *)(v7 + 96);
      v32 = *(_QWORD *)(v7 + 104);
    }
    if ( v33 == v34 )
      v35 = 7LL;
    else
      v35 = 0LL;
    memcpy((void *)(*(_QWORD *)(v7 + 88) + v32), &unk_1DEE8, v35);
    *(_QWORD *)(v7 + 104) += v35;
    if ( (_DWORD)v35 )
    {
LABEL_60:
      if ( (*(_BYTE *)(v7 + 208) & 0x80) == 0 )
        goto LABEL_61;
LABEL_64:
      if ( !(unsigned int)sub_19A48(v7, src, 1, &v95) )
        goto LABEL_70;
      goto LABEL_71;
    }
  }
  v95 = 1;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
    goto LABEL_64;
LABEL_61:
  v36 = *(_QWORD *)(v7 + 104);
  v37 = (v36 + 513) & 0xFFFFFFFFFFFFFE00LL;
  if ( v37 == *(_QWORD *)(v7 + 96) )
  {
    v38 = (v36 + 513) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, (v36 + 513) & 0xFFFFFFFFFFFFFE00LL);
    v38 = *(_QWORD *)(v7 + 96);
    v36 = *(_QWORD *)(v7 + 104);
  }
  memmove((void *)(*(_QWORD *)(v7 + 88) + v36), src, v37 == v38);
  v39 = *(_QWORD *)(v7 + 104);
  if ( v37 == v38 )
    ++v39;
  *(_QWORD *)(v7 + 104) = v39;
  if ( v37 != v38 )
LABEL_70:
    v95 = 1;
LABEL_71:
  buf[0] = bswap32(*((unsigned __int16 *)v8 + 26)) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( !(unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_78;
  }
  else
  {
    v40 = *(_QWORD *)(v7 + 104);
    v41 = (v40 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v41 == *(_QWORD *)(v7 + 96) )
    {
      v42 = (v40 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v40 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v42 = *(_QWORD *)(v7 + 96);
      v40 = *(_QWORD *)(v7 + 104);
    }
    v43 = 2LL * (v41 == v42);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v40), buf, v43);
    *(_QWORD *)(v7 + 104) += v43;
    if ( !(_DWORD)v43 )
LABEL_78:
      v95 = 1;
  }
  buf[0] = bswap32(*((unsigned __int16 *)v8 + 4)) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( !(unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_86;
  }
  else
  {
    v44 = *(_QWORD *)(v7 + 104);
    v45 = (v44 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v45 == *(_QWORD *)(v7 + 96) )
    {
      v46 = (v44 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v44 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v46 = *(_QWORD *)(v7 + 96);
      v44 = *(_QWORD *)(v7 + 104);
    }
    v47 = 2LL * (v45 == v46);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v44), buf, v47);
    *(_QWORD *)(v7 + 104) += v47;
    if ( !(_DWORD)v47 )
LABEL_86:
      v95 = 1;
  }
  v49 = *(const void **)v8;
  v48 = *((_QWORD *)v8 + 1);
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    LODWORD(v53) = sub_19A48(v7, *(void **)v8, v48, &v95);
    if ( !v48 )
      goto LABEL_93;
    goto LABEL_91;
  }
  v50 = v48 + *(_QWORD *)(v7 + 104) + 512;
  v51 = v50 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v50 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v7 + 96) )
  {
    v52 = v50 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, v50 & 0xFFFFFFFFFFFFFE00LL);
    v52 = *(_QWORD *)(v7 + 96);
  }
  if ( v51 == v52 )
    v53 = v48;
  else
    v53 = 0LL;
  if ( v49 )
    memmove((void *)(*(_QWORD *)(v7 + 88) + *(_QWORD *)(v7 + 104)), v49, v53);
  *(_QWORD *)(v7 + 104) += v53;
  if ( v48 )
  {
LABEL_91:
    if ( !(_DWORD)v53 )
      v95 = 1;
  }
LABEL_93:
  if ( (src[0] & 4) == 0 )
    goto LABEL_141;
  buf[0] = bswap32(*((unsigned __int16 *)v8 + 12)) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( !(unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_112;
  }
  else
  {
    v54 = *(_QWORD *)(v7 + 104);
    v55 = (v54 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v55 == *(_QWORD *)(v7 + 96) )
    {
      v56 = (v54 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v54 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v56 = *(_QWORD *)(v7 + 96);
      v54 = *(_QWORD *)(v7 + 104);
    }
    v57 = 2LL * (v55 == v56);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v54), buf, v57);
    *(_QWORD *)(v7 + 104) += v57;
    if ( !(_DWORD)v57 )
LABEL_112:
      v95 = 1;
  }
  v59 = (const void *)*((_QWORD *)v8 + 2);
  v58 = *((_QWORD *)v8 + 3);
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    LODWORD(v63) = sub_19A48(v7, *((void **)v8 + 2), v58, &v95);
    if ( !v58 )
      goto LABEL_119;
    goto LABEL_117;
  }
  v60 = v58 + *(_QWORD *)(v7 + 104) + 512;
  v61 = v60 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v60 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v7 + 96) )
  {
    v62 = v60 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, v60 & 0xFFFFFFFFFFFFFE00LL);
    v62 = *(_QWORD *)(v7 + 96);
  }
  if ( v61 == v62 )
    v63 = v58;
  else
    v63 = 0LL;
  if ( v59 )
    memmove((void *)(*(_QWORD *)(v7 + 88) + *(_QWORD *)(v7 + 104)), v59, v63);
  *(_QWORD *)(v7 + 104) += v63;
  if ( v58 )
  {
LABEL_117:
    if ( !(_DWORD)v63 )
      v95 = 1;
  }
LABEL_119:
  buf[0] = bswap32(*((unsigned __int16 *)v8 + 20)) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( !(unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_134;
  }
  else
  {
    v64 = *(_QWORD *)(v7 + 104);
    v65 = (v64 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v65 == *(_QWORD *)(v7 + 96) )
    {
      v66 = (v64 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v64 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v66 = *(_QWORD *)(v7 + 96);
      v64 = *(_QWORD *)(v7 + 104);
    }
    v67 = 2LL * (v65 == v66);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v64), buf, v67);
    *(_QWORD *)(v7 + 104) += v67;
    if ( !(_DWORD)v67 )
LABEL_134:
      v95 = 1;
  }
  v69 = (const void *)*((_QWORD *)v8 + 4);
  v68 = *((_QWORD *)v8 + 5);
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    LODWORD(v73) = sub_19A48(v7, *((void **)v8 + 4), v68, &v95);
    if ( !v68 )
      goto LABEL_141;
    goto LABEL_139;
  }
  v70 = v68 + *(_QWORD *)(v7 + 104) + 512;
  v71 = v70 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v70 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v7 + 96) )
  {
    v72 = v70 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, v70 & 0xFFFFFFFFFFFFFE00LL);
    v72 = *(_QWORD *)(v7 + 96);
  }
  if ( v71 == v72 )
    v73 = v68;
  else
    v73 = 0LL;
  if ( v69 )
    memmove((void *)(*(_QWORD *)(v7 + 88) + *(_QWORD *)(v7 + 104)), v69, v73);
  *(_QWORD *)(v7 + 104) += v73;
  if ( v68 )
  {
LABEL_139:
    if ( !(_DWORD)v73 )
      v95 = 1;
  }
LABEL_141:
  if ( !v23 )
    goto LABEL_170;
  buf[0] = bswap32(v20) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_157;
  }
  else
  {
    v74 = *(_QWORD *)(v7 + 104);
    v75 = (v74 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v75 == *(_QWORD *)(v7 + 96) )
    {
      v76 = (v74 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v74 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v76 = *(_QWORD *)(v7 + 96);
      v74 = *(_QWORD *)(v7 + 104);
    }
    v77 = 2LL * (v75 == v76);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v74), buf, v77);
    *(_QWORD *)(v7 + 104) += v77;
    if ( (_DWORD)v77 )
    {
LABEL_157:
      if ( (*(_BYTE *)(v7 + 208) & 0x80) == 0 )
        goto LABEL_158;
LABEL_161:
      if ( !(unsigned int)sub_19A48(v7, v89, v20, &v95) )
        goto LABEL_169;
      goto LABEL_170;
    }
  }
  v95 = 1;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
    goto LABEL_161;
LABEL_158:
  v78 = v20 + *(_QWORD *)(v7 + 104) + 512;
  v79 = v78 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v78 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v7 + 96) )
  {
    v80 = v78 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, v78 & 0xFFFFFFFFFFFFFE00LL);
    v80 = *(_QWORD *)(v7 + 96);
  }
  if ( v79 != v80 )
    v20 = 0LL;
  if ( v89 )
    memmove((void *)(*(_QWORD *)(v7 + 88) + *(_QWORD *)(v7 + 104)), v89, v20);
  *(_QWORD *)(v7 + 104) += v20;
  if ( !(_DWORD)v20 )
LABEL_169:
    v95 = 1;
LABEL_170:
  if ( !v21 )
    goto LABEL_191;
  buf[0] = bswap32(v22) >> 16;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(v7, buf, 2, &v95) )
      goto LABEL_178;
  }
  else
  {
    v81 = *(_QWORD *)(v7 + 104);
    v82 = (v81 + 514) & 0xFFFFFFFFFFFFFE00LL;
    if ( v82 == *(_QWORD *)(v7 + 96) )
    {
      v83 = (v81 + 514) & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v7 + 88, (v81 + 514) & 0xFFFFFFFFFFFFFE00LL);
      v83 = *(_QWORD *)(v7 + 96);
      v81 = *(_QWORD *)(v7 + 104);
    }
    v84 = 2LL * (v82 == v83);
    memmove((void *)(*(_QWORD *)(v7 + 88) + v81), buf, v84);
    *(_QWORD *)(v7 + 104) += v84;
    if ( (_DWORD)v84 )
    {
LABEL_178:
      if ( (*(_BYTE *)(v7 + 208) & 0x80) == 0 )
        goto LABEL_179;
LABEL_182:
      if ( !(unsigned int)sub_19A48(v7, v90, v22, &v95) )
        goto LABEL_190;
      goto LABEL_191;
    }
  }
  v95 = 1;
  if ( (*(_BYTE *)(v7 + 208) & 0x80) != 0 )
    goto LABEL_182;
LABEL_179:
  v85 = v22 + *(_QWORD *)(v7 + 104) + 512;
  v86 = v85 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v85 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v7 + 96) )
  {
    v87 = v85 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(v7 + 88, v85 & 0xFFFFFFFFFFFFFE00LL);
    v87 = *(_QWORD *)(v7 + 96);
  }
  if ( v86 != v87 )
    v22 = 0LL;
  if ( v90 )
    memmove((void *)(*(_QWORD *)(v7 + 88) + *(_QWORD *)(v7 + 104)), v90, v22);
  *(_QWORD *)(v7 + 104) += v22;
  if ( !(_DWORD)v22 )
LABEL_190:
    v95 = 1;
LABEL_191:
  *(_QWORD *)(v7 + 128) = sub_16A54;
  return v7;
}

//----- (0000000000016A54) ----------------------------------------------------
void __fastcall sub_16A54(__int64 a1, int a2)
{
  unsigned __int64 i; // x1
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x28
  int v6; // w0
  void (__fastcall *v7)(__int64, __int64, char *, _QWORD); // x8
  void (__fastcall *v8)(__int64, __int64, char *, _QWORD); // x8
  void (__fastcall *v9)(__int64, __int64, __int64 *, _QWORD); // x8
  void (__fastcall *v10)(__int64, __int64, __int64 *, _QWORD); // x8
  void (__fastcall *v11)(__int64, __int64, __int64 *, _QWORD); // x8
  void (__fastcall *v12)(__int64, __int64, __int64 *, _QWORD); // x8
  __int64 v13; // [xsp+0h] [xbp-90h] BYREF
  unsigned __int64 v14; // [xsp+28h] [xbp-68h]
  char v15; // [xsp+32h] [xbp-5Eh]
  char v16[4]; // [xsp+34h] [xbp-5Ch] BYREF
  __int64 v17; // [xsp+38h] [xbp-58h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 != 5 )
    return;
  for ( i = *(_QWORD *)(a1 + 80); ; *(_QWORD *)(a1 + 80) = i )
  {
    v6 = mg_mqtt_parse(*(_BYTE **)(a1 + 64), i, (__int64)&v13);
    if ( v6 )
      break;
    if ( (mg_log_prefix(
            4,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x7C9u,
            "mqtt_cb") & 1) != 0 )
      mg_log("%p MQTT CMD %d len %d [%.*s]");
    if ( v15 == 3 )
    {
      if ( (mg_log_prefix(
              3,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x7D6u,
              "mqtt_cb") & 1) != 0 )
        mg_log("%lu [%.*s] -> [%.*s]");
      v10 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 128);
      if ( v10 )
        v10(a1, 13LL, &v13, *(_QWORD *)(a1 + 136));
      v11 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 112);
      if ( !v11 )
        goto LABEL_30;
      v11(a1, 13LL, &v13, *(_QWORD *)(a1 + 120));
      v9 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 128);
      if ( v9 )
        goto LABEL_31;
    }
    else
    {
      if ( v15 != 2 )
        goto LABEL_30;
      v7 = *(void (__fastcall **)(__int64, __int64, char *, _QWORD))(a1 + 128);
      if ( v7 )
        v7(a1, 14LL, v16, *(_QWORD *)(a1 + 136));
      v8 = *(void (__fastcall **)(__int64, __int64, char *, _QWORD))(a1 + 112);
      if ( v8 )
        v8(a1, 14LL, v16, *(_QWORD *)(a1 + 120));
      if ( !v16[0] )
      {
        if ( (mg_log_prefix(
                2,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0x7CEu,
                "mqtt_cb") & 1) != 0 )
          mg_log("%lu Connected");
LABEL_30:
        v9 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 128);
        if ( !v9 )
          goto LABEL_32;
LABEL_31:
        v9(a1, 12LL, &v13, *(_QWORD *)(a1 + 136));
        goto LABEL_32;
      }
      if ( (mg_log_prefix(
              1,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x7D0u,
              "mqtt_cb") & 1) != 0 )
        mg_log("%lu MQTT auth failed, code %d");
      *(_WORD *)(a1 + 208) |= 0x800u;
      v9 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 128);
      if ( v9 )
        goto LABEL_31;
    }
LABEL_32:
    v12 = *(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(a1 + 112);
    if ( v12 )
      v12(a1, 12LL, &v13, *(_QWORD *)(a1 + 120));
    v4 = *(_QWORD *)(a1 + 80);
    if ( v4 >= v14 )
      v5 = v14;
    else
      v5 = 0LL;
    memmove(*(void **)(a1 + 64), (const void *)(*(_QWORD *)(a1 + 64) + v5), v4 - v5);
    i = *(_QWORD *)(a1 + 80) - v5;
  }
  if ( v6 == 2 )
  {
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x7C3u,
            "mqtt_cb") & 1) != 0 )
      mg_log("%lu MQTT malformed message");
    *(_WORD *)(a1 + 208) |= 0x800u;
  }
}

//----- (0000000000016D20) ----------------------------------------------------
_QWORD *__fastcall mg_mqtt_listen(_QWORD *a1, char *a2, __int64 a3, __int64 a4)
{
  _QWORD *result; // x0

  result = mg_listen(a1, a2, a3, a4);
  if ( result )
  {
    result[16] = sub_16A54;
    result[17] = a1;
  }
  return result;
}

//----- (0000000000016D50) ----------------------------------------------------
__int64 __fastcall mg_vprintf(__int64 a1, const char *a2, __int128 *a3)
{
  __int128 v4; // q0
  int v5; // w0
  char *v6; // x20
  size_t v7; // x21
  __int64 v8; // x8
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x8
  size_t v11; // x22
  __int128 v13[2]; // [xsp+0h] [xbp-170h] BYREF
  void *src; // [xsp+28h] [xbp-148h] BYREF
  int v15; // [xsp+34h] [xbp-13Ch] BYREF
  char v16[256]; // [xsp+38h] [xbp-138h] BYREF
  __int64 v17; // [xsp+138h] [xbp-38h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  src = v16;
  v4 = a3[1];
  v13[0] = *a3;
  v13[1] = v4;
  v5 = mg_vasprintf((char **)&src, 0x100uLL, a2, v13);
  v6 = (char *)src;
  v7 = v5;
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v11) = sub_19A48(a1, src, v5, &v15);
    if ( !(_DWORD)v7 )
      goto LABEL_7;
    goto LABEL_5;
  }
  v8 = v5 + *(_QWORD *)(a1 + 104) + 512LL;
  v9 = v8 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v8 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v10 = v8 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v8 & 0xFFFFFFFFFFFFFE00LL);
    v10 = *(_QWORD *)(a1 + 96);
  }
  if ( v9 == v10 )
    v11 = v7;
  else
    v11 = 0LL;
  if ( v6 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), v6, v11);
  *(_QWORD *)(a1 + 104) += v11;
  if ( (_DWORD)v7 )
  {
LABEL_5:
    if ( !(_DWORD)v11 )
      v15 = 1;
  }
LABEL_7:
  if ( v6 != v16 )
    free(v6);
  return (unsigned int)v11;
}

//----- (0000000000016E84) ----------------------------------------------------
char *__fastcall mg_straddr(__int64 a1, char *a2, size_t a3)
{
  int v4; // w8
  __int64 v7; // x0
  const char *v8; // x22
  char s[100]; // [xsp+4h] [xbp-9Ch] BYREF
  __int64 v11; // [xsp+68h] [xbp-38h]

  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(unsigned __int8 *)(a1 + 40);
  v7 = a1 + 16;
  if ( v4 )
    v8 = "[%s]:%d";
  else
    v8 = "%s:%d";
  mg_ntoa(v7, s, 0x64uLL);
  snprintf(a2, a3, v8, s, bswap32(*(unsigned __int16 *)(a1 + 16)) >> 16);
  return a2;
}

//----- (0000000000016F30) ----------------------------------------------------
char *__fastcall mg_ntoa(__int64 a1, char *s, size_t maxlen)
{
  unsigned int v5; // [xsp+0h] [xbp-30h]
  unsigned int v6; // [xsp+8h] [xbp-28h]
  unsigned int v7; // [xsp+10h] [xbp-20h]

  if ( *(_BYTE *)(a1 + 24) )
  {
    v7 = bswap32(*(unsigned __int16 *)(a1 + 22)) >> 16;
    v6 = bswap32(*(unsigned __int16 *)(a1 + 20)) >> 16;
    v5 = bswap32(*(unsigned __int16 *)(a1 + 18)) >> 16;
    snprintf(
      s,
      maxlen,
      "%x:%x:%x:%x:%x:%x:%x:%x",
      bswap32(*(unsigned __int16 *)(a1 + 8)) >> 16,
      bswap32(*(unsigned __int16 *)(a1 + 10)) >> 16,
      bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16,
      bswap32(*(unsigned __int16 *)(a1 + 14)) >> 16,
      bswap32(*(unsigned __int16 *)(a1 + 16)) >> 16,
      v5,
      v6,
      v7);
  }
  else
  {
    snprintf(
      s,
      maxlen,
      "%d.%d.%d.%d",
      *(unsigned __int8 *)(a1 + 4),
      *(unsigned __int8 *)(a1 + 5),
      *(unsigned __int8 *)(a1 + 6),
      *(unsigned __int8 *)(a1 + 7));
  }
  return s;
}

//----- (000000000001700C) ----------------------------------------------------
void __fastcall mg_mgr_free(__int64 *a1)
{
  __int64 i; // x8

  for ( i = *a1; i; i = *(_QWORD *)i )
    *(_WORD *)(i + 208) |= 0x800u;
  mg_mgr_poll(a1, 0);
  if ( (mg_log_prefix(
          2,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x881u,
          "mg_mgr_free") & 1) != 0 )
    mg_log("All connections closed");
}

//----- (000000000001706C) ----------------------------------------------------
void __fastcall mg_mgr_poll(__int64 *a1, int a2)
{
  __int64 v2; // x19
  __int64 *v3; // x28
  int v4; // w20
  __int64 v5; // x0
  __int64 v6; // x0
  __int16 v7; // w8
  __int64 i; // x19
  int v9; // w8
  __int16 v10; // w9
  __int64 v11; // x0
  int v12; // w0
  __int64 v13; // x0
  __int16 v14; // w8
  int v15; // w0
  __int16 v16; // w9
  __int64 v17; // x20
  unsigned __int64 v18; // x19
  __int64 v19; // x9
  int *v20; // x22
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  char v25; // w11
  __int64 *v26; // x10
  __int64 v27; // x9
  __int64 *v28; // x8
  __int64 v29; // x20
  int v30; // w0
  __int64 v31; // x26
  void (__fastcall *v32)(__int64, __int64, _QWORD, _QWORD); // x8
  void **v33; // x23
  int v34; // w0
  unsigned __int64 v35; // x9
  __int64 v36; // x24
  __int64 v37; // x8
  void (__fastcall *v38)(__int64, __int64, fd_set *, _QWORD); // x8
  void (__fastcall *v39)(__int64, __int64, fd_set *, __int64); // x8
  __int64 v40; // x3
  __int64 v41; // x1
  fd_set *p_writefds; // x2
  __int64 v43; // x0
  const char *v44; // x24
  unsigned __int16 v45; // w8
  __int64 v46; // x0
  _QWORD *v47; // x0
  __int64 *v48; // x9
  __int64 v49; // x24
  __int64 v50; // x28
  unsigned int v51; // w23
  int tv_sec_high; // w8
  __int64 *v53; // x25
  int v54; // w0
  void (__fastcall *v55)(__int64, __int64, _QWORD); // x8
  __int128 v56; // q0
  void (__fastcall *v57)(__int64, __int64, _QWORD, _QWORD); // x8
  unsigned __int64 v58; // x9
  int v59; // w0
  int v60; // w8
  __int64 v61; // x9
  void *v62; // x1
  __int64 v63; // x9
  ssize_t v64; // x0
  int v65; // w24
  int v66; // w0
  int tv_sec; // w8
  void (__fastcall *v68)(__int64, __int64, _QWORD, _QWORD); // x8
  __int64 v69; // x0
  char *v70; // x23
  void (__fastcall *v71)(__int64, __int64, fd_set *, _QWORD); // x8
  void (__fastcall *v72)(__int64, __int64, fd_set *, _QWORD); // x8
  int v73; // w8
  void (__fastcall *v74)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  __int64 v75; // x27
  void (__fastcall *v76)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  unsigned __int16 *v77; // x19
  _QWORD *v78; // x8
  _QWORD *v79; // x9
  __int64 *v80; // x0
  __int64 *v81; // x19
  __int64 *v82; // x9
  __int64 *v83; // x8
  __int64 v84; // x8
  void (__fastcall *v85)(__int64, __int64, _QWORD, _QWORD); // x8
  int v86; // w0
  int v87; // [xsp+24h] [xbp-19Ch]
  __int64 v88; // [xsp+28h] [xbp-198h]
  unsigned __int64 v89; // [xsp+40h] [xbp-180h] BYREF
  socklen_t addr_len; // [xsp+4Ch] [xbp-174h] BYREF
  fd_set writefds; // [xsp+50h] [xbp-170h] BYREF
  fd_set readfds; // [xsp+D0h] [xbp-F0h] BYREF
  struct timeval timeout; // [xsp+150h] [xbp-70h] BYREF
  __int64 v94; // [xsp+160h] [xbp-60h]

  v94 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  timeout.tv_sec = a2 / 1000;
  memset(&readfds, 0, sizeof(readfds));
  memset(&writefds, 0, sizeof(writefds));
  timeout.tv_usec = 1000 * (a2 % 1000);
  v2 = *a1;
  v3 = a1;
  if ( *a1 )
  {
    v4 = 0;
    do
    {
      if ( (*(_WORD *)(v2 + 208) & 0x808) == 0 )
      {
        v5 = *(unsigned int *)(v2 + 48);
        if ( (_DWORD)v5 != -1 )
        {
          __FD_SET_chk(v5, &readfds, 128LL);
          v6 = *(unsigned int *)(v2 + 48);
          v7 = *(_WORD *)(v2 + 208);
          if ( v4 < (int)v6 )
            v4 = *(_DWORD *)(v2 + 48);
          if ( (v7 & 0x10) != 0 || (v7 & 0x40) == 0 && *(_QWORD *)(v2 + 104) )
            __FD_SET_chk(v6, &writefds, 128LL);
        }
      }
      v2 = *(_QWORD *)v2;
    }
    while ( v2 );
  }
  else
  {
    v4 = 0;
  }
  if ( select(v4 + 1, &readfds, &writefds, 0LL, &timeout) < 0 )
  {
    if ( (mg_log_prefix(
            3,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0xBE2u,
            "mg_iotest") & 1) != 0 )
    {
      ((void (*)(void))__errno)();
      mg_log("select: %d %d");
    }
    memset(&readfds, 0, sizeof(readfds));
    memset(&writefds, 0, sizeof(writefds));
  }
  for ( i = *v3; i; i = *(_QWORD *)i )
  {
    v9 = *(unsigned __int16 *)(i + 208);
    if ( (~v9 & 0x1020) != 0 )
    {
      v11 = *(unsigned int *)(i + 48);
      if ( (_DWORD)v11 == -1 )
      {
        v10 = 0;
      }
      else
      {
        v12 = __FD_ISSET_chk(v11, &readfds, 128LL);
        LOWORD(v9) = *(_WORD *)(i + 208);
        v10 = v12 != 0;
      }
    }
    else
    {
      v10 = 1;
    }
    v13 = *(unsigned int *)(i + 48);
    v14 = v9 & 0xEFFF | (v10 << 12);
    *(_WORD *)(i + 208) = v14;
    if ( (_DWORD)v13 == -1 )
    {
      v16 = 0;
    }
    else
    {
      v15 = __FD_ISSET_chk(v13, &writefds, 128LL);
      v14 = *(_WORD *)(i + 208);
      v16 = v15 != 0;
    }
    *(_WORD *)(i + 208) = v14 & 0xDFFF | (v16 << 13);
  }
  clock_gettime(0, (struct timespec *)&readfds);
  v17 = g_timers;
  v18 = readfds.fds_bits[1] / 1000000 + 1000 * readfds.fds_bits[0];
  v89 = v18;
  if ( qword_33530 <= v18 )
    goto LABEL_32;
  if ( !g_timers )
  {
    qword_33530 = readfds.fds_bits[1] / 1000000 + 1000 * readfds.fds_bits[0];
    v29 = *v3;
    if ( !*v3 )
      return;
    while ( 1 )
    {
LABEL_143:
      v74 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(v29 + 128);
      v75 = *(_QWORD *)v29;
      if ( v74 )
        v74(v29, 1LL, &v89, *(_QWORD *)(v29 + 136));
      v76 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(v29 + 112);
      if ( v76 )
        v76(v29, 1LL, &v89, *(_QWORD *)(v29 + 120));
      v77 = (unsigned __int16 *)(v29 + 208);
      if ( (mg_log_prefix(
              4,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0xC0Fu,
              "mg_mgr_poll") & 1) != 0 )
        mg_log("%lu %c%c %c%c%c%c%c");
      v60 = *v77;
      if ( (v60 & 0x8080808) != 0 )
        goto LABEL_150;
      if ( (v60 & 0x81) != 1 )
        break;
      if ( (v60 & 0x1000) == 0 )
        goto LABEL_150;
      addr_len = 16;
      v30 = accept(*(_DWORD *)(v29 + 48), (struct sockaddr *)&timeout, &addr_len);
      if ( v30 == -1 )
      {
        v46 = mg_log_prefix(
                1,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0xB5Bu,
                "accept_conn");
        if ( (v46 & 1) != 0 )
        {
          __errno(v46);
          mg_log("%lu accept failed, errno %d");
          v45 = *v77;
          if ( (*v77 & 0x400) == 0 )
            goto LABEL_153;
          goto LABEL_151;
        }
        goto LABEL_150;
      }
      LODWORD(v31) = v30;
      if ( v30 >= 1024 )
      {
        if ( (mg_log_prefix(
                1,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0xB5Eu,
                "accept_conn") & 1) != 0 )
          mg_log("%ld > %ld");
        goto LABEL_101;
      }
      v47 = calloc(1uLL, 0xD8uLL);
      if ( !v47 )
      {
        if ( (mg_log_prefix(
                1,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0xB62u,
                "accept_conn") & 1) != 0 )
          mg_log("%lu OOM");
LABEL_101:
        close(v31);
        v45 = *v77;
        if ( (*v77 & 0x400) == 0 )
          goto LABEL_153;
        goto LABEL_151;
      }
      v47[1] = v3;
      v47[6] = (int)v31;
      v48 = v3;
      v49 = (__int64)v47;
      v50 = v3[6] + 1;
      v48[6] = v50;
      v51 = WORD1(timeout.tv_sec);
      tv_sec_high = HIDWORD(timeout.tv_sec);
      v53 = v48;
      v47[7] = v50;
      *((_WORD *)v47 + 8) = v51;
      *((_DWORD *)v47 + 5) = tv_sec_high;
      mg_ntoa((__int64)(v47 + 2), (char *)&readfds, 0x64uLL);
      snprintf((char *)&writefds, 0x28uLL, "%s:%d", (const char *)&readfds, bswap32(v51) >> 16);
      if ( (mg_log_prefix(
              3,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0xB70u,
              "accept_conn") & 1) != 0 )
      {
        mg_log("%lu accepted %s");
        v31 = *(_QWORD *)(v49 + 48);
      }
      v54 = fcntl(v31, 3, 0LL);
      fcntl(v31, 4, v54 | 0x800u);
      sub_1A09C(v49);
      v3 = v53;
      *(_QWORD *)v49 = *v53;
      *v53 = v49;
      *(_WORD *)(v49 + 208) = *(_WORD *)(v49 + 208) & 0xFDFF | *(_WORD *)(v29 + 208) & 0x200 | 4;
      v55 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v29 + 128);
      *(_QWORD *)(v49 + 128) = v55;
      *(_QWORD *)(v49 + 136) = *(_QWORD *)(v29 + 136);
      v56 = *(_OWORD *)(v29 + 112);
      *(_OWORD *)(v49 + 112) = v56;
      if ( v55 )
      {
        v55(v49, 4LL, 0LL);
        v57 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v49 + 112);
      }
      else
      {
        v57 = (void (__fastcall *)(__int64, __int64, _QWORD, _QWORD))v56;
      }
      if ( v57 )
        v57(v49, 4LL, 0LL, *(_QWORD *)(v49 + 120));
      v45 = *v77;
      if ( (*v77 & 0x400) != 0 )
        goto LABEL_151;
LABEL_153:
      if ( (v45 & 0x800) != 0 )
      {
        v78 = *(_QWORD **)(v29 + 8);
        do
        {
          v79 = v78;
          v78 = (_QWORD *)*v78;
        }
        while ( v78 != (_QWORD *)v29 );
        *v79 = *(_QWORD *)v29;
        v80 = (__int64 *)qword_33510;
        if ( qword_33510 )
        {
          do
          {
            while ( 1 )
            {
              v81 = (__int64 *)*v80;
              if ( v80[1] == v29 )
                break;
              v80 = (__int64 *)*v80;
              if ( !v81 )
                goto LABEL_163;
            }
            v82 = &qword_33510;
            do
            {
              v83 = v82;
              v82 = (__int64 *)*v82;
            }
            while ( v82 != v80 );
            *v83 = (__int64)v81;
            free(v80);
            v80 = v81;
          }
          while ( v81 );
        }
LABEL_163:
        v84 = *(_QWORD *)(v29 + 8);
        if ( *(_QWORD *)(v84 + 16) == v29 )
          *(_QWORD *)(v84 + 16) = 0LL;
        if ( *(_QWORD *)(v84 + 32) == v29 )
        {
          *(_QWORD *)(v84 + 32) = 0LL;
          v32 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v29 + 128);
          if ( v32 )
            goto LABEL_167;
        }
        else
        {
          v32 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v29 + 128);
          if ( v32 )
LABEL_167:
            v32(v29, 7LL, 0LL, *(_QWORD *)(v29 + 136));
        }
        v85 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v29 + 112);
        if ( v85 )
          v85(v29, 7LL, 0LL, *(_QWORD *)(v29 + 120));
        if ( (mg_log_prefix(
                3,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0xAF8u,
                "close_conn") & 1) != 0 )
          mg_log("%lu closed");
        v86 = *(_DWORD *)(v29 + 48);
        if ( v86 != -1 )
          close(v86);
        free(*(void **)(v29 + 64));
        free(*(void **)(v29 + 88));
        free((void *)v29);
      }
      v29 = v75;
      if ( !v75 )
        return;
    }
    if ( (v60 & 0x10) == 0 )
    {
      if ( (v60 & 0x40) != 0 )
        goto LABEL_150;
      if ( (v60 & 0x1000) == 0 )
        goto LABEL_59;
      v58 = *(_QWORD *)(v29 + 72);
      if ( v58 >> 20 <= 2 && v58 - *(_QWORD *)(v29 + 80) <= 0x1FF )
      {
        v59 = mg_iobuf_resize(v29 + 64, v58 + 512);
        LOWORD(v60) = *v77;
        if ( !v59 )
        {
          LOWORD(v60) = v60 | 0x800;
          *v77 = v60;
        }
      }
      v61 = *(_QWORD *)(v29 + 80);
      v62 = (void *)(*(_QWORD *)(v29 + 64) + v61);
      v63 = *(_QWORD *)(v29 + 72) - v61;
      v88 = (__int64)v62;
      if ( (v60 & 0x20) != 0 )
      {
        v66 = 3;
        v65 = ((v62 != 0LL) & (unsigned __int8)((_DWORD)v63 != 0)) << 31 >> 31;
LABEL_123:
        v87 = 1;
LABEL_124:
        v69 = mg_log_prefix(
                v66,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0xA6Cu,
                "ll_read");
        if ( (v69 & 1) != 0 )
        {
          __errno(v69);
          mg_log("%lu %c%c%c %d/%d %d %d");
        }
        if ( v65 < 1 )
        {
          if ( v87 )
          {
            *v77 |= 0x800u;
            if ( (*(_BYTE *)(v29 + 209) & 0x20) == 0 )
              goto LABEL_150;
            goto LABEL_60;
          }
        }
        else
        {
          if ( (*(_BYTE *)(v29 + 209) & 2) != 0 )
          {
            v70 = mg_hexdump(v88, v65);
            if ( (mg_log_prefix(
                    2,
                    "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                    0xA6Fu,
                    "ll_read") & 1) != 0 )
              mg_log("\n-- %lu %s %s %d\n%s--");
            free(v70);
          }
          readfds.fds_bits[0] = v88;
          readfds.fds_bits[1] = v65;
          v71 = *(void (__fastcall **)(__int64, __int64, fd_set *, _QWORD))(v29 + 128);
          *(_QWORD *)(v29 + 80) += v65;
          if ( v71 )
            v71(v29, 5LL, &readfds, *(_QWORD *)(v29 + 136));
          v72 = *(void (__fastcall **)(__int64, __int64, fd_set *, _QWORD))(v29 + 112);
          if ( v72 )
          {
            v72(v29, 5LL, &readfds, *(_QWORD *)(v29 + 120));
            if ( (*(_BYTE *)(v29 + 209) & 0x20) == 0 )
              goto LABEL_150;
            goto LABEL_60;
          }
        }
LABEL_59:
        if ( (*(_BYTE *)(v29 + 209) & 0x20) == 0 )
          goto LABEL_150;
LABEL_60:
        v33 = (void **)(v29 + 88);
        v34 = sub_19A48(v29, *(void **)(v29 + 88), *(_DWORD *)(v29 + 104), &readfds);
        LODWORD(writefds.fds_bits[0]) = v34;
        if ( v34 < 1 )
        {
          if ( LODWORD(readfds.fds_bits[0]) )
          {
            *v77 |= 0x800u;
            v45 = *v77;
            if ( (*v77 & 0x400) == 0 )
              goto LABEL_153;
            goto LABEL_151;
          }
          goto LABEL_150;
        }
        v35 = *(_QWORD *)(v29 + 104);
        if ( v35 >= v34 )
          v36 = v34;
        else
          v36 = 0LL;
        memmove(*(void **)(v29 + 88), (const void *)(*(_QWORD *)(v29 + 88) + v36), v35 - v36);
        v37 = *(_QWORD *)(v29 + 104) - v36;
        *(_QWORD *)(v29 + 104) = v37;
        if ( !v37 )
        {
          free(*v33);
          *v33 = 0LL;
          *(_QWORD *)(v29 + 96) = 0LL;
          *(_QWORD *)(v29 + 104) = 0LL;
        }
        v38 = *(void (__fastcall **)(__int64, __int64, fd_set *, _QWORD))(v29 + 128);
        if ( v38 )
          v38(v29, 6LL, &writefds, *(_QWORD *)(v29 + 136));
        v39 = *(void (__fastcall **)(__int64, __int64, fd_set *, __int64))(v29 + 112);
        if ( !v39 )
        {
LABEL_150:
          v45 = *v77;
          if ( (*v77 & 0x400) == 0 )
            goto LABEL_153;
LABEL_151:
          if ( !*(_QWORD *)(v29 + 104) )
          {
            v45 |= 0x800u;
            *v77 = v45;
          }
          goto LABEL_153;
        }
        v40 = *(_QWORD *)(v29 + 120);
        v41 = 6LL;
        p_writefds = &writefds;
        v43 = v29;
LABEL_108:
        v39(v43, v41, p_writefds, v40);
        v45 = *v77;
        if ( (*v77 & 0x400) == 0 )
          goto LABEL_153;
        goto LABEL_151;
      }
      if ( (v60 & 0x80) != 0 )
      {
        LODWORD(writefds.fds_bits[0]) = 16;
        v64 = recvfrom(*(_DWORD *)(v29 + 48), v62, (int)v63, 0, (struct sockaddr *)&readfds, (socklen_t *)&writefds);
        v65 = v64;
        if ( (int)v64 >= 1 && !*(_BYTE *)(v29 + 40) )
        {
          *(_DWORD *)(v29 + 20) = HIDWORD(readfds.fds_bits[0]);
          *(_WORD *)(v29 + 16) = WORD1(readfds.fds_bits[0]);
        }
        if ( (_DWORD)v64 )
        {
LABEL_93:
          if ( (v65 & 0x80000000) == 0 || (v73 = *(_DWORD *)__errno(v64), v73 == 4) || v73 == 115 || v73 == 11 )
          {
            v66 = 4;
            v87 = 0;
            goto LABEL_124;
          }
        }
      }
      else
      {
        v64 = recv(*(_DWORD *)(v29 + 48), v62, (int)v63, 0);
        v65 = v64;
        if ( (_DWORD)v64 )
          goto LABEL_93;
      }
      v66 = 3;
      goto LABEL_123;
    }
    if ( (v60 & 0x3000) == 0 )
      goto LABEL_150;
    LODWORD(timeout.tv_sec) = 0;
    addr_len = 4;
    if ( getsockopt(*(_DWORD *)(v29 + 48), 1, 4, &timeout, &addr_len) )
    {
      LODWORD(timeout.tv_sec) = 1;
      *v77 &= ~0x10u;
      goto LABEL_73;
    }
    tv_sec = timeout.tv_sec;
    if ( LODWORD(timeout.tv_sec) == 11 )
    {
      LODWORD(timeout.tv_sec) = 0;
      *v77 &= ~0x10u;
      v68 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v29 + 128);
      if ( !v68 )
        goto LABEL_106;
    }
    else
    {
      *v77 &= ~0x10u;
      if ( tv_sec )
      {
LABEL_73:
        if ( *(_BYTE *)(v29 + 40) )
          v44 = "[%s]:%d";
        else
          v44 = "%s:%d";
        mg_ntoa(v29 + 16, (char *)&readfds, 0x64uLL);
        snprintf((char *)&writefds, 0x28uLL, v44, &readfds, bswap32(*(unsigned __int16 *)(v29 + 16)) >> 16);
        mg_error(v29, "error connecting to %s");
        v45 = *v77;
        if ( (*v77 & 0x400) == 0 )
          goto LABEL_153;
        goto LABEL_151;
      }
      v68 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v29 + 128);
      if ( !v68 )
      {
LABEL_106:
        v39 = *(void (__fastcall **)(__int64, __int64, fd_set *, __int64))(v29 + 112);
        if ( !v39 )
          goto LABEL_150;
        v40 = *(_QWORD *)(v29 + 120);
        v41 = 3LL;
        v43 = v29;
        p_writefds = 0LL;
        goto LABEL_108;
      }
    }
    v68(v29, 3LL, 0LL, *(_QWORD *)(v29 + 136));
    goto LABEL_106;
  }
  v19 = g_timers;
  do
  {
    *(_QWORD *)(v19 + 24) = 0LL;
    v19 = *(_QWORD *)(v19 + 32);
  }
  while ( v19 );
LABEL_32:
  qword_33530 = v18;
  while ( v17 )
  {
    v20 = (int *)v17;
    v21 = *(_QWORD *)(v17 + 24);
    v17 = *(_QWORD *)(v17 + 32);
    if ( v21 )
    {
      if ( v21 <= v18 )
        goto LABEL_37;
    }
    else
    {
      v22 = v18 + *v20;
      *((_QWORD *)v20 + 3) = v22;
      if ( v22 <= v18 )
      {
LABEL_37:
        (*((void (__fastcall **)(_QWORD))v20 + 1))(*((_QWORD *)v20 + 2));
        v23 = *((_QWORD *)v20 + 3);
        v24 = *v20;
        v25 = *((_BYTE *)v20 + 4);
        if ( v18 - v23 > v24 )
          v23 = v18;
        *((_QWORD *)v20 + 3) = v23 + v24;
        if ( (v25 & 1) == 0 )
        {
          v26 = &g_timers;
          do
          {
            v27 = *v26;
            v28 = v26;
            if ( (int *)*v26 == v20 )
              break;
            v26 = (__int64 *)(v27 + 32);
          }
          while ( v27 );
          if ( v27 )
            *v28 = *((_QWORD *)v20 + 4);
        }
      }
    }
  }
  v29 = *v3;
  if ( *v3 )
    goto LABEL_143;
}
// 7190: using guessed type __int64 __fastcall __FD_ISSET_chk(_QWORD, _QWORD, _QWORD);
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);
// 7A00: using guessed type __int64 __fastcall __FD_SET_chk(_QWORD, _QWORD, _QWORD);
// 33510: using guessed type __int64 qword_33510;
// 33530: using guessed type __int64 qword_33530;
// 33548: using guessed type __int64 g_timers;
// 1706C: using guessed type unsigned __int64 var_180;

//----- (0000000000017D3C) ----------------------------------------------------
long double __fastcall mg_mgr_init(__int64 a1)
{
  long double result; // q0

  signal(13, (__sighandler_t)((unsigned int)&dword_0 + 1));
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 40) = 3000;
  *(_QWORD *)(a1 + 8) = "udp://8.8.8.8:53";
  *(_QWORD *)(a1 + 24) = "udp://[2001:4860:4860::8888]:53";
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000017D90) ----------------------------------------------------
__int64 __fastcall mg_sha1_transform(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // w7
  int v3; // w23
  unsigned int v4; // w2
  unsigned int v5; // w3
  unsigned int v6; // w6
  unsigned int v7; // w16
  unsigned int v8; // w17
  unsigned int v9; // w25
  unsigned int v10; // w14
  unsigned int v11; // w15
  unsigned int v12; // w12
  unsigned int v13; // w13
  unsigned int v14; // w9
  unsigned int v15; // w11
  unsigned int v16; // w8
  unsigned int v17; // w10
  int v18; // w20
  unsigned __int64 v19; // t2
  int v20; // w21
  int v21; // w5
  int v22; // w4
  unsigned int v23; // w1
  int v24; // w24
  unsigned int v25; // w19
  int v26; // w7
  int v27; // w19
  int v28; // w23
  int v29; // w22
  int v30; // w20
  int v31; // w21
  int v32; // w19
  int v33; // w3
  int v34; // w1
  int v35; // w6
  int v36; // w7
  int v37; // w22
  int v38; // w20
  int v39; // w23
  int v40; // w19
  int v41; // w21
  int v42; // w22
  int v43; // w7
  int v44; // w6
  int v45; // w24
  int v46; // w20
  int v47; // w21
  int v48; // w6
  int v49; // w19
  int v50; // w24
  int v51; // w22
  int v52; // w24
  int v53; // w23
  int v54; // w5
  int v55; // w21
  int v56; // w0
  int v57; // w6
  int v58; // w15
  int v59; // w22
  int v60; // w2
  int v61; // w16
  int v62; // w17
  int v63; // w25
  int v64; // w7
  int v65; // w14
  int v66; // w4
  int v67; // w20
  int v68; // w5
  int v69; // w24
  int v70; // w3
  int v71; // w21
  int v72; // w19
  int v73; // w13
  int v74; // w22
  int v75; // w15
  int v76; // w5
  int v77; // w20
  int v78; // w12
  int v79; // w14
  int v80; // w3
  int v81; // w2
  int v82; // w15
  int v83; // w22
  int v84; // w4
  int v85; // w14
  int v86; // w13
  int v87; // w1
  int v88; // w11
  int v89; // w21
  int v90; // w0
  unsigned int v91; // w10
  int v92; // w16
  int v93; // w2
  int v94; // w3
  int v95; // w10
  int v96; // w12
  int v97; // w23
  int v98; // w17
  int v99; // w14
  int v100; // w9
  unsigned int v101; // w8
  int v102; // w25
  int v103; // w13
  int v104; // w14
  int v105; // w4
  unsigned int v106; // w24
  unsigned int v107; // w7
  unsigned int v108; // w20
  unsigned int v109; // w22
  int v110; // w23
  int v111; // w15
  int v112; // w8
  int v113; // w14
  unsigned int v114; // w17
  unsigned int v115; // w5
  int v116; // w4
  int v117; // w16
  int v118; // w10
  int v119; // w12
  int v120; // w6
  int v121; // w26
  int v122; // w24
  int v123; // w20
  int v124; // w2
  int v125; // w17
  int v126; // w0
  int v127; // w8
  unsigned int v128; // w13
  int v129; // w14
  int v130; // w15
  int v131; // w5
  int v132; // w17
  int v133; // w4
  int v134; // w0
  int v135; // w13
  int v136; // w14
  unsigned int v137; // w10
  int v138; // w11
  int v139; // w8
  int v140; // w6
  int v141; // w12
  int v142; // w3
  int v143; // w2
  int v144; // w0
  int v145; // w16
  int v146; // w10
  int v147; // w11
  int v148; // w17
  int v149; // w16
  int v150; // w12
  int v151; // w7
  int v152; // w10
  int v153; // w15
  int v154; // w19
  int v155; // w9
  int v156; // w6
  int v157; // w10
  int v158; // w16
  int v159; // w14
  int v160; // w11
  int v161; // w12
  int v162; // w13
  int v163; // w5
  int v164; // w4
  int v165; // w3
  int v166; // w8
  int v167; // w9
  int v168; // w10
  int v169; // w11
  int v170; // w14
  int v171; // w15
  int v172; // w2
  int v173; // w1
  int v174; // w0
  int v175; // w8
  int v176; // w9
  int v177; // w10
  int v178; // w11
  int v179; // w12
  int v180; // w13
  int v181; // w19
  int v182; // w7
  int v183; // w17
  int v184; // w8
  int v185; // w9
  int v186; // w10
  int v187; // w11
  int v188; // w14
  int v189; // w15
  int v190; // w6
  int v191; // w5
  int v192; // w16
  int v193; // w27
  int v194; // w29
  int v195; // w30
  int v196; // w22
  int v197; // w26
  int v198; // w23
  int v199; // w9
  int v200; // w14
  int v201; // w15
  int v202; // w0
  int v203; // w12
  int v204; // w5
  int v205; // w21
  int v206; // w19
  int v207; // w10
  int v208; // w13
  int v209; // w2
  int v210; // w6
  int v211; // w4
  int v212; // w1
  int v213; // w3
  int v214; // w17
  int v215; // w13
  int v216; // w15
  int v217; // w14
  int v218; // w16
  int v219; // w0
  int v220; // w9
  int v221; // w7
  int v222; // w8
  int v223; // w20
  int v224; // w11
  int v225; // w9
  int v226; // w28
  int v227; // w8
  int v228; // w10
  int v229; // w28
  int v230; // w9
  int v231; // w11
  int v232; // w12
  int v233; // w8
  int v234; // w10
  int v235; // w25
  int v236; // w11
  int v237; // w9
  int v238; // w12
  int v239; // w28
  int v240; // w10
  int v241; // w25
  int v242; // w9
  int v243; // w11
  int v244; // w12
  int v245; // w25
  int v246; // w28
  int v247; // w10
  int v248; // w25
  int v249; // w28
  int v250; // w11
  int v251; // w12
  int v252; // w11
  int v253; // w25
  int v254; // w9
  int v255; // w10
  int v256; // w28
  int v257; // w12
  int v258; // w9
  int v259; // w25
  int v260; // w11
  int v261; // w12
  int v262; // w28
  int v263; // w10
  int v264; // w11
  int v265; // w25
  int v266; // w9
  int v267; // w10
  int v268; // w28
  int v269; // w12
  int v270; // w9
  int v271; // w25
  int v272; // w11
  int v273; // w12
  int v274; // w28
  int v275; // w10
  int v276; // w11
  int v277; // w25
  int v278; // w9
  int v279; // w10
  int v280; // w28
  int v281; // w12
  int v282; // w9
  int v283; // w25
  int v284; // w11
  int v285; // w12
  int v286; // w28
  int v287; // w10
  int v288; // w11
  int v289; // w25
  int v290; // w9
  int v291; // w10
  int v292; // w28
  int v293; // w12
  int v294; // w9
  int v295; // w25
  int v296; // w11
  int v297; // w12
  int v298; // w28
  int v299; // w10
  int v300; // w11
  int v301; // w25
  int v302; // w9
  int v303; // w11
  int v304; // w25
  int v305; // w8
  int v306; // w10
  int v307; // w12
  int v308; // w11
  int v309; // w9
  int v310; // w8
  int v311; // w24
  int v312; // w11
  int v313; // w10
  int v314; // w12
  int v315; // w8
  int v316; // w9
  int v317; // w24
  int v318; // w10
  int v319; // w11
  int v320; // w10
  int v321; // w12
  int v322; // w9
  int v323; // w8
  int v324; // w9
  int v325; // w24
  int v326; // w11
  int v327; // w10
  int v328; // w11
  int v329; // w12
  int v330; // w8
  int v331; // w24
  int v332; // w9
  int v333; // w22
  int v334; // w8
  int v335; // w10
  int v336; // w12
  int v337; // w11
  int v338; // w10
  int v339; // w12
  int v340; // w22
  int v341; // w8
  int v342; // w12
  int v343; // w22
  int v344; // w9
  int v345; // w11
  int v346; // w10
  int v347; // w12
  int v348; // w5
  int v349; // w9
  int v350; // w8
  int v351; // w22
  int v352; // w11
  int v353; // w8
  int v354; // w5
  int v355; // w22
  int v356; // w9
  int v357; // w19
  int v358; // w10
  int v359; // w11
  int v360; // w5
  int v361; // w8
  int v362; // w10
  int v363; // w5
  int v364; // w2
  int v365; // w9
  int v366; // w19
  int v367; // w11
  int v368; // w9
  int v369; // w2
  int v370; // w19
  int v371; // w10
  int v372; // w4
  int v373; // w11
  int v374; // w2
  int v375; // w9
  int v376; // w8
  int v377; // w11
  int v378; // w2
  int v379; // w11
  int v380; // w4
  int v381; // w8
  int v382; // w10
  int v383; // w12
  int v384; // w6
  int v385; // w1
  int v386; // w4
  int v387; // w9
  int v388; // w17
  int v389; // w10
  int v390; // w17
  int v391; // w8
  int v392; // w2
  int v393; // w9
  int v394; // w8
  int v395; // w12
  int v396; // w2
  int v397; // w3
  int v398; // w13
  int v399; // w14
  int v400; // w10
  int v401; // w4
  int v402; // w17
  int v403; // w10
  int v404; // w4
  int v405; // w15
  int v406; // w16
  int v407; // w9
  int v408; // w14
  int v409; // w8
  int v410; // w9
  int v411; // w14
  int v412; // w16
  int v413; // w17
  int v414; // w12
  int v415; // w10
  int v416; // w16
  int v417; // w17
  int v418; // w0
  int v419; // w12
  int v420; // w8
  int v421; // w14
  int v422; // w16
  int v423; // w9
  int v424; // w1
  int v425; // w8
  int v426; // w10
  int v427; // w14
  int v428; // w17
  int v429; // w12
  int v430; // w9
  int v431; // w1
  int v432; // w8
  int v433; // w9
  int v434; // w1
  int v435; // w13
  int v436; // w17
  int v437; // w12
  int v438; // w14
  int v439; // w10
  int v440; // w12
  int v441; // w14
  int v442; // w15
  int v443; // w8
  int v444; // w17
  int v445; // w9
  int v446; // w8
  int v447; // w17
  int v448; // w0
  int v449; // w10
  int v450; // w15
  int v451; // w12
  int v452; // w16
  int v453; // w15
  int v454; // w9
  int v455; // w8
  int v456; // w16
  __int64 result; // x0
  int v458; // w12
  int v459; // w15
  int v460; // w10
  int v461; // w13
  int v462; // w15
  int v463; // w8
  int v464; // w17
  int v465; // w9
  int v466; // w14
  int v467; // w16
  int v468; // w8
  int v469; // w10
  int v470; // w12
  int v471; // w13
  int v472; // w15
  int v473; // w9
  int v474; // w16
  int v475; // w8
  int v476; // w13
  int v477; // w9
  int v478; // w12
  int v479; // w15
  int v480; // w14
  int v481; // w10
  int v482; // w14
  int v483; // w12
  int v484; // w8
  int v485; // w9
  int v486; // w13
  int v487; // w10
  int v488; // w12
  int v489; // w10
  int v490; // [xsp+10h] [xbp-110h]
  int v491; // [xsp+14h] [xbp-10Ch]
  int v492; // [xsp+18h] [xbp-108h]
  int v493; // [xsp+1Ch] [xbp-104h]
  int v494; // [xsp+20h] [xbp-100h]
  int v495; // [xsp+24h] [xbp-FCh]
  int v496; // [xsp+28h] [xbp-F8h]
  int v497; // [xsp+2Ch] [xbp-F4h]
  int v498; // [xsp+30h] [xbp-F0h]
  int v499; // [xsp+34h] [xbp-ECh]
  int v500; // [xsp+38h] [xbp-E8h]
  int v501; // [xsp+3Ch] [xbp-E4h]
  int v502; // [xsp+40h] [xbp-E0h]
  int v503; // [xsp+44h] [xbp-DCh]
  int v504; // [xsp+48h] [xbp-D8h]
  int v505; // [xsp+4Ch] [xbp-D4h]
  int v506; // [xsp+50h] [xbp-D0h]
  int v507; // [xsp+54h] [xbp-CCh]
  int v508; // [xsp+58h] [xbp-C8h]
  int v509; // [xsp+5Ch] [xbp-C4h]
  int v510; // [xsp+60h] [xbp-C0h]
  int v511; // [xsp+64h] [xbp-BCh]
  int v512; // [xsp+68h] [xbp-B8h]
  int v513; // [xsp+6Ch] [xbp-B4h]
  int v514; // [xsp+70h] [xbp-B0h]
  int v515; // [xsp+74h] [xbp-ACh]
  int v516; // [xsp+78h] [xbp-A8h]
  int v517; // [xsp+7Ch] [xbp-A4h]
  int v518; // [xsp+80h] [xbp-A0h]
  int v519; // [xsp+84h] [xbp-9Ch]
  int v520; // [xsp+8Ch] [xbp-94h]
  int v521; // [xsp+90h] [xbp-90h]
  int v522; // [xsp+94h] [xbp-8Ch]
  int v523; // [xsp+98h] [xbp-88h]
  int v524; // [xsp+9Ch] [xbp-84h]
  int v525; // [xsp+A0h] [xbp-80h]
  int v526; // [xsp+A4h] [xbp-7Ch]
  int v527; // [xsp+A4h] [xbp-7Ch]
  int v528; // [xsp+A8h] [xbp-78h]
  int v529; // [xsp+ACh] [xbp-74h]
  int v530; // [xsp+B0h] [xbp-70h]
  int v531; // [xsp+B4h] [xbp-6Ch]

  v2 = a2[1];
  v3 = a1[2];
  v5 = a2[2];
  v4 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v9 = a2[6];
  v8 = a2[7];
  v11 = a2[8];
  v10 = a2[9];
  v13 = a2[10];
  v12 = a2[11];
  v15 = a2[12];
  v14 = a2[13];
  v17 = a2[14];
  v16 = a2[15];
  v530 = a1[4];
  v531 = a1[1];
  v529 = a1[3];
  HIDWORD(v19) = *a1;
  LODWORD(v19) = *a1;
  v18 = v19 >> 27;
  HIDWORD(v19) = v531;
  LODWORD(v19) = v531;
  v20 = v19 >> 2;
  v21 = v5 ^ *a2;
  v526 = *a1;
  v528 = v3;
  v22 = v4 ^ v2;
  v23 = bswap32(*a2) + v18 + v530 + (v3 & v531 | v529 & ~v531) + 1518500249;
  HIDWORD(v19) = *a1;
  LODWORD(v19) = *a1;
  v24 = v19 >> 2;
  v25 = bswap32(v2) + v529 + (v20 & *a1 | v3 & ~*a1);
  HIDWORD(v19) = v23;
  LODWORD(v19) = v23;
  v26 = bswap32(v4) + v20;
  v27 = v25 + (v19 >> 27) + 1518500249;
  HIDWORD(v19) = v23;
  LODWORD(v19) = v23;
  v28 = v19 >> 2;
  HIDWORD(v19) = v27;
  LODWORD(v19) = v27;
  v29 = v28 & v27 | v24 & ~v27;
  v30 = bswap32(v5) + a1[2] + (v24 & v23 | v20 & ~v23) + (v19 >> 27) + 1518500249;
  v31 = bswap32(v6) + v24;
  HIDWORD(v19) = v27;
  LODWORD(v19) = v27;
  v32 = v19 >> 2;
  HIDWORD(v19) = v30;
  LODWORD(v19) = v30;
  v33 = v6 ^ v5;
  v34 = v9 ^ v6;
  v35 = bswap32(v7) + v28;
  v36 = v26 + v29 + (v19 >> 27);
  v37 = v32 & v30 | v28 & ~v30;
  HIDWORD(v19) = v30;
  LODWORD(v19) = v30;
  v38 = v19 >> 2;
  HIDWORD(v19) = v36 + 1518500249;
  LODWORD(v19) = v36 + 1518500249;
  v39 = bswap32(v9) + v32;
  v40 = v38 & (v36 + 1518500249) | v32 & ~(v36 + 1518500249);
  v41 = v31 + v37 + (v19 >> 27) + 1518500249;
  HIDWORD(v19) = v36 + 1518500249;
  LODWORD(v19) = v36 + 1518500249;
  v42 = v19 >> 2;
  HIDWORD(v19) = v41;
  LODWORD(v19) = v41;
  v43 = bswap32(v8) + v38;
  v44 = v35 + v40 + (v19 >> 27);
  v45 = v42 & v41 | v38 & ~v41;
  HIDWORD(v19) = v41;
  LODWORD(v19) = v41;
  v46 = v19 >> 2;
  v47 = v44 + 1518500249;
  v48 = v39 + v45;
  HIDWORD(v19) = v47;
  LODWORD(v19) = v47;
  v49 = bswap32(v11) + v42;
  v50 = v42 & ~v47;
  v51 = v48 + (v19 >> 27);
  v52 = v46 & v47 | v50;
  v53 = v21 ^ v11;
  HIDWORD(v19) = v47;
  LODWORD(v19) = v47;
  v54 = v19 >> 2;
  v55 = v51 + 1518500249;
  v56 = v11 ^ v9;
  HIDWORD(v19) = v55;
  LODWORD(v19) = v51 + 1518500249;
  v57 = v13 ^ v11;
  v58 = bswap32(v10) + v46;
  v59 = v43 + v52 + (v19 >> 27);
  v60 = v7 ^ v4;
  v61 = v8 ^ v7;
  v62 = v10 ^ v8;
  v63 = v22 ^ v10;
  v64 = v12 ^ v10;
  HIDWORD(v19) = v55;
  LODWORD(v19) = v55;
  v65 = v19 >> 2;
  HIDWORD(v19) = v59 + 1518500249;
  LODWORD(v19) = v59 + 1518500249;
  v66 = bswap32(v13) + v54;
  v67 = v49 + (v54 & v55 | v46 & ~v55) + (v19 >> 27);
  v68 = v65 & (v59 + 1518500249) | v54 & ~(v59 + 1518500249);
  v69 = v33 ^ v13;
  HIDWORD(v19) = v59 + 1518500249;
  LODWORD(v19) = v59 + 1518500249;
  v70 = v19 >> 2;
  v71 = v67 + 1518500249;
  HIDWORD(v19) = v71;
  LODWORD(v19) = v67 + 1518500249;
  v72 = v15 ^ v13;
  v73 = bswap32(v12) + v65;
  v74 = v70 & (v67 + 1518500249) | v65 & ~(v67 + 1518500249);
  v75 = v58 + v68 + (v19 >> 27) + 1518500249;
  v76 = v60 ^ v12;
  v77 = v14 ^ v12;
  v78 = bswap32(v15) + v70;
  HIDWORD(v19) = v71;
  LODWORD(v19) = v71;
  v79 = v19 >> 2;
  HIDWORD(v19) = v75;
  LODWORD(v19) = v75;
  v80 = v79 & v75 | v70 & ~v75;
  v81 = v66 + v74 + (v19 >> 27) + 1518500249;
  HIDWORD(v19) = v75;
  LODWORD(v19) = v75;
  v82 = v19 >> 2;
  HIDWORD(v19) = v81;
  LODWORD(v19) = v81;
  v83 = v61 ^ v14;
  v84 = bswap32(v14) + v79;
  v85 = v82 & v81 | v79 & ~v81;
  v86 = v73 + v80 + (v19 >> 27) + 1518500249;
  v87 = v34 ^ v15;
  v88 = v17 ^ v15;
  v89 = v56 ^ v17;
  v90 = v63 ^ v17;
  v91 = bswap32(v17);
  HIDWORD(v19) = bswap32(v53 ^ v14);
  LODWORD(v19) = HIDWORD(v19);
  v92 = v19 >> 31;
  HIDWORD(v19) = v81;
  LODWORD(v19) = v81;
  v93 = v19 >> 2;
  HIDWORD(v19) = v86;
  LODWORD(v19) = v86;
  v94 = v92 ^ v91;
  v95 = v91 + v82;
  v96 = v78 + v85 + (v19 >> 27);
  v97 = v62 ^ v16;
  v98 = v69 ^ v16;
  v99 = v93 & v86 | v82 & ~v86;
  v96 += 1518500249;
  v100 = v16 ^ v14;
  v101 = bswap32(v16);
  HIDWORD(v19) = bswap32(v90);
  LODWORD(v19) = HIDWORD(v19);
  v102 = v19 >> 31;
  HIDWORD(v19) = v86;
  LODWORD(v19) = v86;
  v103 = v19 >> 2;
  v104 = v84 + v99;
  HIDWORD(v19) = v96;
  LODWORD(v19) = v96;
  v105 = v19 >> 27;
  v106 = bswap32(v64);
  v107 = bswap32(v77);
  v108 = bswap32(v83);
  v109 = bswap32(v97);
  HIDWORD(v19) = bswap32(v98);
  LODWORD(v19) = HIDWORD(v19);
  v110 = v19 >> 31;
  v111 = v102 ^ v101;
  v112 = v101 + v93;
  v113 = v104 + v105;
  v114 = bswap32(v76) ^ v92;
  v115 = bswap32(v57) ^ v92;
  v116 = v110 ^ v92;
  v113 += 1518500249;
  v525 = v92 + v103;
  HIDWORD(v19) = v96;
  LODWORD(v19) = v96;
  v117 = v19 >> 2;
  v118 = v95 + (v103 & v96 | v93 & ~v96);
  HIDWORD(v19) = v113;
  LODWORD(v19) = v113;
  v119 = v19 >> 27;
  v120 = v106 ^ v102;
  HIDWORD(v19) = v114;
  LODWORD(v19) = v114;
  v121 = v19 >> 31;
  HIDWORD(v19) = bswap32(v87) ^ v102;
  LODWORD(v19) = HIDWORD(v19);
  v122 = v19 >> 31;
  HIDWORD(v19) = v108 ^ v110;
  LODWORD(v19) = v108 ^ v110;
  v123 = v19 >> 31;
  v522 = v118 + v119;
  HIDWORD(v19) = bswap32(v89) ^ v121;
  LODWORD(v19) = HIDWORD(v19);
  v124 = v19 >> 31;
  HIDWORD(v19) = v109 ^ v122;
  LODWORD(v19) = v109 ^ v122;
  v125 = v19 >> 31;
  HIDWORD(v19) = v115 ^ v123;
  LODWORD(v19) = v115 ^ v123;
  v126 = v19 >> 31;
  v523 = v117;
  v524 = v113;
  v127 = v112 + (v117 & v113 | v103 & ~v113);
  v128 = bswap32(v72) ^ v110 ^ v125;
  v129 = v107 ^ v121 ^ v126;
  v521 = v127;
  v130 = v111 ^ v125;
  v131 = v125;
  v132 = v116 ^ v126;
  v133 = v126;
  HIDWORD(v19) = v120 ^ v124;
  LODWORD(v19) = v120 ^ v124;
  v134 = v19 >> 31;
  HIDWORD(v19) = v128;
  LODWORD(v19) = v128;
  v135 = v19 >> 31;
  HIDWORD(v19) = v129;
  LODWORD(v19) = v129;
  v136 = v19 >> 31;
  v137 = bswap32(v88) ^ v122 ^ v134;
  v138 = v94 ^ v124 ^ v136;
  v139 = v122 ^ v110 ^ v135;
  v140 = v124;
  v141 = v121 ^ v102 ^ v134;
  v142 = v134;
  v143 = v136;
  HIDWORD(v19) = v137;
  LODWORD(v19) = v137;
  v144 = v19 >> 31;
  HIDWORD(v19) = bswap32(v100) ^ v123 ^ v135;
  LODWORD(v19) = HIDWORD(v19);
  v145 = v19 >> 31;
  HIDWORD(v19) = v138;
  LODWORD(v19) = v138;
  v146 = v132 ^ v145;
  v147 = v141 ^ (v19 >> 31);
  v148 = v145;
  v149 = v19 >> 31;
  v150 = v140 ^ v122 ^ v144;
  HIDWORD(v19) = v130 ^ v144;
  LODWORD(v19) = v130 ^ v144;
  v151 = v19 >> 31;
  HIDWORD(v19) = v146;
  LODWORD(v19) = v146;
  v152 = v19 >> 31;
  HIDWORD(v19) = v147;
  LODWORD(v19) = v147;
  v517 = v140;
  v518 = v123;
  v153 = v133 ^ v140 ^ v149;
  v154 = v149;
  v155 = v123 ^ v121 ^ v136 ^ v152;
  v156 = v152;
  v157 = v150 ^ (v19 >> 31);
  v158 = v19 >> 31;
  v515 = v133;
  v516 = v131;
  v159 = v131 ^ v123 ^ v148;
  v513 = v135;
  v514 = v142;
  v160 = v142 ^ v131 ^ v151;
  v161 = v135 ^ v133;
  v162 = v143 ^ v142;
  HIDWORD(v19) = v139 ^ v151;
  LODWORD(v19) = v139 ^ v151;
  v163 = v19 >> 31;
  HIDWORD(v19) = v155;
  LODWORD(v19) = v155;
  v164 = v19 >> 31;
  HIDWORD(v19) = v157;
  LODWORD(v19) = v157;
  v165 = v19 >> 31;
  v166 = v159 ^ v163;
  v167 = v153 ^ v164;
  v168 = v160 ^ v165;
  v511 = v144;
  v512 = v143;
  v169 = v144 ^ v513 ^ v163;
  v170 = v148 ^ v143;
  v171 = v154 ^ v144;
  HIDWORD(v19) = v166;
  LODWORD(v19) = v166;
  v172 = v19 >> 31;
  HIDWORD(v19) = v167;
  LODWORD(v19) = v167;
  v173 = v19 >> 31;
  HIDWORD(v19) = v168;
  LODWORD(v19) = v168;
  v174 = v19 >> 31;
  v175 = v161 ^ v156 ^ v172;
  v176 = v162 ^ v158 ^ v173;
  v177 = v169 ^ v174;
  v509 = v154;
  v510 = v148;
  v507 = v156;
  v508 = v151;
  v178 = v151 ^ v148 ^ v172;
  v179 = v156 ^ v154;
  v180 = v158 ^ v151;
  HIDWORD(v19) = v175;
  LODWORD(v19) = v175;
  v181 = v19 >> 31;
  HIDWORD(v19) = v176;
  LODWORD(v19) = v176;
  v182 = v19 >> 31;
  HIDWORD(v19) = v177;
  LODWORD(v19) = v177;
  v183 = v19 >> 31;
  v184 = v170 ^ v164 ^ v181;
  v185 = v171 ^ v165 ^ v182;
  v186 = v178 ^ v183;
  v505 = v163;
  v506 = v158;
  v187 = v163 ^ v156 ^ v181;
  v188 = v164 ^ v158;
  v189 = v165 ^ v163;
  HIDWORD(v19) = v184;
  LODWORD(v19) = v184;
  v190 = v19 >> 31;
  HIDWORD(v19) = v185;
  LODWORD(v19) = v185;
  v191 = v19 >> 31;
  HIDWORD(v19) = v186;
  LODWORD(v19) = v186;
  v192 = v19 >> 31;
  HIDWORD(v19) = v179 ^ v173 ^ v190;
  LODWORD(v19) = HIDWORD(v19);
  v193 = v19 >> 31;
  HIDWORD(v19) = v180 ^ v174 ^ v191;
  LODWORD(v19) = HIDWORD(v19);
  v194 = v19 >> 31;
  HIDWORD(v19) = v187 ^ v192;
  LODWORD(v19) = v187 ^ v192;
  v195 = v19 >> 31;
  v520 = v110;
  v519 = v121;
  HIDWORD(v19) = v188 ^ v182 ^ v193;
  LODWORD(v19) = HIDWORD(v19);
  v196 = v19 >> 31;
  HIDWORD(v19) = v189 ^ v183 ^ v194;
  LODWORD(v19) = HIDWORD(v19);
  v197 = v19 >> 31;
  HIDWORD(v19) = v172 ^ v164 ^ v190 ^ v195;
  LODWORD(v19) = HIDWORD(v19);
  v198 = v19 >> 31;
  v199 = v174 ^ v172 ^ v192 ^ v197;
  v499 = v181;
  v500 = v174;
  v200 = v182 ^ v174 ^ v194;
  v201 = v183 ^ v181 ^ v195;
  v495 = v191;
  v496 = v190;
  v202 = v191;
  v203 = v191 ^ v183;
  HIDWORD(v19) = v173 ^ v165 ^ v191 ^ v196;
  LODWORD(v19) = HIDWORD(v19);
  v204 = v19 >> 31;
  HIDWORD(v19) = v199;
  LODWORD(v19) = v199;
  v205 = v19 >> 31;
  HIDWORD(v19) = v181 ^ v173 ^ v193 ^ v198;
  LODWORD(v19) = HIDWORD(v19);
  v206 = v19 >> 31;
  v207 = v190 ^ v182 ^ v196 ^ v206;
  v503 = v165;
  v504 = v164;
  v501 = v173;
  v502 = v172;
  v208 = v192 ^ v190 ^ v198;
  HIDWORD(v19) = v200 ^ v204;
  LODWORD(v19) = v200 ^ v204;
  v209 = v19 >> 31;
  HIDWORD(v19) = v201 ^ v205;
  LODWORD(v19) = v201 ^ v205;
  v210 = v19 >> 31;
  HIDWORD(v19) = v207;
  LODWORD(v19) = v207;
  v211 = v19 >> 31;
  v494 = v192;
  v497 = v183;
  v498 = v182;
  HIDWORD(v19) = v203 ^ v197 ^ v209;
  LODWORD(v19) = HIDWORD(v19);
  v212 = v19 >> 31;
  HIDWORD(v19) = v208 ^ v210;
  LODWORD(v19) = v208 ^ v210;
  v213 = v19 >> 31;
  HIDWORD(v19) = v193 ^ v202 ^ v204 ^ v211;
  LODWORD(v19) = HIDWORD(v19);
  v214 = v19 >> 31;
  HIDWORD(v19) = v194 ^ v192 ^ v205 ^ v212;
  LODWORD(v19) = HIDWORD(v19);
  v215 = v19 >> 31;
  HIDWORD(v19) = v195 ^ v193 ^ v206 ^ v213;
  LODWORD(v19) = HIDWORD(v19);
  v216 = v19 >> 31;
  HIDWORD(v19) = v196 ^ v194 ^ v209 ^ v214;
  LODWORD(v19) = HIDWORD(v19);
  v217 = v19 >> 31;
  HIDWORD(v19) = v197 ^ v195 ^ v210 ^ v215;
  LODWORD(v19) = HIDWORD(v19);
  v218 = v19 >> 31;
  HIDWORD(v19) = v198 ^ v196 ^ v211 ^ v216;
  LODWORD(v19) = HIDWORD(v19);
  v219 = v19 >> 31;
  HIDWORD(v19) = v205 ^ v198 ^ v213 ^ v218;
  LODWORD(v19) = HIDWORD(v19);
  v493 = v19 >> 31;
  HIDWORD(v19) = v206 ^ v204 ^ v214 ^ v219;
  LODWORD(v19) = HIDWORD(v19);
  v220 = v19 >> 31;
  v492 = v220;
  HIDWORD(v19) = v210 ^ v206 ^ v216 ^ v493;
  LODWORD(v19) = HIDWORD(v19);
  v221 = v19 >> 31;
  HIDWORD(v19) = v213 ^ v211 ^ v219 ^ v221;
  LODWORD(v19) = HIDWORD(v19);
  v222 = v19 >> 31;
  HIDWORD(v19) = v211 ^ v209 ^ v217 ^ v220;
  LODWORD(v19) = HIDWORD(v19);
  v223 = v19 >> 31;
  v490 = v222;
  HIDWORD(v19) = v216 ^ v214 ^ v220 ^ v222;
  LODWORD(v19) = HIDWORD(v19);
  v491 = v19 >> 31;
  HIDWORD(v19) = v219 ^ v217 ^ v223 ^ v491;
  LODWORD(v19) = HIDWORD(v19);
  v527 = v526 + (v19 >> 31);
  HIDWORD(v19) = v522 + 1518500249;
  LODWORD(v19) = v522 + 1518500249;
  v224 = v521 + (v19 >> 27) + 1518500249;
  HIDWORD(v19) = v524;
  LODWORD(v19) = v524;
  v225 = v19 >> 2;
  HIDWORD(v19) = v224;
  LODWORD(v19) = v224;
  v226 = v19 >> 27;
  HIDWORD(v19) = v522 + 1518500249;
  LODWORD(v19) = v522 + 1518500249;
  v227 = v19 >> 2;
  v228 = v525 + (v225 & (v522 + 1518500249) | v523 & ~(v522 + 1518500249)) + v226;
  v229 = v520 + v225;
  v228 += 1518500249;
  HIDWORD(v19) = v228;
  LODWORD(v19) = v228;
  v230 = v102 + v523 + (v227 & v224 | v225 & ~v224) + (v19 >> 27);
  HIDWORD(v19) = v224;
  LODWORD(v19) = v224;
  v231 = v19 >> 2;
  v230 += 1518500249;
  v232 = v519 + v227;
  HIDWORD(v19) = v230;
  LODWORD(v19) = v230;
  v233 = v229 + (v231 & v228 | v227 & ~v228) + (v19 >> 27);
  HIDWORD(v19) = v228;
  LODWORD(v19) = v228;
  v234 = v19 >> 2;
  v233 += 1518500249;
  v235 = v122 + v231;
  HIDWORD(v19) = v233;
  LODWORD(v19) = v233;
  v236 = v232 + (v234 & v230 | v231 & ~v230) + (v19 >> 27);
  HIDWORD(v19) = v230;
  LODWORD(v19) = v230;
  v237 = v19 >> 2;
  v236 += 1518500249;
  v238 = v518 + v234;
  HIDWORD(v19) = v233;
  LODWORD(v19) = v233;
  v239 = v19 >> 2;
  HIDWORD(v19) = v236;
  LODWORD(v19) = v236;
  v240 = v235 + (v237 ^ v234 ^ v233) + (v19 >> 27);
  v241 = v517 + v237;
  v240 += 1859775393;
  HIDWORD(v19) = v240;
  LODWORD(v19) = v240;
  v242 = v238 + (v239 ^ v237 ^ v236) + (v19 >> 27);
  HIDWORD(v19) = v236;
  LODWORD(v19) = v236;
  v243 = v19 >> 2;
  v242 += 1859775393;
  v244 = v516 + v239;
  v245 = v241 + (v243 ^ v239 ^ v240);
  HIDWORD(v19) = v242;
  LODWORD(v19) = v242;
  v246 = v19 >> 27;
  HIDWORD(v19) = v240;
  LODWORD(v19) = v240;
  v247 = v19 >> 2;
  v248 = v245 + v246;
  v249 = v515 + v243;
  v250 = v244 + (v247 ^ v243 ^ v242);
  v251 = v248 + 1859775393;
  HIDWORD(v19) = v248 + 1859775393;
  LODWORD(v19) = v248 + 1859775393;
  v252 = v250 + (v19 >> 27);
  v253 = v514 + v247;
  HIDWORD(v19) = v242;
  LODWORD(v19) = v242;
  v254 = v19 >> 2;
  v252 += 1859775393;
  HIDWORD(v19) = v252;
  LODWORD(v19) = v252;
  v255 = v249 + (v254 ^ v247 ^ v251) + (v19 >> 27);
  v256 = v513 + v254;
  HIDWORD(v19) = v251;
  LODWORD(v19) = v251;
  v257 = v19 >> 2;
  v255 += 1859775393;
  HIDWORD(v19) = v255;
  LODWORD(v19) = v255;
  v258 = v253 + (v257 ^ v254 ^ v252) + (v19 >> 27);
  v259 = v512 + v257;
  HIDWORD(v19) = v252;
  LODWORD(v19) = v252;
  v260 = v19 >> 2;
  v258 += 1859775393;
  HIDWORD(v19) = v258;
  LODWORD(v19) = v258;
  v261 = v256 + (v260 ^ v257 ^ v255) + (v19 >> 27);
  v262 = v511 + v260;
  HIDWORD(v19) = v255;
  LODWORD(v19) = v255;
  v263 = v19 >> 2;
  v261 += 1859775393;
  HIDWORD(v19) = v261;
  LODWORD(v19) = v261;
  v264 = v259 + (v263 ^ v260 ^ v258) + (v19 >> 27);
  v265 = v510 + v263;
  HIDWORD(v19) = v258;
  LODWORD(v19) = v258;
  v266 = v19 >> 2;
  v264 += 1859775393;
  HIDWORD(v19) = v264;
  LODWORD(v19) = v264;
  v267 = v262 + (v266 ^ v263 ^ v261) + (v19 >> 27);
  v268 = v509 + v266;
  HIDWORD(v19) = v261;
  LODWORD(v19) = v261;
  v269 = v19 >> 2;
  v267 += 1859775393;
  HIDWORD(v19) = v267;
  LODWORD(v19) = v267;
  v270 = v265 + (v269 ^ v266 ^ v264) + (v19 >> 27);
  v271 = v508 + v269;
  HIDWORD(v19) = v264;
  LODWORD(v19) = v264;
  v272 = v19 >> 2;
  v270 += 1859775393;
  HIDWORD(v19) = v270;
  LODWORD(v19) = v270;
  v273 = v268 + (v272 ^ v269 ^ v267) + (v19 >> 27);
  v274 = v507 + v272;
  HIDWORD(v19) = v267;
  LODWORD(v19) = v267;
  v275 = v19 >> 2;
  v273 += 1859775393;
  HIDWORD(v19) = v273;
  LODWORD(v19) = v273;
  v276 = v271 + (v275 ^ v272 ^ v270) + (v19 >> 27);
  v277 = v506 + v275;
  HIDWORD(v19) = v270;
  LODWORD(v19) = v270;
  v278 = v19 >> 2;
  v276 += 1859775393;
  HIDWORD(v19) = v276;
  LODWORD(v19) = v276;
  v279 = v274 + (v278 ^ v275 ^ v273) + (v19 >> 27);
  v280 = v505 + v278;
  HIDWORD(v19) = v273;
  LODWORD(v19) = v273;
  v281 = v19 >> 2;
  v279 += 1859775393;
  HIDWORD(v19) = v279;
  LODWORD(v19) = v279;
  v282 = v277 + (v281 ^ v278 ^ v276) + (v19 >> 27);
  v283 = v504 + v281;
  HIDWORD(v19) = v276;
  LODWORD(v19) = v276;
  v284 = v19 >> 2;
  v282 += 1859775393;
  HIDWORD(v19) = v282;
  LODWORD(v19) = v282;
  v285 = v280 + (v284 ^ v281 ^ v279) + (v19 >> 27);
  v286 = v503 + v284;
  HIDWORD(v19) = v279;
  LODWORD(v19) = v279;
  v287 = v19 >> 2;
  v285 += 1859775393;
  HIDWORD(v19) = v285;
  LODWORD(v19) = v285;
  v288 = v283 + (v287 ^ v284 ^ v282) + (v19 >> 27);
  v289 = v502 + v287;
  HIDWORD(v19) = v282;
  LODWORD(v19) = v282;
  v290 = v19 >> 2;
  v288 += 1859775393;
  HIDWORD(v19) = v288;
  LODWORD(v19) = v288;
  v291 = v286 + (v290 ^ v287 ^ v285) + (v19 >> 27);
  v292 = v501 + v290;
  HIDWORD(v19) = v285;
  LODWORD(v19) = v285;
  v293 = v19 >> 2;
  v291 += 1859775393;
  HIDWORD(v19) = v291;
  LODWORD(v19) = v291;
  v294 = v289 + (v293 ^ v290 ^ v288) + (v19 >> 27);
  v295 = v500 + v293;
  HIDWORD(v19) = v288;
  LODWORD(v19) = v288;
  v296 = v19 >> 2;
  v294 += 1859775393;
  HIDWORD(v19) = v294;
  LODWORD(v19) = v294;
  v297 = v292 + (v296 ^ v293 ^ v291) + (v19 >> 27);
  v298 = v499 + v296;
  HIDWORD(v19) = v291;
  LODWORD(v19) = v291;
  v299 = v19 >> 2;
  v297 += 1859775393;
  v300 = v295 + (v299 ^ v296 ^ v294);
  HIDWORD(v19) = v297;
  LODWORD(v19) = v297;
  v301 = v19 >> 27;
  HIDWORD(v19) = v294;
  LODWORD(v19) = v294;
  v302 = v19 >> 2;
  v303 = v300 + v301;
  v304 = v498 + v299;
  v305 = v303 + 1859775393;
  HIDWORD(v19) = v303 + 1859775393;
  LODWORD(v19) = v303 + 1859775393;
  v306 = v298 + ((v297 | v302) & v299 | v297 & v302) + (v19 >> 27);
  HIDWORD(v19) = v297;
  LODWORD(v19) = v297;
  v307 = v19 >> 2;
  v308 = v497 + v302;
  v306 -= 1894007588;
  HIDWORD(v19) = v306;
  LODWORD(v19) = v306;
  v309 = v304 + ((v305 | v307) & v302 | v305 & v307) + (v19 >> 27);
  HIDWORD(v19) = v305;
  LODWORD(v19) = v305;
  v310 = v19 >> 2;
  v309 -= 1894007588;
  v311 = v496 + v307;
  HIDWORD(v19) = v309;
  LODWORD(v19) = v309;
  v312 = v308 + ((v306 | v310) & v307 | v306 & v310) + (v19 >> 27);
  HIDWORD(v19) = v306;
  LODWORD(v19) = v306;
  v313 = v19 >> 2;
  v312 -= 1894007588;
  v314 = v495 + v310;
  HIDWORD(v19) = v312;
  LODWORD(v19) = v312;
  v315 = v311 + ((v309 | v313) & v310 | v309 & v313) + (v19 >> 27);
  HIDWORD(v19) = v309;
  LODWORD(v19) = v309;
  v316 = v19 >> 2;
  v315 -= 1894007588;
  v317 = v494 + v313;
  v318 = (v312 | v316) & v313 | v312 & v316;
  HIDWORD(v19) = v312;
  LODWORD(v19) = v312;
  v319 = v19 >> 2;
  HIDWORD(v19) = v315;
  LODWORD(v19) = v315;
  v320 = v314 + v318 + (v19 >> 27);
  v321 = v193 + v316;
  v322 = (v315 | v319) & v316 | v315 & v319;
  v320 -= 1894007588;
  HIDWORD(v19) = v315;
  LODWORD(v19) = v315;
  v323 = v19 >> 2;
  HIDWORD(v19) = v320;
  LODWORD(v19) = v320;
  v324 = v317 + v322 + (v19 >> 27);
  v325 = v194 + v319;
  v326 = (v320 | v323) & v319 | v320 & v323;
  v324 -= 1894007588;
  HIDWORD(v19) = v320;
  LODWORD(v19) = v320;
  v327 = v19 >> 2;
  HIDWORD(v19) = v324;
  LODWORD(v19) = v324;
  v328 = v321 + v326 + (v19 >> 27);
  v329 = v195 + v323;
  v328 -= 1894007588;
  v330 = v325 + ((v324 | v327) & v323 | v324 & v327);
  HIDWORD(v19) = v328;
  LODWORD(v19) = v328;
  v331 = v19 >> 27;
  HIDWORD(v19) = v324;
  LODWORD(v19) = v324;
  v332 = v19 >> 2;
  v333 = v196 + v327;
  v334 = v330 + v331 - 1894007588;
  v335 = v329 + ((v328 | v332) & v327 | v328 & v332);
  HIDWORD(v19) = v334;
  LODWORD(v19) = v334;
  v336 = v19 >> 27;
  HIDWORD(v19) = v328;
  LODWORD(v19) = v328;
  v337 = v19 >> 2;
  v338 = v335 + v336 - 1894007588;
  v339 = v333 + ((v334 | v337) & v332 | v334 & v337);
  HIDWORD(v19) = v338;
  LODWORD(v19) = v338;
  v340 = v19 >> 27;
  HIDWORD(v19) = v334;
  LODWORD(v19) = v334;
  v341 = v19 >> 2;
  v342 = v339 + v340;
  v343 = v198 + v337;
  v344 = v197 + v332 + ((v338 | v341) & v337 | v338 & v341);
  v345 = v342 - 1894007588;
  HIDWORD(v19) = v338;
  LODWORD(v19) = v338;
  v346 = v19 >> 2;
  HIDWORD(v19) = v345;
  LODWORD(v19) = v342 - 1894007588;
  v347 = v204 ^ v197;
  v348 = v204 + v341;
  v349 = v344 + (v19 >> 27) - 1894007588;
  v350 = v343 + ((v345 | v346) & v341 | v345 & v346);
  HIDWORD(v19) = v349;
  LODWORD(v19) = v349;
  v351 = v19 >> 27;
  HIDWORD(v19) = v345;
  LODWORD(v19) = v345;
  v352 = v19 >> 2;
  v353 = v350 + v351 - 1894007588;
  v354 = v348 + ((v349 | v352) & v346 | v349 & v352);
  HIDWORD(v19) = v353;
  LODWORD(v19) = v353;
  v355 = v19 >> 27;
  HIDWORD(v19) = v349;
  LODWORD(v19) = v349;
  v356 = v19 >> 2;
  v357 = v206 + v352;
  v358 = v205 + v346 + ((v353 | v356) & v352 | v353 & v356);
  v359 = v354 + v355 - 1894007588;
  HIDWORD(v19) = v359;
  LODWORD(v19) = v359;
  v360 = v19 >> 27;
  HIDWORD(v19) = v353;
  LODWORD(v19) = v353;
  v361 = v19 >> 2;
  v362 = v358 + v360;
  v363 = v209 ^ v205;
  v364 = v209 + v356;
  v362 -= 1894007588;
  v365 = v357 + ((v359 | v361) & v356 | v359 & v361);
  HIDWORD(v19) = v362;
  LODWORD(v19) = v362;
  v366 = v19 >> 27;
  HIDWORD(v19) = v359;
  LODWORD(v19) = v359;
  v367 = v19 >> 2;
  v368 = v365 + v366 - 1894007588;
  v369 = v364 + ((v362 | v367) & v361 | v362 & v367);
  HIDWORD(v19) = v368;
  LODWORD(v19) = v368;
  v370 = v19 >> 27;
  HIDWORD(v19) = v362;
  LODWORD(v19) = v362;
  v371 = v19 >> 2;
  v372 = v211 + v367;
  v373 = (v368 | v371) & v367 | v368 & v371;
  v374 = v369 + v370 - 1894007588;
  HIDWORD(v19) = v368;
  LODWORD(v19) = v368;
  v375 = v19 >> 2;
  HIDWORD(v19) = v374;
  LODWORD(v19) = v374;
  v376 = v210 + v361 + v373 + (v19 >> 27);
  v377 = (v374 | v375) & v371 | v374 & v375;
  v376 -= 1894007588;
  HIDWORD(v19) = v374;
  LODWORD(v19) = v374;
  v378 = v19 >> 2;
  HIDWORD(v19) = v376;
  LODWORD(v19) = v376;
  v379 = v372 + v377 + (v19 >> 27);
  v380 = (v376 | v378) & v375 | v376 & v378;
  v379 -= 1894007588;
  HIDWORD(v19) = v376;
  LODWORD(v19) = v376;
  v381 = v19 >> 2;
  HIDWORD(v19) = v379;
  LODWORD(v19) = v379;
  v382 = v212 + v371 + v380 + (v19 >> 27);
  v383 = v347 ^ v212;
  v384 = v212 ^ v210;
  v385 = v214 ^ v212;
  v382 -= 1894007588;
  HIDWORD(v19) = v379;
  LODWORD(v19) = v379;
  v386 = v19 >> 2;
  HIDWORD(v19) = v382;
  LODWORD(v19) = v382;
  v387 = v213 + v375 + ((v379 | v381) & v378 | v379 & v381) + (v19 >> 27) - 1894007588;
  v388 = v214 + v378 + (v386 ^ v381 ^ v382);
  HIDWORD(v19) = v382;
  LODWORD(v19) = v382;
  v389 = v19 >> 2;
  HIDWORD(v19) = v387;
  LODWORD(v19) = v387;
  v390 = v388 + (v19 >> 27) - 899497514;
  v391 = v215 + v381 + (v389 ^ v386 ^ v387);
  HIDWORD(v19) = v390;
  LODWORD(v19) = v390;
  v392 = v19 >> 27;
  HIDWORD(v19) = v387;
  LODWORD(v19) = v387;
  v393 = v19 >> 2;
  v394 = v391 + v392;
  v395 = v383 ^ v217;
  v396 = v363 ^ v215;
  v397 = v215 ^ v213;
  v398 = v217 ^ v215;
  v399 = v217 + v389;
  v394 -= 899497514;
  v400 = v216 + v386 + (v393 ^ v389 ^ v390);
  HIDWORD(v19) = v394;
  LODWORD(v19) = v394;
  v401 = v19 >> 27;
  HIDWORD(v19) = v390;
  LODWORD(v19) = v390;
  v402 = v19 >> 2;
  v403 = v400 + v401;
  v404 = v384 ^ v218;
  v405 = v218 ^ v216;
  v406 = v218 + v393;
  v403 -= 899497514;
  v407 = v399 + (v402 ^ v393 ^ v394);
  HIDWORD(v19) = v403;
  LODWORD(v19) = v403;
  v408 = v19 >> 27;
  HIDWORD(v19) = v394;
  LODWORD(v19) = v394;
  v409 = v19 >> 2;
  v410 = v407 + v408;
  v411 = v219 + v402;
  v410 -= 899497514;
  v412 = v406 + (v409 ^ v402 ^ v403);
  HIDWORD(v19) = v410;
  LODWORD(v19) = v410;
  v413 = v19 >> 27;
  HIDWORD(v19) = v395;
  LODWORD(v19) = v395;
  v414 = v19 >> 31;
  HIDWORD(v19) = v403;
  LODWORD(v19) = v403;
  v415 = v19 >> 2;
  v416 = v412 + v413;
  v417 = v396 ^ v414;
  v418 = v385 ^ v414;
  v419 = v414 + v409;
  v420 = v411 + (v415 ^ v409 ^ v410);
  v421 = v416 - 899497514;
  HIDWORD(v19) = v416 - 899497514;
  LODWORD(v19) = v416 - 899497514;
  v422 = v19 >> 27;
  HIDWORD(v19) = v410;
  LODWORD(v19) = v410;
  v423 = v19 >> 2;
  v424 = v493 + v415;
  v425 = v420 + v422 - 899497514;
  HIDWORD(v19) = v425;
  LODWORD(v19) = v425;
  v426 = v419 + (v423 ^ v415 ^ v421) + (v19 >> 27);
  HIDWORD(v19) = v421;
  LODWORD(v19) = v421;
  v427 = v19 >> 2;
  v426 -= 899497514;
  HIDWORD(v19) = v417;
  LODWORD(v19) = v417;
  v428 = v19 >> 31;
  v429 = v492 + v423;
  v430 = v424 + (v427 ^ v423 ^ v425);
  HIDWORD(v19) = v426;
  LODWORD(v19) = v426;
  v431 = v19 >> 27;
  HIDWORD(v19) = v425;
  LODWORD(v19) = v425;
  v432 = v19 >> 2;
  v433 = v430 + v431;
  v434 = v404 ^ v428;
  v435 = v398 ^ v428;
  v436 = v428 + v427;
  v433 -= 899497514;
  v437 = v429 + (v432 ^ v427 ^ v426);
  HIDWORD(v19) = v433;
  LODWORD(v19) = v433;
  v438 = v19 >> 27;
  HIDWORD(v19) = v426;
  LODWORD(v19) = v426;
  v439 = v19 >> 2;
  v440 = v437 + v438;
  v441 = v405 ^ v221;
  v442 = v221 + v432;
  v440 -= 899497514;
  v443 = v436 + (v439 ^ v432 ^ v433);
  HIDWORD(v19) = v440;
  LODWORD(v19) = v440;
  v444 = v19 >> 27;
  HIDWORD(v19) = v433;
  LODWORD(v19) = v433;
  v445 = v19 >> 2;
  v446 = v443 + v444;
  v447 = v418 ^ v223;
  v448 = v223 + v439;
  v446 -= 899497514;
  HIDWORD(v19) = v446;
  LODWORD(v19) = v446;
  v449 = v442 + (v445 ^ v439 ^ v440) + (v19 >> 27);
  HIDWORD(v19) = v434;
  LODWORD(v19) = v434;
  v450 = v19 >> 31;
  HIDWORD(v19) = v440;
  LODWORD(v19) = v440;
  v451 = v19 >> 2;
  v452 = v397 ^ v493 ^ v450;
  v453 = v450 + v445;
  v449 -= 899497514;
  HIDWORD(v19) = v449;
  LODWORD(v19) = v449;
  v454 = v448 + (v451 ^ v445 ^ v446) + (v19 >> 27);
  HIDWORD(v19) = v446;
  LODWORD(v19) = v446;
  v455 = v19 >> 2;
  v454 -= 899497514;
  HIDWORD(v19) = v452;
  LODWORD(v19) = v452;
  v456 = v19 >> 31;
  result = (unsigned int)(v490 + v451);
  HIDWORD(v19) = v454;
  LODWORD(v19) = v454;
  v458 = v453 + (v455 ^ v451 ^ v449) + (v19 >> 27);
  HIDWORD(v19) = v447;
  LODWORD(v19) = v447;
  v459 = v19 >> 31;
  HIDWORD(v19) = v449;
  LODWORD(v19) = v449;
  v460 = v19 >> 2;
  v461 = v435 ^ v459;
  v462 = v459 + v455;
  v458 -= 899497514;
  v463 = result + (v460 ^ v455 ^ v454);
  HIDWORD(v19) = v458;
  LODWORD(v19) = v458;
  v464 = v19 >> 27;
  HIDWORD(v19) = v454;
  LODWORD(v19) = v454;
  v465 = v19 >> 2;
  v466 = v441 ^ v456;
  v467 = v456 + v460;
  v468 = v463 + v464 - 899497514;
  HIDWORD(v19) = v468;
  LODWORD(v19) = v468;
  v469 = v462 + (v465 ^ v460 ^ v458) + (v19 >> 27);
  HIDWORD(v19) = v458;
  LODWORD(v19) = v458;
  v470 = v19 >> 2;
  v469 -= 899497514;
  HIDWORD(v19) = v461;
  LODWORD(v19) = v461;
  v471 = v19 >> 31;
  v472 = v491 + v465;
  v473 = v467 + (v470 ^ v465 ^ v468);
  HIDWORD(v19) = v469;
  LODWORD(v19) = v469;
  v474 = v19 >> 27;
  HIDWORD(v19) = v468;
  LODWORD(v19) = v468;
  v475 = v19 >> 2;
  v476 = v471 + v470;
  v477 = v473 + v474 - 899497514;
  v478 = v472 + (v475 ^ v470 ^ v469);
  HIDWORD(v19) = v477;
  LODWORD(v19) = v477;
  v479 = v19 >> 27;
  HIDWORD(v19) = v466;
  LODWORD(v19) = v466;
  v480 = v19 >> 31;
  HIDWORD(v19) = v469;
  LODWORD(v19) = v469;
  v481 = v19 >> 2;
  v482 = v480 + v475;
  v483 = v478 + v479 - 899497514;
  HIDWORD(v19) = v483;
  LODWORD(v19) = v483;
  v484 = v476 + (v481 ^ v475 ^ v477) + (v19 >> 27);
  HIDWORD(v19) = v477;
  LODWORD(v19) = v477;
  v485 = v19 >> 2;
  v484 -= 899497514;
  v486 = v527 + v481;
  v487 = v482 + (v485 ^ v481 ^ v483);
  HIDWORD(v19) = v483;
  LODWORD(v19) = v483;
  v488 = v19 >> 2;
  a1[3] = v488 + v529;
  a1[4] = v485 + v530;
  HIDWORD(v19) = v484;
  LODWORD(v19) = v484;
  v489 = v487 + (v19 >> 27);
  HIDWORD(v19) = v484;
  LODWORD(v19) = v484;
  a1[2] = (v19 >> 2) + v528;
  HIDWORD(v19) = v489 - 899497514;
  LODWORD(v19) = v489 - 899497514;
  *a1 = v486 + (v488 ^ v485 ^ v484) + (v19 >> 27) - 899497514;
  a1[1] = v489 - 899497514 + v531;
  return result;
}

//----- (0000000000018EFC) ----------------------------------------------------
long double __fastcall mg_sha1_init(__int64 a1)
{
  long double result; // q0

  result = *(long double *)&xmmword_1DED0;
  *(_QWORD *)(a1 + 16) = 3285377520LL;
  *(_OWORD *)a1 = xmmword_1DED0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}
// 1DED0: using guessed type __int128 xmmword_1DED0;

//----- (0000000000018F1C) ----------------------------------------------------
void *__fastcall mg_sha1_update(_DWORD *a1, char *src, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  int v4; // w9
  __int64 v8; // x24
  char *v9; // x22
  __int64 v10; // x23
  bool v11; // cf

  v3 = (unsigned int)a1[5];
  v4 = a1[6];
  a1[5] = v3 + 8 * a3;
  if ( __CFADD__((_DWORD)v3, 8 * a3) )
    a1[6] = ++v4;
  v8 = (v3 >> 3) & 0x3F;
  v9 = (char *)a1 + v8 + 28;
  a1[6] = v4 + (a3 >> 29);
  if ( v8 + a3 < 0x40 )
  {
    v10 = 0LL;
  }
  else
  {
    v10 = 64 - v8;
    memcpy((char *)a1 + v8 + 28, src, 64 - v8);
    v9 = (char *)(a1 + 7);
    mg_sha1_transform(a1, a1 + 7);
    if ( 127 - v8 < a3 )
    {
      do
      {
        mg_sha1_transform(a1, (unsigned int *)&src[v10]);
        v11 = v10 + 127 >= a3;
        v10 += 64LL;
      }
      while ( !v11 );
    }
  }
  return memcpy(v9, &src[v10], a3 - v10);
}

//----- (0000000000018FF4) ----------------------------------------------------
long double __fastcall mg_sha1_final(__int64 a1, __int64 a2)
{
  int v4; // w8
  unsigned __int64 v5; // x9
  __int64 v6; // x8
  void *v7; // x21
  __int64 v8; // x22
  unsigned int i; // w8
  int v10; // w9
  __int64 v11; // x8
  void *v12; // x0
  __int64 v13; // x22
  int v14; // w9
  __int64 v15; // x8
  void *v16; // x21
  __int64 v17; // x22
  int v18; // w8
  __int64 j; // x9
  char v20; // w11
  long double result; // q0
  char src[4]; // [xsp+Ch] [xbp-54h] BYREF
  char v23[8]; // [xsp+10h] [xbp-50h] BYREF
  __int64 v24; // [xsp+18h] [xbp-48h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(_DWORD *)(a2 + 24);
  v23[0] = HIBYTE(v4);
  v23[1] = BYTE2(v4);
  v23[2] = BYTE1(v4);
  v23[3] = v4;
  v5 = *(unsigned int *)(a2 + 20);
  src[0] = 0x80;
  v23[4] = BYTE3(v5);
  v23[5] = BYTE2(v5);
  v23[6] = BYTE1(v5);
  v23[7] = v5;
  *(_DWORD *)(a2 + 20) = v5 + 8;
  if ( (unsigned int)v5 >= 0xFFFFFFF8 )
    *(_DWORD *)(a2 + 24) = ++v4;
  *(_DWORD *)(a2 + 24) = v4;
  v6 = (v5 >> 3) & 0x3F;
  v7 = (void *)(a2 + v6 + 28);
  if ( (_DWORD)v6 == 63 )
  {
    v8 = 64 - v6;
    memcpy(v7, src, 64 - v6);
    v7 = (void *)(a2 + 28);
    mg_sha1_transform((_DWORD *)a2, (unsigned int *)(a2 + 28));
  }
  else
  {
    v8 = 0LL;
  }
  memcpy(v7, &src[v8], 1 - v8);
  for ( i = *(_DWORD *)(a2 + 20); (i & 0x1F8) != 448; i = *(_DWORD *)(a2 + 20) )
  {
    src[0] = 0;
    v10 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a2 + 20) = i + 8;
    if ( i >= 0xFFFFFFF8 )
      *(_DWORD *)(a2 + 24) = ++v10;
    v11 = (i >> 3) & 0x3F;
    *(_DWORD *)(a2 + 24) = v10;
    v12 = (void *)(a2 + v11 + 28);
    if ( (_DWORD)v11 == 63 )
    {
      v13 = 64 - v11;
      memcpy(v12, src, 64 - v11);
      mg_sha1_transform((_DWORD *)a2, (unsigned int *)(a2 + 28));
      v12 = (void *)(a2 + 28);
    }
    else
    {
      v13 = 0LL;
    }
    memcpy(v12, &src[v13], 1 - v13);
  }
  v14 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 20) = i + 64;
  if ( i >= 0xFFFFFFC0 )
    *(_DWORD *)(a2 + 24) = ++v14;
  v15 = (i >> 3) & 0x3F;
  *(_DWORD *)(a2 + 24) = v14;
  v16 = (void *)(a2 + v15 + 28);
  if ( (unsigned int)v15 < 0x38 )
  {
    v17 = 0LL;
  }
  else
  {
    v17 = 64 - v15;
    memcpy((void *)(a2 + v15 + 28), v23, 64 - v15);
    v16 = (void *)(a2 + 28);
    mg_sha1_transform((_DWORD *)a2, (unsigned int *)(a2 + 28));
  }
  memcpy(v16, &v23[v17], 8 - v17);
  v18 = 0;
  for ( j = 0LL; j != 20; ++j )
  {
    v20 = ~(_BYTE)v18 & 0x18;
    v18 += 8;
    *(_BYTE *)(a1 + j) = *(_DWORD *)(a2 + 4LL * ((unsigned int)j >> 2)) >> v20;
  }
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}
// 18FF4: using guessed type char src[4];

//----- (000000000001926C) ----------------------------------------------------
long double __fastcall mg_hmac_sha1(int8x16_t *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, char *a5)
{
  size_t v8; // x22
  char *v9; // x23
  __int128 v10; // q0
  __int128 v11; // q2
  __int128 v12; // q3
  __int64 v13; // x28
  __int64 v14; // x8
  bool v15; // cf
  size_t v16; // x2
  size_t v17; // x2
  int8x16_t v18; // q1
  int8x16_t v19; // q3
  unsigned __int64 v20; // x8
  int v21; // w9
  __int64 v22; // x24
  int8x16_t *v23; // x0
  __int64 v24; // x23
  unsigned __int64 v25; // x8
  int v26; // w9
  __int64 v27; // x8
  int8x16_t *v28; // x0
  __int64 v29; // x20
  char v31[20]; // [xsp+1Ch] [xbp-164h] BYREF
  int8x16_t v32; // [xsp+30h] [xbp-150h] BYREF
  int8x16_t v33; // [xsp+40h] [xbp-140h]
  int8x16_t v34; // [xsp+50h] [xbp-130h]
  int8x16_t v35; // [xsp+60h] [xbp-120h]
  int8x16_t dest; // [xsp+70h] [xbp-110h] BYREF
  int8x16_t v37; // [xsp+80h] [xbp-100h]
  int8x16_t v38; // [xsp+90h] [xbp-F0h]
  int8x16_t v39; // [xsp+A0h] [xbp-E0h]
  __int128 v40; // [xsp+B0h] [xbp-D0h] BYREF
  int v41; // [xsp+C0h] [xbp-C0h]
  unsigned __int64 v42; // [xsp+C4h] [xbp-BCh]
  int8x16_t v43; // [xsp+CCh] [xbp-B4h] BYREF
  int8x16_t v44; // [xsp+DCh] [xbp-A4h]
  int8x16_t v45; // [xsp+ECh] [xbp-94h]
  int8x16_t v46; // [xsp+FCh] [xbp-84h]
  __int64 v47; // [xsp+118h] [xbp-68h]

  v8 = a2;
  v9 = (char *)a1;
  v47 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 < 0x41 )
  {
    v16 = 64 - a2;
  }
  else
  {
    v40 = xmmword_1DED0;
    v41 = -1009589776;
    v42 = 8 * a2;
    v10 = (__int128)a1[2];
    v11 = (__int128)*a1;
    v12 = (__int128)a1[1];
    v46 = a1[3];
    v45 = (int8x16_t)v10;
    v44 = (int8x16_t)v12;
    v43 = (int8x16_t)v11;
    mg_sha1_transform(&v40, (unsigned int *)&v43);
    if ( v8 < 0x80 )
    {
      v14 = 64LL;
    }
    else
    {
      v13 = 64LL;
      do
      {
        mg_sha1_transform(&v40, (unsigned int *)&v9[v13]);
        v14 = v13 + 64;
        v15 = v13 + 127 >= v8;
        v13 += 64LL;
      }
      while ( !v15 );
    }
    memcpy(&v43, &v9[v14], v8 - v14);
    mg_sha1_final((__int64)v31, (__int64)&v40);
    v16 = 44LL;
    v8 = 20LL;
    v9 = v31;
  }
  memset((char *)&dest + v8, 0, v16);
  memcpy(&dest, v9, v8);
  if ( v8 <= 0x3F )
    v17 = 64 - v8;
  else
    v17 = 0LL;
  memset((char *)&v32 + v8, 0, v17);
  memcpy(&v32, v9, v8);
  v18.n128_u64[0] = 0x3636363636363636LL;
  v18.n128_u64[1] = 0x3636363636363636LL;
  v19.n128_u64[0] = 0x5C5C5C5C5C5C5C5CLL;
  v19.n128_u64[1] = 0x5C5C5C5C5C5C5C5CLL;
  dest = veorq_s8(dest, v18);
  v32 = veorq_s8(v32, v19);
  v37 = veorq_s8(v37, v18);
  v33 = veorq_s8(v33, v19);
  v38 = veorq_s8(v38, v18);
  v34 = veorq_s8(v34, v19);
  v41 = -1009589776;
  v42 = 512LL;
  v39 = veorq_s8(v39, v18);
  v40 = xmmword_1DED0;
  v35 = veorq_s8(v35, v19);
  v46 = v39;
  v45 = v38;
  v44 = v37;
  v43 = dest;
  mg_sha1_transform(&v40, (unsigned int *)&v43);
  v20 = (unsigned int)v42;
  v15 = __CFADD__((_DWORD)v42, 8 * a4);
  LODWORD(v42) = v42 + 8 * a4;
  v21 = HIDWORD(v42);
  if ( v15 )
    v21 = ++HIDWORD(v42);
  v22 = (v20 >> 3) & 0x3F;
  v23 = (int8x16_t *)((char *)&v43 + v22);
  HIDWORD(v42) = v21 + (a4 >> 29);
  if ( v22 + a4 < 0x40 )
  {
    v24 = 0LL;
  }
  else
  {
    v24 = 64 - v22;
    memcpy(v23, a3, 64 - v22);
    mg_sha1_transform(&v40, (unsigned int *)&v43);
    if ( 127 - v22 < a4 )
    {
      do
      {
        mg_sha1_transform(&v40, (unsigned int *)&a3[v24]);
        v15 = v24 + 127 >= a4;
        v24 += 64LL;
      }
      while ( !v15 );
    }
    v23 = &v43;
  }
  memcpy(v23, &a3[v24], a4 - v24);
  mg_sha1_final((__int64)a5, (__int64)&v40);
  v40 = xmmword_1DED0;
  v41 = -1009589776;
  v42 = 512LL;
  v45 = v34;
  v46 = v35;
  v43 = v32;
  v44 = v33;
  mg_sha1_transform(&v40, (unsigned int *)&v43);
  v25 = (unsigned int)v42;
  LODWORD(v42) = v42 + 160;
  v26 = HIDWORD(v42);
  if ( (unsigned int)v25 >= 0xFFFFFF60 )
    v26 = ++HIDWORD(v42);
  v27 = (v25 >> 3) & 0x3F;
  HIDWORD(v42) = v26;
  v28 = (int8x16_t *)((char *)&v43 + v27);
  if ( (unsigned int)v27 < 0x2C )
  {
    v29 = 0LL;
  }
  else
  {
    v29 = 64 - v27;
    memcpy(v28, a5, 64 - v27);
    mg_sha1_transform(&v40, (unsigned int *)&v43);
    v28 = &v43;
  }
  memcpy(v28, &a5[v29], 20 - v29);
  return mg_sha1_final((__int64)a5, (__int64)&v40);
}
// 1DED0: using guessed type __int128 xmmword_1DED0;

//----- (0000000000019608) ----------------------------------------------------
__int64 __fastcall mg_sntp_parse(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  __int64 result; // x0
  __int64 v5; // x9

  if ( a2 > 0x2F )
  {
    if ( (*(_BYTE *)a1 & 0x38) == 32 )
    {
      if ( (*(_BYTE *)a1 & 6 | 1) == 5 )
      {
        if ( *(_BYTE *)(a1 + 1) )
        {
          result = 0LL;
          v5 = bswap32(*(_DWORD *)(a1 + 40)) - 2208988800LL;
          *a3 = v5;
          a3[1] = bswap32(*(_DWORD *)(a1 + 44));
          qword_33528 = v5 + 3600;
        }
        else
        {
          if ( (mg_log_prefix(
                  1,
                  "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                  0x9B1u,
                  "mg_sntp_parse") & 1) != 0 )
            goto LABEL_3;
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if ( (mg_log_prefix(
                1,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                0x9AFu,
                "mg_sntp_parse") & 1) != 0 )
          goto LABEL_3;
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if ( (mg_log_prefix(
              1,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x9ADu,
              "mg_sntp_parse") & 1) != 0 )
        goto LABEL_3;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x9ABu,
            "mg_sntp_parse") & 1) != 0 )
    {
LABEL_3:
      mg_log("%s");
      return 0xFFFFFFFFLL;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 33528: using guessed type __int64 qword_33528;

//----- (0000000000019790) ----------------------------------------------------
__int64 __fastcall mg_ntohl(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0000000000019798) ----------------------------------------------------
void __fastcall mg_sntp_send(__int64 a1, unsigned __int64 a2)
{
  __int16 v3; // w8
  __int64 v4; // x8
  unsigned __int64 v5; // x21
  unsigned __int64 v6; // x9
  size_t v7; // x21
  int v8; // [xsp+Ch] [xbp-74h] BYREF
  __int128 src[3]; // [xsp+10h] [xbp-70h] BYREF
  __int64 v10; // [xsp+48h] [xbp-38h]

  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_WORD *)(a1 + 208);
  if ( (v3 & 8) == 0 )
  {
    if ( qword_33528 >= a2 )
      return;
    memset(src, 0, sizeof(src));
    qword_33528 = a2 + 3600;
    LOBYTE(src[0]) = -29;
    if ( (v3 & 0x80) != 0 )
    {
      if ( (unsigned int)sub_19A48(a1, src, 48, &v8) )
        goto LABEL_16;
    }
    else
    {
      v4 = *(_QWORD *)(a1 + 104);
      v5 = (v4 + 560) & 0xFFFFFFFFFFFFFE00LL;
      if ( v5 == *(_QWORD *)(a1 + 96) )
      {
        v6 = (v4 + 560) & 0xFFFFFFFFFFFFFE00LL;
      }
      else
      {
        mg_iobuf_resize(a1 + 88, (v4 + 560) & 0xFFFFFFFFFFFFFE00LL);
        v6 = *(_QWORD *)(a1 + 96);
        v4 = *(_QWORD *)(a1 + 104);
      }
      if ( v5 == v6 )
        v7 = 48LL;
      else
        v7 = 0LL;
      memmove((void *)(*(_QWORD *)(a1 + 88) + v4), src, v7);
      *(_QWORD *)(a1 + 104) += v7;
      if ( (_DWORD)v7 )
        goto LABEL_16;
    }
    v8 = 1;
LABEL_16:
    if ( (mg_log_prefix(
            3,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x9D7u,
            "mg_sntp_send") & 1) != 0 )
      mg_log("%p request sent, ct %lu, next at %lu");
    return;
  }
  if ( (mg_log_prefix(
          1,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x9D0u,
          "mg_sntp_send") & 1) != 0 )
    mg_log("%lu wait until resolved");
}
// 33528: using guessed type __int64 qword_33528;

//----- (0000000000019918) ----------------------------------------------------
__int64 __fastcall mg_sntp_connect(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0

  if ( !a2 )
    a2 = "udp://time.google.com:123";
  result = mg_connect(a1, a2, a3, a4);
  if ( result )
    *(_QWORD *)(result + 128) = sub_1994C;
  return result;
}

//----- (000000000001994C) ----------------------------------------------------
void __fastcall sub_1994C(_QWORD *a1, int a2)
{
  void (__fastcall *v3)(_QWORD *, __int64, __int64 *, _QWORD); // x8
  void (__fastcall *v4)(_QWORD *, __int64, __int64 *, _QWORD); // x8
  unsigned __int64 v5; // x0
  __int64 v6[3]; // [xsp+8h] [xbp-28h] BYREF

  v6[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 == 2 )
  {
    v5 = time(0LL);
    mg_sntp_send((__int64)a1, v5);
  }
  else if ( a2 == 5 )
  {
    v6[0] = 0LL;
    v6[1] = 0LL;
    if ( !(unsigned int)mg_sntp_parse(a1[8], a1[10], v6) )
    {
      v3 = (void (__fastcall *)(_QWORD *, __int64, __int64 *, _QWORD))a1[16];
      if ( v3 )
        v3(a1, 15LL, v6, a1[17]);
      v4 = (void (__fastcall *)(_QWORD *, __int64, __int64 *, _QWORD))a1[14];
      if ( v4 )
        v4(a1, 15LL, v6, a1[15]);
      if ( (mg_log_prefix(
              3,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x9C2u,
              "sntp_cb") & 1) != 0 )
        mg_log("%u.%u, next at %lu");
    }
    a1[10] = 0LL;
  }
}
// 33528: using guessed type __int64 qword_33528;

//----- (0000000000019A48) ----------------------------------------------------
__int64 __fastcall sub_19A48(__int64 a1, void *buf, int a3, _DWORD *a4)
{
  __int16 v7; // w8
  ssize_t v9; // x0
  int v10; // w22
  int v11; // w0
  __int64 v12; // x0
  char *v13; // x21
  int v15; // w8
  struct sockaddr addr; // [xsp+8h] [xbp-68h] BYREF
  __int64 v17; // [xsp+18h] [xbp-58h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = *(_WORD *)(a1 + 208);
  if ( (v7 & 0x20) != 0 )
  {
    v11 = 1;
    *a4 = 1;
    v10 = ((buf != 0LL) & (unsigned __int8)(a3 != 0)) << 31 >> 31;
    goto LABEL_10;
  }
  if ( (v7 & 0x80) != 0 )
  {
    *(_QWORD *)&addr.sa_family = ((unsigned __int64)*(unsigned int *)(a1 + 20) << 32) | ((unsigned __int64)*(unsigned __int16 *)(a1 + 16) << 16) | 2;
    *(_QWORD *)&addr.sa_data[6] = 0LL;
    v9 = sendto(*(_DWORD *)(a1 + 48), buf, a3, 0, &addr, 0x10u);
    v10 = v9;
    if ( (_DWORD)v9 )
      goto LABEL_4;
LABEL_9:
    v11 = 1;
    *a4 = 1;
    goto LABEL_10;
  }
  v9 = send(*(_DWORD *)(a1 + 48), buf, a3, 0);
  v10 = v9;
  if ( !(_DWORD)v9 )
    goto LABEL_9;
LABEL_4:
  if ( (v10 & 0x80000000) == 0 || (v15 = *(_DWORD *)__errno(v9), v15 == 115) || v15 == 11 )
  {
    *a4 = 0;
LABEL_6:
    v11 = 4;
    goto LABEL_10;
  }
  *a4 = v15 != 4;
  if ( v15 == 4 )
    goto LABEL_6;
  v11 = 1;
LABEL_10:
  v12 = mg_log_prefix(
          v11,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0xA7Cu,
          "ll_write");
  if ( (v12 & 1) != 0 )
  {
    __errno(v12);
    mg_log("%lu %c%c%c %d/%d %d");
  }
  if ( v10 >= 1 && (*(_BYTE *)(a1 + 209) & 2) != 0 )
  {
    v13 = mg_hexdump((__int64)buf, a3);
    if ( (mg_log_prefix(
            2,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0xA7Fu,
            "ll_write") & 1) != 0 )
      mg_log("\n-- %lu %s %s %d\n%s--");
    free(v13);
  }
  return (unsigned int)v10;
}
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);

//----- (0000000000019C78) ----------------------------------------------------
__int64 __fastcall mg_open_listener(char *a1)
{
  unsigned __int8 *v2; // x0
  unsigned __int64 v3; // x1
  int v4; // w0
  int v5; // w21
  int v6; // w1
  int v7; // w2
  unsigned int v8; // w20
  __int64 v9; // x0
  int v11; // w0
  int optval; // [xsp+4h] [xbp-5Ch] BYREF
  struct sockaddr addr; // [xsp+8h] [xbp-58h] BYREF
  __int64 v14[3]; // [xsp+18h] [xbp-48h] BYREF
  int v15; // [xsp+30h] [xbp-30h]
  __int64 v16; // [xsp+38h] [xbp-28h]

  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14[1] = 0LL;
  v15 = 0;
  v14[2] = 0LL;
  v14[0] = bswap32(mg_url_port(a1)) >> 16;
  v2 = (unsigned __int8 *)mg_url_host(a1);
  if ( (mg_aton(v2, v3, (__int64)v14) & 1) == 0 )
  {
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0xAA1u,
            "mg_open_listener") & 1) != 0 )
      mg_log("invalid listening URL: %s");
    return (unsigned int)-1;
  }
  *(_QWORD *)&addr.sa_family = ((unsigned __int64)HIDWORD(v14[0]) << 32) | ((unsigned __int64)LOWORD(v14[0]) << 16) | 2;
  *(_QWORD *)&addr.sa_data[6] = 0LL;
  optval = 1;
  v4 = strncmp(a1, "udp:", 4uLL);
  v5 = v4;
  if ( v4 )
    v6 = 1;
  else
    v6 = 2;
  if ( v4 )
    v7 = 6;
  else
    v7 = 17;
  v8 = socket(2, v6, v7);
  if ( v8 != -1 )
  {
    if ( !setsockopt(v8, 1, 2, &optval, 4u) && !bind(v8, &addr, 0x10u) && (!v5 || !listen(v8, 128)) )
    {
      v11 = fcntl(v8, 3, 0LL);
      fcntl(v8, 4, v11 | 0x800u);
      return v8;
    }
    v9 = mg_log_prefix(
           1,
           "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
           0xAC3u,
           "mg_open_listener");
    if ( (v9 & 1) != 0 )
    {
      __errno(v9);
      mg_log("Failed to listen on %s, errno %d");
    }
    close(v8);
    return (unsigned int)-1;
  }
  return v8;
}
// 19CC4: variable 'v3' is possibly undefined
// 7970: using guessed type __int64 __fastcall __errno(_QWORD);

//----- (0000000000019E38) ----------------------------------------------------
__int64 __fastcall mg_url_port(char *s1)
{
  char v1; // w10
  int v3; // w0
  __int64 v4; // x8
  int v5; // w20
  unsigned int v6; // w21
  __int64 result; // x0

  v1 = *s1;
  if ( *s1 )
  {
    v3 = 0;
    v4 = 0LL;
    do
    {
      if ( v4 && v1 == 47 && s1[v4 - 1] == 47 )
      {
        v5 = 0;
      }
      else
      {
        v5 = 0;
        if ( v1 != 93 && v1 != 64 )
        {
          if ( v1 == 58 )
            v5 = v4 + 1;
          else
            v5 = v3;
        }
      }
      v1 = s1[(unsigned int)++v4];
      v3 = v5;
    }
    while ( v1 );
  }
  else
  {
    v5 = 0;
  }
  if ( !memcmp(s1, "http:", 5uLL) || !memcmp(s1, "ws:", 3uLL) )
    v6 = 80;
  else
    v6 = 0;
  if ( *(_DWORD *)s1 == 980644727 || !memcmp(s1, "https:", 6uLL) )
    v6 = 443;
  if ( !memcmp(s1, "mqtt:", 5uLL) )
    v6 = 1883;
  if ( !memcmp(s1, "mqtts:", 6uLL) )
    result = 8883LL;
  else
    result = v6;
  if ( v5 )
    return atoi(&s1[v5]);
  return result;
}

//----- (0000000000019F90) ----------------------------------------------------
char *__fastcall mg_url_host(char *a1)
{
  char v1; // w15
  int v2; // w10
  int v3; // w13
  int v4; // w8
  int v5; // w11
  int v6; // w14
  __int64 v7; // x9
  unsigned int v8; // w9
  char *result; // x0

  v1 = *a1;
  if ( !*a1 )
  {
    v4 = 0;
    LODWORD(v7) = 0;
LABEL_19:
    v8 = v7 - v4;
    goto LABEL_22;
  }
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0LL;
  do
  {
    if ( v7 && v1 == 47 && a1[v7 - 1] == 47 )
    {
LABEL_10:
      v4 = v7 + 1;
      v3 = 0;
      v6 = v7 + 1;
      goto LABEL_15;
    }
    switch ( v1 )
    {
      case ']':
        v3 = 0;
        break;
      case '@':
        goto LABEL_10;
      case ':':
        v3 = v7 + 1;
        break;
      default:
        if ( v6 && v5 == 0 && v1 == 47 )
        {
          v2 = v7;
          v5 = v7;
        }
        break;
    }
LABEL_15:
    v1 = a1[(unsigned int)++v7];
  }
  while ( v1 );
  if ( !v3 )
  {
    if ( v2 )
    {
      v8 = v2 - v4;
      goto LABEL_22;
    }
    goto LABEL_19;
  }
  v8 = v3 + ~v4;
LABEL_22:
  result = &a1[v4];
  if ( v8 >= 3 && *result == 91 && result[v8 - 1] == 93 )
    ++result;
  return result;
}

//----- (000000000001A09C) ----------------------------------------------------
__int64 __fastcall sub_1A09C(__int64 a1)
{
  int v3; // [xsp+8h] [xbp-28h] BYREF
  int v4; // [xsp+Ch] [xbp-24h] BYREF
  int v5; // [xsp+10h] [xbp-20h] BYREF
  int optval; // [xsp+14h] [xbp-1Ch] BYREF
  __int64 v7; // [xsp+18h] [xbp-18h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  optval = 1;
  setsockopt(*(_DWORD *)(a1 + 48), 6, 1, &optval, 4u);
  setsockopt(*(_DWORD *)(a1 + 48), 6, 12, &optval, 4u);
  setsockopt(*(_DWORD *)(a1 + 48), 1, 9, &optval, 4u);
  v5 = 60;
  setsockopt(*(_DWORD *)(a1 + 48), 6, 4, &v5, 4u);
  v3 = 20;
  v4 = 3;
  setsockopt(*(_DWORD *)(a1 + 48), 6, 6, &v4, 4u);
  return setsockopt(*(_DWORD *)(a1 + 48), 6, 5, &v3, 4u);
}

//----- (000000000001A18C) ----------------------------------------------------
__int64 mg_millis()
{
  __int64 v1; // [xsp+8h] [xbp-28h] BYREF
  __int64 v2; // [xsp+10h] [xbp-20h]
  __int64 v3; // [xsp+18h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  clock_gettime(0, (struct timespec *)&v1);
  return v2 / 1000000 + 1000 * v1;
}

//----- (000000000001A200) ----------------------------------------------------
unsigned __int64 __fastcall mg_timer_poll(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  __int64 v2; // x20
  __int64 v3; // x9
  int *v4; // x22
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  char v9; // w11
  __int64 *v10; // x10
  __int64 v11; // x9
  __int64 *v12; // x8

  v1 = result;
  v2 = g_timers;
  if ( qword_33530 > result )
  {
    if ( !g_timers )
    {
      qword_33530 = result;
      return result;
    }
    v3 = g_timers;
    do
    {
      *(_QWORD *)(v3 + 24) = 0LL;
      v3 = *(_QWORD *)(v3 + 32);
    }
    while ( v3 );
  }
  qword_33530 = result;
  while ( v2 )
  {
    v4 = (int *)v2;
    v5 = *(_QWORD *)(v2 + 24);
    v2 = *(_QWORD *)(v2 + 32);
    if ( v5 )
    {
      if ( v5 <= v1 )
        goto LABEL_10;
    }
    else
    {
      v6 = *v4 + v1;
      *((_QWORD *)v4 + 3) = v6;
      if ( v6 <= v1 )
      {
LABEL_10:
        result = (*((__int64 (__fastcall **)(_QWORD))v4 + 1))(*((_QWORD *)v4 + 2));
        v7 = *((_QWORD *)v4 + 3);
        v8 = *v4;
        v9 = *((_BYTE *)v4 + 4);
        if ( v1 - v7 > v8 )
          v7 = v1;
        *((_QWORD *)v4 + 3) = v7 + v8;
        if ( (v9 & 1) == 0 )
        {
          v10 = &g_timers;
          do
          {
            v11 = *v10;
            v12 = v10;
            if ( (int *)*v10 == v4 )
              break;
            v10 = (__int64 *)(v11 + 32);
          }
          while ( v11 );
          if ( v11 )
            *v12 = *((_QWORD *)v4 + 4);
        }
      }
    }
  }
  return result;
}
// 33530: using guessed type __int64 qword_33530;
// 33548: using guessed type __int64 g_timers;

//----- (000000000001A2F0) ----------------------------------------------------
bool __fastcall mg_tls_handshake(__int64 a1)
{
  return a1 != 0;
}

//----- (000000000001A300) ----------------------------------------------------
__int64 __fastcall mg_lower(unsigned __int8 *a1)
{
  return tolower(*a1);
}

//----- (000000000001A308) ----------------------------------------------------
__int64 __fastcall mg_casecmp(__int64 a1, __int64 a2)
{
  __int64 i; // x23
  int v5; // w21
  int v6; // w22
  __int64 result; // x0

  for ( i = 0LL; i != -1; ++i )
  {
    v5 = *(unsigned __int8 *)(a1 + i);
    v6 = tolower(v5);
    result = (unsigned int)(v6 - tolower(*(unsigned __int8 *)(a2 + i)));
    if ( !v5 )
      break;
    if ( (_DWORD)result )
      break;
  }
  return result;
}

//----- (000000000001A370) ----------------------------------------------------
__int64 __fastcall mg_vcmp(__int64 a1, char *s)
{
  size_t v4; // x0
  const char *v5; // x8
  size_t v6; // x21
  int v7; // w20
  size_t v8; // x2
  __int64 result; // x0

  v4 = strlen(s);
  v5 = *(const char **)a1;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v4;
  if ( v6 >= v4 )
    v8 = v4;
  else
    v8 = v6;
  LODWORD(result) = strncmp(v5, s, v8);
  if ( (_DWORD)result )
    return (unsigned int)result;
  else
    return (unsigned int)(v6 - v7);
}

//----- (000000000001A3C8) ----------------------------------------------------
_BYTE *__fastcall mg_strdup(const void *a1, size_t a2)
{
  _BYTE *v4; // x0
  _BYTE *v5; // x20

  if ( !a2 )
    return 0LL;
  if ( !a1 )
    return 0LL;
  v4 = malloc(a2 + 1);
  v5 = v4;
  if ( v4 )
  {
    memcpy(v4, a1, a2);
    v5[a2] = 0;
  }
  return v5;
}

//----- (000000000001A438) ----------------------------------------------------
__int64 __fastcall mg_strcmp(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 i; // x8
  unsigned int v5; // w9
  unsigned int v6; // w10
  unsigned int v8; // w9

  for ( i = 0LL; i < a2 && i < a4; ++i )
  {
    v5 = *(unsigned __int8 *)(a1 + i);
    v6 = *(unsigned __int8 *)(a3 + i);
    if ( v5 < v6 )
      return 0xFFFFFFFFLL;
    if ( v5 > v6 )
      return 1LL;
  }
  if ( i >= a4 )
    v8 = 0;
  else
    v8 = -1;
  if ( i < a2 )
    return 1LL;
  else
    return v8;
}

//----- (000000000001A48C) ----------------------------------------------------
__int64 __fastcall mg_strstr(__int64 a1, unsigned __int64 a2, void *s2, size_t n)
{
  unsigned __int64 v4; // x23
  __int64 v8; // x24
  __int64 v9; // x22

  v4 = a2 - n;
  if ( a2 < n )
    return 0LL;
  v8 = 0LL;
  while ( 1 )
  {
    v9 = a1 + v8;
    if ( !memcmp((const void *)(a1 + v8), s2, n) )
      break;
    if ( ++v8 > v4 )
      return 0LL;
  }
  return v9;
}

//----- (000000000001A4F8) ----------------------------------------------------
unsigned __int8 *__fastcall mg_strstrip(unsigned __int8 *a1, __int64 a2)
{
  __int64 v2; // x20

  v2 = a2;
  if ( a2 )
  {
    while ( isspace(*a1) )
    {
      --v2;
      ++a1;
      if ( !v2 )
        return a1;
    }
    do
    {
      if ( !isspace(a1[v2 - 1]) )
        break;
      --v2;
    }
    while ( v2 );
  }
  return a1;
}

//----- (000000000001A558) ----------------------------------------------------
__int64 __fastcall mg_timer_init(__int64 result, int a2, int a3, __int64 (__fastcall *a4)(__int64), __int64 a5)
{
  __int64 v5; // x9

  v5 = g_timers;
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_QWORD *)(result + 8) = a4;
  *(_QWORD *)(result + 16) = a5;
  *(_QWORD *)(result + 24) = 0LL;
  *(_QWORD *)(result + 32) = v5;
  g_timers = result;
  if ( (a3 & 2) != 0 )
    return a4(a5);
  return result;
}
// 33548: using guessed type __int64 g_timers;

//----- (000000000001A584) ----------------------------------------------------
__int64 __fastcall mg_timer_free(__int64 result)
{
  __int64 *v1; // x10
  __int64 v2; // x9
  __int64 *v3; // x8

  v1 = &g_timers;
  do
  {
    v2 = *v1;
    v3 = v1;
    if ( *v1 == result )
      break;
    v1 = (__int64 *)(v2 + 32);
  }
  while ( v2 );
  if ( v2 )
    *v3 = *(_QWORD *)(result + 32);
  return result;
}
// 33548: using guessed type __int64 g_timers;

//----- (000000000001A5B4) ----------------------------------------------------
__int64 __fastcall mg_tls_init(__int64 a1)
{
  mg_error(a1, "TLS is not enabled");
  return 0LL;
}

//----- (000000000001A5D4) ----------------------------------------------------
bool __fastcall mg_tls_free(__int64 a1)
{
  return a1 != 0;
}

//----- (000000000001A5E0) ----------------------------------------------------
__int64 __fastcall mg_tls_recv(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 result; // x0

  result = (unsigned int)(((a3 != 0) & (a1 != 0) & (unsigned __int8)(a2 != 0)) << 31 >> 31);
  *a4 = 1;
  return result;
}

//----- (000000000001A610) ----------------------------------------------------
__int64 __fastcall mg_tls_send(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 result; // x0

  result = (unsigned int)(((a3 != 0) & (a1 != 0) & (unsigned __int8)(a2 != 0)) << 31 >> 31);
  *a4 = 1;
  return result;
}

//----- (000000000001A640) ----------------------------------------------------
bool __fastcall mg_url_is_ssl(const char *a1)
{
  return !strncmp(a1, "wss:", 4uLL)
      || !strncmp(a1, "https:", 6uLL)
      || !strncmp(a1, "mqtts:", 6uLL)
      || !strncmp(a1, "ssl:", 4uLL)
      || strncmp(a1, "tls:", 4uLL) == 0;
}

//----- (000000000001A6DC) ----------------------------------------------------
const char *__fastcall mg_url_uri(char *a1)
{
  char v1; // w13
  int v2; // w8
  int v3; // w9
  int v4; // w12
  __int64 v5; // x10

  v1 = *a1;
  if ( !*a1 )
    return "/";
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0LL;
  do
  {
    if ( v5 && v1 == 47 && a1[v5 - 1] == 47 )
    {
LABEL_13:
      v4 = v5 + 1;
      goto LABEL_14;
    }
    if ( v1 != 58 && v1 != 93 )
    {
      if ( v1 == 64 )
        goto LABEL_13;
      if ( v4 )
      {
        if ( v3 == 0 && v1 == 47 )
        {
          v2 = v5;
          v3 = v5;
        }
      }
    }
LABEL_14:
    v1 = a1[(unsigned int)++v5];
  }
  while ( v1 );
  if ( v2 )
    return &a1[v2];
  return "/";
}

//----- (000000000001A784) ----------------------------------------------------
char *__fastcall mg_url_user(char *a1)
{
  char v1; // w14
  int v2; // w9
  int v3; // w10
  int v4; // w8
  int v5; // w13
  int v6; // w1
  __int64 v7; // x11

  v1 = *a1;
  if ( !*a1 )
    return "";
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0LL;
  do
  {
    if ( v7 && v1 == 47 && a1[v7 - 1] == 47 )
    {
      v2 = v7 + 1;
      v5 = 0;
      v6 = v7 + 1;
      goto LABEL_13;
    }
    switch ( v1 )
    {
      case ']':
        goto LABEL_12;
      case '@':
        v2 = v7 + 1;
        v3 = v5;
        v4 = v6;
        v6 = v7 + 1;
LABEL_12:
        v5 = 0;
        break;
      case ':':
        v5 = v7 + 1;
        break;
    }
LABEL_13:
    v1 = a1[(unsigned int)++v7];
  }
  while ( v1 );
  if ( v4 && (v3 || v2) )
    return &a1[v4];
  return "";
}

//----- (000000000001A84C) ----------------------------------------------------
char *__fastcall mg_url_pass(char *a1)
{
  char v1; // w13
  int v2; // w9
  int v3; // w10
  int v4; // w12
  __int64 v5; // x8
  char *v6; // x8

  v1 = *a1;
  if ( !*a1 )
    return "";
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0LL;
  do
  {
    if ( v5 && v1 == 47 && a1[v5 - 1] == 47 )
    {
      v4 = 0;
      v2 = v5 + 1;
      goto LABEL_13;
    }
    switch ( v1 )
    {
      case ']':
        goto LABEL_12;
      case '@':
        v2 = v5 + 1;
        v3 = v4;
LABEL_12:
        v4 = 0;
        break;
      case ':':
        v4 = v5 + 1;
        break;
    }
LABEL_13:
    v1 = a1[(unsigned int)++v5];
  }
  while ( v1 );
  v6 = "";
  if ( v2 )
  {
    if ( v3 )
      return &a1[v3];
  }
  return v6;
}

//----- (000000000001A90C) ----------------------------------------------------
__int64 __fastcall mg_file_size(const char *a1)
{
  char v2[48]; // [xsp+8h] [xbp-98h] BYREF
  __int64 v3; // [xsp+38h] [xbp-68h]
  __int64 v4; // [xsp+88h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( stat(a1, (struct stat *)v2) )
    return 0LL;
  else
    return v3;
}
// 1A90C: using guessed type char var_98[48];

//----- (000000000001A960) ----------------------------------------------------
_BYTE *__fastcall mg_file_read(const char *a1)
{
  size_t v2; // x21
  FILE *v3; // x0
  FILE *v4; // x19
  _BYTE *v5; // x0
  _BYTE *v6; // x20
  char v8[48]; // [xsp+8h] [xbp-A8h] BYREF
  size_t v9; // [xsp+38h] [xbp-78h]
  __int64 v10; // [xsp+88h] [xbp-28h]

  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( stat(a1, (struct stat *)v8) )
    v2 = 0LL;
  else
    v2 = v9;
  v3 = fopen(a1, "rb");
  if ( !v3 )
    return 0LL;
  v4 = v3;
  v5 = malloc(v2 + 1);
  v6 = v5;
  if ( v5 )
  {
    if ( fread(v5, 1uLL, v2, v4) == v2 )
    {
      v6[v2] = 0;
    }
    else
    {
      free(v6);
      v6 = 0LL;
    }
  }
  fclose(v4);
  return v6;
}
// 1A960: using guessed type char var_A8[48];

//----- (000000000001AA2C) ----------------------------------------------------
FILE *__fastcall mg_file_write(const char *a1, const void *a2, size_t a3)
{
  unsigned int v6; // w0
  FILE *result; // x0
  FILE *v8; // x22
  size_t v9; // x21
  char s[4096]; // [xsp+8h] [xbp-1038h] BYREF
  __int64 v11; // [xsp+1008h] [xbp-38h]

  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = rand();
  snprintf(s, 0x1000uLL, "%s.%d", a1, v6);
  result = fopen(s, "wb");
  if ( result )
  {
    v8 = result;
    v9 = fwrite(a2, 1uLL, a3, result);
    fclose(v8);
    if ( v9 == a3 )
    {
      remove(a1);
      rename(s, a1);
      return (FILE *)(&dword_0 + 1);
    }
    else
    {
      remove(s);
      return 0LL;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001AB18) ----------------------------------------------------
__int64 mg_file_printf(const char *a1, const char *a2, ...)
{
  int v3; // w0
  char *v4; // x20
  unsigned __int8 v5; // w19
  gcc_va_list va1; // [xsp+B0h] [xbp-180h] BYREF
  gcc_va_list va; // [xsp+D0h] [xbp-160h] BYREF
  char *v9; // [xsp+F0h] [xbp-140h] BYREF
  char v10[256]; // [xsp+F8h] [xbp-138h] BYREF
  __int64 v11; // [xsp+1F8h] [xbp-38h]

  va_start(va, a2);
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = v10;
  va_copy(va1, va);
  v3 = mg_vasprintf(&v9, 0x100uLL, a2, (__int128 *)va1);
  v4 = v9;
  v5 = (unsigned __int8)mg_file_write(a1, v9, v3);
  if ( v4 != v10 )
    free(v4);
  return v5 & 1;
}

//----- (000000000001AC00) ----------------------------------------------------
FILE *__fastcall mg_random(_BYTE *a1, size_t a2)
{
  FILE *result; // x0
  FILE *v5; // x21

  result = fopen("/dev/urandom", "rb");
  if ( result )
  {
    v5 = result;
    fread(a1, 1uLL, a2, result);
    return (FILE *)fclose(v5);
  }
  else
  {
    for ( ; a2; ++a1 )
    {
      result = (FILE *)rand();
      --a2;
      *a1 = (_BYTE)result + (int)result / 255;
    }
  }
  return result;
}

//----- (000000000001ACA0) ----------------------------------------------------
char *__fastcall mg_hexdump(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x25
  size_t v3; // x20
  char *v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 v8; // x24
  __int64 v9; // x27
  int v10; // w0
  int v11; // w8
  char *v12; // x9
  bool v13; // w8
  unsigned __int64 v14; // x23
  unsigned __int64 v16; // x8
  __int64 v18[2]; // [xsp+10h] [xbp-70h] BYREF
  char v19; // [xsp+20h] [xbp-60h]
  __int64 v20; // [xsp+28h] [xbp-58h]

  v2 = 5 * a2;
  v3 = 5 * a2 + 100;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v18[0] = 0LL;
  v18[1] = 0LL;
  v19 = 0;
  v6 = (char *)malloc(v3);
  if ( !v6 )
    return v6;
  if ( a2 )
  {
    v7 = 0LL;
    v8 = 0LL;
    do
    {
      v9 = v7 & 0xF;
      if ( (v7 & 0xF) == 0 )
      {
        if ( v3 > v8 && v7 )
          v8 += snprintf(&v6[v8], v3 - v8, "  %s\n", (const char *)v18);
        if ( v3 > v8 )
          v8 += snprintf(&v6[v8], v3 - v8, "%04x ", (unsigned int)v7);
      }
      if ( v3 < v8 )
        break;
      v10 = snprintf(&v6[v8], v3 - v8, " %02x", *(unsigned __int8 *)(a1 + v7));
      v11 = *(unsigned __int8 *)(a1 + v7++);
      v8 += v10;
      v12 = (char *)v18 + v9;
      if ( (unsigned int)(v11 - 32) > 0x5E )
        LOBYTE(v11) = 46;
      *v12 = v11;
      v12[1] = 0;
    }
    while ( v7 < a2 );
    v13 = v3 > v8;
    if ( (v7 & 0xF) != 0 )
    {
      v14 = v7 + 1;
      do
      {
        if ( v13 )
          v8 += snprintf(&v6[v8], v3 - v8, "%s", "   ");
        v13 = v3 > v8;
      }
      while ( (v14++ & 0xF) != 0 );
      if ( v3 <= v8 )
        goto LABEL_22;
    }
    else if ( v3 <= v8 )
    {
      goto LABEL_22;
    }
  }
  else
  {
    v8 = 0LL;
    if ( !v3 )
      goto LABEL_22;
  }
  v8 += snprintf(&v6[v8], v3 - v8, "  %s\n", (const char *)v18);
LABEL_22:
  v16 = v2 + 99;
  if ( v8 <= v2 + 99 )
    v16 = v8;
  v6[v16] = 0;
  return v6;
}

//----- (000000000001AE84) ----------------------------------------------------
__int64 __fastcall mg_unhexn(__int64 a1, int a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  int v4; // w14
  int v5; // w13
  int v6; // w13

  if ( !a2 )
    return 0LL;
  v2 = 0LL;
  v3 = 0LL;
  do
  {
    v4 = *(unsigned __int8 *)(a1 + v2);
    if ( v2 )
      v3 *= 16LL;
    v5 = v4 - 48;
    if ( (unsigned int)(v4 - 48) > 9 )
    {
      if ( (unsigned int)(v4 - 65) >= 6 )
        v6 = -87;
      else
        v6 = -55;
      v5 = v6 + v4;
    }
    ++v2;
    v3 |= v5;
  }
  while ( v2 < a2 );
  return v3;
}

//----- (000000000001AEEC) ----------------------------------------------------
__int64 mg_asprintf(char **a1, size_t a2, const char *a3, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  va_copy(va1, va);
  return mg_vasprintf(a1, a2, a3, (__int128 *)va1);
}

//----- (000000000001AF80) ----------------------------------------------------
double mg_time()
{
  int v0; // w0
  double result; // d0
  struct timeval tv; // [xsp+8h] [xbp-28h] BYREF
  __int64 v3; // [xsp+18h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v0 = gettimeofday(&tv, 0LL);
  result = 0.0;
  if ( !v0 )
    return (double)tv.tv_usec / 1000000.0 + (double)tv.tv_sec;
  return result;
}

//----- (000000000001AFF4) ----------------------------------------------------
unsigned __int64 __fastcall mg_ws_send(__int64 a1, void *a2, unsigned __int64 a3, char a4)
{
  __int64 v7; // x20
  char v8; // w8
  __int16 v9; // w9
  __int64 v10; // x8
  unsigned __int64 v11; // x23
  unsigned __int64 v12; // x9
  size_t v13; // x23
  FILE *v14; // x0
  FILE *v15; // x23
  __int64 v16; // x8
  unsigned __int64 v17; // x23
  unsigned __int64 v18; // x9
  int v19; // w0
  int v20; // w0
  int v21; // w0
  size_t v22; // x23
  __int64 v23; // x8
  unsigned __int64 v24; // x23
  unsigned __int64 v25; // x8
  size_t v26; // x23
  __int64 v27; // x10
  __int64 v28; // x11
  unsigned __int64 v29; // x9
  unsigned __int64 v30; // x8
  int8x16_t v31; // q0
  int8x16_t v32; // q1
  int8x16_t *v33; // x10
  unsigned __int64 v34; // x11
  int8x16_t v35; // q3
  int v37; // [xsp+Ch] [xbp-54h] BYREF
  _BYTE src[32]; // [xsp+10h] [xbp-50h] BYREF

  *(_QWORD *)&src[24] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  src[12] = a4 | 0x80;
  if ( a3 <= 0x7D )
  {
    src[13] = a3;
    v7 = 2LL;
    v8 = a3;
    v9 = *(_WORD *)(a1 + 208);
    if ( (v9 & 2) == 0 )
      goto LABEL_4;
    goto LABEL_3;
  }
  if ( !(a3 >> 16) )
  {
    v8 = 126;
    src[13] = 126;
    *(_WORD *)&src[14] = bswap32(a3) >> 16;
    v7 = 4LL;
    v9 = *(_WORD *)(a1 + 208);
    if ( (v9 & 2) == 0 )
      goto LABEL_4;
LABEL_3:
    src[13] = v8 | 0x80;
    goto LABEL_4;
  }
  v8 = 127;
  v7 = 10LL;
  src[13] = 127;
  *(_DWORD *)&src[14] = bswap32(HIDWORD(a3));
  *(_DWORD *)&src[18] = bswap32(a3);
  v9 = *(_WORD *)(a1 + 208);
  if ( (v9 & 2) != 0 )
    goto LABEL_3;
LABEL_4:
  if ( (v9 & 0x80) != 0 )
  {
    if ( (unsigned int)sub_19A48(a1, &src[12], v7, &v37) )
      goto LABEL_18;
    goto LABEL_17;
  }
  v10 = *(_QWORD *)(a1 + 104);
  v11 = (v10 + (v7 | 0x200)) & 0xFFFFFFFFFFFFFE00LL;
  if ( v11 == *(_QWORD *)(a1 + 96) )
  {
    v12 = (v10 + (v7 | 0x200)) & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, (v10 + (v7 | 0x200)) & 0xFFFFFFFFFFFFFE00LL);
    v12 = *(_QWORD *)(a1 + 96);
    v10 = *(_QWORD *)(a1 + 104);
  }
  if ( v11 == v12 )
    v13 = v7;
  else
    v13 = 0LL;
  memmove((void *)(*(_QWORD *)(a1 + 88) + v10), &src[12], v13);
  *(_QWORD *)(a1 + 104) += v13;
  if ( !(_DWORD)v13 )
LABEL_17:
    v37 = 1;
LABEL_18:
  if ( (*(_BYTE *)(a1 + 208) & 2) == 0 )
    goto LABEL_32;
  v14 = fopen("/dev/urandom", "rb");
  if ( v14 )
  {
    v15 = v14;
    fread(src, 1uLL, 4uLL, v14);
    fclose(v15);
    if ( (*(_BYTE *)(a1 + 208) & 0x80) == 0 )
      goto LABEL_21;
  }
  else
  {
    v19 = rand();
    src[0] = v19 + v19 / 255;
    v20 = rand();
    src[1] = v20 + v20 / 255;
    v21 = rand();
    src[2] = v21 + v21 / 255;
    rand();
    src[3] = 0;
    if ( (*(_BYTE *)(a1 + 208) & 0x80) == 0 )
    {
LABEL_21:
      v16 = *(_QWORD *)(a1 + 104);
      v17 = (v16 + 516) & 0xFFFFFFFFFFFFFE00LL;
      if ( v17 == *(_QWORD *)(a1 + 96) )
      {
        v18 = (v16 + 516) & 0xFFFFFFFFFFFFFE00LL;
      }
      else
      {
        mg_iobuf_resize(a1 + 88, (v16 + 516) & 0xFFFFFFFFFFFFFE00LL);
        v18 = *(_QWORD *)(a1 + 96);
        v16 = *(_QWORD *)(a1 + 104);
      }
      v22 = 4LL * (v17 == v18);
      memmove((void *)(*(_QWORD *)(a1 + 88) + v16), src, v22);
      *(_QWORD *)(a1 + 104) += v22;
      if ( (_DWORD)v22 )
        goto LABEL_31;
      goto LABEL_30;
    }
  }
  if ( !(unsigned int)sub_19A48(a1, src, 4, &v37) )
LABEL_30:
    v37 = 1;
LABEL_31:
  v7 += 4LL;
LABEL_32:
  if ( (mg_log_prefix(
          4,
          "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
          0x1080u,
          "mg_ws_send") & 1) != 0 )
    mg_log("WS out: %d [%.*s]");
  if ( (*(_BYTE *)(a1 + 208) & 0x80) != 0 )
  {
    LODWORD(v26) = sub_19A48(a1, a2, a3, &v37);
    if ( !a3 )
      goto LABEL_40;
    goto LABEL_38;
  }
  v23 = a3 + *(_QWORD *)(a1 + 104) + 512;
  v24 = v23 & 0xFFFFFFFFFFFFFE00LL;
  if ( (v23 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(a1 + 96) )
  {
    v25 = v23 & 0xFFFFFFFFFFFFFE00LL;
  }
  else
  {
    mg_iobuf_resize(a1 + 88, v23 & 0xFFFFFFFFFFFFFE00LL);
    v25 = *(_QWORD *)(a1 + 96);
  }
  if ( v24 == v25 )
    v26 = a3;
  else
    v26 = 0LL;
  if ( a2 )
    memmove((void *)(*(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104)), a2, v26);
  *(_QWORD *)(a1 + 104) += v26;
  if ( a3 )
  {
LABEL_38:
    if ( !(_DWORD)v26 )
      v37 = 1;
  }
LABEL_40:
  if ( (*(_BYTE *)(a1 + 208) & 2) != 0 )
  {
    v27 = *(_QWORD *)(a1 + 88);
    if ( v27 )
    {
      if ( a3 )
      {
        v28 = *(_QWORD *)(a1 + 104);
        v29 = 0LL;
        v30 = v27 + v28 - a3;
        if ( a3 < 0x20 || a3 - 1 > 3 )
          goto LABEL_59;
        if ( v30 < (unsigned __int64)&src[a3] && (unsigned __int64)src < v27 + v28 )
        {
          v29 = 0LL;
          do
          {
LABEL_59:
            *(_BYTE *)(v30 + v29) ^= *(_BYTE *)((unsigned __int64)src | v29 & 3);
            ++v29;
          }
          while ( a3 != v29 );
          return v7 + a3;
        }
        v31 = *(int8x16_t *)src;
        v32 = *(int8x16_t *)&src[16];
        v29 = a3 & 0xFFFFFFFFFFFFFFE0LL;
        v33 = (int8x16_t *)(v27 + v28 + 16 - a3);
        v34 = a3 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v34 -= 32LL;
          v35 = veorq_s8(*v33, v32);
          v33[-1] = veorq_s8(v33[-1], v31);
          *v33 = v35;
          v33 += 2;
        }
        while ( v34 );
        if ( v29 != a3 )
          goto LABEL_59;
      }
    }
  }
  return v7 + a3;
}

//----- (000000000001B448) ----------------------------------------------------
__int64 mg_ws_connect(__int64 a1, char *a2, __int64 a3, __int64 a4, const char *a5, ...)
{
  __int64 v8; // x20
  FILE *v9; // x0
  FILE *v10; // x25
  int v11; // w0
  int v12; // w0
  int v13; // w0
  int v14; // w0
  int v15; // w0
  int v16; // w0
  int v17; // w0
  int v18; // w0
  int v19; // w0
  int v20; // w0
  int v21; // w0
  int v22; // w0
  int v23; // w0
  int v24; // w0
  int v25; // w0
  int v26; // w0
  int v27; // w0
  int v28; // w0
  int v29; // w0
  int v30; // w0
  int v31; // w0
  int v32; // w0
  int v33; // w0
  int v34; // w0
  int v35; // w0
  int v36; // w0
  int v37; // w0
  int v38; // w0
  int v39; // w0
  int v40; // w0
  int v41; // w0
  int v42; // w0
  char v43; // w13
  int v44; // w9
  int v45; // w12
  __int64 v46; // x10
  char *v47; // x21
  int v48; // w0
  char *v49; // x22
  size_t v50; // x23
  __int64 v51; // x8
  unsigned __int64 v52; // x24
  unsigned __int64 v53; // x8
  size_t v54; // x24
  gcc_va_list va1; // [xsp+B0h] [xbp-240h] BYREF
  void *src; // [xsp+D0h] [xbp-220h] BYREF
  char *v58; // [xsp+D8h] [xbp-218h] BYREF
  int v59; // [xsp+E4h] [xbp-20Ch] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-208h] BYREF
  char v61[256]; // [xsp+108h] [xbp-1E8h] BYREF
  char v62[128]; // [xsp+208h] [xbp-E8h] BYREF
  unsigned __int8 ptr; // [xsp+288h] [xbp-68h] BYREF
  unsigned __int8 v64; // [xsp+289h] [xbp-67h]
  unsigned __int8 v65; // [xsp+28Ah] [xbp-66h]
  unsigned __int8 v66; // [xsp+28Bh] [xbp-65h]
  unsigned __int8 v67; // [xsp+28Ch] [xbp-64h]
  unsigned __int8 v68; // [xsp+28Dh] [xbp-63h]
  unsigned __int8 v69; // [xsp+28Eh] [xbp-62h]
  unsigned __int8 v70; // [xsp+28Fh] [xbp-61h]
  unsigned __int8 v71; // [xsp+290h] [xbp-60h]
  unsigned __int8 v72; // [xsp+291h] [xbp-5Fh]
  unsigned __int8 v73; // [xsp+292h] [xbp-5Eh]
  unsigned __int8 v74; // [xsp+293h] [xbp-5Dh]
  unsigned __int8 v75; // [xsp+294h] [xbp-5Ch]
  unsigned __int8 v76; // [xsp+295h] [xbp-5Bh]
  unsigned __int8 v77; // [xsp+296h] [xbp-5Ah]
  unsigned __int8 v78; // [xsp+297h] [xbp-59h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = mg_connect(a1, a2, a3, a4);
  if ( !v8 )
    return v8;
  src = v61;
  v58 = v62;
  mg_url_host(a2);
  if ( a5 )
  {
    va_start(va, a5);
    va_copy(va1, va);
    mg_vasprintf(&v58, 0x80uLL, a5, (__int128 *)va1);
  }
  v9 = fopen("/dev/urandom", "rb");
  if ( v9 )
  {
    v10 = v9;
    fread(&ptr, 1uLL, 0x10uLL, v9);
    fclose(v10);
  }
  else
  {
    v11 = rand();
    ptr = v11 + v11 / 255;
    v12 = rand();
    v64 = v12 + v12 / 255;
    v13 = rand();
    v65 = v13 + v13 / 255;
    v14 = rand();
    v66 = v14 + v14 / 255;
    v15 = rand();
    v67 = v15 + v15 / 255;
    v16 = rand();
    v68 = v16 + v16 / 255;
    v17 = rand();
    v69 = v17 + v17 / 255;
    v18 = rand();
    v70 = v18 + v18 / 255;
    v19 = rand();
    v71 = v19 + v19 / 255;
    v20 = rand();
    v72 = v20 + v20 / 255;
    v21 = rand();
    v73 = v21 + v21 / 255;
    v22 = rand();
    v74 = v22 + v22 / 255;
    v23 = rand();
    v75 = v23 + v23 / 255;
    v24 = rand();
    v76 = v24 + v24 / 255;
    v25 = rand();
    v77 = v25 + v25 / 255;
    v26 = rand();
    v78 = v26 + v26 / 255;
  }
  v27 = mg_base64_update(ptr, (__int64)va, 0);
  v28 = mg_base64_update(v64, (__int64)va, v27);
  v29 = mg_base64_update(v65, (__int64)va, v28);
  v30 = mg_base64_update(v66, (__int64)va, v29);
  v31 = mg_base64_update(v67, (__int64)va, v30);
  v32 = mg_base64_update(v68, (__int64)va, v31);
  v33 = mg_base64_update(v69, (__int64)va, v32);
  v34 = mg_base64_update(v70, (__int64)va, v33);
  v35 = mg_base64_update(v71, (__int64)va, v34);
  v36 = mg_base64_update(v72, (__int64)va, v35);
  v37 = mg_base64_update(v73, (__int64)va, v36);
  v38 = mg_base64_update(v74, (__int64)va, v37);
  v39 = mg_base64_update(v75, (__int64)va, v38);
  v40 = mg_base64_update(v76, (__int64)va, v39);
  v41 = mg_base64_update(v77, (__int64)va, v40);
  v42 = mg_base64_update(v78, (__int64)va, v41);
  mg_base64_final((__int64)va, v42);
  v43 = *a2;
  if ( *a2 )
  {
    v44 = 0;
    v45 = 0;
    v46 = 0LL;
    do
    {
      if ( !v46 || v43 != 47 || a2[v46 - 1] != 47 )
      {
        if ( v43 == 58 || v43 == 93 )
          goto LABEL_20;
        if ( v43 != 64 )
        {
          if ( v45 && v44 == 0 && v43 == 47 )
            v44 = v46;
          goto LABEL_20;
        }
      }
      v45 = v46 + 1;
LABEL_20:
      v43 = a2[(unsigned int)++v46];
    }
    while ( v43 );
  }
  v47 = v58;
  v48 = mg_asprintf(
          (char **)&src,
          0x100uLL,
          "GET %s HTTP/1.1\r\n"
          "Upgrade: websocket\r\n"
          "Host: %.*s\r\n"
          "Connection: Upgrade\r\n"
          "%.*sSec-WebSocket-Version: 13\r\n"
          "Sec-WebSocket-Key: %s\r\n"
          "\r\n");
  v49 = (char *)src;
  v50 = v48;
  if ( (*(_BYTE *)(v8 + 208) & 0x80) == 0 )
  {
    v51 = v48 + *(_QWORD *)(v8 + 104) + 512LL;
    v52 = v51 & 0xFFFFFFFFFFFFFE00LL;
    if ( (v51 & 0xFFFFFFFFFFFFFE00LL) == *(_QWORD *)(v8 + 96) )
    {
      v53 = v51 & 0xFFFFFFFFFFFFFE00LL;
    }
    else
    {
      mg_iobuf_resize(v8 + 88, v51 & 0xFFFFFFFFFFFFFE00LL);
      v53 = *(_QWORD *)(v8 + 96);
    }
    if ( v52 == v53 )
      v54 = v50;
    else
      v54 = 0LL;
    if ( v49 )
      memmove((void *)(*(_QWORD *)(v8 + 88) + *(_QWORD *)(v8 + 104)), v49, v54);
    *(_QWORD *)(v8 + 104) += v54;
    if ( !(_DWORD)v50 )
      goto LABEL_27;
    goto LABEL_25;
  }
  LODWORD(v54) = sub_19A48(v8, src, v48, &v59);
  if ( (_DWORD)v50 )
  {
LABEL_25:
    if ( !(_DWORD)v54 )
      v59 = 1;
  }
LABEL_27:
  if ( v47 != v62 )
    free(v47);
  if ( v49 != v61 )
    free(v49);
  *(_QWORD *)(v8 + 120) = a4;
  *(_QWORD *)(v8 + 128) = sub_1BA80;
  return v8;
}

//----- (000000000001BA80) ----------------------------------------------------
void __fastcall sub_1BA80(__int64 a1, int a2)
{
  __int16 v2; // w22
  unsigned __int8 *v4; // x20
  void **v5; // x28
  unsigned __int64 v6; // x24
  unsigned __int64 *v7; // x27
  unsigned __int64 v8; // x23
  int v9; // w21
  int v10; // w0
  int v11; // w8
  int v12; // w21
  __int64 v13; // x20
  unsigned __int64 v14; // x23
  unsigned __int8 *v15; // x10
  unsigned __int64 v16; // x9
  char v17; // w8
  unsigned __int64 v18; // x25
  unsigned __int64 v19; // x11
  __int64 v20; // x9
  char *v21; // x12
  __int64 v22; // x14
  int8x16_t *v23; // x13
  int8x16_t v24; // q0
  int8x16_t v25; // q1
  int8x16_t *v26; // x10
  __int64 v27; // x11
  int8x16_t v28; // q3
  char *v29; // x11
  int v30; // w10
  char *v31; // x24
  void (__fastcall *v32)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v33)(__int64, __int64, unsigned __int64 *, __int64); // x8
  __int64 v34; // x3
  __int64 v35; // x1
  void (__fastcall *v36)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v37)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v38)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v39)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  void (__fastcall *v40)(__int64, __int64, unsigned __int64 *, _QWORD); // x8
  unsigned __int64 v41[2]; // [xsp+0h] [xbp-5E0h] BYREF
  char v42; // [xsp+10h] [xbp-5D0h]
  __int64 v43; // [xsp+580h] [xbp-60h]

  v43 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 == 5 )
  {
    v2 = *(_WORD *)(a1 + 208);
    if ( (v2 & 0x102) != 2 )
    {
      v7 = (unsigned __int64 *)(a1 + 80);
      v6 = *(_QWORD *)(a1 + 80);
      v5 = (void **)(a1 + 64);
      goto LABEL_33;
    }
    v5 = (void **)(a1 + 64);
    v4 = *(unsigned __int8 **)(a1 + 64);
    v7 = (unsigned __int64 *)(a1 + 80);
    v6 = *(_QWORD *)(a1 + 80);
    if ( v6 )
    {
      v8 = 0LL;
      while ( 1 )
      {
        v9 = (char)v4[v8];
        v10 = isprint(v4[v8]);
        if ( (v9 & 0x80000000) == 0 && v9 != 10 && v9 != 13 && !v10 )
          goto LABEL_29;
        if ( v8 )
        {
          if ( v9 == 10 )
          {
            v11 = v4[v8 - 1];
            if ( v11 == 10 || v8 >= 4 && v11 == 13 && v4[v8 - 2] == 10 )
              break;
          }
        }
        if ( ++v8 >= v6 )
          return;
      }
      v12 = v8 + 1;
      if ( (_DWORD)v8 + 1 < 0 )
      {
LABEL_29:
        *(_WORD *)(a1 + 208) = v2 | 0x800;
        goto LABEL_33;
      }
      if ( (_DWORD)v8 != -1 )
      {
        if ( v12 >= 15 && !memcmp(v4 + 9, "101", 3uLL) )
        {
          mg_http_parse(v4, v6, v41);
          v39 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 128);
          *(_WORD *)(a1 + 208) |= 0x100u;
          if ( v39 )
            v39(a1, 9LL, v41, *(_QWORD *)(a1 + 136));
          v40 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 112);
          if ( v40 )
            v40(a1, 9LL, v41, *(_QWORD *)(a1 + 120));
        }
        else
        {
          if ( (mg_log_prefix(
                  1,
                  "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                  0x1095u,
                  "mg_ws_cb") & 1) != 0 )
            mg_log("%lu WS handshake error: %.*s");
          *(_WORD *)(a1 + 208) |= 0x800u;
        }
        if ( *v7 >= v12 )
          v13 = v12;
        else
          v13 = 0LL;
        memmove(*v5, (char *)*v5 + v13, *v7 - v13);
        v6 = *v7 - v13;
        for ( *v7 = v6; ; *v7 = v6 )
        {
LABEL_33:
          v15 = (unsigned __int8 *)*v5;
          if ( v6 < 2 )
          {
            v17 = 0;
            v18 = 0LL;
            v20 = 0LL;
            v19 = 0LL;
          }
          else
          {
            v16 = v15[1];
            v17 = *v15;
            v18 = v16 & 0x7F;
            v19 = (v16 >> 5) & 4;
            if ( (v16 & 0x7F) > 0x7D || v6 < v19 )
            {
              if ( (_DWORD)v18 == 126 && (v20 = v19 + 4, v19 + 4 <= v6) )
              {
                v18 = bswap32(*((unsigned __int16 *)v15 + 1)) >> 16;
              }
              else
              {
                v20 = v19 | 0xA;
                if ( (v19 | 0xA) <= v6 )
                {
                  v18 = bswap32(*(_DWORD *)(v15 + 6));
                }
                else
                {
                  v18 = 0LL;
                  v20 = 0LL;
                }
              }
            }
            else
            {
              v20 = v19 | 2;
            }
          }
          v14 = v20 + v18;
          if ( v20 + v18 > v6 )
            return;
          if ( v19 && v18 )
          {
            v21 = (char *)&v15[v20];
            v22 = 0LL;
            v23 = (int8x16_t *)&v15[v20 - v19];
            if ( v18 >= 0x20 && v18 - 1 <= 3 )
            {
              if ( v21 < (char *)&v15[v18 + v20 - v19] && v23 < (int8x16_t *)&v15[v18 + v20] )
              {
                v22 = 0LL;
                goto LABEL_55;
              }
              v24 = *v23;
              v25 = v23[1];
              v22 = (unsigned int)v18 & 0xFFFFFFE0;
              v26 = (int8x16_t *)&v15[v20 + 16];
              v27 = v22;
              do
              {
                v27 -= 32LL;
                v28 = veorq_s8(*v26, v25);
                v26[-1] = veorq_s8(v26[-1], v24);
                *v26 = v28;
                v26 += 2;
              }
              while ( v27 );
              goto LABEL_56;
            }
            do
            {
LABEL_55:
              v21[v22] ^= v23->n128_u8[v22 & 3];
              ++v22;
LABEL_56:
              ;
            }
            while ( v18 != v22 );
          }
          if ( !(v18 + v20) )
            return;
          v29 = (char *)*v5;
          v30 = v17 & 0xF;
          v42 = v17;
          v31 = &v29[v20];
          v41[0] = (unsigned __int64)&v29[v20];
          v41[1] = v18;
          switch ( v30 )
          {
            case 9:
              if ( (mg_log_prefix(
                      3,
                      "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                      0x10A8u,
                      "mg_ws_cb") & 1) != 0 )
                mg_log("%s");
              mg_ws_send(a1, v31, v18, 10);
              break;
            case 10:
              break;
            case 8:
              if ( (mg_log_prefix(
                      1,
                      "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                      0x10B0u,
                      "mg_ws_cb") & 1) != 0 )
                mg_log("%lu Got WS CLOSE");
              v37 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 128);
              if ( v37 )
                v37(a1, 11LL, v41, *(_QWORD *)(a1 + 136));
              v38 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 112);
              if ( v38 )
                v38(a1, 11LL, v41, *(_QWORD *)(a1 + 120));
              *(_WORD *)(a1 + 208) |= 0x800u;
              return;
            default:
              v32 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 128);
              if ( v32 )
                v32(a1, 10LL, v41, *(_QWORD *)(a1 + 136));
              v33 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, __int64))(a1 + 112);
              if ( v33 )
              {
                v34 = *(_QWORD *)(a1 + 120);
                v35 = 10LL;
LABEL_72:
                v33(a1, v35, v41, v34);
                goto LABEL_30;
              }
              goto LABEL_30;
          }
          v36 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, _QWORD))(a1 + 128);
          if ( v36 )
            v36(a1, 11LL, v41, *(_QWORD *)(a1 + 136));
          v33 = *(void (__fastcall **)(__int64, __int64, unsigned __int64 *, __int64))(a1 + 112);
          if ( v33 )
          {
            v34 = *(_QWORD *)(a1 + 120);
            v35 = 11LL;
            goto LABEL_72;
          }
LABEL_30:
          if ( *v7 < v14 )
            v14 = 0LL;
          memmove(*v5, (char *)*v5 + v14, *v7 - v14);
          v6 = *v7 - v14;
        }
      }
    }
  }
}

//----- (000000000001BF6C) ----------------------------------------------------
void mg_ws_upgrade(__int64 a1, __int64 a2, const char *a3, ...)
{
  unsigned __int64 v6; // x25
  __int64 v7; // x9
  __int64 v8; // x8
  __int64 v9; // x27
  __int64 v10; // x28
  int v11; // w22
  int v12; // w23
  __int64 v13; // x9
  unsigned __int64 v14; // x22
  __int128 *v15; // x23
  __int128 v16; // q1
  __int128 v17; // q2
  __int128 v18; // q3
  __int64 v19; // x25
  __int64 v20; // x8
  bool v21; // cf
  unsigned __int64 v22; // x8
  int v23; // w9
  __int64 v24; // x8
  char *v25; // x0
  __int64 v26; // x22
  int v27; // w8
  char v28; // w10
  unsigned int v29; // w10
  char v30; // w10
  unsigned int v31; // w10
  char v32; // w8
  unsigned int v33; // w9
  char v34; // w8
  int v35; // w8
  char v36; // w10
  unsigned int v37; // w10
  char v38; // w10
  unsigned int v39; // w10
  char v40; // w8
  unsigned int v41; // w9
  char v42; // w8
  int v43; // w8
  char v44; // w10
  unsigned int v45; // w10
  char v46; // w10
  unsigned int v47; // w10
  char v48; // w8
  unsigned int v49; // w9
  char v50; // w8
  int v51; // w8
  char v52; // w10
  unsigned int v53; // w10
  char v54; // w10
  unsigned int v55; // w10
  char v56; // w8
  unsigned int v57; // w9
  char v58; // w8
  int v59; // w8
  char v60; // w10
  unsigned int v61; // w10
  char v62; // w10
  unsigned int v63; // w10
  char v64; // w8
  unsigned int v65; // w9
  char v66; // w8
  int v67; // w8
  char v68; // w10
  unsigned int v69; // w10
  char v70; // w10
  unsigned int v71; // w10
  char v72; // w8
  unsigned int v73; // w9
  char v74; // w9
  int v75; // w9
  char v76; // w10
  unsigned int v77; // w10
  char v78; // w8
  unsigned int v79; // w8
  char v80; // w8
  char *v81; // x20
  gcc_va_list va1; // [xsp+B0h] [xbp-1E0h] BYREF
  gcc_va_list va; // [xsp+D0h] [xbp-1C0h] BYREF
  gcc_va_list va2; // [xsp+F0h] [xbp-1A0h] BYREF
  char *v85; // [xsp+118h] [xbp-178h] BYREF
  __int128 v86; // [xsp+120h] [xbp-170h] BYREF
  int v87; // [xsp+130h] [xbp-160h]
  unsigned __int64 v88; // [xsp+134h] [xbp-15Ch]
  _OWORD v89[4]; // [xsp+13Ch] [xbp-154h] BYREF
  char v90[129]; // [xsp+17Ch] [xbp-114h] BYREF
  char v91; // [xsp+1FDh] [xbp-93h]
  char v92; // [xsp+1FEh] [xbp-92h]
  char v93; // [xsp+1FFh] [xbp-91h]
  char v94; // [xsp+200h] [xbp-90h]
  char v95; // [xsp+201h] [xbp-8Fh]
  char v96; // [xsp+202h] [xbp-8Eh]
  char v97; // [xsp+203h] [xbp-8Dh]
  char v98; // [xsp+204h] [xbp-8Ch]
  char v99; // [xsp+205h] [xbp-8Bh]
  char v100; // [xsp+206h] [xbp-8Ah]
  char v101; // [xsp+207h] [xbp-89h]
  char v102; // [xsp+208h] [xbp-88h]
  char v103; // [xsp+209h] [xbp-87h]
  char v104; // [xsp+20Ah] [xbp-86h]
  char v105; // [xsp+20Bh] [xbp-85h]
  char v106; // [xsp+20Ch] [xbp-84h]
  char v107; // [xsp+20Dh] [xbp-83h]
  char v108; // [xsp+20Eh] [xbp-82h]
  char v109; // [xsp+20Fh] [xbp-81h]
  char v110; // [xsp+210h] [xbp-80h]
  char v111; // [xsp+211h] [xbp-7Fh]
  char v112; // [xsp+212h] [xbp-7Eh]
  char v113; // [xsp+213h] [xbp-7Dh]
  char v114; // [xsp+214h] [xbp-7Ch]
  char v115; // [xsp+215h] [xbp-7Bh]
  char v116; // [xsp+216h] [xbp-7Ah]
  __int16 v117; // [xsp+217h] [xbp-79h]
  unsigned __int8 v118; // [xsp+21Ch] [xbp-74h] BYREF
  unsigned __int8 v119; // [xsp+21Dh] [xbp-73h]
  unsigned __int8 v120; // [xsp+21Eh] [xbp-72h]
  unsigned __int8 v121; // [xsp+21Fh] [xbp-71h]
  unsigned __int8 v122; // [xsp+220h] [xbp-70h]
  unsigned __int8 v123; // [xsp+221h] [xbp-6Fh]
  unsigned __int8 v124; // [xsp+222h] [xbp-6Eh]
  unsigned __int8 v125; // [xsp+223h] [xbp-6Dh]
  unsigned __int8 v126; // [xsp+224h] [xbp-6Ch]
  unsigned __int8 v127; // [xsp+225h] [xbp-6Bh]
  unsigned __int8 v128; // [xsp+226h] [xbp-6Ah]
  unsigned __int8 v129; // [xsp+227h] [xbp-69h]
  unsigned __int8 v130; // [xsp+228h] [xbp-68h]
  unsigned __int8 v131; // [xsp+229h] [xbp-67h]
  unsigned __int8 v132; // [xsp+22Ah] [xbp-66h]
  unsigned __int8 v133; // [xsp+22Bh] [xbp-65h]
  unsigned __int8 v134; // [xsp+22Ch] [xbp-64h]
  unsigned __int8 v135; // [xsp+22Dh] [xbp-63h]
  unsigned __int8 v136; // [xsp+22Eh] [xbp-62h]
  unsigned __int8 v137; // [xsp+22Fh] [xbp-61h]
  __int64 v138; // [xsp+230h] [xbp-60h]

  v6 = 0LL;
  v138 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  do
  {
    v7 = a2 + 32 * v6;
    v8 = *(_QWORD *)(v7 + 72);
    if ( v8 == 17 )
    {
      v9 = *(_QWORD *)(v7 + 64);
      v10 = 0LL;
      while ( 1 )
      {
        v11 = *(unsigned __int8 *)(v9 + v10);
        v12 = tolower(v11);
        if ( v12 != tolower((unsigned __int8)aSecWebsocketKe[v10]) )
          break;
        if ( v11 )
        {
          if ( ++v10 != 17 )
            continue;
        }
        *(_QWORD *)(a1 + 128) = sub_1BA80;
        va_start(va, a3);
        v13 = a2 + 32 * v6;
        v15 = *(__int128 **)(v13 + 80);
        v14 = *(_QWORD *)(v13 + 88);
        v86 = xmmword_1DED0;
        v85 = v90;
        v87 = -1009589776;
        v88 = 8 * v14;
        va_copy(va1, va);
        if ( v14 < 0x40 )
        {
          v20 = 0LL;
        }
        else
        {
          v16 = v15[3];
          v17 = *v15;
          v18 = v15[1];
          v89[2] = v15[2];
          v89[3] = v16;
          v89[0] = v17;
          v89[1] = v18;
          mg_sha1_transform(&v86, (unsigned int *)v89);
          if ( v14 < 0x80 )
          {
            v20 = 64LL;
          }
          else
          {
            v19 = 4LL;
            do
            {
              mg_sha1_transform(&v86, (unsigned int *)&v15[v19]);
              v20 = v19 * 16 + 64;
              v21 = v19 * 16 + 127 >= v14;
              v19 += 4LL;
            }
            while ( !v21 );
          }
        }
        memcpy(v89, (char *)v15 + v20, v14 - v20);
        v22 = (unsigned int)v88;
        LODWORD(v88) = v88 + 288;
        v23 = HIDWORD(v88);
        if ( (unsigned int)v22 >= 0xFFFFFEE0 )
          v23 = ++HIDWORD(v88);
        HIDWORD(v88) = v23;
        v24 = (v22 >> 3) & 0x3F;
        v25 = (char *)v89 + v24;
        if ( (unsigned int)v24 < 0x1C )
        {
          v26 = 0LL;
        }
        else
        {
          v26 = 64 - v24;
          memcpy(v25, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", 64 - v24);
          mg_sha1_transform(&v86, (unsigned int *)v89);
          v25 = (char *)v89;
        }
        memcpy(v25, &a258eafa5E91447[v26], 36 - v26);
        mg_sha1_final((__int64)&v118, (__int64)&v86);
        v27 = v118 >> 2;
        if ( v118 > 0x67u )
        {
          if ( v118 > 0xCFu )
          {
            if ( v118 > 0xF7u )
            {
              if ( v27 == 62 )
                v28 = 43;
              else
                v28 = 47;
            }
            else
            {
              v28 = v27 - 4;
            }
          }
          else
          {
            v28 = v27 + 71;
          }
        }
        else
        {
          v28 = v27 + 65;
        }
        v90[128] = v28;
        v91 = 16 * (v118 & 3);
        v29 = (v119 >> 4) & 0xFFFFFFCF | (16 * (v118 & 3));
        if ( v29 > 0x19 )
        {
          if ( v29 > 0x33 )
          {
            if ( v29 > 0x3D )
            {
              if ( v29 == 62 )
                v30 = 43;
              else
                v30 = 47;
            }
            else
            {
              v30 = v29 - 4;
            }
          }
          else
          {
            v30 = v29 + 71;
          }
        }
        else
        {
          v30 = v29 + 65;
        }
        v91 = v30;
        v92 = 4 * (v119 & 0xF);
        v31 = (v120 >> 6) & 0xFFFFFFC3 | (4 * (v119 & 0xF));
        if ( v31 > 0x19 )
        {
          if ( v31 > 0x33 )
          {
            if ( v31 > 0x3D )
            {
              if ( v31 == 62 )
                v32 = 43;
              else
                v32 = 47;
            }
            else
            {
              v32 = v31 - 4;
            }
          }
          else
          {
            v32 = v31 + 71;
          }
        }
        else
        {
          v32 = v31 + 65;
        }
        v33 = v120 & 0x3F;
        v92 = v32;
        if ( v33 > 0x19 )
        {
          if ( v33 > 0x33 )
          {
            if ( v33 > 0x3D )
            {
              if ( v33 == 62 )
                v34 = 43;
              else
                v34 = 47;
            }
            else
            {
              v34 = v33 - 4;
            }
          }
          else
          {
            v34 = v33 + 71;
          }
        }
        else
        {
          v34 = v33 + 65;
        }
        v93 = v34;
        v35 = v121 >> 2;
        if ( v121 > 0x67u )
        {
          if ( v121 > 0xCFu )
          {
            if ( v121 > 0xF7u )
            {
              if ( v35 == 62 )
                v36 = 43;
              else
                v36 = 47;
            }
            else
            {
              v36 = v35 - 4;
            }
          }
          else
          {
            v36 = v35 + 71;
          }
        }
        else
        {
          v36 = v35 + 65;
        }
        v94 = v36;
        v95 = 16 * (v121 & 3);
        v37 = (v122 >> 4) & 0xFFFFFFCF | (16 * (v121 & 3));
        if ( v37 > 0x19 )
        {
          if ( v37 > 0x33 )
          {
            if ( v37 > 0x3D )
            {
              if ( v37 == 62 )
                v38 = 43;
              else
                v38 = 47;
            }
            else
            {
              v38 = v37 - 4;
            }
          }
          else
          {
            v38 = v37 + 71;
          }
        }
        else
        {
          v38 = v37 + 65;
        }
        v95 = v38;
        v96 = 4 * (v122 & 0xF);
        v39 = (v123 >> 6) & 0xFFFFFFC3 | (4 * (v122 & 0xF));
        if ( v39 > 0x19 )
        {
          if ( v39 > 0x33 )
          {
            if ( v39 > 0x3D )
            {
              if ( v39 == 62 )
                v40 = 43;
              else
                v40 = 47;
            }
            else
            {
              v40 = v39 - 4;
            }
          }
          else
          {
            v40 = v39 + 71;
          }
        }
        else
        {
          v40 = v39 + 65;
        }
        v41 = v123 & 0x3F;
        v96 = v40;
        if ( v41 > 0x19 )
        {
          if ( v41 > 0x33 )
          {
            if ( v41 > 0x3D )
            {
              if ( v41 == 62 )
                v42 = 43;
              else
                v42 = 47;
            }
            else
            {
              v42 = v41 - 4;
            }
          }
          else
          {
            v42 = v41 + 71;
          }
        }
        else
        {
          v42 = v41 + 65;
        }
        v97 = v42;
        v43 = v124 >> 2;
        if ( v124 > 0x67u )
        {
          if ( v124 > 0xCFu )
          {
            if ( v124 > 0xF7u )
            {
              if ( v43 == 62 )
                v44 = 43;
              else
                v44 = 47;
            }
            else
            {
              v44 = v43 - 4;
            }
          }
          else
          {
            v44 = v43 + 71;
          }
        }
        else
        {
          v44 = v43 + 65;
        }
        v98 = v44;
        v99 = 16 * (v124 & 3);
        v45 = (v125 >> 4) & 0xFFFFFFCF | (16 * (v124 & 3));
        if ( v45 > 0x19 )
        {
          if ( v45 > 0x33 )
          {
            if ( v45 > 0x3D )
            {
              if ( v45 == 62 )
                v46 = 43;
              else
                v46 = 47;
            }
            else
            {
              v46 = v45 - 4;
            }
          }
          else
          {
            v46 = v45 + 71;
          }
        }
        else
        {
          v46 = v45 + 65;
        }
        v99 = v46;
        v100 = 4 * (v125 & 0xF);
        v47 = (v126 >> 6) & 0xFFFFFFC3 | (4 * (v125 & 0xF));
        if ( v47 > 0x19 )
        {
          if ( v47 > 0x33 )
          {
            if ( v47 > 0x3D )
            {
              if ( v47 == 62 )
                v48 = 43;
              else
                v48 = 47;
            }
            else
            {
              v48 = v47 - 4;
            }
          }
          else
          {
            v48 = v47 + 71;
          }
        }
        else
        {
          v48 = v47 + 65;
        }
        v49 = v126 & 0x3F;
        v100 = v48;
        if ( v49 > 0x19 )
        {
          if ( v49 > 0x33 )
          {
            if ( v49 > 0x3D )
            {
              if ( v49 == 62 )
                v50 = 43;
              else
                v50 = 47;
            }
            else
            {
              v50 = v49 - 4;
            }
          }
          else
          {
            v50 = v49 + 71;
          }
        }
        else
        {
          v50 = v49 + 65;
        }
        v101 = v50;
        v51 = v127 >> 2;
        if ( v127 > 0x67u )
        {
          if ( v127 > 0xCFu )
          {
            if ( v127 > 0xF7u )
            {
              if ( v51 == 62 )
                v52 = 43;
              else
                v52 = 47;
            }
            else
            {
              v52 = v51 - 4;
            }
          }
          else
          {
            v52 = v51 + 71;
          }
        }
        else
        {
          v52 = v51 + 65;
        }
        v102 = v52;
        v103 = 16 * (v127 & 3);
        v53 = (v128 >> 4) & 0xFFFFFFCF | (16 * (v127 & 3));
        if ( v53 > 0x19 )
        {
          if ( v53 > 0x33 )
          {
            if ( v53 > 0x3D )
            {
              if ( v53 == 62 )
                v54 = 43;
              else
                v54 = 47;
            }
            else
            {
              v54 = v53 - 4;
            }
          }
          else
          {
            v54 = v53 + 71;
          }
        }
        else
        {
          v54 = v53 + 65;
        }
        v103 = v54;
        v104 = 4 * (v128 & 0xF);
        v55 = (v129 >> 6) & 0xFFFFFFC3 | (4 * (v128 & 0xF));
        if ( v55 > 0x19 )
        {
          if ( v55 > 0x33 )
          {
            if ( v55 > 0x3D )
            {
              if ( v55 == 62 )
                v56 = 43;
              else
                v56 = 47;
            }
            else
            {
              v56 = v55 - 4;
            }
          }
          else
          {
            v56 = v55 + 71;
          }
        }
        else
        {
          v56 = v55 + 65;
        }
        v57 = v129 & 0x3F;
        v104 = v56;
        if ( v57 > 0x19 )
        {
          if ( v57 > 0x33 )
          {
            if ( v57 > 0x3D )
            {
              if ( v57 == 62 )
                v58 = 43;
              else
                v58 = 47;
            }
            else
            {
              v58 = v57 - 4;
            }
          }
          else
          {
            v58 = v57 + 71;
          }
        }
        else
        {
          v58 = v57 + 65;
        }
        v105 = v58;
        v59 = v130 >> 2;
        if ( v130 > 0x67u )
        {
          if ( v130 > 0xCFu )
          {
            if ( v130 > 0xF7u )
            {
              if ( v59 == 62 )
                v60 = 43;
              else
                v60 = 47;
            }
            else
            {
              v60 = v59 - 4;
            }
          }
          else
          {
            v60 = v59 + 71;
          }
        }
        else
        {
          v60 = v59 + 65;
        }
        v106 = v60;
        v107 = 16 * (v130 & 3);
        v61 = (v131 >> 4) & 0xFFFFFFCF | (16 * (v130 & 3));
        if ( v61 > 0x19 )
        {
          if ( v61 > 0x33 )
          {
            if ( v61 > 0x3D )
            {
              if ( v61 == 62 )
                v62 = 43;
              else
                v62 = 47;
            }
            else
            {
              v62 = v61 - 4;
            }
          }
          else
          {
            v62 = v61 + 71;
          }
        }
        else
        {
          v62 = v61 + 65;
        }
        v107 = v62;
        v108 = 4 * (v131 & 0xF);
        v63 = (v132 >> 6) & 0xFFFFFFC3 | (4 * (v131 & 0xF));
        if ( v63 > 0x19 )
        {
          if ( v63 > 0x33 )
          {
            if ( v63 > 0x3D )
            {
              if ( v63 == 62 )
                v64 = 43;
              else
                v64 = 47;
            }
            else
            {
              v64 = v63 - 4;
            }
          }
          else
          {
            v64 = v63 + 71;
          }
        }
        else
        {
          v64 = v63 + 65;
        }
        v65 = v132 & 0x3F;
        v108 = v64;
        if ( v65 > 0x19 )
        {
          if ( v65 > 0x33 )
          {
            if ( v65 > 0x3D )
            {
              if ( v65 == 62 )
                v66 = 43;
              else
                v66 = 47;
            }
            else
            {
              v66 = v65 - 4;
            }
          }
          else
          {
            v66 = v65 + 71;
          }
        }
        else
        {
          v66 = v65 + 65;
        }
        v109 = v66;
        v67 = v133 >> 2;
        if ( v133 > 0x67u )
        {
          if ( v133 > 0xCFu )
          {
            if ( v133 > 0xF7u )
            {
              if ( v67 == 62 )
                v68 = 43;
              else
                v68 = 47;
            }
            else
            {
              v68 = v67 - 4;
            }
          }
          else
          {
            v68 = v67 + 71;
          }
        }
        else
        {
          v68 = v67 + 65;
        }
        v110 = v68;
        v111 = 16 * (v133 & 3);
        v69 = (v134 >> 4) & 0xFFFFFFCF | (16 * (v133 & 3));
        if ( v69 > 0x19 )
        {
          if ( v69 > 0x33 )
          {
            if ( v69 > 0x3D )
            {
              if ( v69 == 62 )
                v70 = 43;
              else
                v70 = 47;
            }
            else
            {
              v70 = v69 - 4;
            }
          }
          else
          {
            v70 = v69 + 71;
          }
        }
        else
        {
          v70 = v69 + 65;
        }
        v111 = v70;
        v112 = 4 * (v134 & 0xF);
        v71 = (v135 >> 6) & 0xFFFFFFC3 | (4 * (v134 & 0xF));
        if ( v71 > 0x19 )
        {
          if ( v71 > 0x33 )
          {
            if ( v71 > 0x3D )
            {
              if ( v71 == 62 )
                v72 = 43;
              else
                v72 = 47;
            }
            else
            {
              v72 = v71 - 4;
            }
          }
          else
          {
            v72 = v71 + 71;
          }
        }
        else
        {
          v72 = v71 + 65;
        }
        v73 = v135 & 0x3F;
        v112 = v72;
        if ( v73 > 0x19 )
        {
          if ( v73 > 0x33 )
          {
            if ( v73 > 0x3D )
            {
              if ( v73 == 62 )
                v74 = 43;
              else
                v74 = 47;
            }
            else
            {
              v74 = v73 - 4;
            }
          }
          else
          {
            v74 = v73 + 71;
          }
        }
        else
        {
          v74 = v73 + 65;
        }
        v113 = v74;
        v75 = v136 >> 2;
        if ( v136 > 0x67u )
        {
          if ( v136 > 0xCFu )
          {
            if ( v136 > 0xF7u )
            {
              if ( v75 == 62 )
                v76 = 43;
              else
                v76 = 47;
            }
            else
            {
              v76 = v75 - 4;
            }
          }
          else
          {
            v76 = v75 + 71;
          }
        }
        else
        {
          v76 = v75 + 65;
        }
        v114 = v76;
        v115 = 16 * (v136 & 3);
        v77 = (v137 >> 4) & 0xFFFFFFCF | (16 * (v136 & 3));
        if ( v77 > 0x19 )
        {
          if ( v77 > 0x33 )
          {
            if ( v77 > 0x3D )
            {
              if ( v77 == 62 )
                v78 = 43;
              else
                v78 = 47;
            }
            else
            {
              v78 = v77 - 4;
            }
          }
          else
          {
            v78 = v77 + 71;
          }
        }
        else
        {
          v78 = v77 + 65;
        }
        v115 = v78;
        v79 = 4 * (v137 & 0xF);
        v116 = 4 * (v137 & 0xF);
        if ( v79 > 0x19 )
        {
          if ( v79 > 0x33 )
            v80 = v79 - 4;
          else
            v80 = v79 + 71;
        }
        else
        {
          v80 = v79 | 0x41;
        }
        v116 = v80;
        v117 = 61;
        v90[0] = 0;
        if ( a3 )
        {
          va_copy(va2, va1);
          mg_vasprintf(&v85, 0x80uLL, a3, (__int128 *)va2);
          v81 = v85;
          mg_printf(
            a1,
            "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Accept: %s\r\n"
            "%s\r\n");
          if ( v81 != v90 )
            free(v81);
        }
        else
        {
          mg_printf(
            a1,
            "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Accept: %s\r\n"
            "%s\r\n");
        }
        goto LABEL_268;
      }
    }
    else if ( !v8 )
    {
      break;
    }
    ++v6;
  }
  while ( v6 < 0x28 );
  *(_QWORD *)(a1 + 128) = sub_1BA80;
LABEL_268:
  *(_WORD *)(a1 + 208) |= 0x100u;
}
// 1DED0: using guessed type __int128 xmmword_1DED0;

//----- (000000000001CAF0) ----------------------------------------------------
void __fastcall sub_1CAF0(__int64 a1, int a2, unsigned __int64 *a3)
{
  _QWORD *v3; // x8
  unsigned __int64 v4; // x20
  _QWORD *v5; // x21
  char v7; // w0
  __int64 *v8; // x20
  int v9; // w8
  __int64 *v10; // x25
  __int64 v11; // x8
  __int16 v12; // w9
  __int64 v13; // x8
  __int128 v14; // q1
  __int64 *v15; // x9
  __int64 *v16; // x8
  __int64 *v17; // x0
  __int64 *v18; // x20
  __int64 *v19; // x9
  __int64 *v20; // x8
  char *v21; // x20
  char s[100]; // [xsp+Ch] [xbp-1E4h] BYREF
  __int16 v23; // [xsp+70h] [xbp-180h] BYREF
  char v24; // [xsp+72h] [xbp-17Eh]
  _OWORD v25[18]; // [xsp+74h] [xbp-17Ch]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a2 != 7 )
  {
    if ( a2 != 5 )
    {
      if ( a2 == 1 )
      {
        v3 = (_QWORD *)qword_33510;
        if ( qword_33510 )
        {
          v4 = *a3;
          do
          {
            v5 = (_QWORD *)*v3;
            if ( v4 > v3[2] )
              mg_error(v3[1], "DNS timeout");
            v3 = v5;
          }
          while ( v5 );
        }
      }
      return;
    }
    mg_dns_parse(*(unsigned __int16 **)(a1 + 64), *(_QWORD *)(a1 + 80), (__int64)&v23);
    if ( (v7 & 1) != 0 )
    {
      if ( (mg_log_prefix(
              4,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x115u,
              "dns_cb") & 1) != 0 )
        mg_log("%s %d");
      v8 = (__int64 *)qword_33510;
      if ( qword_33510 )
      {
        v9 = 0;
        do
        {
          v10 = (__int64 *)*v8;
          if ( v23 == *((_WORD *)v8 + 12) )
          {
            v11 = v8[1];
            v12 = *(_WORD *)(v11 + 208);
            if ( (v12 & 8) != 0 )
            {
              *(_WORD *)(v11 + 208) = v12 & 0xFFF7;
              if ( v24 )
              {
                v13 = v8[1];
                LOWORD(v25[0]) = *(_WORD *)(v13 + 16);
                v14 = v25[0];
                *(_OWORD *)(v13 + 28) = *(_OWORD *)((char *)v25 + 12);
                *(_OWORD *)(v13 + 16) = v14;
                if ( (mg_log_prefix(
                        3,
                        "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                        0x123u,
                        "dns_cb") & 1) != 0 )
                {
                  mg_ntoa(v8[1] + 16, s, 0x64uLL);
                  mg_log("%lu %s resolved to %s");
                }
                mg_connect_resolved(v8[1]);
              }
              else
              {
                mg_error(v8[1], "%s DNS lookup failed");
              }
            }
            else if ( (mg_log_prefix(
                         1,
                         "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
                         0x12Eu,
                         "dns_cb") & 1) != 0 )
            {
              mg_log("%lu already resolved");
            }
            v15 = &qword_33510;
            do
            {
              v16 = v15;
              v15 = (__int64 *)*v15;
            }
            while ( v15 != v8 );
            *v16 = *v8;
            free(v8);
            v9 = 1;
          }
          v8 = v10;
        }
        while ( v10 );
        if ( v9 )
          goto LABEL_40;
      }
    }
    else
    {
      v21 = mg_hexdump(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 80));
      if ( (mg_log_prefix(
              1,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
              0x112u,
              "dns_cb") & 1) != 0 )
        mg_log("Unexpected DNS response:\n%s\n");
      free(v21);
    }
    if ( (mg_log_prefix(
            1,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mongoose.c",
            0x134u,
            "dns_cb") & 1) != 0 )
      mg_log("stray DNS reply");
LABEL_40:
    *(_QWORD *)(a1 + 80) = 0LL;
    return;
  }
  v17 = (__int64 *)qword_33510;
  if ( qword_33510 )
  {
    do
    {
      v18 = (__int64 *)*v17;
      v19 = &qword_33510;
      do
      {
        v20 = v19;
        v19 = (__int64 *)*v19;
      }
      while ( v19 != v17 );
      *v20 = *v17;
      free(v17);
      v17 = v18;
    }
    while ( v18 );
  }
}
// 1CB8C: variable 'v7' is possibly undefined
// 33510: using guessed type __int64 qword_33510;
// 1CAF0: using guessed type _OWORD var_17C[18];
// 1CAF0: using guessed type char s[100];

//----- (000000000001CE1C) ----------------------------------------------------
size_t __fastcall sub_1CE1C(const void *a1, int a2)
{
  return fwrite(a1, 1uLL, a2, (FILE *)((char *)&_sF + 152));
}

//----- (000000000001CE34) ----------------------------------------------------
__int64 __fastcall sub_1CE34(const char *a1, int a2)
{
  printf("cb-usbres:%.*s\n", a2, a1);
  return 0LL;
}

//----- (000000000001CE58) ----------------------------------------------------
__int64 client_thread()
{
  signed int v1; // w0

  if ( client_fd > 0 )
    return 0xFFFFFFFFLL;
  v1 = mqtt_create();
  client_fd = v1;
  if ( v1 < 1 )
    return 4294967294LL;
  mqtt_sub_cb(v1, client_st, (__int64)off_33208);
  return 0LL;
}
// 33208: using guessed type __int64 (__fastcall *off_33208)();
// 33538: using guessed type int client_fd;

//----- (000000000001CEB8) ----------------------------------------------------
__int64 __fastcall send_data(int a1, __int64 a2, int a3)
{
  char *v5; // x1

  switch ( a1 )
  {
    case 3:
      v5 = "pd/send/lora";
      goto LABEL_7;
    case 2:
      v5 = "pd/send/esp32";
      goto LABEL_7;
    case 1:
      v5 = "pd/send/usb";
LABEL_7:
      mqtt_pub(client_fd, v5, a2, a3);
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001CF38) ----------------------------------------------------
__int64 __fastcall send_cmd(const char *a1)
{
  int v2; // w19
  int v3; // w0

  v2 = client_fd;
  v3 = strlen(a1);
  mqtt_pub(v2, "pd/send/cmd", (__int64)a1, v3 + 1);
  return 0LL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001CF80) ----------------------------------------------------
__int64 __fastcall client_regeister(const char *a1, __int64 a2)
{
  mqtt_sub_cb(client_fd, a1, a2);
  return 0LL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001CFB0) ----------------------------------------------------
__int64 easynode_init()
{
  unsigned int v0; // w19
  signed int v1; // w0

  if ( client_fd <= 0 )
  {
    v1 = mqtt_create();
    client_fd = v1;
    if ( v1 < 1 )
    {
      v0 = -2;
    }
    else
    {
      mqtt_sub_cb(v1, client_st, (__int64)off_33208);
      v0 = 0;
    }
  }
  else
  {
    v0 = -1;
  }
  printf("[%s %d]compile time %s\n", "easynode_init", 117LL, "15:14:19");
  return v0;
}
// 33208: using guessed type __int64 (__fastcall *off_33208)();
// 33538: using guessed type int client_fd;

//----- (000000000001D034) ----------------------------------------------------
__int64 __fastcall register_ctrl(__int64 a1)
{
  mqtt_sub_cb(client_fd, "pd/recv/usb", a1);
  return 0LL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001D068) ----------------------------------------------------
__int64 __fastcall register_esp32(__int64 a1)
{
  mqtt_sub_cb(client_fd, "pd/recv/esp32", a1);
  return 0LL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001D09C) ----------------------------------------------------
__int64 __fastcall register_lora(__int64 a1)
{
  mqtt_sub_cb(client_fd, "pd/recv/lora", a1);
  return 0LL;
}
// 33538: using guessed type int client_fd;

//----- (000000000001D0D0) ----------------------------------------------------
__int64 get_mqtt_connect_state()
{
  return (unsigned int)state;
}
// 33580: using guessed type int state;

//----- (000000000001D0E0) ----------------------------------------------------
void __fastcall __noreturn mqtt_thread(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x1
  __int64 v4; // x0
  unsigned int v5; // w8
  __int128 v6; // [xsp+0h] [xbp-90h] BYREF
  char *v7; // [xsp+10h] [xbp-80h]
  __int64 v8; // [xsp+18h] [xbp-78h]
  char *v9; // [xsp+20h] [xbp-70h]
  __int64 v10; // [xsp+28h] [xbp-68h]
  __int64 v11; // [xsp+30h] [xbp-60h]
  __int64 v12[8]; // [xsp+40h] [xbp-50h] BYREF

  mg_mgr_init((__int64)v12);
  v6 = 0u;
  v11 = 1LL;
  v7 = mg_str("pd/bye");
  v8 = v2;
  v9 = mg_str("goodbye");
  v10 = v3;
  v4 = mg_mqtt_connect((__int64)v12, "0.0.0.0:1883", &v6, (__int64)sub_1D1B0, a1);
  v5 = *(_DWORD *)(a1 + 4);
  *(_QWORD *)(a1 + 16) = v4;
  if ( v5 <= 2 )
  {
    do
    {
      pthread_mutex_lock(&mqtt_mutex);
      mg_mgr_poll(v12, 100);
      pthread_mutex_unlock(&mqtt_mutex);
      usleep(0x2710u);
    }
    while ( *(_DWORD *)(a1 + 4) < 3u );
  }
  mg_mgr_free(v12);
  while ( 1 )
    usleep(0x3E8u);
}
// 1D120: variable 'v2' is possibly undefined
// 1D130: variable 'v3' is possibly undefined
// 33558: using guessed type pthread_mutex_t mqtt_mutex;
// 1D0E0: using guessed type __int64 var_50[8];

//----- (000000000001D1B0) ----------------------------------------------------
void __fastcall sub_1D1B0(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v6; // x19
  const char *v7; // x23
  size_t v8; // x24
  __int64 v9; // x20
  __int64 v10; // x22
  __int64 i; // x20
  __int64 v12; // x1
  void (__fastcall *v13)(__int64, _QWORD); // x8
  char *v14; // [xsp+8h] [xbp-78h] BYREF
  __int128 v15; // [xsp+10h] [xbp-70h]
  __int128 v16; // [xsp+20h] [xbp-60h]
  __int64 v17; // [xsp+30h] [xbp-50h]
  __int64 v18; // [xsp+38h] [xbp-48h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(a4 + 4) = 3;
      if ( (mg_log_prefix(
              1,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mqtt_mid.c",
              0x4Cu,
              "fn") & 1) != 0 )
        mg_log("%p %s");
      break;
    case 3:
      *(_DWORD *)(a4 + 4) = 1;
      if ( mg_url_is_ssl("0.0.0.0:1883") )
      {
        v17 = 0LL;
        v15 = 0u;
        v16 = 0u;
        v14 = "ca.pem";
        mg_tls_init(a1);
      }
      break;
    case 7:
      *(_DWORD *)(a4 + 4) = 4;
      state = 4;
      break;
    case 13:
      v6 = *(_QWORD *)(a4 + 24);
      if ( v6 )
      {
        v7 = *(const char **)a3;
        v8 = *(_QWORD *)(a3 + 8);
        v10 = *(_QWORD *)(a3 + 16);
        v9 = *(_QWORD *)(a3 + 24);
        while ( strncmp(v7, (const char *)v6, v8) )
        {
          v6 = *(_QWORD *)(v6 + 48);
          if ( !v6 )
            goto LABEL_11;
        }
        v13 = *(void (__fastcall **)(__int64, _QWORD))(v6 + 32);
        if ( v13 )
          v13(v10, (unsigned int)v9);
      }
      else
      {
LABEL_11:
        puts("topic no find");
      }
      break;
    case 14:
      *(_DWORD *)(a4 + 4) = 2;
      if ( (mg_log_prefix(
              2,
              "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mqtt_mid.c",
              0x58u,
              "fn") & 1) != 0 )
        mg_log("CONNECTED to %s");
      for ( i = *(_QWORD *)(a4 + 24); i; i = *(_QWORD *)(i + 48) )
      {
        v14 = mg_str((char *)i);
        *(_QWORD *)&v15 = v12;
        mg_mqtt_sub(*(_QWORD *)(a4 + 16), (__int64)&v14);
        *(_BYTE *)(i + 40) = 1;
        if ( (mg_log_prefix(
                2,
                "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mqtt_mid.c",
                0x27u,
                "mqtt_loop_sub") & 1) != 0 )
          mg_log("SUBSCRIBED to %.*s");
      }
      break;
    default:
      return;
  }
}
// 1D344: variable 'v12' is possibly undefined
// 33580: using guessed type int state;

//----- (000000000001D3D0) ----------------------------------------------------
__int64 mqtt_create()
{
  __int64 result; // x0
  _DWORD *v1; // x19
  __int64 v2; // x8
  __int64 v3; // x9
  int v4; // w8

  if ( pthread_mutex_init(&mqtt_mutex, 0LL) )
  {
    puts("mutex init failed");
    return 0xFFFFFFFFLL;
  }
  else
  {
    v1 = malloc(0x28uLL);
    v1[1] = 0;
    *((_QWORD *)v1 + 3) = 0LL;
    *((_QWORD *)v1 + 4) = 0LL;
    *((_QWORD *)v1 + 2) = 0LL;
    if ( pthread_create((pthread_t *)v1 + 1, 0LL, (void *(*)(void *))mqtt_thread, v1) )
    {
      puts("Create thread error!");
      free(v1);
      return 0xFFFFFFFFLL;
    }
    else
    {
      puts("mqtt mid create thread success");
      v2 = mqtt_mid_head;
      if ( mqtt_mid_head )
      {
        do
        {
          v3 = v2;
          v2 = *(_QWORD *)(v2 + 32);
        }
        while ( v2 );
        v4 = *(_DWORD *)v3;
        *(_QWORD *)(v3 + 32) = v1;
        result = (unsigned int)(v4 + 1);
      }
      else
      {
        mqtt_mid_head = (__int64)v1;
        result = 1LL;
      }
      *v1 = result;
    }
  }
  return result;
}
// 33540: using guessed type __int64 mqtt_mid_head;
// 33558: using guessed type pthread_mutex_t mqtt_mutex;

//----- (000000000001D4A4) ----------------------------------------------------
__int64 __fastcall mqtt_del(int a1)
{
  _QWORD *v1; // x19
  _QWORD *v2; // x21
  int v3; // w19
  _QWORD *v5; // x0
  _QWORD *v6; // x22

  if ( a1 < 1 )
  {
    v3 = 1;
    goto LABEL_11;
  }
  v1 = (_QWORD *)mqtt_mid_head;
  if ( !mqtt_mid_head )
  {
LABEL_10:
    v3 = 2;
    goto LABEL_11;
  }
  if ( *(_DWORD *)mqtt_mid_head != a1 )
  {
    while ( 1 )
    {
      v2 = v1;
      v1 = (_QWORD *)v1[4];
      if ( !v1 )
        goto LABEL_10;
      if ( *(_DWORD *)v1 == a1 )
        goto LABEL_7;
    }
  }
  v2 = 0LL;
LABEL_7:
  *((_DWORD *)v1 + 1) = 4;
  usleep(0x493E0u);
  if ( pthread_join(v1[1], 0LL) )
  {
    v3 = 3;
LABEL_11:
    printf("mqtt_del err:%d\n", (unsigned int)-v3);
    return (unsigned int)-v3;
  }
  v5 = (_QWORD *)v1[3];
  if ( v5 )
  {
    do
    {
      v6 = (_QWORD *)v5[6];
      free(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  if ( v2 )
    v2[4] = v1[4];
  else
    mqtt_mid_head = 0LL;
  free(v1);
  v3 = 0;
  return (unsigned int)-v3;
}
// 33540: using guessed type __int64 mqtt_mid_head;

//----- (000000000001D590) ----------------------------------------------------
__int64 __fastcall mqtt_sub_cb(unsigned int a1, const char *a2, __int64 a3)
{
  char *v3; // x21
  __int64 v6; // x24
  int v7; // w22
  __int64 v9; // x26
  size_t v10; // x22
  char *v11; // x0
  char *v12; // x22
  char **v13; // x8
  size_t v14; // x0
  int v15; // w8
  __int64 v16; // x1
  __int64 v17[3]; // [xsp+8h] [xbp-58h] BYREF

  v3 = (char *)a1;
  v17[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = mqtt_mid_head;
  pthread_mutex_lock(&mqtt_mutex);
  v7 = 1;
  if ( (int)v3 < 1 || !a2 || !a3 )
    goto LABEL_8;
  if ( !v6 )
  {
LABEL_7:
    v7 = 2;
LABEL_8:
    printf("-------------------sub err:%d\n", (unsigned int)-v7);
    goto LABEL_9;
  }
  while ( *(_DWORD *)v6 != (_DWORD)v3 )
  {
    v6 = *(_QWORD *)(v6 + 32);
    if ( !v6 )
      goto LABEL_7;
  }
  v9 = *(_QWORD *)(v6 + 24);
  if ( v9 )
  {
    v10 = strlen(a2);
    while ( 1 )
    {
      v3 = (char *)v9;
      if ( !strncmp(a2, (const char *)v9, v10) )
        break;
      v9 = *(_QWORD *)(v9 + 48);
      if ( !v9 )
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    v11 = (char *)malloc(0x38uLL);
    v12 = v11;
    if ( *(_QWORD *)(v6 + 24) )
      v13 = (char **)(v3 + 48);
    else
      v13 = (char **)(v6 + 24);
    *v13 = v11;
    v14 = strlen(a2);
    strncpy(v12, a2, v14 + 1);
    v3 = v12;
    *((_QWORD *)v12 + 6) = 0LL;
    v12[40] = 0;
  }
  v15 = (unsigned __int8)v3[40];
  *((_QWORD *)v3 + 4) = a3;
  if ( !v15 && *(_DWORD *)(v6 + 4) == 2 )
  {
    v3[40] = 1;
    v17[0] = (__int64)mg_str(v3);
    v17[1] = v16;
    mg_mqtt_sub(*(_QWORD *)(v6 + 16), (__int64)v17);
    if ( (mg_log_prefix(
            2,
            "D:\\project\\MirEasyNodeApp\\EasyNodeLib\\src\\main\\jni\\usb_decode\\mqtt\\mqtt_mid.c",
            0x132u,
            "mqtt_sub_cb") & 1) != 0 )
      mg_log("SUBSCRIBED to %.*s");
  }
  v7 = 0;
LABEL_9:
  pthread_mutex_unlock(&mqtt_mutex);
  return (unsigned int)-v7;
}
// 1D700: variable 'v16' is possibly undefined
// 33540: using guessed type __int64 mqtt_mid_head;
// 33558: using guessed type pthread_mutex_t mqtt_mutex;

//----- (000000000001D750) ----------------------------------------------------
__int64 __fastcall mqtt_pub(int a1, char *a2, __int64 a3, int a4)
{
  __int64 v8; // x25
  unsigned int v9; // w19
  __int64 v11; // x1
  __int64 v12; // x1
  __int64 v13[2]; // [xsp+8h] [xbp-68h] BYREF
  __int64 v14[3]; // [xsp+18h] [xbp-58h] BYREF

  v14[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = mqtt_mid_head;
  pthread_mutex_lock(&mqtt_mutex);
  v9 = 1;
  if ( (a1 & 0x80000000) == 0 && a2 && a3 && a4 )
  {
    if ( v8 )
    {
      while ( *(_DWORD *)v8 != a1 )
      {
        v8 = *(_QWORD *)(v8 + 32);
        if ( !v8 )
          goto LABEL_8;
      }
      if ( *(_DWORD *)(v8 + 4) == 2 )
      {
        v14[0] = mg_str_n();
        v14[1] = v11;
        v13[0] = (__int64)mg_str(a2);
        v13[1] = v12;
        mg_mqtt_pub(*(_QWORD *)(v8 + 16), (__int64)v13, (__int64)v14);
        v9 = 0;
        goto LABEL_10;
      }
      v9 = 3;
    }
    else
    {
LABEL_8:
      v9 = 2;
    }
  }
  printf("[%s %d]pub err:%d\n", "mqtt_pub", 360LL, v9);
LABEL_10:
  pthread_mutex_unlock(&mqtt_mutex);
  return -v9;
}
// 1D840: variable 'v11' is possibly undefined
// 1D84C: variable 'v12' is possibly undefined
// 33540: using guessed type __int64 mqtt_mid_head;
// 33558: using guessed type pthread_mutex_t mqtt_mutex;

// nfuncs=496 queued=286 decompiled=286 lumina nreq=0 worse=0 better=0
// ALL OK, 286 function(s) have been successfully decompiled
