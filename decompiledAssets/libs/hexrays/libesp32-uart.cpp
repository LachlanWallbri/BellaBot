/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_7420();
// char *strerror(int errnum);
// void *memcpy(void *dest, const void *src, size_t n);
// FILE *fopen(const char *filename, const char *modes);
// DIR *opendir(const char *name);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
bool __fastcall pudutech::ESP32::checkHardwareHandshake(pudutech::ESP32 *this);
// void __fastcall operator delete(void *); idb
__int64 __fastcall pudutech::ESP32::openDev(pudutech::ESP32 *this); // idb
bool __fastcall pudutech::ESP32::connectStatus(pudutech::ESP32 *this);
// int fseeko(FILE *stream, __off_t off, int whence);
// int close(int fd);
// _QWORD __fastcall operator new[](unsigned __int64); idb
// _QWORD __fastcall std::logic_error::logic_error(std::logic_error *__hidden this, const char *); idb
// void __fastcall std::ios_base::~ios_base(std::ios_base *__hidden this); idb
// _QWORD __fastcall std::ios_base::clear(std::ios_base *__hidden this, unsigned int); idb
// int tcflush(int fd, int queue_selector);
// void __cxa_end_catch(void);
_QWORD *__fastcall std::shared_ptr<pudutech::ESP32>::shared_ptr<pudutech::ESP32>(_QWORD *a1, __int64 a2);
// void *__fastcall __cxa_allocate_exception(size_t thrown_size);
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
// ssize_t readlink(const char *path, char *buf, size_t len);
__int64 __fastcall pudutech::ESP32::resetChannel(pudutech::ESP32 *this, int a2); // idb
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// _QWORD std::thread::detach(std::thread *__hidden this); idb
// _QWORD std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *__hidden this); idb
__int64 __fastcall registerPuduNativeClass(_JNIEnv *a1); // idb
__int64 __fastcall pudutech::ESP32::set_interface_attribs(pudutech::ESP32 *this, int fd, speed_t a3, int a4);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
// _QWORD std::mutex::unlock(std::mutex *__hidden this); idb
// void __fastcall std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *__hidden this); idb
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// __off_t ftello(FILE *stream);
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *memmove(void *dest, const void *src, size_t n);
__int64 __fastcall std::filebuf::sync(__int64 a1);
// size_t strlen(const char *s);
// _QWORD __fastcall std::ios_base::init(std::ios_base *__hidden this, void *); idb
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// _QWORD std::__thread_struct::__thread_struct(std::__thread_struct *__hidden this); idb
// int fclose(FILE *stream);
// __int64 __fastcall g3::logLevel(_QWORD); weak
// LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *); weak
// void __usercall zeroPadding(int a1@<W0>, unsigned __int64 *a2@<X8>);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// void __usercall pudutech::ESP32::readMsg(pudutech::ESP32 *this@<X0>, __int64 a2@<X8>);
__int64 __fastcall pudutech::ESP32::getErrorCode(pudutech::ESP32 *this); // idb
void __fastcall pudutech::ESP32::resetDevice(pudutech::ESP32 *this);
void __fastcall std::string::__init<std::istreambuf_iterator<char>>(__int64 *a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall pudutech::ESP32::openESP(pudutech::ESP32 *this, int a2, int a3); // idb
bool __fastcall pudutech::ESP32::hasHardwareResponsed(pudutech::ESP32 *this);
__int64 __fastcall pudutech::ESP32::closeESP(pudutech::ESP32 *this); // idb
// _QWORD __fastcall std::locale::locale(std::locale *__hidden this, const std::locale *); idb
// __int64 *__usercall std::operator+<char>@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
void __noreturn std::__vector_base_common<true>::__throw_length_error();
// _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this); idb
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
__int64 __fastcall pudutech::ESP32::crc16(pudutech::ESP32 *this, unsigned __int8 *a2, unsigned __int8 *a3);
// void __fastcall LogCapture::~LogCapture(LogCapture *__hidden this); idb
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c);
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1);
// _QWORD *__fastcall std::to_string(_QWORD *__hidden __return_ptr, std::__ndk1 *__hidden this, int); idb
// void __fastcall operator delete[](void *); idb
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int system(const char *command);
__int64 __fastcall pudutech::ESP32::ESP32(pudutech::ESP32 *this); // idb
// void *memset(void *s, int c, size_t n);
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
// int tcgetattr(int fd, struct termios *termios_p);
// _QWORD std::__shared_weak_count::__release_weak(std::__shared_weak_count *__hidden this); idb
void __fastcall std::filebuf::~filebuf(__int64 a1);
// void *__fastcall __cxa_begin_catch(void *);
// void __noreturn __cxa_rethrow(void);
// int ioctl(int fd, unsigned __int64 request, ...);
// void __fastcall __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (__fastcall *)(void *));
// int __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int atoi(const char *nptr);
// __int64 __fastcall g3::logTag(_QWORD); weak
// int fseek(FILE *stream, __int64 off, int whence);
// void __usercall pudutech::ESP32::parseMsg(pudutech::ESP32 *this@<X0>, void ***a2@<X8>);
// void __noreturn exit(int status);
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n);
// int memcmp(const void *s1, const void *s2, size_t n);
// ssize_t write(int fd, const void *buf, size_t n);
// __int64 __fastcall __errno(_QWORD); weak
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
// _QWORD std::chrono::steady_clock::now(std::chrono::steady_clock *__hidden this); idb
// unsigned __int64 __usercall std::stringbuf::str@<X0>(unsigned __int64 result@<X0>, unsigned __int64 *a2@<X8>);
__int64 __fastcall pudutech::ESP32::sendMsg(__int64 a1, char **a2, char a3);
void __fastcall pudutech::ESP32::set_blocking(pudutech::ESP32 *this, int fd, cc_t a3);
// void __fastcall std::thread::~thread(std::thread *__hidden this); idb
__int64 __fastcall pudutech::ESP32::getChannel(pudutech::ESP32 *this); // idb
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
// _QWORD __fastcall operator new(unsigned __int64); idb
// __int64 __fastcall std::this_thread::sleep_for(_QWORD); weak
// struct dirent *readdir(DIR *dirp);
// int __fastcall __cxa_finalize(void *);
// int fflush(FILE *stream);
void __fastcall std::string::push_back(__int64 *a1, char a2);
// void __fastcall std::__thread_struct::~__thread_struct(std::__thread_struct *__hidden this); idb
// _QWORD std::locale::locale(std::locale *__hidden this); idb
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// _QWORD *std::ios_base::getloc(_QWORD *__hidden __return_ptr, std::ios_base *__hidden this); idb
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// void __fastcall std::mutex::~mutex(std::mutex *__hidden this); idb
// _QWORD std::__thread_local_data(std::__ndk1 *__hidden this); idb
__int64 __fastcall pudutech::ESP32::blockReOpen(pudutech::ESP32 *this); // idb
// _QWORD LogCapture::capturef(LogCapture *__hidden this, const char *, ...); idb
__int64 __fastcall pudutech::ESP32::getEspFirmwareVersion(pudutech::ESP32 *this); // idb
// void __noreturn std::terminate(void); idb
// void __fastcall std::locale::~locale(std::locale *__hidden this); idb
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
// __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD); weak
// _QWORD std::uncaught_exception(void); idb
// _QWORD std::mutex::lock(std::mutex *__hidden this); idb
// _QWORD __fastcall std::__throw_system_error(std::__ndk1 *__hidden this, int, const char *); idb
// __int64 __fastcall std::locale::has_facet(_QWORD, _QWORD); weak
void __noreturn std::__basic_string_common<true>::__throw_length_error();
// void __usercall pudutech::ESP32::create(__int64 *a1@<X8>);
// int open(const char *file, int oflag, ...);
// int closedir(DIR *dirp);
__int64 start();
__int64 sub_7F10();
__int64 sub_7F30();
__int64 (*__fastcall sub_7F44(__int64 (*result)(void)))(void);
__int64 __fastcall sub_7F50(void *a1);
void __fastcall std::string::~string(__int64 a1);
void __fastcall LEVELS::~LEVELS(void **this);
// void __usercall zeroPadding(int a1@<W0>, unsigned __int64 *a2@<X8>);
void __fastcall std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(__int64 a1);
__int64 __fastcall std::shared_ptr<pudutech::ESP32>::~shared_ptr(__int64 result);
// void __usercall pudutech::ESP32::create(__int64 *a1@<X8>);
_QWORD *__fastcall std::shared_ptr<pudutech::ESP32>::shared_ptr<pudutech::ESP32>(_QWORD *a1, __int64 a2);
__int64 __fastcall pudutech::ESP32::ESP32(pudutech::ESP32 *this); // idb
__int64 __fastcall pudutech::ESP32::openESP(pudutech::ESP32 *this, int a2, int a3); // idb
__int64 __fastcall pudutech::ESP32::openDev(pudutech::ESP32 *this); // idb
__int64 __fastcall pudutech::ESP32::closeESP(pudutech::ESP32 *this); // idb
__int64 __fastcall pudutech::ESP32::resetChannel(pudutech::ESP32 *this, int a2); // idb
__int64 __fastcall pudutech::ESP32::getChannel(pudutech::ESP32 *this); // idb
// void __usercall pudutech::ESP32::readMsg(pudutech::ESP32 *this@<X0>, __int64 a2@<X8>);
// void __usercall pudutech::ESP32::parseMsg(pudutech::ESP32 *this@<X0>, void ***a2@<X8>);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
void __fastcall pudutech::ESP32::resetDevice(pudutech::ESP32 *this);
__int64 __fastcall pudutech::ESP32::blockReOpen(pudutech::ESP32 *this); // idb
__int64 __fastcall pudutech::ESP32::sendMsg(__int64 a1, char **a2, char a3);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
__int64 __fastcall pudutech::ESP32::crc16(pudutech::ESP32 *this, unsigned __int8 *a2, unsigned __int8 *a3);
bool __fastcall pudutech::ESP32::hasHardwareResponsed(pudutech::ESP32 *this);
__int64 __fastcall pudutech::ESP32::getEspFirmwareVersion(pudutech::ESP32 *this); // idb
bool __fastcall pudutech::ESP32::connectStatus(pudutech::ESP32 *this);
bool __fastcall pudutech::ESP32::checkHardwareHandshake(pudutech::ESP32 *this);
_BYTE *__fastcall pudutech::ESP32::delayLoops(_BYTE *this, int a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
__int64 __fastcall pudutech::ESP32::getErrorCode(pudutech::ESP32 *this); // idb
__int64 __fastcall sub_EFC8(int a1, char a2);
__int64 __fastcall pudutech::ESP32::set_interface_attribs(pudutech::ESP32 *this, int fd, speed_t a3, int a4);
void __fastcall pudutech::ESP32::set_blocking(pudutech::ESP32 *this, int fd, cc_t a3);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
void __noreturn std::__basic_string_common<true>::__throw_length_error();
void __fastcall __noreturn sub_12454(const char *a1);
__int64 __fastcall sub_124A4(std::logic_error *a1, const char *a2);
void __fastcall `non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(__int64 a1);
void __fastcall `virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(_QWORD *a1);
void __fastcall std::istream::~istream(__int64 a1);
void __fastcall std::istream::~istream(__int64 a1);
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1);
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1);
void __fastcall std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(char *a1);
void __fastcall `non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(__int64 a1);
void __fastcall `virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(_QWORD *a1);
void __fastcall std::stringbuf::~stringbuf(__int64 a1);
void __fastcall std::stringbuf::~stringbuf(void **a1);
__int64 __fastcall std::stringbuf::seekoff(__int64 a1, __int64 a2, int a3, char a4);
__int64 __fastcall sub_129A4(__int64 a1, __int64 a2, __int64 a3);
__int64 std::streambuf::sync();
__int64 std::streambuf::showmanyc();
__int64 __fastcall std::streambuf::xsgetn(_QWORD *a1, char *dest, __int64 a3);
__int64 __fastcall std::stringbuf::underflow(__int64 a1);
__int64 __fastcall std::streambuf::uflow(_QWORD *a1);
__int64 __fastcall std::stringbuf::pbackfail(__int64 a1, unsigned int a2);
__int64 __fastcall std::streambuf::xsputn(_QWORD *a1, unsigned __int8 *src, __int64 a3);
__int64 __fastcall std::stringbuf::overflow(_QWORD *a1, int a2);
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
__int64 std::streambuf::seekoff();
__int64 std::streambuf::seekpos();
__int64 std::streambuf::underflow();
__int64 std::streambuf::pbackfail();
__int64 std::streambuf::overflow();
void __fastcall std::string::push_back(__int64 *a1, char a2);
void __fastcall __noreturn sub_12FDC(void *a1);
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c);
// __int64 *__usercall sub_13144@<X0>(char *s@<X1>, unsigned __int8 *a2@<X0>, __int64 *a3@<X8>);
FILE *__fastcall sub_13250(__int64 a1, __int64 a2, int a3);
// __int64 *__usercall std::operator+<char>@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
void __fastcall std::fstream::~fstream(_QWORD *a1);
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n);
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1);
void __fastcall std::filebuf::~filebuf(__int64 a1);
void __fastcall std::fstream::~fstream(_QWORD *a1);
void __fastcall `non-virtual thunk to'std::fstream::~fstream(_QWORD *a1);
void __fastcall `non-virtual thunk to'std::fstream::~fstream(_QWORD *a1);
void __fastcall `virtual thunk to'std::fstream::~fstream(_QWORD *a1);
void __fastcall `virtual thunk to'std::fstream::~fstream(_QWORD *a1);
void __fastcall std::filebuf::~filebuf(void *a1);
void __fastcall std::filebuf::imbue(__int64 a1, __int64 a2);
__int64 __fastcall std::filebuf::setbuf(__int64 a1, __int64 a2, signed __int64 a3);
__int64 __fastcall std::filebuf::seekoff(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall std::filebuf::seekpos(__int64 a1, __int64 a2, __off_t a3);
__int64 __fastcall std::filebuf::sync(__int64 a1);
__int64 __fastcall std::filebuf::underflow(__int64 a1);
__int64 __fastcall std::filebuf::pbackfail(__int64 a1, unsigned int a2);
__int64 __fastcall std::filebuf::overflow(__int64 a1, unsigned int a2);
void __noreturn sub_146A4();
void __fastcall std::string::__init<std::istreambuf_iterator<char>>(__int64 *a1, _QWORD *a2, _QWORD *a3);
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
void __fastcall __noreturn sub_1480C(const char *a1);
__int64 __fastcall sub_1485C(std::logic_error *a1, const char *a2);
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14C2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
// unsigned __int64 __usercall std::stringbuf::str@<X0>(unsigned __int64 result@<X0>, unsigned __int64 *a2@<X8>);
void __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1);
void __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::__on_zero_shared(__int64 a1);
__int64 __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::__get_deleter(__int64 a1, __int64 a2);
__int64 __fastcall sub_1525C(std::__ndk1 *a1);
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this);
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this);
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(__int64 a1);
__int64 __fastcall sendMsg(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall readMsg(__int64 a1);
__int64 __fastcall openESP(int a1, int a2, int a3, int a4); // idb
__int64 closeESP();
bool checkHardwareHandshake();
bool hasHardwareResponsed();
bool connectStatus();
__int64 __fastcall resetChannel(int a1, int a2, int a3); // idb
__int64 getChannel();
__int64 getEspFirmwareVersion();
__int64 getErrorCode();
__int64 __fastcall registerPuduNativeClass(_JNIEnv *a1); // idb
jint JNI_OnLoad(JavaVM *vm, void *reserved);
void __noreturn std::__vector_base_common<true>::__throw_length_error();
// void __fastcall std::out_of_range::~out_of_range(std::out_of_range *__hidden this); idb
// void __fastcall std::length_error::~length_error(std::length_error *__hidden this); idb
// void __fastcall std::bad_cast::~bad_cast(std::bad_cast *__hidden this); idb

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
__int128 xmmword_15C40 = 0x10000000100001006LL; // weak
char aDevTtyusb[12] = "/dev/ttyUSB"; // weak
__int64 (__fastcall *off_29430[2])() =
{
  &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream,
  &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream
}; // weak
__int64 (__fastcall *off_29458[2])() =
{
  &`non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream,
  &`non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream
}; // weak
__int64 (__fastcall *off_29480[2])() =
{
  &`virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream,
  &`virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream
}; // weak
__int64 (__fastcall *off_29570[2])() =
{
  &`virtual thunk to'std::istream::~istream,
  &`virtual thunk to'std::istream::~istream
}; // weak
__int64 (__fastcall *off_295A8[8])() =
{
  &std::stringbuf::~stringbuf,
  &std::stringbuf::~stringbuf,
  &std::streambuf::imbue,
  &std::streambuf::setbuf,
  &std::stringbuf::seekoff,
  &sub_129A4,
  &std::streambuf::sync,
  &std::streambuf::showmanyc
}; // weak
__int64 (__fastcall *off_29650[8])() =
{
  &std::streambuf::~streambuf,
  &std::streambuf::~streambuf,
  &std::streambuf::imbue,
  &std::streambuf::setbuf,
  &std::streambuf::seekoff,
  &std::streambuf::seekpos,
  &std::streambuf::sync,
  &std::streambuf::showmanyc
}; // weak
__int64 (__fastcall *off_296D8[2])() = { &std::fstream::~fstream, &std::fstream::~fstream }; // weak
__int64 (__fastcall *off_29700[2])() =
{
  &`non-virtual thunk to'std::fstream::~fstream,
  &`non-virtual thunk to'std::fstream::~fstream
}; // weak
__int64 (__fastcall *off_29728[2])() =
{
  &`virtual thunk to'std::fstream::~fstream,
  &`virtual thunk to'std::fstream::~fstream
}; // weak
__int64 (__fastcall *off_29750[2])() = { &std::istream::~istream, &std::istream::~istream }; // weak
__int64 (__fastcall *off_29778[2])() =
{
  &`virtual thunk to'std::istream::~istream,
  &`virtual thunk to'std::istream::~istream
}; // weak
__int64 (__fastcall *off_297B0[3])() = { &std::filebuf::~filebuf, &std::filebuf::~filebuf, &std::filebuf::imbue }; // weak
void (__fastcall *off_29848)(std::__shared_weak_count *__hidden this) = &std::__shared_weak_count::~__shared_weak_count; // weak
__int64 (__fastcall *off_29898[2])(std::__shared_weak_count *this) =
{
  &std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace,
  &std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace
}; // weak
void *off_2A000 = &off_2A000; // weak
void *TAG = (void *)0x16307LL; // weak
char *moduleMethods[2] = { "openESP", "(II)Z" }; // weak
int dword_2A120; // weak
__int16 word_2A128; // weak
_UNKNOWN unk_2A12A; // weak
_UNKNOWN unk_2A132; // weak
__int64 qword_2A138; // weak
int dword_2A140; // weak
__int16 word_2A148; // weak
_UNKNOWN unk_2A14A; // weak
_UNKNOWN unk_2A152; // weak
__int64 qword_2A158; // weak
int dword_2A160; // weak
__int16 word_2A168; // weak
_UNKNOWN unk_2A16A; // weak
_UNKNOWN unk_2A172; // weak
__int64 qword_2A178; // weak
int dword_2A180; // weak
__int16 word_2A188; // weak
_UNKNOWN unk_2A18A; // weak
_UNKNOWN unk_2A192; // weak
__int64 qword_2A198; // weak
int dword_2A1A0; // weak
__int16 word_2A1A8; // weak
_UNKNOWN unk_2A1AA; // weak
_UNKNOWN unk_2A1B2; // weak
__int64 qword_2A1B8; // weak
int dword_2A1C0; // weak
__int16 word_2A1C8; // weak
_UNKNOWN unk_2A1CA; // weak
_UNKNOWN unk_2A1D2; // weak
__int64 qword_2A1D8; // weak
int dword_2A1E0; // weak
char byte_2A1E8; // weak
_UNKNOWN unk_2A1E9; // weak
_UNKNOWN unk_2A1F1; // weak
__int64 qword_2A1F8; // weak
int dword_2A200; // weak
char byte_2A208; // weak
_UNKNOWN unk_2A209; // weak
_UNKNOWN unk_2A211; // weak
_UNKNOWN unk_2A215; // weak
_UNKNOWN unk_2A21D; // weak
char byte_2A21F; // weak
int dword_2A220; // weak
char byte_2A228; // weak
_BYTE algn_2A229[7]; // weak
_UNKNOWN unk_2A239; // weak
_UNKNOWN unk_2A23D; // weak
char byte_2A23F; // weak
__int64 qword_2A240; // weak
_UNKNOWN unk_2A248; // weak
__int64 qword_2A250; // weak
__int64 qword_2A258; // weak
_UNKNOWN unk_2A260; // weak
__int64 qword_2A268; // weak
__int64 pudutech::ESP32::instance_; // weak
__int64 qword_2A278; // weak
__int64 esp; // weak
__int64 qword_2A288; // weak
// extern _UNKNOWN std::ctype<char>::id; weak
// extern _UNKNOWN `typeinfo for'std::out_of_range; weak
// extern _UNKNOWN std::codecvt<char,char,mbstate_t>::id; weak
// extern _UNKNOWN std::num_put<char,std::ostreambuf_iterator<char>>::id; weak
// extern _UNKNOWN `typeinfo for'std::length_error; weak
// extern _UNKNOWN `vtable for'std::length_error; weak
// extern _UNKNOWN `vtable for'std::out_of_range; weak
// extern _UNKNOWN `typeinfo for'std::bad_cast; weak


//----- (0000000000007420) ----------------------------------------------------
void sub_7420()
{
  JUMPOUT(0LL);
}
// 7430: control flows out of bounds to 0

//----- (0000000000007490) ----------------------------------------------------
// attributes: thunk
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  return _ZNSt6__ndk1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EEPKS6_RKS9_(a1, a2, a3);
}

//----- (00000000000074A0) ----------------------------------------------------
// attributes: thunk
bool __fastcall pudutech::ESP32::checkHardwareHandshake(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3222checkHardwareHandshakeEv(this);
}

//----- (00000000000074C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::openDev(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP327openDevEv(this);
}

//----- (00000000000074D0) ----------------------------------------------------
// attributes: thunk
bool __fastcall pudutech::ESP32::connectStatus(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3213connectStatusEv(this);
}

//----- (0000000000007560) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::shared_ptr<pudutech::ESP32>::shared_ptr<pudutech::ESP32>(_QWORD *a1, __int64 a2)
{
  return _ZNSt6__ndk110shared_ptrIN8pudutech5ESP32EEC2IS2_EEPT_NS_9enable_ifIXsr14is_convertibleIS6_PS2_EE5valueENS3_5__natEE4typeE(
           a1,
           a2);
}

//----- (0000000000007580) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_out_of_rangeEv();
}

//----- (00000000000075A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::resetChannel(pudutech::ESP32 *this, int a2)
{
  return _ZN8pudutech5ESP3212resetChannelEi(this, a2);
}

//----- (00000000000075E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall registerPuduNativeClass(_JNIEnv *a1)
{
  return _Z23registerPuduNativeClassP7_JNIEnv(a1);
}

//----- (00000000000075F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::set_interface_attribs(pudutech::ESP32 *this, int fd, speed_t a3, int a4)
{
  return _ZN8pudutech5ESP3221set_interface_attribsEiii(this, fd, a3, a4);
}

//----- (0000000000007600) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev(result);
}

//----- (0000000000007650) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  return _ZNSt6__ndk124__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m(a1, a2, a3);
}

//----- (0000000000007680) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::filebuf::sync(__int64 a1)
{
  return _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEE4syncEv(a1);
}

//----- (00000000000076B0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEm(a1);
}

//----- (0000000000007700) ----------------------------------------------------
// attributes: thunk
void __usercall zeroPadding(int a1@<W0>, unsigned __int64 *a2@<X8>)
{
  _Z11zeroPaddingi(a1, a2);
}

//----- (0000000000007710) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEi(a1);
}

//----- (0000000000007720) ----------------------------------------------------
// attributes: thunk
void __usercall pudutech::ESP32::readMsg(pudutech::ESP32 *this@<X0>, __int64 a2@<X8>)
{
  _ZN8pudutech5ESP327readMsgEv(this, a2);
}

//----- (0000000000007730) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::getErrorCode(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3212getErrorCodeEv(this);
}

//----- (0000000000007740) ----------------------------------------------------
// attributes: thunk
void __fastcall pudutech::ESP32::resetDevice(pudutech::ESP32 *this)
{
  _ZN8pudutech5ESP3211resetDeviceEv(this);
}

//----- (0000000000007750) ----------------------------------------------------
// attributes: thunk
void __fastcall std::string::__init<std::istreambuf_iterator<char>>(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initINS_19istreambuf_iteratorIcS2_EEEENS_9enable_ifIXsr27__is_exactly_input_iteratorIT_EE5valueEvE4typeESA_SA_(
    a1,
    a2,
    a3);
}

//----- (0000000000007760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::openESP(pudutech::ESP32 *this, int a2, int a3)
{
  return _ZN8pudutech5ESP327openESPEii(this, a2, a3);
}

//----- (0000000000007770) ----------------------------------------------------
// attributes: thunk
bool __fastcall pudutech::ESP32::hasHardwareResponsed(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3220hasHardwareResponsedEv(this);
}

//----- (0000000000007780) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::closeESP(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP328closeESPEv(this);
}

//----- (00000000000077A0) ----------------------------------------------------
// attributes: thunk
__int64 *__usercall std::operator+<char>@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  return _ZNSt6__ndk1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EERKS9_SB_(a1, a2, a3);
}

//----- (00000000000077B0) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__vector_base_common<true>::__throw_length_error()
{
  _ZNKSt6__ndk120__vector_base_commonILb1EE20__throw_length_errorEv();
}

//----- (0000000000007800) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::crc16(pudutech::ESP32 *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  return _ZN8pudutech5ESP325crc16EPhS1_i(this, a2, a3);
}

//----- (0000000000007820) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc(a1, n, c);
}

//----- (0000000000007830) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1)
{
  return _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEEC2Ev(a1);
}

//----- (0000000000007880) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::ESP32(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP32C2Ev(this);
}

//----- (00000000000078A0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  _ZNSt6__ndk115basic_streambufIcNS_11char_traitsIcEEED2Ev(a1);
}

//----- (00000000000078E0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::filebuf::~filebuf(__int64 a1)
{
  _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEED2Ev(a1);
}

//----- (0000000000007980) ----------------------------------------------------
// attributes: thunk
void __usercall pudutech::ESP32::parseMsg(pudutech::ESP32 *this@<X0>, void ***a2@<X8>)
{
  _ZN8pudutech5ESP328parseMsgEv(this, a2);
}

//----- (00000000000079B0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm(a1, src, n);
}

//----- (00000000000079F0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm(a1, src, n);
}

//----- (0000000000007A10) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __usercall std::stringbuf::str@<X0>(unsigned __int64 result@<X0>, unsigned __int64 *a2@<X8>)
{
  return _ZNKSt6__ndk115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strEv(result, a2);
}

//----- (0000000000007A20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::sendMsg(__int64 a1, char **a2, char a3)
{
  return _ZN8pudutech5ESP327sendMsgERNSt6__ndk16vectorIhNS1_9allocatorIhEEEEb(a1, a2, a3);
}

//----- (0000000000007A30) ----------------------------------------------------
// attributes: thunk
void __fastcall pudutech::ESP32::set_blocking(pudutech::ESP32 *this, int fd, cc_t a3)
{
  _ZN8pudutech5ESP3212set_blockingEii(this, fd, a3);
}

//----- (0000000000007A50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::getChannel(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3210getChannelEv(this);
}

//----- (0000000000007A60) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKcm(a1, a2, src, n);
}

//----- (0000000000007AC0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::string::push_back(__int64 *a1, char a2)
{
  _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc(a1, a2);
}

//----- (0000000000007AF0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEx(a1);
}

//----- (0000000000007B20) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEb(a1);
}

//----- (0000000000007B50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::blockReOpen(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3211blockReOpenEv(this);
}

//----- (0000000000007B70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall pudutech::ESP32::getEspFirmwareVersion(pudutech::ESP32 *this)
{
  return _ZN8pudutech5ESP3221getEspFirmwareVersionEv(this);
}

//----- (0000000000007BA0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE5flushEv(a1);
}

//----- (0000000000007C00) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_length_errorEv();
}

//----- (0000000000007C10) ----------------------------------------------------
// attributes: thunk
void __usercall pudutech::ESP32::create(__int64 *a1@<X8>)
{
  _ZN8pudutech5ESP326createEv(a1);
}

//----- (0000000000007C50) ----------------------------------------------------
__int64 start()
{
  dword_2A120 = 100;
  word_2A128 = 17410;
  unk_2A132 = 0LL;
  unk_2A12A = 0LL;
  qword_2A138 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A120, &off_2A000);
  dword_2A140 = 50;
  word_2A148 = 22018;
  unk_2A152 = 0LL;
  unk_2A14A = 0LL;
  qword_2A158 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A140, &off_2A000);
  dword_2A160 = 300;
  word_2A168 = 18690;
  unk_2A172 = 0LL;
  unk_2A16A = 0LL;
  qword_2A178 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A160, &off_2A000);
  dword_2A180 = 500;
  word_2A188 = 22274;
  unk_2A192 = 0LL;
  unk_2A18A = 0LL;
  qword_2A198 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A180, &off_2A000);
  dword_2A1A0 = 800;
  word_2A1A8 = 17666;
  unk_2A1B2 = 0LL;
  unk_2A1AA = 0LL;
  qword_2A1B8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A1A0, &off_2A000);
  dword_2A1C0 = 1000;
  word_2A1C8 = 17922;
  unk_2A1D2 = 0LL;
  unk_2A1CA = 0LL;
  qword_2A1D8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A1C0, &off_2A000);
  dword_2A1E0 = 2000;
  byte_2A1E8 = 16;
  unk_2A1E9 = 0x54434152544E4F43LL;
  qword_2A1F8 = 0LL;
  unk_2A1F1 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A1E0, &off_2A000);
  dword_2A200 = 2001;
  byte_2A208 = 24;
  unk_2A211 = 1279348295;
  byte_2A21F = 0;
  unk_2A21D = 0;
  unk_2A209 = *(_QWORD *)"FATAL_SIGNAL";
  unk_2A215 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A200, &off_2A000);
  dword_2A220 = 2002;
  byte_2A228 = 30;
  byte_2A23F = 0;
  unk_2A23D = 0;
  strcpy(algn_2A229, "FATAL_EXCEPTION");
  unk_2A239 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_2A220, &off_2A000);
  unk_2A248 = 0LL;
  qword_2A250 = 0LL;
  qword_2A240 = 16LL;
  *(__int64 *)((char *)&qword_2A240 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_2A240, &off_2A000);
  unk_2A260 = 0x3366252000LL;
  qword_2A268 = 0LL;
  qword_2A258 = 24LL;
  *(__int64 *)((char *)&qword_2A258 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_2A258, &off_2A000);
  pudutech::ESP32::instance_ = 0LL;
  qword_2A278 = 0LL;
  return __cxa_atexit(
           (void (__fastcall *)(void *))std::shared_ptr<pudutech::ESP32>::~shared_ptr,
           &pudutech::ESP32::instance_,
           &off_2A000);
}
// 2A000: using guessed type void *off_2A000;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A140: using guessed type int dword_2A140;
// 2A148: using guessed type __int16 word_2A148;
// 2A158: using guessed type __int64 qword_2A158;
// 2A160: using guessed type int dword_2A160;
// 2A168: using guessed type __int16 word_2A168;
// 2A178: using guessed type __int64 qword_2A178;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;
// 2A1A0: using guessed type int dword_2A1A0;
// 2A1A8: using guessed type __int16 word_2A1A8;
// 2A1B8: using guessed type __int64 qword_2A1B8;
// 2A1C0: using guessed type int dword_2A1C0;
// 2A1C8: using guessed type __int16 word_2A1C8;
// 2A1D8: using guessed type __int64 qword_2A1D8;
// 2A1E0: using guessed type int dword_2A1E0;
// 2A1E8: using guessed type char byte_2A1E8;
// 2A1F8: using guessed type __int64 qword_2A1F8;
// 2A200: using guessed type int dword_2A200;
// 2A208: using guessed type char byte_2A208;
// 2A21F: using guessed type char byte_2A21F;
// 2A220: using guessed type int dword_2A220;
// 2A228: using guessed type char byte_2A228;
// 2A229: using guessed type _BYTE algn_2A229[7];
// 2A230: using guessed type __int64 qword_2A230;
// 2A238: using guessed type char byte_2A238;
// 2A23F: using guessed type char byte_2A23F;
// 2A240: using guessed type __int64 qword_2A240;
// 2A250: using guessed type __int64 qword_2A250;
// 2A258: using guessed type __int64 qword_2A258;
// 2A268: using guessed type __int64 qword_2A268;
// 2A270: using guessed type __int64 pudutech::ESP32::instance_;
// 2A278: using guessed type __int64 qword_2A278;

//----- (0000000000007F10) ----------------------------------------------------
__int64 sub_7F10()
{
  esp = 0LL;
  qword_2A288 = 0LL;
  return __cxa_atexit((void (__fastcall *)(void *))std::shared_ptr<pudutech::ESP32>::~shared_ptr, &esp, &off_2A000);
}
// 2A000: using guessed type void *off_2A000;
// 2A280: using guessed type __int64 esp;
// 2A288: using guessed type __int64 qword_2A288;

//----- (0000000000007F30) ----------------------------------------------------
__int64 sub_7F30()
{
  return __cxa_finalize(&off_2A000);
}
// 2A000: using guessed type void *off_2A000;

//----- (0000000000007F44) ----------------------------------------------------
__int64 (*__fastcall sub_7F44(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (0000000000007F50) ----------------------------------------------------
__int64 __fastcall sub_7F50(void *a1)
{
  return __cxa_atexit((void (__fastcall *)(void *))sub_7F44, a1, &off_2A000);
}
// 2A000: using guessed type void *off_2A000;

//----- (0000000000007F6C) ----------------------------------------------------
void __fastcall std::string::~string(__int64 a1)
{
  if ( (*(_BYTE *)a1 & 1) != 0 )
    operator delete(*(void **)(a1 + 16));
}

//----- (0000000000007F80) ----------------------------------------------------
void __fastcall LEVELS::~LEVELS(void **this)
{
  if ( ((_BYTE)this[1] & 1) != 0 )
    operator delete(this[3]);
}

//----- (0000000000007F94) ----------------------------------------------------
void __usercall zeroPadding(int a1@<W0>, unsigned __int64 *a2@<X8>)
{
  __int128 v4; // q0
  int v5; // w28
  __int128 v6; // [xsp+10h] [xbp-170h] BYREF
  _BYTE v7[24]; // [xsp+20h] [xbp-160h] BYREF
  __int128 v8; // [xsp+38h] [xbp-148h]
  __int128 v9; // [xsp+48h] [xbp-138h]
  __int128 v10; // [xsp+58h] [xbp-128h]
  void *v11[2]; // [xsp+68h] [xbp-118h]
  int v12; // [xsp+78h] [xbp-108h]
  __int64 v13[18]; // [xsp+80h] [xbp-100h] BYREF
  int v14; // [xsp+110h] [xbp-70h]
  __int64 v15; // [xsp+120h] [xbp-60h]

  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13[0] = (__int64)off_29570;
  std::ios_base::init((std::ios_base *)v13, (char *)&v6 + 8);
  v13[17] = 0LL;
  *(_QWORD *)&v4 = off_29458;
  v14 = -1;
  *((_QWORD *)&v4 + 1) = off_29650;
  v13[0] = (__int64)off_29480;
  v6 = v4;
  std::locale::locale((std::locale *)v7);
  v9 = 0u;
  v8 = 0u;
  *(_OWORD *)&v7[8] = 0u;
  *(_OWORD *)v11 = 0u;
  *((_QWORD *)&v6 + 1) = off_295A8;
  v10 = 0u;
  v12 = 24;
  if ( a1 >= 1 )
  {
    v5 = 0;
    do
    {
      std::__put_character_sequence<char,std::char_traits<char>>(&v6, (__int64)"0", 1LL);
      ++v5;
    }
    while ( v5 < a1 );
  }
  std::stringbuf::str((unsigned __int64)&v6 + 8, a2);
  v13[0] = (__int64)off_29480;
  *(_QWORD *)&v6 = off_29458;
  *((_QWORD *)&v6 + 1) = off_295A8;
  if ( (v10 & 1) != 0 )
    operator delete(v11[0]);
  *((_QWORD *)&v6 + 1) = off_29650;
  std::locale::~locale((std::locale *)v7);
  std::ios_base::~ios_base((std::ios_base *)v13);
}
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 29570: using guessed type __int64 (__fastcall *[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (00000000000081C8) ----------------------------------------------------
void __fastcall std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        __int64 a1)
{
  char v1; // w10

  v1 = *(_BYTE *)(a1 + 88);
  *(_QWORD *)a1 = off_29430;
  *(_QWORD *)(a1 + 128) = off_29480;
  *(_QWORD *)(a1 + 16) = off_29458;
  *(_QWORD *)(a1 + 24) = off_295A8;
  if ( (v1 & 1) != 0 )
    operator delete(*(void **)(a1 + 104));
  *(_QWORD *)(a1 + 24) = off_29650;
  std::locale::~locale((std::locale *)(a1 + 32));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 128));
}
// 29430: using guessed type __int64 (__fastcall *[2])();
// 29458: using guessed type __int64 (__fastcall *[2])();
// 29480: using guessed type __int64 (__fastcall *[2])();
// 295A8: using guessed type __int64 (__fastcall *[8])();
// 29650: using guessed type __int64 (__fastcall *[8])();

//----- (000000000000823C) ----------------------------------------------------
__int64 __fastcall std::shared_ptr<pudutech::ESP32>::~shared_ptr(__int64 result)
{
  std::__shared_weak_count *v1; // x19
  unsigned __int64 *v2; // x8
  unsigned __int64 v3; // x9

  v1 = *(std::__shared_weak_count **)(result + 8);
  if ( v1 )
  {
    v2 = (unsigned __int64 *)((char *)v1 + 8);
    do
      v3 = __ldaxr(v2);
    while ( __stlxr(v3 - 1, v2) );
    if ( !v3 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v1 + 16LL))(v1);
      return std::__shared_weak_count::__release_weak(v1);
    }
  }
  return result;
}

//----- (0000000000008294) ----------------------------------------------------
void __usercall pudutech::ESP32::create(__int64 *a1@<X8>)
{
  __int64 v3; // x9
  pudutech::ESP32 *v4; // x20
  __int64 v5; // x8
  __int64 v6; // x9
  std::__shared_weak_count *v7; // x20
  unsigned __int64 *v8; // x8
  unsigned __int64 v9; // x9
  std::__shared_weak_count *v10; // x20
  unsigned __int64 *v11; // x8
  unsigned __int64 v12; // x9
  __int64 v13; // x8
  unsigned __int64 *v14; // x8
  unsigned __int64 v15; // x9
  __int64 v16; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 *v17; // [xsp+10h] [xbp-30h]
  __int64 v18; // [xsp+18h] [xbp-28h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = pudutech::ESP32::instance_;
  if ( !pudutech::ESP32::instance_ )
  {
    v4 = (pudutech::ESP32 *)operator new(0x170uLL);
    pudutech::ESP32::ESP32(v4);
    std::shared_ptr<pudutech::ESP32>::shared_ptr<pudutech::ESP32>(&v16, (__int64)v4);
    v5 = v16;
    v6 = (__int64)v17;
    v7 = (std::__shared_weak_count *)qword_2A278;
    v16 = 0LL;
    v17 = 0LL;
    pudutech::ESP32::instance_ = v5;
    qword_2A278 = v6;
    if ( v7 )
    {
      v8 = (unsigned __int64 *)((char *)v7 + 8);
      do
        v9 = __ldaxr(v8);
      while ( __stlxr(v9 - 1, v8) );
      if ( !v9 )
      {
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v7 + 16LL))(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = (std::__shared_weak_count *)v17;
    if ( v17 )
    {
      v11 = v17 + 1;
      do
        v12 = __ldaxr(v11);
      while ( __stlxr(v12 - 1, v11) );
      if ( !v12 )
      {
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v10 + 16LL))(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v3 = pudutech::ESP32::instance_;
  }
  v13 = qword_2A278;
  *a1 = v3;
  a1[1] = v13;
  if ( v13 )
  {
    v14 = (unsigned __int64 *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while ( __stxr(v15 + 1, v14) );
  }
}
// 2A270: using guessed type __int64 pudutech::ESP32::instance_;
// 2A278: using guessed type __int64 qword_2A278;

//----- (00000000000083C4) ----------------------------------------------------
_QWORD *__fastcall std::shared_ptr<pudutech::ESP32>::shared_ptr<pudutech::ESP32>(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // x0

  *a1 = a2;
  result = (_QWORD *)operator new(0x20uLL);
  result[2] = 0LL;
  result[3] = a2;
  *result = &off_29848;
  result[1] = 0LL;
  a1[1] = result;
  return result;
}
// 29848: using guessed type void (__fastcall *)(std::__shared_weak_count *__hidden this);

//----- (000000000000845C) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::ESP32(pudutech::ESP32 *this)
{
  std::chrono::steady_clock *v2; // x0
  std::chrono::steady_clock *v3; // x0
  std::thread *v4; // x20
  __int64 result; // x0

  *((_QWORD *)this + 5) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  *(_WORD *)this = 0;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((_DWORD *)this + 1) = -1;
  *((_QWORD *)this + 45) = 0LL;
  *((_QWORD *)this + 1) = 12LL;
  *((_OWORD *)this + 1) = xmmword_15C40;
  v2 = (std::chrono::steady_clock *)operator new(0xCuLL);
  *((_DWORD *)v2 + 2) = 0;
  *(_QWORD *)v2 = 0LL;
  *((_QWORD *)this + 4) = v2;
  *(_OWORD *)((char *)this + 290) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 77) = 0;
  v3 = (std::chrono::steady_clock *)std::chrono::steady_clock::now(v2);
  v4 = (std::thread *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 39) = v3;
  *((_QWORD *)this + 5) = 0LL;
  if ( v4 )
  {
    std::thread::~thread(v4);
    operator delete(v4);
  }
  *((_BYTE *)this + 2) = 1;
  result = std::chrono::steady_clock::now(v3);
  *((_QWORD *)this + 40) = result;
  return result;
}
// 8550: variable 'v3' is possibly undefined
// 15C40: using guessed type __int128 xmmword_15C40;

//----- (00000000000085AC) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::openESP(pudutech::ESP32 *this, int a2, int a3)
{
  if ( *(_BYTE *)this )
    return (unsigned int)&dword_0 + 1;
  *((_DWORD *)this + 4) = a2;
  *((_DWORD *)this + 6) = a3;
  *(_BYTE *)this = 1;
  return pudutech::ESP32::openDev(this);
}
// 0: using guessed type int dword_0;

//----- (00000000000085D0) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::openDev(pudutech::ESP32 *this)
{
  int v2; // w0
  int v3; // w8
  speed_t v4; // w20
  unsigned int v5; // w0
  const char *v6; // x23
  unsigned int v7; // w21
  size_t v8; // x0
  size_t v9; // x22
  char *v10; // x24
  const char *v11; // x20
  size_t v12; // x0
  size_t v13; // x19
  char *v14; // x21
  unsigned __int64 v15; // x25
  int v16; // w1
  const void *v17; // x22
  size_t v18; // x0
  size_t v19; // x23
  char *v20; // x24
  char v21; // w22
  unsigned __int64 v22; // x22
  const void *v23; // x19
  size_t v24; // x0
  size_t v25; // x20
  char *v26; // x21
  char v27; // w19
  unsigned __int64 v28; // x25
  __int64 *v29; // x0
  __int128 v30; // q0
  char *v31; // x1
  unsigned __int64 v32; // x2
  const char *v33; // x22
  size_t v34; // x0
  size_t v35; // x21
  char *v36; // x23
  unsigned __int64 v37; // x24
  const void *v38; // x21
  size_t v39; // x0
  size_t v40; // x22
  char *v41; // x23
  char v42; // w21
  unsigned __int64 v43; // x24
  const char *v44; // x2
  const char *v45; // x0
  const char *v46; // x0
  int v47; // w21
  pudutech::ESP32 *v48; // x0
  pudutech::ESP32 *v49; // x0
  unsigned int v50; // w19
  const char *v51; // x20
  size_t v52; // x0
  size_t v53; // x19
  char *v54; // x21
  unsigned __int64 v55; // x22
  const void *v56; // x19
  size_t v57; // x0
  size_t v58; // x20
  char *v59; // x21
  char v60; // w19
  unsigned __int64 v61; // x22
  unsigned __int64 v63; // x22
  LogCapture *v64; // x0
  unsigned int v65; // w19
  char v66; // w20
  const char *v67; // x21
  char *v68; // x4
  const char *v69; // x3
  unsigned __int64 v70; // [xsp+8h] [xbp-2C8h] BYREF
  size_t v71; // [xsp+10h] [xbp-2C0h]
  void *v72; // [xsp+18h] [xbp-2B8h]
  int v73; // [xsp+20h] [xbp-2B0h] BYREF
  unsigned __int64 v74; // [xsp+28h] [xbp-2A8h] BYREF
  size_t v75; // [xsp+30h] [xbp-2A0h]
  void *v76; // [xsp+38h] [xbp-298h]
  unsigned __int64 v77; // [xsp+40h] [xbp-290h] BYREF
  size_t v78; // [xsp+48h] [xbp-288h]
  void *v79; // [xsp+50h] [xbp-280h]
  int v80; // [xsp+58h] [xbp-278h] BYREF
  unsigned __int64 v81; // [xsp+60h] [xbp-270h] BYREF
  size_t v82; // [xsp+68h] [xbp-268h]
  void *v83; // [xsp+70h] [xbp-260h]
  _BYTE v84[24]; // [xsp+78h] [xbp-258h] BYREF
  __int128 v85; // [xsp+90h] [xbp-240h] BYREF
  void *v86; // [xsp+A0h] [xbp-230h]
  unsigned __int64 v87; // [xsp+B0h] [xbp-220h] BYREF
  size_t v88; // [xsp+B8h] [xbp-218h]
  void *v89; // [xsp+C0h] [xbp-210h]
  int v90; // [xsp+C8h] [xbp-208h] BYREF
  unsigned __int64 v91; // [xsp+D0h] [xbp-200h] BYREF
  size_t v92; // [xsp+D8h] [xbp-1F8h]
  void *v93; // [xsp+E0h] [xbp-1F0h]
  unsigned __int64 v94; // [xsp+E8h] [xbp-1E8h] BYREF
  size_t v95; // [xsp+F0h] [xbp-1E0h]
  void *v96; // [xsp+F8h] [xbp-1D8h]
  int v97; // [xsp+100h] [xbp-1D0h] BYREF
  unsigned __int64 v98; // [xsp+108h] [xbp-1C8h] BYREF
  size_t v99; // [xsp+110h] [xbp-1C0h]
  void *v100; // [xsp+118h] [xbp-1B8h]
  __int64 v101[44]; // [xsp+120h] [xbp-1B0h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = *((_DWORD *)this + 1);
  if ( v2 != -1 )
  {
    *((_BYTE *)this + 1) = 0;
    close(v2);
    *((_DWORD *)this + 1) = -1;
  }
  *((_DWORD *)this + 77) = 0;
  *(_OWORD *)((char *)this + 290) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  v3 = *((_DWORD *)this + 4);
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  switch ( v3 )
  {
    case 230400:
      v4 = 4099;
      break;
    case 460800:
      v4 = 4100;
      break;
    case 576000:
      v4 = 4102;
      break;
    default:
      v4 = 0;
      break;
  }
  **((_BYTE **)this + 4) = -86;
  *(_BYTE *)(*((_QWORD *)this + 4) + 1LL) = 85;
  *(_WORD *)(*((_QWORD *)this + 4) + 4LL) = -9510;
  v5 = sub_EFC8(1, *((_DWORD *)this + 6) == 2);
  if ( v5 == -1 )
  {
    if ( (word_2A188 & 1) != 0 )
      v11 = (const char *)qword_2A198;
    else
      v11 = (char *)&word_2A188 + 1;
    v97 = dword_2A180;
    v99 = 0LL;
    v100 = 0LL;
    v98 = 0LL;
    v12 = strlen(v11);
    if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v13 = v12;
    if ( v12 >= 0x17 )
    {
      v22 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v14 = (char *)operator new(v22);
      v99 = v13;
      v100 = v14;
      v98 = v22 | 1;
    }
    else
    {
      v14 = (char *)&v98 + 1;
      LOBYTE(v98) = 2 * v12;
      if ( !v12 )
      {
LABEL_37:
        v14[v13] = 0;
        if ( (g3::logLevel(&v97) & 1) == 0 )
        {
          v27 = 0;
          if ( (v98 & 1) == 0 )
            goto LABEL_121;
          goto LABEL_43;
        }
        v95 = 0LL;
        v96 = 0LL;
        v94 = 0LL;
        v23 = TAG;
        v24 = strlen((const char *)TAG);
        if ( v24 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v25 = v24;
        if ( v24 >= 0x17 )
        {
          v61 = (v24 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v26 = (char *)operator new(v61);
          v95 = v25;
          v96 = v26;
          v94 = v61 | 1;
        }
        else
        {
          v26 = (char *)&v94 + 1;
          LOBYTE(v94) = 2 * v24;
          if ( !v24 )
          {
LABEL_119:
            v26[v25] = 0;
            v27 = g3::logTag(&v94);
            if ( (v94 & 1) != 0 )
            {
              operator delete(v96);
              if ( (v98 & 1) == 0 )
              {
LABEL_121:
                if ( (v27 & 1) != 0 )
                {
LABEL_122:
                  LogCapture::LogCapture(
                    (LogCapture *)v101,
                    (const char *)TAG,
                    (const LEVELS *)&dword_2A180,
                    "",
                    6,
                    0LL);
                  LogCapture::capturef((LogCapture *)v101, "getValid id error");
                  LogCapture::~LogCapture((LogCapture *)v101);
                }
                return 0;
              }
            }
            else if ( (v98 & 1) == 0 )
            {
              goto LABEL_121;
            }
LABEL_43:
            operator delete(v100);
            if ( (v27 & 1) != 0 )
              goto LABEL_122;
            return 0;
          }
        }
        memcpy(v26, v23, v25);
        goto LABEL_119;
      }
    }
    memcpy(v14, v11, v13);
    goto LABEL_37;
  }
  if ( (word_2A128 & 1) != 0 )
    v6 = (const char *)qword_2A138;
  else
    v6 = (char *)&word_2A128 + 1;
  v7 = v5;
  v90 = dword_2A120;
  v92 = 0LL;
  v93 = 0LL;
  v91 = 0LL;
  v8 = strlen(v6);
  if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v9 = v8;
  if ( v8 >= 0x17 )
  {
    v15 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = (char *)operator new(v15);
    v92 = v9;
    v93 = v10;
    v91 = v15 | 1;
    goto LABEL_26;
  }
  v10 = (char *)&v91 + 1;
  LOBYTE(v91) = 2 * v8;
  if ( v8 )
LABEL_26:
    memcpy(v10, v6, v9);
  v10[v9] = 0;
  if ( (g3::logLevel(&v90) & 1) == 0 )
  {
    v21 = 0;
    if ( (v91 & 1) == 0 )
      goto LABEL_49;
    goto LABEL_33;
  }
  v88 = 0LL;
  v89 = 0LL;
  v87 = 0LL;
  v17 = TAG;
  v18 = strlen((const char *)TAG);
  if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v19 = v18;
  if ( v18 >= 0x17 )
  {
    v28 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v20 = (char *)operator new(v28);
    v88 = v19;
    v89 = v20;
    v87 = v28 | 1;
    goto LABEL_46;
  }
  v20 = (char *)&v87 + 1;
  LOBYTE(v87) = 2 * v18;
  if ( v18 )
LABEL_46:
    memcpy(v20, v17, v19);
  v20[v19] = 0;
  v21 = g3::logTag(&v87);
  if ( (v87 & 1) != 0 )
  {
    operator delete(v89);
    if ( (v91 & 1) == 0 )
    {
LABEL_49:
      if ( (v21 & 1) == 0 )
        goto LABEL_51;
      goto LABEL_50;
    }
  }
  else if ( (v91 & 1) == 0 )
  {
    goto LABEL_49;
  }
LABEL_33:
  operator delete(v93);
  if ( (v21 & 1) == 0 )
    goto LABEL_51;
LABEL_50:
  LogCapture::LogCapture((LogCapture *)v101, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
  LogCapture::capturef((LogCapture *)v101, "getValidId success, id: %d", v7);
  LogCapture::~LogCapture((LogCapture *)v101);
LABEL_51:
  std::to_string(v101, (std::__ndk1 *)v7, v16);
  v29 = std::string::insert(v101, 0LL, "/dev/ttyUSB", 0xBuLL);
  v30 = *(_OWORD *)v29;
  v86 = (void *)v29[2];
  v85 = v30;
  v29[1] = 0LL;
  v29[2] = 0LL;
  *v29 = 0LL;
  if ( (v101[0] & 1) != 0 )
    operator delete((void *)v101[2]);
  *(_QWORD *)&v84[16] = 0x2000LL;
  *(_OWORD *)v84 = 0x22uLL;
  if ( (v85 & 1) != 0 )
    v31 = (char *)v86;
  else
    v31 = (char *)&v85 + 1;
  *(_OWORD *)&v84[1] = *(_OWORD *)"su -c \"chmod 777 ";
  if ( (v85 & 1) != 0 )
    v32 = *((_QWORD *)&v85 + 1);
  else
    v32 = (unsigned __int64)(unsigned __int8)v85 >> 1;
  std::string::append((__int64 *)v84, v31, v32);
  std::string::append((__int64 *)v84, "\"", 1uLL);
  if ( (word_2A128 & 1) != 0 )
    v33 = (const char *)qword_2A138;
  else
    v33 = (char *)&word_2A128 + 1;
  v80 = dword_2A120;
  v82 = 0LL;
  v83 = 0LL;
  v81 = 0LL;
  v34 = strlen(v33);
  if ( v34 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v35 = v34;
  if ( v34 >= 0x17 )
  {
    v37 = (v34 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v36 = (char *)operator new(v37);
    v82 = v35;
    v83 = v36;
    v81 = v37 | 1;
    goto LABEL_67;
  }
  v36 = (char *)&v81 + 1;
  LOBYTE(v81) = 2 * v34;
  if ( v34 )
LABEL_67:
    memcpy(v36, v33, v35);
  v36[v35] = 0;
  if ( (g3::logLevel(&v80) & 1) == 0 )
  {
    v42 = 0;
    if ( (v81 & 1) == 0 )
      goto LABEL_82;
    goto LABEL_74;
  }
  v78 = 0LL;
  v79 = 0LL;
  v77 = 0LL;
  v38 = TAG;
  v39 = strlen((const char *)TAG);
  if ( v39 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v40 = v39;
  if ( v39 >= 0x17 )
  {
    v43 = (v39 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v41 = (char *)operator new(v43);
    v78 = v40;
    v79 = v41;
    v77 = v43 | 1;
    goto LABEL_79;
  }
  v41 = (char *)&v77 + 1;
  LOBYTE(v77) = 2 * v39;
  if ( v39 )
LABEL_79:
    memcpy(v41, v38, v40);
  v41[v40] = 0;
  v42 = g3::logTag(&v77);
  if ( (v77 & 1) != 0 )
  {
    operator delete(v79);
    if ( (v81 & 1) == 0 )
    {
LABEL_82:
      if ( (v42 & 1) == 0 )
        goto LABEL_87;
      goto LABEL_83;
    }
  }
  else if ( (v81 & 1) == 0 )
  {
    goto LABEL_82;
  }
LABEL_74:
  operator delete(v83);
  if ( (v42 & 1) == 0 )
    goto LABEL_87;
LABEL_83:
  LogCapture::LogCapture((LogCapture *)v101, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
  if ( (v84[0] & 1) != 0 )
    v44 = *(const char **)&v84[16];
  else
    v44 = &v84[1];
  LogCapture::capturef((LogCapture *)v101, "system cmd %s", v44);
  LogCapture::~LogCapture((LogCapture *)v101);
LABEL_87:
  if ( (v84[0] & 1) != 0 )
    v45 = *(const char **)&v84[16];
  else
    v45 = &v84[1];
  system(v45);
  if ( (v85 & 1) != 0 )
    v46 = (const char *)v86;
  else
    v46 = (char *)&v85 + 1;
  v47 = open(v46, 1052930);
  if ( (v47 & 0x80000000) == 0 )
  {
    tcflush(v47, 2);
    v48 = (pudutech::ESP32 *)tcflush(v47, 2);
    v49 = (pudutech::ESP32 *)pudutech::ESP32::set_interface_attribs(v48, v47, v4, 0);
    pudutech::ESP32::set_blocking(v49, v47, 0);
    *((_DWORD *)this + 1) = v47;
    v50 = 1;
    if ( (v84[0] & 1) == 0 )
      goto LABEL_96;
    goto LABEL_95;
  }
  if ( (word_2A188 & 1) != 0 )
    v51 = (const char *)qword_2A198;
  else
    v51 = (char *)&word_2A188 + 1;
  v73 = dword_2A180;
  v75 = 0LL;
  v76 = 0LL;
  v74 = 0LL;
  v52 = strlen(v51);
  if ( v52 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v53 = v52;
  if ( v52 >= 0x17 )
  {
    v55 = (v52 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v54 = (char *)operator new(v55);
    v75 = v53;
    v76 = v54;
    v74 = v55 | 1;
    goto LABEL_108;
  }
  v54 = (char *)&v74 + 1;
  LOBYTE(v74) = 2 * v52;
  if ( v52 )
LABEL_108:
    memcpy(v54, v51, v53);
  v54[v53] = 0;
  if ( (g3::logLevel(&v73) & 1) == 0 )
  {
    v60 = 0;
    if ( (v74 & 1) == 0 )
      goto LABEL_131;
    goto LABEL_115;
  }
  v71 = 0LL;
  v72 = 0LL;
  v70 = 0LL;
  v56 = TAG;
  v57 = strlen((const char *)TAG);
  if ( v57 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v58 = v57;
  if ( v57 >= 0x17 )
  {
    v63 = (v57 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v59 = (char *)operator new(v63);
    v71 = v58;
    v72 = v59;
    v70 = v63 | 1;
    goto LABEL_128;
  }
  v59 = (char *)&v70 + 1;
  LOBYTE(v70) = 2 * v57;
  if ( v57 )
LABEL_128:
    memcpy(v59, v56, v58);
  v59[v58] = 0;
  v60 = g3::logTag(&v70);
  if ( (v70 & 1) == 0 )
  {
    if ( (v74 & 1) == 0 )
      goto LABEL_131;
LABEL_115:
    operator delete(v76);
    if ( (v60 & 1) == 0 )
      goto LABEL_136;
    goto LABEL_132;
  }
  operator delete(v72);
  if ( (v74 & 1) != 0 )
    goto LABEL_115;
LABEL_131:
  if ( (v60 & 1) == 0 )
    goto LABEL_136;
LABEL_132:
  v64 = LogCapture::LogCapture((LogCapture *)v101, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
  v65 = *(_DWORD *)__errno(v64);
  v66 = v85;
  v67 = (const char *)v86;
  v68 = strerror(v65);
  if ( (v66 & 1) != 0 )
    v69 = v67;
  else
    v69 = (char *)&v85 + 1;
  LogCapture::capturef((LogCapture *)v101, "error %d opening %s: %s", v65, v69, v68);
  LogCapture::~LogCapture((LogCapture *)v101);
LABEL_136:
  v50 = 0;
  if ( (v84[0] & 1) != 0 )
LABEL_95:
    operator delete(*(void **)&v84[16]);
LABEL_96:
  if ( (v85 & 1) != 0 )
    operator delete(v86);
  return v50;
}
// 89B8: variable 'v16' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (0000000000009148) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::closeESP(pudutech::ESP32 *this)
{
  int v2; // w0
  __int64 result; // x0

  v2 = *((_DWORD *)this + 1);
  *(_BYTE *)this = 0;
  result = close(v2);
  *((_DWORD *)this + 1) = -1;
  return result;
}

//----- (0000000000009178) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::resetChannel(pudutech::ESP32 *this, int a2)
{
  if ( (unsigned int)(a2 - 1) > 0xC )
    return 0LL;
  *((_DWORD *)this + 5) = a2;
  return 1LL;
}

//----- (0000000000009198) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::getChannel(pudutech::ESP32 *this)
{
  return *((unsigned int *)this + 5);
}

//----- (00000000000091A0) ----------------------------------------------------
void __usercall pudutech::ESP32::readMsg(pudutech::ESP32 *this@<X0>, __int64 a2@<X8>)
{
  const char *v4; // x23
  size_t v5; // x0
  size_t v6; // x22
  char *v7; // x24
  unsigned __int64 v8; // x25
  const void *v9; // x22
  size_t v10; // x0
  size_t v11; // x23
  char *v12; // x24
  char v13; // w22
  unsigned __int64 v14; // x25
  std::chrono::steady_clock *v15; // x0
  std::chrono::steady_clock *v16; // x0
  std::chrono::steady_clock *v17; // x27
  const char *v18; // x26
  size_t v19; // x0
  size_t v20; // x28
  char *v21; // x23
  unsigned __int64 v22; // x22
  const void *v23; // x28
  size_t v24; // x0
  size_t v25; // x26
  char *v26; // x23
  char v27; // w26
  unsigned __int64 v28; // x22
  ssize_t v29; // x0
  int v30; // w28
  unsigned __int64 v31; // x9
  std::chrono::steady_clock *v32; // x0
  unsigned __int64 v33; // x8
  const char *v34; // x27
  size_t v35; // x0
  size_t v36; // x26
  char *v37; // x23
  unsigned __int64 v38; // x22
  const void *v39; // x27
  size_t v40; // x0
  size_t v41; // x26
  char *v42; // x23
  char v43; // w26
  unsigned __int64 v44; // x22
  _QWORD *v45; // x0
  _QWORD *v46; // x0
  _QWORD *v47; // x26
  int *v48; // x23
  _QWORD *v49; // x0
  _QWORD *v50; // x26
  char *v51; // x23
  __int64 v52; // x0
  const char *v53; // x27
  size_t v54; // x0
  size_t v55; // x26
  char *v56; // x23
  unsigned __int64 v57; // x22
  const void *v58; // x27
  size_t v59; // x0
  size_t v60; // x26
  char *v61; // x23
  char v62; // w26
  unsigned __int64 v63; // x22
  const char *v64; // x27
  size_t v65; // x0
  size_t v66; // x26
  char *v67; // x23
  void **v68; // x8
  __int64 v69; // x9
  std::__shared_weak_count *v70; // x23
  unsigned __int64 *v71; // x8
  unsigned __int64 v72; // x9
  std::__shared_weak_count *v73; // x23
  unsigned __int64 *v74; // x8
  unsigned __int64 v75; // x9
  unsigned __int64 v76; // x22
  const void *v77; // x27
  size_t v78; // x0
  size_t v79; // x26
  char *v80; // x23
  char v81; // w26
  unsigned __int64 v82; // x22
  _QWORD *v83; // x0
  _QWORD *v84; // x0
  _QWORD *v85; // x0
  _QWORD *v86; // x0
  _QWORD *v87; // x0
  unsigned __int64 v88; // [xsp+70h] [xbp-2C0h] BYREF
  size_t v89; // [xsp+78h] [xbp-2B8h]
  void *v90; // [xsp+80h] [xbp-2B0h]
  int v91; // [xsp+88h] [xbp-2A8h] BYREF
  unsigned __int64 v92; // [xsp+90h] [xbp-2A0h] BYREF
  size_t v93; // [xsp+98h] [xbp-298h]
  void *v94; // [xsp+A0h] [xbp-290h]
  unsigned __int64 v95; // [xsp+A8h] [xbp-288h] BYREF
  size_t v96; // [xsp+B0h] [xbp-280h]
  void *v97; // [xsp+B8h] [xbp-278h]
  int v98; // [xsp+C0h] [xbp-270h] BYREF
  unsigned __int64 v99; // [xsp+C8h] [xbp-268h] BYREF
  size_t v100; // [xsp+D0h] [xbp-260h]
  void *v101; // [xsp+D8h] [xbp-258h]
  unsigned __int64 v102; // [xsp+E0h] [xbp-250h] BYREF
  size_t v103; // [xsp+E8h] [xbp-248h]
  void *v104; // [xsp+F0h] [xbp-240h]
  int v105; // [xsp+F8h] [xbp-238h] BYREF
  unsigned __int64 v106; // [xsp+100h] [xbp-230h] BYREF
  size_t v107; // [xsp+108h] [xbp-228h]
  void *v108; // [xsp+110h] [xbp-220h]
  unsigned __int64 v109; // [xsp+118h] [xbp-218h] BYREF
  size_t v110; // [xsp+120h] [xbp-210h]
  void *v111; // [xsp+128h] [xbp-208h]
  int v112; // [xsp+130h] [xbp-200h] BYREF
  unsigned __int64 v113; // [xsp+138h] [xbp-1F8h] BYREF
  size_t v114; // [xsp+140h] [xbp-1F0h]
  void *v115; // [xsp+148h] [xbp-1E8h]
  unsigned __int64 v116; // [xsp+150h] [xbp-1E0h] BYREF
  size_t v117; // [xsp+158h] [xbp-1D8h]
  void *v118; // [xsp+160h] [xbp-1D0h]
  int v119; // [xsp+168h] [xbp-1C8h] BYREF
  unsigned __int64 v120; // [xsp+170h] [xbp-1C0h] BYREF
  size_t v121; // [xsp+178h] [xbp-1B8h]
  void *v122; // [xsp+180h] [xbp-1B0h]
  void **v123; // [xsp+188h] [xbp-1A8h] BYREF
  __int64 v124[42]; // [xsp+190h] [xbp-1A0h] BYREF

  v124[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v119 = dword_2A140;
  v121 = 0LL;
  v122 = 0LL;
  if ( (word_2A148 & 1) != 0 )
    v4 = (const char *)qword_2A158;
  else
    v4 = (char *)&word_2A148 + 1;
  v120 = 0LL;
  v5 = strlen(v4);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v6 = v5;
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v121 = v6;
    v122 = v7;
    v120 = v8 | 1;
    goto LABEL_9;
  }
  v7 = (char *)&v120 + 1;
  LOBYTE(v120) = 2 * v5;
  if ( v5 )
LABEL_9:
    memcpy(v7, v4, v6);
  v7[v6] = 0;
  if ( (g3::logLevel(&v119) & 1) == 0 )
  {
    v13 = 0;
    goto LABEL_20;
  }
  v117 = 0LL;
  v118 = 0LL;
  v116 = 0LL;
  v9 = TAG;
  v10 = strlen((const char *)TAG);
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v11 = v10;
  if ( v10 >= 0x17 )
  {
    v14 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)operator new(v14);
    v117 = v11;
    v118 = v12;
    v116 = v14 | 1;
    goto LABEL_17;
  }
  v12 = (char *)&v116 + 1;
  LOBYTE(v116) = 2 * v10;
  if ( v10 )
LABEL_17:
    memcpy(v12, v9, v11);
  v12[v11] = 0;
  v13 = g3::logTag(&v116);
  if ( (v116 & 1) != 0 )
    operator delete(v118);
LABEL_20:
  if ( (v120 & 1) != 0 )
    operator delete(v122);
  if ( (v13 & 1) != 0 )
  {
    LogCapture::LogCapture((LogCapture *)&v123, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)&v123,
      "head def len %lu, fd= %d",
      *((_QWORD *)this + 1),
      *((unsigned int *)this + 1));
    LogCapture::~LogCapture((LogCapture *)&v123);
  }
  pudutech::ESP32::parseMsg(this, (void ***)a2);
  if ( *(_QWORD *)a2 || *((_DWORD *)this + 1) == -1 )
    return;
  do
  {
    v16 = (std::chrono::steady_clock *)std::chrono::steady_clock::now(v15);
    if ( *((_DWORD *)this + 1) == -1 )
    {
LABEL_123:
      pudutech::ESP32::parseMsg(this, &v123);
      v68 = v123;
      v69 = v124[0];
      v123 = 0LL;
      v124[0] = 0LL;
      v70 = *(std::__shared_weak_count **)(a2 + 8);
      *(_QWORD *)a2 = v68;
      *(_QWORD *)(a2 + 8) = v69;
      if ( !v70 )
        goto LABEL_127;
      v71 = (unsigned __int64 *)((char *)v70 + 8);
      do
        v72 = __ldaxr(v71);
      while ( __stlxr(v72 - 1, v71) );
      if ( !v72 )
      {
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v70 + 16LL))(v70);
        v15 = (std::chrono::steady_clock *)std::__shared_weak_count::__release_weak(v70);
        v73 = (std::__shared_weak_count *)v124[0];
        if ( v124[0] )
          goto LABEL_128;
      }
      else
      {
LABEL_127:
        v73 = (std::__shared_weak_count *)v124[0];
        if ( v124[0] )
        {
LABEL_128:
          v74 = (unsigned __int64 *)((char *)v73 + 8);
          do
            v75 = __ldaxr(v74);
          while ( __stlxr(v75 - 1, v74) );
          if ( !v75 )
          {
            (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v73 + 16LL))(v73);
            v15 = (std::chrono::steady_clock *)std::__shared_weak_count::__release_weak(v73);
            if ( !*(_QWORD *)a2 )
              continue;
            return;
          }
        }
      }
      if ( !*(_QWORD *)a2 )
        continue;
      return;
    }
    v17 = v16;
    while ( 1 )
    {
      if ( (word_2A148 & 1) != 0 )
        v18 = (const char *)qword_2A158;
      else
        v18 = (char *)&word_2A148 + 1;
      v112 = dword_2A140;
      v113 = 0LL;
      v114 = 0LL;
      v115 = 0LL;
      v19 = strlen(v18);
      if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v20 = v19;
      if ( v19 >= 0x17 )
      {
        v22 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v21 = (char *)operator new(v22);
        v114 = v20;
        v115 = v21;
        v113 = v22 | 1;
LABEL_37:
        memcpy(v21, v18, v20);
        goto LABEL_38;
      }
      v21 = (char *)&v113 + 1;
      LOBYTE(v113) = 2 * v19;
      if ( v19 )
        goto LABEL_37;
LABEL_38:
      v21[v20] = 0;
      if ( (g3::logLevel(&v112) & 1) == 0 )
      {
        v27 = 0;
        if ( (v113 & 1) != 0 )
          goto LABEL_52;
        goto LABEL_49;
      }
      v23 = TAG;
      v110 = 0LL;
      v111 = 0LL;
      v109 = 0LL;
      v24 = strlen((const char *)TAG);
      if ( v24 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v25 = v24;
      if ( v24 >= 0x17 )
      {
        v28 = (v24 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v26 = (char *)operator new(v28);
        v110 = v25;
        v111 = v26;
        v109 = v28 | 1;
LABEL_46:
        memcpy(v26, v23, v25);
        goto LABEL_47;
      }
      v26 = (char *)&v109 + 1;
      LOBYTE(v109) = 2 * v24;
      if ( v24 )
        goto LABEL_46;
LABEL_47:
      v26[v25] = 0;
      v27 = g3::logTag(&v109);
      if ( (v109 & 1) != 0 )
      {
        operator delete(v111);
        if ( (v113 & 1) != 0 )
        {
LABEL_52:
          operator delete(v115);
          if ( (v27 & 1) == 0 )
            goto LABEL_54;
LABEL_53:
          LogCapture::LogCapture((LogCapture *)&v123, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
          std::__put_character_sequence<char,std::char_traits<char>>(v124, (__int64)"start read", 10LL);
          LogCapture::~LogCapture((LogCapture *)&v123);
          goto LABEL_54;
        }
      }
      else if ( (v113 & 1) != 0 )
      {
        goto LABEL_52;
      }
LABEL_49:
      if ( (v27 & 1) != 0 )
        goto LABEL_53;
LABEL_54:
      v29 = read(*((_DWORD *)this + 1), (char *)this + *((int *)this + 77) + 56, 250LL - *((int *)this + 77));
      v30 = v29;
      if ( (v29 & 0x80000000) != 0 )
      {
        v105 = dword_2A180;
        if ( (word_2A188 & 1) != 0 )
          v34 = (const char *)qword_2A198;
        else
          v34 = (char *)&word_2A188 + 1;
        v106 = 0LL;
        v107 = 0LL;
        v108 = 0LL;
        v35 = strlen(v34);
        if ( v35 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v36 = v35;
        if ( v35 >= 0x17 )
        {
          v38 = (v35 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v37 = (char *)operator new(v38);
          v107 = v36;
          v108 = v37;
          v106 = v38 | 1;
        }
        else
        {
          v37 = (char *)&v106 + 1;
          LOBYTE(v106) = 2 * v35;
          if ( !v35 )
          {
LABEL_72:
            v37[v36] = 0;
            if ( (g3::logLevel(&v105) & 1) == 0 )
            {
              v43 = 0;
              if ( (v106 & 1) == 0 )
                goto LABEL_84;
              goto LABEL_87;
            }
            v39 = TAG;
            v103 = 0LL;
            v104 = 0LL;
            v102 = 0LL;
            v40 = strlen((const char *)TAG);
            if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v41 = v40;
            if ( v40 >= 0x17 )
            {
              v44 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v42 = (char *)operator new(v44);
              v103 = v41;
              v104 = v42;
              v102 = v44 | 1;
            }
            else
            {
              v42 = (char *)&v102 + 1;
              LOBYTE(v102) = 2 * v40;
              if ( !v40 )
              {
LABEL_82:
                v42[v41] = 0;
                v43 = g3::logTag(&v102);
                if ( (v102 & 1) != 0 )
                {
                  operator delete(v104);
                  if ( (v106 & 1) == 0 )
                  {
LABEL_84:
                    if ( (v43 & 1) == 0 )
                      goto LABEL_115;
LABEL_88:
                    LogCapture::LogCapture(
                      (LogCapture *)&v123,
                      (const char *)TAG,
                      (const LEVELS *)&dword_2A180,
                      "",
                      6,
                      0LL);
                    v45 = std::__put_character_sequence<char,std::char_traits<char>>(
                            v124,
                            (__int64)"read esp failed, ret ",
                            21LL);
                    v46 = std::ostream::operator<<(v45);
                    v47 = std::__put_character_sequence<char,std::char_traits<char>>(v46, (__int64)" err: ", 6LL);
                    v48 = (int *)__errno(v47);
                    v49 = std::ostream::operator<<(v47);
                    v50 = std::__put_character_sequence<char,std::char_traits<char>>(v49, (__int64)" ", 1LL);
                    v51 = strerror(*v48);
                    v52 = strlen(v51);
                    std::__put_character_sequence<char,std::char_traits<char>>(v50, (__int64)v51, v52);
                    LogCapture::~LogCapture((LogCapture *)&v123);
                    goto LABEL_115;
                  }
                }
                else if ( (v106 & 1) == 0 )
                {
                  goto LABEL_84;
                }
LABEL_87:
                operator delete(v108);
                if ( (v43 & 1) == 0 )
                  goto LABEL_115;
                goto LABEL_88;
              }
            }
            memcpy(v42, v39, v41);
            goto LABEL_82;
          }
        }
        memcpy(v37, v34, v36);
        goto LABEL_72;
      }
      if ( (_DWORD)v29 )
      {
        v31 = *((_QWORD *)this + 1);
        v32 = v17;
        v33 = *((int *)this + 77) + (__int64)v30;
        *((_DWORD *)this + 77) = v33;
        if ( v31 <= v33 )
          goto LABEL_123;
        goto LABEL_61;
      }
      v32 = (std::chrono::steady_clock *)std::chrono::steady_clock::now((std::chrono::steady_clock *)v29);
      if ( v32 - v17 < 5000000 )
        goto LABEL_115;
      if ( *((int *)this + 6) >= 2 && (__int64)v32 - *((_QWORD *)this + 39) >= 5000000000LL )
        break;
LABEL_61:
      v17 = v32;
      if ( *((_DWORD *)this + 1) == -1 )
        goto LABEL_123;
    }
    *((_QWORD *)this + 39) = std::chrono::steady_clock::now(v32);
    v98 = dword_2A120;
    if ( (word_2A128 & 1) != 0 )
      v53 = (const char *)qword_2A138;
    else
      v53 = (char *)&word_2A128 + 1;
    v100 = 0LL;
    v101 = 0LL;
    v99 = 0LL;
    v54 = strlen(v53);
    if ( v54 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v55 = v54;
    if ( v54 >= 0x17 )
    {
      v57 = (v54 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v56 = (char *)operator new(v57);
      v100 = v55;
      v101 = v56;
      v99 = v57 | 1;
LABEL_97:
      memcpy(v56, v53, v55);
      goto LABEL_98;
    }
    v56 = (char *)&v99 + 1;
    LOBYTE(v99) = 2 * v54;
    if ( v54 )
      goto LABEL_97;
LABEL_98:
    v56[v55] = 0;
    if ( (g3::logLevel(&v98) & 1) == 0 )
    {
      v62 = 0;
      if ( (v99 & 1) == 0 )
        goto LABEL_109;
      goto LABEL_112;
    }
    v58 = TAG;
    v96 = 0LL;
    v97 = 0LL;
    v95 = 0LL;
    v59 = strlen((const char *)TAG);
    if ( v59 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v60 = v59;
    if ( v59 >= 0x17 )
    {
      v63 = (v59 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v61 = (char *)operator new(v63);
      v96 = v60;
      v97 = v61;
      v95 = v63 | 1;
LABEL_106:
      memcpy(v61, v58, v60);
      goto LABEL_107;
    }
    v61 = (char *)&v95 + 1;
    LOBYTE(v95) = 2 * v59;
    if ( v59 )
      goto LABEL_106;
LABEL_107:
    v61[v60] = 0;
    v62 = g3::logTag(&v95);
    if ( (v95 & 1) != 0 )
    {
      operator delete(v97);
      if ( (v99 & 1) != 0 )
        goto LABEL_112;
LABEL_109:
      if ( (v62 & 1) != 0 )
        goto LABEL_113;
    }
    else
    {
      if ( (v99 & 1) == 0 )
        goto LABEL_109;
LABEL_112:
      operator delete(v101);
      if ( (v62 & 1) != 0 )
      {
LABEL_113:
        LogCapture::LogCapture((LogCapture *)&v123, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
        LogCapture::capturef((LogCapture *)&v123, "reset device");
        LogCapture::~LogCapture((LogCapture *)&v123);
      }
    }
    pudutech::ESP32::resetDevice(this);
LABEL_115:
    if ( *((_DWORD *)this + 1) == -1 )
      goto LABEL_123;
    v91 = dword_2A120;
    if ( (word_2A128 & 1) != 0 )
      v64 = (const char *)qword_2A138;
    else
      v64 = (char *)&word_2A128 + 1;
    v92 = 0LL;
    v93 = 0LL;
    v94 = 0LL;
    v65 = strlen(v64);
    if ( v65 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v66 = v65;
    if ( v65 >= 0x17 )
    {
      v76 = (v65 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v67 = (char *)operator new(v76);
      v93 = v66;
      v94 = v67;
      v92 = v76 | 1;
LABEL_137:
      memcpy(v67, v64, v66);
      goto LABEL_138;
    }
    v67 = (char *)&v92 + 1;
    LOBYTE(v92) = 2 * v65;
    if ( v65 )
      goto LABEL_137;
LABEL_138:
    v67[v66] = 0;
    if ( (g3::logLevel(&v91) & 1) == 0 )
    {
      v81 = 0;
      if ( (v92 & 1) == 0 )
        goto LABEL_149;
      goto LABEL_152;
    }
    v77 = TAG;
    v89 = 0LL;
    v90 = 0LL;
    v88 = 0LL;
    v78 = strlen((const char *)TAG);
    if ( v78 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v79 = v78;
    if ( v78 >= 0x17 )
    {
      v82 = (v78 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v80 = (char *)operator new(v82);
      v89 = v79;
      v90 = v80;
      v88 = v82 | 1;
LABEL_146:
      memcpy(v80, v77, v79);
      goto LABEL_147;
    }
    v80 = (char *)&v88 + 1;
    LOBYTE(v88) = 2 * v78;
    if ( v78 )
      goto LABEL_146;
LABEL_147:
    v80[v79] = 0;
    v81 = g3::logTag(&v88);
    if ( (v88 & 1) != 0 )
    {
      operator delete(v90);
      if ( (v92 & 1) != 0 )
        goto LABEL_152;
LABEL_149:
      if ( (v81 & 1) != 0 )
        goto LABEL_153;
    }
    else
    {
      if ( (v92 & 1) == 0 )
        goto LABEL_149;
LABEL_152:
      operator delete(v94);
      if ( (v81 & 1) != 0 )
      {
LABEL_153:
        LogCapture::LogCapture((LogCapture *)&v123, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
        v83 = std::__put_character_sequence<char,std::char_traits<char>>(v124, (__int64)"reopen for ret ", 15LL);
        v84 = std::ostream::operator<<(v83);
        v85 = std::__put_character_sequence<char,std::char_traits<char>>(v84, (__int64)" buffer offset ", 15LL);
        v86 = std::ostream::operator<<(v85);
        v87 = std::__put_character_sequence<char,std::char_traits<char>>(v86, (__int64)" fd ", 4LL);
        std::ostream::operator<<(v87);
        LogCapture::~LogCapture((LogCapture *)&v123);
      }
    }
    v15 = (std::chrono::steady_clock *)pudutech::ESP32::blockReOpen(this);
  }
  while ( *((_DWORD *)this + 1) != -1 );
}
// 9460: variable 'v15' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A140: using guessed type int dword_2A140;
// 2A148: using guessed type __int16 word_2A148;
// 2A158: using guessed type __int64 qword_2A158;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (0000000000009F64) ----------------------------------------------------
void __usercall pudutech::ESP32::parseMsg(pudutech::ESP32 *this@<X0>, void ***a2@<X8>)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x10
  pudutech::ESP32 *v5; // x20
  __int64 v6; // x28
  int v7; // w25
  const char *v8; // x22
  size_t v9; // x0
  size_t v10; // x21
  char *v11; // x23
  unsigned __int64 v12; // x24
  const void *v13; // x21
  size_t v14; // x0
  size_t v15; // x22
  char *v16; // x23
  char v17; // w21
  const char *v18; // x23
  size_t v19; // x0
  size_t v20; // x22
  char *v21; // x24
  unsigned __int64 v22; // x24
  int v23; // w25
  unsigned __int64 v24; // x25
  const void *v25; // x22
  size_t v26; // x0
  size_t v27; // x23
  char *v28; // x24
  char v29; // w22
  unsigned __int64 v30; // x25
  __int64 v31; // x8
  size_t v32; // x22
  __int64 v33; // x0
  __int64 v34; // x22
  unsigned __int8 *v35; // x22
  unsigned int v36; // t1
  unsigned int v37; // w23
  __int64 v38; // x24
  unsigned int v39; // w21
  void **v40; // x0
  std::__shared_weak_count *v41; // x26
  unsigned __int64 v42; // x23
  _BYTE *v43; // x8
  __int64 v44; // x9
  void *v45; // x0
  const char *v46; // x22
  size_t v47; // x0
  size_t v48; // x21
  char *v49; // x23
  const char *v50; // x24
  size_t v51; // x0
  size_t v52; // x23
  char *v53; // x25
  unsigned __int64 v54; // x24
  const void *v55; // x21
  size_t v56; // x0
  size_t v57; // x22
  char *v58; // x23
  char v59; // w21
  unsigned __int64 v60; // x26
  const void *v61; // x23
  size_t v62; // x0
  size_t v63; // x24
  char *v64; // x25
  char v65; // w23
  unsigned __int64 v66; // x24
  const char *v67; // x24
  size_t v68; // x0
  size_t v69; // x23
  char *v70; // x25
  unsigned __int64 v71; // x22
  const void *v72; // x23
  size_t v73; // x0
  size_t v74; // x24
  char *v75; // x25
  char v76; // w23
  unsigned __int64 v77; // x26
  unsigned __int64 v78; // x22
  int v79; // w8
  __int64 v80; // x21
  unsigned __int64 v81; // x25
  signed int v82; // w8
  size_t v83; // x24
  bool v84; // cc
  __int64 v85; // x8
  size_t v86; // x2
  unsigned __int64 *v87; // x8
  unsigned __int64 v88; // x9
  unsigned __int64 *v89; // x8
  unsigned __int64 v90; // x9
  unsigned int v91; // [xsp+Ch] [xbp-2E4h]
  void **v92; // [xsp+10h] [xbp-2E0h]
  int v93; // [xsp+1Ch] [xbp-2D4h]
  unsigned __int64 v94; // [xsp+28h] [xbp-2C8h] BYREF
  size_t v95; // [xsp+30h] [xbp-2C0h]
  void *v96; // [xsp+38h] [xbp-2B8h]
  int v97; // [xsp+40h] [xbp-2B0h] BYREF
  unsigned __int64 v98; // [xsp+48h] [xbp-2A8h] BYREF
  size_t v99; // [xsp+50h] [xbp-2A0h]
  void *v100; // [xsp+58h] [xbp-298h]
  unsigned __int64 v101; // [xsp+60h] [xbp-290h] BYREF
  size_t v102; // [xsp+68h] [xbp-288h]
  void *v103; // [xsp+70h] [xbp-280h]
  int v104; // [xsp+78h] [xbp-278h] BYREF
  unsigned __int64 v105; // [xsp+80h] [xbp-270h] BYREF
  size_t v106; // [xsp+88h] [xbp-268h]
  void *v107; // [xsp+90h] [xbp-260h]
  unsigned __int64 v108; // [xsp+98h] [xbp-258h] BYREF
  size_t v109; // [xsp+A0h] [xbp-250h]
  void *v110; // [xsp+A8h] [xbp-248h]
  int v111; // [xsp+B0h] [xbp-240h] BYREF
  unsigned __int64 v112; // [xsp+B8h] [xbp-238h] BYREF
  size_t v113; // [xsp+C0h] [xbp-230h]
  void *v114; // [xsp+C8h] [xbp-228h]
  unsigned __int64 v115; // [xsp+D0h] [xbp-220h] BYREF
  size_t v116; // [xsp+D8h] [xbp-218h]
  void *v117; // [xsp+E0h] [xbp-210h]
  int v118; // [xsp+E8h] [xbp-208h] BYREF
  unsigned __int64 v119; // [xsp+F0h] [xbp-200h] BYREF
  size_t v120; // [xsp+F8h] [xbp-1F8h]
  void *v121; // [xsp+100h] [xbp-1F0h]
  unsigned __int64 v122; // [xsp+108h] [xbp-1E8h] BYREF
  size_t v123; // [xsp+110h] [xbp-1E0h]
  void *v124; // [xsp+118h] [xbp-1D8h]
  int v125; // [xsp+120h] [xbp-1D0h] BYREF
  unsigned __int64 v126; // [xsp+128h] [xbp-1C8h] BYREF
  size_t v127; // [xsp+130h] [xbp-1C0h]
  void *v128; // [xsp+138h] [xbp-1B8h]
  char dest[352]; // [xsp+140h] [xbp-1B0h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = *((int *)this + 77);
  v4 = *((_QWORD *)this + 1);
  if ( v4 >= v3 )
    goto LABEL_65;
  v5 = this;
  if ( v3 == v4 )
  {
    v7 = 0;
    v6 = 0LL;
LABEL_9:
    if ( (word_2A188 & 1) != 0 )
      v8 = (const char *)qword_2A198;
    else
      v8 = (char *)&word_2A188 + 1;
    v97 = dword_2A180;
    v99 = 0LL;
    v100 = 0LL;
    v98 = 0LL;
    v9 = strlen(v8);
    if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v10 = v9;
    if ( v9 >= 0x17 )
    {
      v12 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v11 = (char *)operator new(v12);
      v99 = v10;
      v100 = v11;
      v98 = v12 | 1;
    }
    else
    {
      v11 = (char *)&v98 + 1;
      LOBYTE(v98) = 2 * v9;
      if ( !v9 )
      {
LABEL_18:
        v11[v10] = 0;
        if ( (g3::logLevel(&v97) & 1) == 0 )
        {
          v17 = 0;
          if ( (v98 & 1) == 0 )
            goto LABEL_37;
          goto LABEL_40;
        }
        v95 = 0LL;
        v96 = 0LL;
        v94 = 0LL;
        v13 = TAG;
        v14 = strlen((const char *)TAG);
        if ( v14 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v15 = v14;
        if ( v14 >= 0x17 )
        {
          v22 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v16 = (char *)operator new(v22);
          v95 = v15;
          v96 = v16;
          v94 = v22 | 1;
        }
        else
        {
          v16 = (char *)&v94 + 1;
          LOBYTE(v94) = 2 * v14;
          if ( !v14 )
          {
LABEL_35:
            v16[v15] = 0;
            v17 = g3::logTag(&v94);
            if ( (v94 & 1) != 0 )
            {
              operator delete(v96);
              if ( (v98 & 1) == 0 )
              {
LABEL_37:
                if ( (v17 & 1) == 0 )
                  goto LABEL_64;
                goto LABEL_38;
              }
            }
            else if ( (v98 & 1) == 0 )
            {
              goto LABEL_37;
            }
LABEL_40:
            operator delete(v100);
            if ( (v17 & 1) == 0 )
              goto LABEL_64;
LABEL_38:
            LogCapture::LogCapture((LogCapture *)dest, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
            LogCapture::capturef(
              (LogCapture *)dest,
              "not find head from buf, buf offset %d, head length %lu",
              *((unsigned int *)v5 + 77),
              *((_QWORD *)v5 + 1));
            LogCapture::~LogCapture((LogCapture *)dest);
LABEL_64:
            memset(dest, 0, 250);
            v32 = *((int *)v5 + 77) - (__int64)v7;
            memcpy(dest, (char *)v5 + v6 + 56, v32);
            memcpy((char *)v5 + 56, dest, v32);
            *((_DWORD *)v5 + 77) -= v7;
LABEL_65:
            *a2 = 0LL;
            a2[1] = 0LL;
            return;
          }
        }
        memcpy(v16, v13, v15);
        goto LABEL_35;
      }
    }
    memcpy(v11, v8, v10);
    goto LABEL_18;
  }
  v6 = 0LL;
  while ( *((unsigned __int8 *)this + v6 + 56) != 170 || *((_BYTE *)this + v6 + 57) != 85 )
  {
    if ( v3 - v4 <= ++v6 )
    {
      v7 = v6;
      v6 = (unsigned int)v6;
      goto LABEL_9;
    }
  }
  *((_QWORD *)this + 6) = (char *)this + v6 + 56;
  if ( *(_WORD *)((char *)this + v6 + 60) != 30069 )
  {
    v23 = 0;
    goto LABEL_62;
  }
  *((_QWORD *)this + 39) = std::chrono::steady_clock::now(this);
  v125 = dword_2A120;
  v127 = 0LL;
  v128 = 0LL;
  if ( (word_2A128 & 1) != 0 )
    v18 = (const char *)qword_2A138;
  else
    v18 = (char *)&word_2A128 + 1;
  v126 = 0LL;
  v19 = strlen(v18);
  if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v20 = v19;
  if ( v19 >= 0x17 )
  {
    v24 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v21 = (char *)operator new(v24);
    v127 = v20;
    v128 = v21;
    v126 = v24 | 1;
    goto LABEL_44;
  }
  v21 = (char *)&v126 + 1;
  LOBYTE(v126) = 2 * v19;
  if ( v19 )
LABEL_44:
    memcpy(v21, v18, v20);
  v21[v20] = 0;
  this = (pudutech::ESP32 *)g3::logLevel(&v125);
  if ( ((unsigned __int8)this & 1) == 0 )
  {
    v29 = 0;
    if ( (v126 & 1) == 0 )
      goto LABEL_56;
    goto LABEL_59;
  }
  v123 = 0LL;
  v124 = 0LL;
  v122 = 0LL;
  v25 = TAG;
  v26 = strlen((const char *)TAG);
  if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v27 = v26;
  if ( v26 >= 0x17 )
  {
    v30 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v28 = (char *)operator new(v30);
    v123 = v27;
    v124 = v28;
    v122 = v30 | 1;
    goto LABEL_53;
  }
  v28 = (char *)&v122 + 1;
  LOBYTE(v122) = 2 * v26;
  if ( v26 )
LABEL_53:
    memcpy(v28, v25, v27);
  v28[v27] = 0;
  this = (pudutech::ESP32 *)g3::logTag(&v122);
  v29 = (char)this;
  if ( (v122 & 1) != 0 )
  {
    operator delete(v124);
    if ( (v126 & 1) == 0 )
    {
LABEL_56:
      if ( (v29 & 1) == 0 )
        goto LABEL_61;
      goto LABEL_60;
    }
  }
  else if ( (v126 & 1) == 0 )
  {
    goto LABEL_56;
  }
LABEL_59:
  operator delete(v128);
  if ( (v29 & 1) != 0 )
  {
LABEL_60:
    LogCapture::LogCapture((LogCapture *)dest, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)dest, "receive response");
    LogCapture::~LogCapture((LogCapture *)dest);
  }
LABEL_61:
  v23 = 1;
LABEL_62:
  v31 = *((_QWORD *)v5 + 6);
  if ( 1LL - *((_QWORD *)v5 + 1) + *((_DWORD *)v5 + 77) - (int)v6 < (unsigned __int64)*(unsigned __int8 *)(v31 + 2) )
  {
    v7 = v6;
    goto LABEL_64;
  }
  v93 = v23;
  if ( *((_DWORD *)v5 + 5) != *(unsigned __int8 *)(v31 + 3) )
  {
    if ( (word_2A148 & 1) != 0 )
      v46 = (const char *)qword_2A158;
    else
      v46 = (char *)&word_2A148 + 1;
    v118 = dword_2A140;
    v120 = 0LL;
    v121 = 0LL;
    v119 = 0LL;
    v47 = strlen(v46);
    if ( v47 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v48 = v47;
    if ( v47 >= 0x17 )
    {
      v54 = (v47 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v49 = (char *)operator new(v54);
      v120 = v48;
      v121 = v49;
      v119 = v54 | 1;
    }
    else
    {
      v49 = (char *)&v119 + 1;
      LOBYTE(v119) = 2 * v47;
      if ( !v47 )
      {
LABEL_89:
        v49[v48] = 0;
        if ( (g3::logLevel(&v118) & 1) == 0 )
        {
          v59 = 0;
          if ( (v119 & 1) == 0 )
            goto LABEL_109;
          goto LABEL_112;
        }
        v116 = 0LL;
        v117 = 0LL;
        v115 = 0LL;
        v55 = TAG;
        v56 = strlen((const char *)TAG);
        if ( v56 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v57 = v56;
        if ( v56 >= 0x17 )
        {
          v66 = (v56 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v58 = (char *)operator new(v66);
          v116 = v57;
          v117 = v58;
          v115 = v66 | 1;
        }
        else
        {
          v58 = (char *)&v115 + 1;
          LOBYTE(v115) = 2 * v56;
          if ( !v56 )
          {
LABEL_107:
            v58[v57] = 0;
            v59 = g3::logTag(&v115);
            if ( (v115 & 1) != 0 )
            {
              operator delete(v117);
              if ( (v119 & 1) == 0 )
              {
LABEL_109:
                if ( (v59 & 1) == 0 )
                  goto LABEL_114;
                goto LABEL_113;
              }
            }
            else if ( (v119 & 1) == 0 )
            {
              goto LABEL_109;
            }
LABEL_112:
            operator delete(v121);
            if ( (v59 & 1) == 0 )
            {
LABEL_114:
              v41 = 0LL;
              v92 = 0LL;
              goto LABEL_151;
            }
LABEL_113:
            LogCapture::LogCapture((LogCapture *)dest, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
            LogCapture::capturef(
              (LogCapture *)dest,
              "recv msg from channel %d, current channel %d",
              *(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 3LL),
              *((unsigned int *)v5 + 5));
            LogCapture::~LogCapture((LogCapture *)dest);
            goto LABEL_114;
          }
        }
        memcpy(v58, v55, v57);
        goto LABEL_107;
      }
    }
    memcpy(v49, v46, v48);
    goto LABEL_89;
  }
  v33 = std::chrono::steady_clock::now(this);
  v34 = *((_QWORD *)v5 + 6);
  *((_QWORD *)v5 + 40) = v33;
  v36 = *(unsigned __int8 *)(v34 + 2);
  v35 = (unsigned __int8 *)(v34 + 2);
  v37 = *((unsigned __int16 *)v35 + 2);
  *((_WORD *)v35 + 2) = 0;
  v38 = *((_QWORD *)v5 + 1);
  v39 = (unsigned __int16)pudutech::ESP32::crc16(
                            (pudutech::ESP32 *)((char *)v5 + v6 + 56),
                            (unsigned __int8 *)v5 + v38 + v6 + 56,
                            (unsigned __int8 *)v36);
  v91 = v37;
  if ( v37 != v39 )
  {
    if ( (word_2A128 & 1) != 0 )
      v50 = (const char *)qword_2A138;
    else
      v50 = (char *)&word_2A128 + 1;
    v111 = dword_2A120;
    v113 = 0LL;
    v114 = 0LL;
    v112 = 0LL;
    v51 = strlen(v50);
    if ( v51 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v52 = v51;
    if ( v51 >= 0x17 )
    {
      v60 = (v51 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v53 = (char *)operator new(v60);
      v113 = v52;
      v114 = v53;
      v112 = v60 | 1;
    }
    else
    {
      v53 = (char *)&v112 + 1;
      LOBYTE(v112) = 2 * v51;
      if ( !v51 )
      {
LABEL_98:
        v53[v52] = 0;
        if ( (g3::logLevel(&v111) & 1) == 0 )
        {
          v65 = 0;
          if ( (v112 & 1) == 0 )
            goto LABEL_136;
          goto LABEL_139;
        }
        v109 = 0LL;
        v110 = 0LL;
        v108 = 0LL;
        v61 = TAG;
        v62 = strlen((const char *)TAG);
        if ( v62 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v63 = v62;
        if ( v62 >= 0x17 )
        {
          v77 = (v62 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v64 = (char *)operator new(v77);
          v109 = v63;
          v110 = v64;
          v108 = v77 | 1;
        }
        else
        {
          v64 = (char *)&v108 + 1;
          LOBYTE(v108) = 2 * v62;
          if ( !v62 )
          {
LABEL_134:
            v64[v63] = 0;
            v65 = g3::logTag(&v108);
            if ( (v108 & 1) != 0 )
            {
              operator delete(v110);
              if ( (v112 & 1) == 0 )
              {
LABEL_136:
                if ( (v65 & 1) == 0 )
                  goto LABEL_141;
                goto LABEL_140;
              }
            }
            else if ( (v112 & 1) == 0 )
            {
              goto LABEL_136;
            }
LABEL_139:
            operator delete(v114);
            if ( (v65 & 1) == 0 )
            {
LABEL_141:
              v41 = 0LL;
              v92 = 0LL;
              *((_BYTE *)v5 + 2) = 3;
              goto LABEL_151;
            }
LABEL_140:
            LogCapture::LogCapture((LogCapture *)dest, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)dest, "CRC check error: current crc %d, compute crc %d", v91, v39);
            LogCapture::~LogCapture((LogCapture *)dest);
            goto LABEL_141;
          }
        }
        memcpy(v64, v61, v63);
        goto LABEL_134;
      }
    }
    memcpy(v53, v50, v52);
    goto LABEL_98;
  }
  *((_BYTE *)v5 + 2) = 1;
  v40 = (void **)operator new(0x30uLL);
  v40[2] = 0LL;
  v40[1] = 0LL;
  v41 = (std::__shared_weak_count *)v40;
  *v40 = off_29898;
  v42 = *v35;
  v40[3] = 0LL;
  v40[4] = 0LL;
  v40[5] = 0LL;
  v92 = v40 + 3;
  if ( v42 )
  {
    v43 = (_BYTE *)operator new(v42);
    *((_QWORD *)v41 + 5) = &v43[v42];
    v44 = -(__int64)v42;
    *((_QWORD *)v41 + 3) = v43;
    *((_QWORD *)v41 + 4) = v43;
    do
    {
      *v43 = 0;
      ++v44;
      v43 = (_BYTE *)(*((_QWORD *)v41 + 4) + 1LL);
      *((_QWORD *)v41 + 4) = v43;
    }
    while ( v44 );
    v38 = *((_QWORD *)v5 + 1);
    v45 = *v92;
    v35 = (unsigned __int8 *)(*((_QWORD *)v5 + 6) + 2LL);
  }
  else
  {
    v45 = 0LL;
  }
  memcpy(v45, (char *)v5 + v38 + v6 + 56, *v35);
  if ( (word_2A148 & 1) != 0 )
    v67 = (const char *)qword_2A158;
  else
    v67 = (char *)&word_2A148 + 1;
  v104 = dword_2A140;
  v106 = 0LL;
  v107 = 0LL;
  v105 = 0LL;
  v68 = strlen(v67);
  if ( v68 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v69 = v68;
  if ( v68 >= 0x17 )
  {
    v71 = (v68 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v70 = (char *)operator new(v71);
    v106 = v69;
    v107 = v70;
    v105 = v71 | 1;
    goto LABEL_124;
  }
  v70 = (char *)&v105 + 1;
  LOBYTE(v105) = 2 * v68;
  if ( v68 )
LABEL_124:
    memcpy(v70, v67, v69);
  v70[v69] = 0;
  if ( (g3::logLevel(&v104) & 1) == 0 )
  {
    v76 = 0;
    if ( (v105 & 1) == 0 )
      goto LABEL_146;
    goto LABEL_149;
  }
  v102 = 0LL;
  v103 = 0LL;
  v101 = 0LL;
  v72 = TAG;
  v73 = strlen((const char *)TAG);
  if ( v73 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v74 = v73;
  if ( v73 >= 0x17 )
  {
    v78 = (v73 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v75 = (char *)operator new(v78);
    v102 = v74;
    v103 = v75;
    v101 = v78 | 1;
    goto LABEL_143;
  }
  v75 = (char *)&v101 + 1;
  LOBYTE(v101) = 2 * v73;
  if ( v73 )
LABEL_143:
    memcpy(v75, v72, v74);
  v75[v74] = 0;
  v76 = g3::logTag(&v101);
  if ( (v101 & 1) == 0 )
  {
    if ( (v105 & 1) == 0 )
      goto LABEL_146;
LABEL_149:
    operator delete(v107);
    if ( (v76 & 1) == 0 )
      goto LABEL_151;
    goto LABEL_150;
  }
  operator delete(v103);
  if ( (v105 & 1) != 0 )
    goto LABEL_149;
LABEL_146:
  if ( (v76 & 1) != 0 )
  {
LABEL_150:
    LogCapture::LogCapture((LogCapture *)dest, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)dest,
      "recv msg length %d, crc %d",
      *(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 2LL),
      v91);
    LogCapture::~LogCapture((LogCapture *)dest);
  }
LABEL_151:
  v79 = *((_DWORD *)v5 + 77);
  v80 = *((_QWORD *)v5 + 1);
  v81 = *(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 2LL);
  if ( v79 - (int)v6 - v80 > v81 )
  {
    v82 = v79 - v81 - v80 - v6;
    v83 = v82;
    v84 = (unsigned int)v82 > 0xF9;
    v85 = 250LL - v82;
    if ( v84 )
      v86 = 0LL;
    else
      v86 = v85;
    memset(&dest[v83], 0, v86);
    memcpy(dest, (char *)v5 + (int)v80 + (int)v81 + (int)v6 + 56, v83);
    memcpy((char *)v5 + 56, dest, v83);
    *((_DWORD *)v5 + 77) = *((_DWORD *)v5 + 77) - v81 - v80 - v6;
    if ( !v93 )
      goto LABEL_160;
LABEL_158:
    *a2 = 0LL;
    a2[1] = 0LL;
    if ( !v41 )
      return;
    goto LABEL_163;
  }
  *((_DWORD *)v5 + 77) = 0;
  if ( v93 )
    goto LABEL_158;
LABEL_160:
  *a2 = v92;
  a2[1] = (void **)v41;
  if ( !v41 )
    return;
  v87 = (unsigned __int64 *)((char *)v41 + 8);
  do
    v88 = __ldxr(v87);
  while ( __stxr(v88 + 1, v87) );
LABEL_163:
  v89 = (unsigned __int64 *)((char *)v41 + 8);
  do
    v90 = __ldaxr(v89);
  while ( __stlxr(v90 - 1, v89) );
  if ( !v90 )
  {
    (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v41 + 16LL))(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
}
// A480: variable 'this' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 29898: using guessed type __int64 (__fastcall *off_29898[2])(std::__shared_weak_count *this);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A140: using guessed type int dword_2A140;
// 2A148: using guessed type __int16 word_2A148;
// 2A158: using guessed type __int64 qword_2A158;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (000000000000AE04) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// AE04: using guessed type char var_60[8];

//----- (000000000000AFF0) ----------------------------------------------------
void __fastcall pudutech::ESP32::resetDevice(pudutech::ESP32 *this)
{
  unsigned int v2; // w19
  unsigned int v3; // w0
  int v4; // w1
  unsigned int v5; // w20
  int v6; // w1
  int v7; // w8
  char *v8; // x1
  unsigned __int64 v9; // x2
  __int64 *v10; // x0
  __int128 v11; // q0
  int v12; // w8
  char *v13; // x1
  unsigned __int64 v14; // x2
  __int64 *v15; // x0
  __int128 v16; // q0
  __int64 *v17; // x0
  __int128 v18; // q0
  char *v19; // x1
  unsigned __int64 v20; // x2
  __int64 *v21; // x0
  __int128 v22; // q0
  const char *v23; // x0
  int v24; // w19
  unsigned int v25; // w20
  const char *v26; // x22
  size_t v27; // x0
  size_t v28; // x21
  char *v29; // x23
  const char *v30; // x20
  size_t v31; // x0
  size_t v32; // x19
  char *v33; // x21
  unsigned __int64 v34; // x22
  const void *v35; // x19
  size_t v36; // x0
  size_t v37; // x20
  char *v38; // x21
  char v39; // w19
  const char *v40; // x20
  size_t v41; // x0
  size_t v42; // x19
  char *v43; // x21
  unsigned __int64 v44; // x22
  const char *v45; // x22
  size_t v46; // x0
  size_t v47; // x21
  char *v48; // x23
  unsigned __int64 v49; // x24
  const void *v50; // x21
  size_t v51; // x0
  size_t v52; // x22
  char *v53; // x23
  char v54; // w21
  unsigned __int64 v55; // x22
  const void *v56; // x19
  size_t v57; // x0
  size_t v58; // x20
  char *v59; // x21
  char v60; // w19
  unsigned __int64 v61; // x24
  const void *v62; // x21
  size_t v63; // x0
  size_t v64; // x22
  char *v65; // x23
  char v66; // w21
  unsigned __int64 v67; // x24
  unsigned __int64 v68; // x22
  const char *v69; // x2
  unsigned __int64 v70; // x24
  const char *v71; // x22
  size_t v72; // x0
  size_t v73; // x21
  char *v74; // x23
  unsigned __int64 v75; // x24
  const void *v76; // x21
  size_t v77; // x0
  size_t v78; // x22
  char *v79; // x23
  char v80; // w21
  unsigned __int64 v81; // x24
  unsigned __int64 v82; // [xsp+8h] [xbp-348h] BYREF
  size_t v83; // [xsp+10h] [xbp-340h]
  void *v84; // [xsp+18h] [xbp-338h]
  int v85; // [xsp+20h] [xbp-330h] BYREF
  unsigned __int64 v86; // [xsp+28h] [xbp-328h] BYREF
  size_t v87; // [xsp+30h] [xbp-320h]
  void *v88; // [xsp+38h] [xbp-318h]
  unsigned __int64 v89; // [xsp+40h] [xbp-310h] BYREF
  size_t v90; // [xsp+48h] [xbp-308h]
  void *v91; // [xsp+50h] [xbp-300h]
  int v92; // [xsp+58h] [xbp-2F8h] BYREF
  unsigned __int64 v93; // [xsp+60h] [xbp-2F0h] BYREF
  size_t v94; // [xsp+68h] [xbp-2E8h]
  void *v95; // [xsp+70h] [xbp-2E0h]
  unsigned __int64 v96; // [xsp+78h] [xbp-2D8h] BYREF
  size_t v97; // [xsp+80h] [xbp-2D0h]
  void *v98; // [xsp+88h] [xbp-2C8h]
  int v99; // [xsp+90h] [xbp-2C0h] BYREF
  unsigned __int64 v100; // [xsp+98h] [xbp-2B8h] BYREF
  size_t v101; // [xsp+A0h] [xbp-2B0h]
  void *v102; // [xsp+A8h] [xbp-2A8h]
  unsigned __int64 v103; // [xsp+B0h] [xbp-2A0h] BYREF
  size_t v104; // [xsp+B8h] [xbp-298h]
  void *v105; // [xsp+C0h] [xbp-290h]
  int v106; // [xsp+C8h] [xbp-288h] BYREF
  unsigned __int64 v107; // [xsp+D0h] [xbp-280h] BYREF
  size_t v108; // [xsp+D8h] [xbp-278h]
  void *v109; // [xsp+E0h] [xbp-270h]
  __int64 v110[3]; // [xsp+E8h] [xbp-268h] BYREF
  __int128 v111; // [xsp+100h] [xbp-250h] BYREF
  void *v112; // [xsp+110h] [xbp-240h]
  __int128 v113; // [xsp+120h] [xbp-230h] BYREF
  void *v114; // [xsp+130h] [xbp-220h]
  __int128 v115; // [xsp+140h] [xbp-210h] BYREF
  void *v116; // [xsp+150h] [xbp-200h]
  __int64 v117; // [xsp+158h] [xbp-1F8h] BYREF
  unsigned __int64 v118; // [xsp+160h] [xbp-1F0h]
  void *v119; // [xsp+168h] [xbp-1E8h]
  __int64 v120; // [xsp+170h] [xbp-1E0h] BYREF
  unsigned __int64 v121; // [xsp+178h] [xbp-1D8h]
  void *v122; // [xsp+180h] [xbp-1D0h]
  unsigned __int64 v123; // [xsp+188h] [xbp-1C8h] BYREF
  size_t v124; // [xsp+190h] [xbp-1C0h]
  void *v125; // [xsp+198h] [xbp-1B8h]
  int v126; // [xsp+1A0h] [xbp-1B0h] BYREF
  unsigned __int64 v127; // [xsp+1A8h] [xbp-1A8h] BYREF
  size_t v128; // [xsp+1B0h] [xbp-1A0h]
  void *v129; // [xsp+1B8h] [xbp-198h]
  __int128 v130; // [xsp+1C0h] [xbp-190h] BYREF
  void *v131; // [xsp+1D0h] [xbp-180h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = sub_EFC8(2, *((_DWORD *)this + 6) == 2);
  v3 = sub_EFC8(0, *((_DWORD *)this + 6) == 2);
  if ( v2 == -1 || (v5 = v3, v3 == -1) )
  {
    if ( (word_2A188 & 1) != 0 )
      v30 = (const char *)qword_2A198;
    else
      v30 = (char *)&word_2A188 + 1;
    v126 = dword_2A180;
    v128 = 0LL;
    v129 = 0LL;
    v127 = 0LL;
    v31 = strlen(v30);
    if ( v31 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v32 = v31;
    if ( v31 >= 0x17 )
    {
      v34 = (v31 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v33 = (char *)operator new(v34);
      v128 = v32;
      v129 = v33;
      v127 = v34 | 1;
    }
    else
    {
      v33 = (char *)&v127 + 1;
      LOBYTE(v127) = 2 * v31;
      if ( !v31 )
      {
LABEL_56:
        v33[v32] = 0;
        if ( (g3::logLevel(&v126) & 1) == 0 )
        {
          v39 = 0;
          if ( (v127 & 1) == 0 )
            goto LABEL_75;
          goto LABEL_62;
        }
        v124 = 0LL;
        v125 = 0LL;
        v123 = 0LL;
        v35 = TAG;
        v36 = strlen((const char *)TAG);
        if ( v36 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v37 = v36;
        if ( v36 >= 0x17 )
        {
          v44 = (v36 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v38 = (char *)operator new(v44);
          v124 = v37;
          v125 = v38;
          v123 = v44 | 1;
        }
        else
        {
          v38 = (char *)&v123 + 1;
          LOBYTE(v123) = 2 * v36;
          if ( !v36 )
          {
LABEL_73:
            v38[v37] = 0;
            v39 = g3::logTag(&v123);
            if ( (v123 & 1) != 0 )
            {
              operator delete(v125);
              if ( (v127 & 1) == 0 )
              {
LABEL_75:
                if ( (v39 & 1) == 0 )
                  return;
LABEL_76:
                LogCapture::LogCapture((LogCapture *)&v130, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
                LogCapture::capturef((LogCapture *)&v130, "can not find device");
                LogCapture::~LogCapture((LogCapture *)&v130);
                return;
              }
            }
            else if ( (v127 & 1) == 0 )
            {
              goto LABEL_75;
            }
LABEL_62:
            operator delete(v129);
            if ( (v39 & 1) == 0 )
              return;
            goto LABEL_76;
          }
        }
        memcpy(v38, v35, v37);
        goto LABEL_73;
      }
    }
    memcpy(v33, v30, v32);
    goto LABEL_56;
  }
  std::to_string(&v120, (std::__ndk1 *)v2, v4);
  std::to_string(&v117, (std::__ndk1 *)v5, v6);
  if ( (v120 & 1) != 0 )
    v7 = v121;
  else
    v7 = (unsigned __int64)(unsigned __int8)v120 >> 1;
  zeroPadding(3 - v7, (unsigned __int64 *)&v130);
  if ( (v120 & 1) != 0 )
    v8 = (char *)v122;
  else
    v8 = (char *)&v120 + 1;
  if ( (v120 & 1) != 0 )
    v9 = v121;
  else
    v9 = (unsigned __int64)(unsigned __int8)v120 >> 1;
  v10 = std::string::append((__int64 *)&v130, v8, v9);
  v11 = *(_OWORD *)v10;
  v116 = (void *)v10[2];
  v115 = v11;
  v10[1] = 0LL;
  v10[2] = 0LL;
  *v10 = 0LL;
  if ( (v130 & 1) != 0 )
    operator delete(v131);
  if ( (v117 & 1) != 0 )
    v12 = v118;
  else
    v12 = (unsigned __int64)(unsigned __int8)v117 >> 1;
  zeroPadding(3 - v12, (unsigned __int64 *)&v130);
  if ( (v117 & 1) != 0 )
    v13 = (char *)v119;
  else
    v13 = (char *)&v117 + 1;
  if ( (v117 & 1) != 0 )
    v14 = v118;
  else
    v14 = (unsigned __int64)(unsigned __int8)v117 >> 1;
  v15 = std::string::append((__int64 *)&v130, v13, v14);
  v16 = *(_OWORD *)v15;
  v114 = (void *)v15[2];
  v113 = v16;
  v15[1] = 0LL;
  v15[2] = 0LL;
  *v15 = 0LL;
  if ( (v130 & 1) != 0 )
    operator delete(v131);
  std::operator+<char>("/dev/bus/usb/", (unsigned __int8 *)&v115, v110);
  v17 = std::string::append(v110, "/", 1uLL);
  v18 = *(_OWORD *)v17;
  v131 = (void *)v17[2];
  v130 = v18;
  v17[1] = 0LL;
  v17[2] = 0LL;
  *v17 = 0LL;
  if ( (v113 & 1) != 0 )
    v19 = (char *)v114;
  else
    v19 = (char *)&v113 + 1;
  if ( (v113 & 1) != 0 )
    v20 = *((_QWORD *)&v113 + 1);
  else
    v20 = (unsigned __int64)(unsigned __int8)v113 >> 1;
  v21 = std::string::append((__int64 *)&v130, v19, v20);
  v22 = *(_OWORD *)v21;
  v112 = (void *)v21[2];
  v111 = v22;
  v21[1] = 0LL;
  v21[2] = 0LL;
  *v21 = 0LL;
  if ( (v130 & 1) != 0 )
    operator delete(v131);
  if ( (v110[0] & 1) != 0 )
    operator delete((void *)v110[2]);
  if ( (v111 & 1) != 0 )
    v23 = (const char *)v112;
  else
    v23 = (char *)&v111 + 1;
  v24 = open(v23, 1);
  if ( (v24 & 0x80000000) == 0 )
  {
    v25 = ioctl(v24, 0x5514uLL, 0LL);
    if ( (v25 & 0x80000000) == 0 )
    {
      if ( (word_2A128 & 1) != 0 )
        v26 = (const char *)qword_2A138;
      else
        v26 = (char *)&word_2A128 + 1;
      v99 = dword_2A120;
      v101 = 0LL;
      v102 = 0LL;
      v100 = 0LL;
      v27 = strlen(v26);
      if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v28 = v27;
      if ( v27 >= 0x17 )
      {
        v49 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v29 = (char *)operator new(v49);
        v101 = v28;
        v102 = v29;
        v100 = v49 | 1;
      }
      else
      {
        v29 = (char *)&v100 + 1;
        LOBYTE(v100) = 2 * v27;
        if ( !v27 )
        {
LABEL_88:
          v29[v28] = 0;
          if ( (g3::logLevel(&v99) & 1) == 0 )
          {
            v54 = 0;
            if ( (v100 & 1) == 0 )
              goto LABEL_120;
            goto LABEL_94;
          }
          v97 = 0LL;
          v98 = 0LL;
          v96 = 0LL;
          v50 = TAG;
          v51 = strlen((const char *)TAG);
          if ( v51 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v52 = v51;
          if ( v51 >= 0x17 )
          {
            v67 = (v51 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v53 = (char *)operator new(v67);
            v97 = v52;
            v98 = v53;
            v96 = v67 | 1;
          }
          else
          {
            v53 = (char *)&v96 + 1;
            LOBYTE(v96) = 2 * v51;
            if ( !v51 )
            {
LABEL_118:
              v53[v52] = 0;
              v54 = g3::logTag(&v96);
              if ( (v96 & 1) != 0 )
              {
                operator delete(v98);
                if ( (v100 & 1) == 0 )
                {
LABEL_120:
                  if ( (v54 & 1) == 0 )
                    goto LABEL_147;
                  goto LABEL_121;
                }
              }
              else if ( (v100 & 1) == 0 )
              {
                goto LABEL_120;
              }
LABEL_94:
              operator delete(v102);
              if ( (v54 & 1) == 0 )
                goto LABEL_147;
LABEL_121:
              LogCapture::LogCapture((LogCapture *)&v130, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
              LogCapture::capturef((LogCapture *)&v130, "reset success");
LABEL_146:
              LogCapture::~LogCapture((LogCapture *)&v130);
LABEL_147:
              if ( (word_2A128 & 1) != 0 )
                v71 = (const char *)qword_2A138;
              else
                v71 = (char *)&word_2A128 + 1;
              v85 = dword_2A120;
              v87 = 0LL;
              v88 = 0LL;
              v86 = 0LL;
              v72 = strlen(v71);
              if ( v72 >= 0xFFFFFFFFFFFFFFF0LL )
                std::__basic_string_common<true>::__throw_length_error();
              v73 = v72;
              if ( v72 >= 0x17 )
              {
                v75 = (v72 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                v74 = (char *)operator new(v75);
                v87 = v73;
                v88 = v74;
                v86 = v75 | 1;
              }
              else
              {
                v74 = (char *)&v86 + 1;
                LOBYTE(v86) = 2 * v72;
                if ( !v72 )
                {
LABEL_156:
                  v74[v73] = 0;
                  if ( (g3::logLevel(&v85) & 1) == 0 )
                  {
                    v80 = 0;
                    if ( (v86 & 1) == 0 )
                      goto LABEL_168;
                    goto LABEL_162;
                  }
                  v83 = 0LL;
                  v84 = 0LL;
                  v82 = 0LL;
                  v76 = TAG;
                  v77 = strlen((const char *)TAG);
                  if ( v77 >= 0xFFFFFFFFFFFFFFF0LL )
                    std::__basic_string_common<true>::__throw_length_error();
                  v78 = v77;
                  if ( v77 >= 0x17 )
                  {
                    v81 = (v77 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                    v79 = (char *)operator new(v81);
                    v83 = v78;
                    v84 = v79;
                    v82 = v81 | 1;
                  }
                  else
                  {
                    v79 = (char *)&v82 + 1;
                    LOBYTE(v82) = 2 * v77;
                    if ( !v77 )
                    {
LABEL_166:
                      v79[v78] = 0;
                      v80 = g3::logTag(&v82);
                      if ( (v82 & 1) != 0 )
                      {
                        operator delete(v84);
                        if ( (v86 & 1) == 0 )
                        {
LABEL_168:
                          if ( (v80 & 1) != 0 )
                          {
LABEL_169:
                            LogCapture::LogCapture(
                              (LogCapture *)&v130,
                              (const char *)TAG,
                              (const LEVELS *)&dword_2A120,
                              "",
                              6,
                              0LL);
                            LogCapture::capturef((LogCapture *)&v130, "ioctl ret:%d", v25);
                            LogCapture::~LogCapture((LogCapture *)&v130);
                          }
LABEL_170:
                          close(v24);
LABEL_171:
                          if ( (v111 & 1) == 0 )
                            goto LABEL_172;
LABEL_133:
                          operator delete(v112);
                          if ( (v113 & 1) == 0 )
                            goto LABEL_173;
LABEL_134:
                          operator delete(v114);
                          if ( (v115 & 1) == 0 )
                            goto LABEL_174;
LABEL_135:
                          operator delete(v116);
                          if ( (v117 & 1) == 0 )
                            goto LABEL_175;
                          goto LABEL_136;
                        }
                      }
                      else if ( (v86 & 1) == 0 )
                      {
                        goto LABEL_168;
                      }
LABEL_162:
                      operator delete(v88);
                      if ( (v80 & 1) != 0 )
                        goto LABEL_169;
                      goto LABEL_170;
                    }
                  }
                  memcpy(v79, v76, v78);
                  goto LABEL_166;
                }
              }
              memcpy(v74, v71, v73);
              goto LABEL_156;
            }
          }
          memcpy(v53, v50, v52);
          goto LABEL_118;
        }
      }
      memcpy(v29, v26, v28);
      goto LABEL_88;
    }
    if ( (word_2A188 & 1) != 0 )
      v45 = (const char *)qword_2A198;
    else
      v45 = (char *)&word_2A188 + 1;
    v92 = dword_2A180;
    v94 = 0LL;
    v95 = 0LL;
    v93 = 0LL;
    v46 = strlen(v45);
    if ( v46 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v47 = v46;
    if ( v46 >= 0x17 )
    {
      v61 = (v46 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v48 = (char *)operator new(v61);
      v94 = v47;
      v95 = v48;
      v93 = v61 | 1;
    }
    else
    {
      v48 = (char *)&v93 + 1;
      LOBYTE(v93) = 2 * v46;
      if ( !v46 )
      {
LABEL_108:
        v48[v47] = 0;
        if ( (g3::logLevel(&v92) & 1) == 0 )
        {
          v66 = 0;
          if ( (v93 & 1) == 0 )
            goto LABEL_144;
          goto LABEL_114;
        }
        v90 = 0LL;
        v91 = 0LL;
        v89 = 0LL;
        v62 = TAG;
        v63 = strlen((const char *)TAG);
        if ( v63 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v64 = v63;
        if ( v63 >= 0x17 )
        {
          v70 = (v63 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v65 = (char *)operator new(v70);
          v90 = v64;
          v91 = v65;
          v89 = v70 | 1;
        }
        else
        {
          v65 = (char *)&v89 + 1;
          LOBYTE(v89) = 2 * v63;
          if ( !v63 )
          {
LABEL_142:
            v65[v64] = 0;
            v66 = g3::logTag(&v89);
            if ( (v89 & 1) != 0 )
            {
              operator delete(v91);
              if ( (v93 & 1) == 0 )
              {
LABEL_144:
                if ( (v66 & 1) == 0 )
                  goto LABEL_147;
                goto LABEL_145;
              }
            }
            else if ( (v93 & 1) == 0 )
            {
              goto LABEL_144;
            }
LABEL_114:
            operator delete(v95);
            if ( (v66 & 1) == 0 )
              goto LABEL_147;
LABEL_145:
            LogCapture::LogCapture((LogCapture *)&v130, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)&v130, "reset fail");
            goto LABEL_146;
          }
        }
        memcpy(v65, v62, v64);
        goto LABEL_142;
      }
    }
    memcpy(v48, v45, v47);
    goto LABEL_108;
  }
  if ( (word_2A188 & 1) != 0 )
    v40 = (const char *)qword_2A198;
  else
    v40 = (char *)&word_2A188 + 1;
  v106 = dword_2A180;
  v108 = 0LL;
  v109 = 0LL;
  v107 = 0LL;
  v41 = strlen(v40);
  if ( v41 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v42 = v41;
  if ( v41 >= 0x17 )
  {
    v55 = (v41 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v43 = (char *)operator new(v55);
    v108 = v42;
    v109 = v43;
    v107 = v55 | 1;
    goto LABEL_97;
  }
  v43 = (char *)&v107 + 1;
  LOBYTE(v107) = 2 * v41;
  if ( v41 )
LABEL_97:
    memcpy(v43, v40, v42);
  v43[v42] = 0;
  if ( (g3::logLevel(&v106) & 1) == 0 )
  {
    v60 = 0;
    if ( (v107 & 1) == 0 )
      goto LABEL_128;
    goto LABEL_104;
  }
  v104 = 0LL;
  v105 = 0LL;
  v103 = 0LL;
  v56 = TAG;
  v57 = strlen((const char *)TAG);
  if ( v57 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v58 = v57;
  if ( v57 >= 0x17 )
  {
    v68 = (v57 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v59 = (char *)operator new(v68);
    v104 = v58;
    v105 = v59;
    v103 = v68 | 1;
    goto LABEL_125;
  }
  v59 = (char *)&v103 + 1;
  LOBYTE(v103) = 2 * v57;
  if ( v57 )
LABEL_125:
    memcpy(v59, v56, v58);
  v59[v58] = 0;
  v60 = g3::logTag(&v103);
  if ( (v103 & 1) == 0 )
  {
    if ( (v107 & 1) == 0 )
      goto LABEL_128;
LABEL_104:
    operator delete(v109);
    if ( (v60 & 1) == 0 )
      goto LABEL_171;
    goto LABEL_129;
  }
  operator delete(v105);
  if ( (v107 & 1) != 0 )
    goto LABEL_104;
LABEL_128:
  if ( (v60 & 1) == 0 )
    goto LABEL_171;
LABEL_129:
  LogCapture::LogCapture((LogCapture *)&v130, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
  if ( (v111 & 1) != 0 )
    v69 = (const char *)v112;
  else
    v69 = (char *)&v111 + 1;
  LogCapture::capturef((LogCapture *)&v130, "open device %s fail", v69);
  LogCapture::~LogCapture((LogCapture *)&v130);
  if ( (v111 & 1) != 0 )
    goto LABEL_133;
LABEL_172:
  if ( (v113 & 1) != 0 )
    goto LABEL_134;
LABEL_173:
  if ( (v115 & 1) != 0 )
    goto LABEL_135;
LABEL_174:
  if ( (v117 & 1) == 0 )
  {
LABEL_175:
    if ( (v120 & 1) == 0 )
      return;
    goto LABEL_176;
  }
LABEL_136:
  operator delete(v119);
  if ( (v120 & 1) == 0 )
    return;
LABEL_176:
  operator delete(v122);
}
// B064: variable 'v4' is possibly undefined
// B070: variable 'v6' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (000000000000BE30) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::blockReOpen(pudutech::ESP32 *this)
{
  __int64 result; // x0
  int v3; // w8
  const char *v4; // x26
  size_t v5; // x0
  size_t v6; // x25
  char *v7; // x0
  unsigned __int64 v8; // x27
  char *v9; // x27
  void *v10; // x25
  size_t v11; // x0
  size_t v12; // x8
  char *v13; // x26
  char v14; // w25
  __int64 v15; // x20
  unsigned __int64 v16; // x27
  const void *v17; // x1
  size_t v18; // x25
  int v19; // w25
  unsigned __int64 v20; // [xsp+10h] [xbp-1E0h] BYREF
  __int64 v21; // [xsp+18h] [xbp-1D8h]
  void *v22; // [xsp+20h] [xbp-1D0h]
  int v23; // [xsp+28h] [xbp-1C8h] BYREF
  unsigned __int64 v24; // [xsp+30h] [xbp-1C0h] BYREF
  size_t v25; // [xsp+38h] [xbp-1B8h]
  void *v26; // [xsp+40h] [xbp-1B0h]
  __int64 v27; // [xsp+48h] [xbp-1A8h] BYREF
  _QWORD v28[42]; // [xsp+50h] [xbp-1A0h] BYREF

  v28[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *((int *)this + 6) >= 2 )
    *((_BYTE *)this + 1) = 0;
  result = close(*((_DWORD *)this + 1));
  v3 = *(unsigned __int8 *)this;
  *((_DWORD *)this + 1) = -1;
  if ( v3 )
  {
    v27 = 50000000LL;
    result = std::this_thread::sleep_for(&v27);
    if ( *(_BYTE *)this )
    {
      v27 = 50000000LL;
      result = std::this_thread::sleep_for(&v27);
      if ( *(_BYTE *)this )
      {
        v27 = 50000000LL;
        result = std::this_thread::sleep_for(&v27);
        if ( *(_BYTE *)this )
        {
          v27 = 50000000LL;
          result = std::this_thread::sleep_for(&v27);
          if ( *(_BYTE *)this )
          {
            v27 = 50000000LL;
            result = std::this_thread::sleep_for(&v27);
            if ( *(_BYTE *)this )
            {
              v27 = 50000000LL;
              result = std::this_thread::sleep_for(&v27);
              if ( *(_BYTE *)this )
              {
                v27 = 50000000LL;
                result = std::this_thread::sleep_for(&v27);
                if ( *(_BYTE *)this )
                {
                  v27 = 50000000LL;
                  result = std::this_thread::sleep_for(&v27);
                  if ( *(_BYTE *)this )
                  {
                    v27 = 50000000LL;
                    result = std::this_thread::sleep_for(&v27);
                    if ( *(_BYTE *)this )
                    {
                      v27 = 50000000LL;
                      result = std::this_thread::sleep_for(&v27);
                      if ( *(_BYTE *)this )
                      {
                        v27 = 50000000LL;
                        result = std::this_thread::sleep_for(&v27);
                        if ( *(_BYTE *)this )
                        {
                          v27 = 50000000LL;
                          result = std::this_thread::sleep_for(&v27);
                          if ( *(_BYTE *)this )
                          {
                            v27 = 50000000LL;
                            result = std::this_thread::sleep_for(&v27);
                            if ( *(_BYTE *)this )
                            {
                              v27 = 50000000LL;
                              result = std::this_thread::sleep_for(&v27);
                              if ( *(_BYTE *)this )
                              {
                                v27 = 50000000LL;
                                result = std::this_thread::sleep_for(&v27);
                                if ( *(_BYTE *)this )
                                {
                                  v27 = 50000000LL;
                                  result = std::this_thread::sleep_for(&v27);
                                  if ( *(_BYTE *)this )
                                  {
                                    v27 = 50000000LL;
                                    result = std::this_thread::sleep_for(&v27);
                                    if ( *(_BYTE *)this )
                                    {
                                      v27 = 50000000LL;
                                      result = std::this_thread::sleep_for(&v27);
                                      if ( *(_BYTE *)this )
                                      {
                                        v27 = 50000000LL;
                                        result = std::this_thread::sleep_for(&v27);
                                        if ( *(_BYTE *)this )
                                        {
                                          v27 = 50000000LL;
                                          result = std::this_thread::sleep_for(&v27);
                                          if ( *(_BYTE *)this )
                                          {
                                            v27 = 50000000LL;
                                            result = std::this_thread::sleep_for(&v27);
                                            if ( *(_BYTE *)this )
                                            {
                                              while ( 1 )
                                              {
                                                if ( (word_2A128 & 1) != 0 )
                                                  v4 = (const char *)qword_2A138;
                                                else
                                                  v4 = (char *)&word_2A128 + 1;
                                                v23 = dword_2A120;
                                                v24 = 0LL;
                                                v25 = 0LL;
                                                v26 = 0LL;
                                                v5 = strlen(v4);
                                                if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
                                                  std::__basic_string_common<true>::__throw_length_error();
                                                v6 = v5;
                                                if ( v5 >= 0x17 )
                                                  break;
                                                v7 = (char *)&v24 + 1;
                                                LOBYTE(v24) = 2 * v6;
                                                if ( v6 )
                                                  goto LABEL_33;
LABEL_34:
                                                v7[v6] = 0;
                                                if ( (g3::logLevel(&v23) & 1) == 0 )
                                                {
                                                  v14 = 0;
                                                  if ( (v24 & 1) != 0 )
                                                    goto LABEL_48;
                                                  goto LABEL_45;
                                                }
                                                v21 = 0LL;
                                                v22 = 0LL;
                                                v20 = 0LL;
                                                v10 = TAG;
                                                v11 = strlen((const char *)TAG);
                                                if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
                                                  std::__basic_string_common<true>::__throw_length_error();
                                                v12 = v11;
                                                if ( v11 >= 0x17 )
                                                {
                                                  v15 = v11;
                                                  v16 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                                                  v13 = (char *)operator new(v16);
                                                  v21 = v15;
                                                  v22 = v13;
                                                  v20 = v16 | 1;
                                                  v12 = v15;
LABEL_42:
                                                  v17 = v10;
                                                  v18 = v12;
                                                  memcpy(v13, v17, v12);
                                                  v12 = v18;
                                                  goto LABEL_43;
                                                }
                                                v13 = (char *)&v20 + 1;
                                                LOBYTE(v20) = 2 * v11;
                                                if ( v11 )
                                                  goto LABEL_42;
LABEL_43:
                                                v13[v12] = 0;
                                                v14 = g3::logTag(&v20);
                                                if ( (v20 & 1) != 0 )
                                                {
                                                  operator delete(v22);
                                                  if ( (v24 & 1) != 0 )
                                                  {
LABEL_48:
                                                    operator delete(v26);
                                                    if ( (v14 & 1) == 0 )
                                                      goto LABEL_50;
LABEL_49:
                                                    LogCapture::LogCapture(
                                                      (LogCapture *)&v27,
                                                      (const char *)TAG,
                                                      (const LEVELS *)&dword_2A120,
                                                      "",
                                                      6,
                                                      0LL);
                                                    std::__put_character_sequence<char,std::char_traits<char>>(
                                                      v28,
                                                      (__int64)"block reopen ESP",
                                                      16LL);
                                                    LogCapture::~LogCapture((LogCapture *)&v27);
                                                    goto LABEL_50;
                                                  }
                                                }
                                                else if ( (v24 & 1) != 0 )
                                                {
                                                  goto LABEL_48;
                                                }
LABEL_45:
                                                if ( (v14 & 1) != 0 )
                                                  goto LABEL_49;
LABEL_50:
                                                if ( (pudutech::ESP32::openDev(this) & 1) != 0 )
                                                {
                                                  if ( *(_BYTE *)this )
                                                  {
                                                    v27 = 50000000LL;
                                                    std::this_thread::sleep_for(&v27);
                                                    if ( *(_BYTE *)this )
                                                    {
                                                      v27 = 50000000LL;
                                                      std::this_thread::sleep_for(&v27);
                                                      if ( *(_BYTE *)this )
                                                      {
                                                        v27 = 50000000LL;
                                                        std::this_thread::sleep_for(&v27);
                                                        if ( *(_BYTE *)this )
                                                        {
                                                          v27 = 50000000LL;
                                                          std::this_thread::sleep_for(&v27);
                                                          if ( *(_BYTE *)this )
                                                          {
                                                            v27 = 50000000LL;
                                                            std::this_thread::sleep_for(&v27);
                                                            if ( *(_BYTE *)this )
                                                            {
                                                              v27 = 50000000LL;
                                                              std::this_thread::sleep_for(&v27);
                                                              if ( *(_BYTE *)this )
                                                              {
                                                                v27 = 50000000LL;
                                                                std::this_thread::sleep_for(&v27);
                                                                if ( *(_BYTE *)this )
                                                                {
                                                                  v27 = 50000000LL;
                                                                  std::this_thread::sleep_for(&v27);
                                                                  if ( *(_BYTE *)this )
                                                                  {
                                                                    v27 = 50000000LL;
                                                                    std::this_thread::sleep_for(&v27);
                                                                    if ( *(_BYTE *)this )
                                                                    {
                                                                      v27 = 50000000LL;
                                                                      std::this_thread::sleep_for(&v27);
                                                                      if ( *(_BYTE *)this )
                                                                      {
                                                                        v27 = 50000000LL;
                                                                        std::this_thread::sleep_for(&v27);
                                                                        if ( *(_BYTE *)this )
                                                                        {
                                                                          v27 = 50000000LL;
                                                                          std::this_thread::sleep_for(&v27);
                                                                          if ( *(_BYTE *)this )
                                                                          {
                                                                            v27 = 50000000LL;
                                                                            std::this_thread::sleep_for(&v27);
                                                                            if ( *(_BYTE *)this )
                                                                            {
                                                                              v27 = 50000000LL;
                                                                              std::this_thread::sleep_for(&v27);
                                                                              if ( *(_BYTE *)this )
                                                                              {
                                                                                v27 = 50000000LL;
                                                                                std::this_thread::sleep_for(&v27);
                                                                                if ( *(_BYTE *)this )
                                                                                {
                                                                                  v27 = 50000000LL;
                                                                                  std::this_thread::sleep_for(&v27);
                                                                                  if ( *(_BYTE *)this )
                                                                                  {
                                                                                    v27 = 50000000LL;
                                                                                    std::this_thread::sleep_for(&v27);
                                                                                    if ( *(_BYTE *)this )
                                                                                    {
                                                                                      v27 = 50000000LL;
                                                                                      std::this_thread::sleep_for(&v27);
                                                                                      if ( *(_BYTE *)this )
                                                                                      {
                                                                                        v27 = 50000000LL;
                                                                                        std::this_thread::sleep_for(&v27);
                                                                                        if ( *(_BYTE *)this )
                                                                                        {
                                                                                          v27 = 50000000LL;
                                                                                          std::this_thread::sleep_for(&v27);
                                                                                          if ( *(_BYTE *)this )
                                                                                          {
                                                                                            v27 = 50000000LL;
                                                                                            std::this_thread::sleep_for(&v27);
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
LABEL_78:
                                                  result = pudutech::ESP32::checkHardwareHandshake(this);
                                                  if ( (result & 1) != 0 )
                                                    return result;
                                                  goto LABEL_79;
                                                }
                                                if ( !*(_BYTE *)this )
                                                  goto LABEL_78;
                                                v19 = -1;
                                                while ( 1 )
                                                {
                                                  v27 = 50000000LL;
                                                  result = std::this_thread::sleep_for(&v27);
                                                  if ( (unsigned int)++v19 >= 0x28 )
                                                    break;
                                                  if ( !*(_BYTE *)this )
                                                    return result;
                                                }
LABEL_79:
                                                if ( !*(_BYTE *)this )
                                                  return result;
                                              }
                                              v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                                              v7 = (char *)operator new(v8);
                                              v25 = v6;
                                              v26 = v7;
                                              v24 = v8 | 1;
LABEL_33:
                                              v9 = v7;
                                              memcpy(v7, v4, v6);
                                              v7 = v9;
                                              goto LABEL_34;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 7A80: using guessed type __int64 __fastcall std::this_thread::sleep_for(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;

//----- (000000000000C4AC) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::sendMsg(__int64 a1, char **a2, char a3)
{
  __int64 v3; // x27
  const char *v4; // x21
  size_t v5; // x0
  size_t v6; // x19
  char *v7; // x22
  const char *v9; // x25
  size_t v12; // x0
  size_t v13; // x19
  char *v14; // x26
  unsigned __int64 v15; // x23
  const void *v16; // x19
  size_t v17; // x0
  size_t v18; // x21
  char *v19; // x22
  char v20; // w19
  const char *v21; // x20
  size_t v22; // x0
  size_t v23; // x19
  char *v24; // x21
  unsigned __int64 v25; // x27
  const void *v26; // x19
  size_t v27; // x0
  size_t v28; // x25
  char *v29; // x26
  char v30; // w19
  unsigned __int64 v31; // x23
  unsigned __int64 v32; // x22
  const void *v33; // x19
  size_t v34; // x0
  size_t v35; // x20
  char *v36; // x21
  char v37; // w19
  unsigned int v38; // w20
  unsigned __int64 v39; // x27
  _QWORD *v40; // x0
  __int64 v41; // x27
  __int16 v42; // w8
  char v43; // w8
  __int16 v44; // w0
  __int64 v45; // x8
  int v46; // w20
  int v47; // w27
  const char *v48; // x19
  size_t v49; // x0
  size_t v50; // x28
  char *v51; // x25
  unsigned __int64 v52; // x26
  const void *v53; // x28
  size_t v54; // x0
  size_t v55; // x19
  char *v56; // x25
  char v57; // w19
  unsigned __int64 v58; // x26
  const char *v59; // x19
  size_t v60; // x0
  size_t v61; // x20
  char *v62; // x21
  __int64 v63; // x24
  int v64; // w20
  __int64 v65; // x25
  int v66; // w0
  unsigned int v67; // w26
  const char *v68; // x27
  size_t v69; // x0
  size_t v70; // x19
  char *v71; // x28
  unsigned __int64 v72; // x24
  const void *v73; // x27
  size_t v74; // x0
  size_t v75; // x19
  char *v76; // x28
  char v77; // w19
  unsigned __int64 v78; // x24
  unsigned __int64 v79; // x22
  const void *v80; // x20
  size_t v81; // x0
  size_t v82; // x21
  char *v83; // x19
  char v84; // w19
  unsigned __int64 v85; // x22
  unsigned __int64 v86; // x22
  const char *v88; // x19
  size_t v89; // x0
  size_t v90; // x20
  char *v91; // x21
  unsigned __int64 v92; // x22
  const void *v93; // x20
  size_t v94; // x0
  size_t v95; // x21
  char *v96; // x19
  char v97; // w19
  unsigned __int64 v98; // x22
  std::mutex *v99; // [xsp+10h] [xbp-350h]
  __int64 v100; // [xsp+18h] [xbp-348h]
  char **v101; // [xsp+20h] [xbp-340h]
  char *dest; // [xsp+28h] [xbp-338h]
  unsigned __int64 v103; // [xsp+30h] [xbp-330h] BYREF
  size_t v104; // [xsp+38h] [xbp-328h]
  void *v105; // [xsp+40h] [xbp-320h]
  int v106; // [xsp+48h] [xbp-318h] BYREF
  unsigned __int64 v107; // [xsp+50h] [xbp-310h] BYREF
  size_t v108; // [xsp+58h] [xbp-308h]
  void *v109; // [xsp+60h] [xbp-300h]
  unsigned __int64 v110; // [xsp+68h] [xbp-2F8h] BYREF
  size_t v111; // [xsp+70h] [xbp-2F0h]
  void *v112; // [xsp+78h] [xbp-2E8h]
  int v113; // [xsp+80h] [xbp-2E0h] BYREF
  unsigned __int64 v114; // [xsp+88h] [xbp-2D8h] BYREF
  size_t v115; // [xsp+90h] [xbp-2D0h]
  void *v116; // [xsp+98h] [xbp-2C8h]
  unsigned __int64 v117; // [xsp+A0h] [xbp-2C0h] BYREF
  size_t v118; // [xsp+A8h] [xbp-2B8h]
  void *v119; // [xsp+B0h] [xbp-2B0h]
  int v120; // [xsp+B8h] [xbp-2A8h] BYREF
  unsigned __int64 v121; // [xsp+C0h] [xbp-2A0h] BYREF
  size_t v122; // [xsp+C8h] [xbp-298h]
  void *v123; // [xsp+D0h] [xbp-290h]
  unsigned __int64 v124; // [xsp+D8h] [xbp-288h] BYREF
  size_t v125; // [xsp+E0h] [xbp-280h]
  void *v126; // [xsp+E8h] [xbp-278h]
  int v127; // [xsp+F0h] [xbp-270h] BYREF
  unsigned __int64 v128; // [xsp+F8h] [xbp-268h] BYREF
  size_t v129; // [xsp+100h] [xbp-260h]
  void *v130; // [xsp+108h] [xbp-258h]
  unsigned __int64 v131; // [xsp+110h] [xbp-250h] BYREF
  size_t v132; // [xsp+118h] [xbp-248h]
  void *v133; // [xsp+120h] [xbp-240h]
  int v134; // [xsp+128h] [xbp-238h] BYREF
  unsigned __int64 v135; // [xsp+130h] [xbp-230h] BYREF
  size_t v136; // [xsp+138h] [xbp-228h]
  void *v137; // [xsp+140h] [xbp-220h]
  unsigned __int64 v138; // [xsp+148h] [xbp-218h] BYREF
  size_t v139; // [xsp+150h] [xbp-210h]
  void *v140; // [xsp+158h] [xbp-208h]
  int v141; // [xsp+160h] [xbp-200h] BYREF
  unsigned __int64 v142; // [xsp+168h] [xbp-1F8h] BYREF
  size_t v143; // [xsp+170h] [xbp-1F0h]
  void *v144; // [xsp+178h] [xbp-1E8h]
  unsigned __int64 v145; // [xsp+180h] [xbp-1E0h] BYREF
  size_t v146; // [xsp+188h] [xbp-1D8h]
  void *v147; // [xsp+190h] [xbp-1D0h]
  int v148; // [xsp+198h] [xbp-1C8h] BYREF
  unsigned __int64 v149; // [xsp+1A0h] [xbp-1C0h] BYREF
  size_t v150; // [xsp+1A8h] [xbp-1B8h]
  void *v151; // [xsp+1B0h] [xbp-1B0h]
  char v152[8]; // [xsp+1B8h] [xbp-1A8h] BYREF
  _QWORD v153[42]; // [xsp+1C0h] [xbp-1A0h] BYREF

  v153[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = a2[1] - *a2;
  if ( (int)v3 >= 239 )
  {
    if ( (word_2A128 & 1) != 0 )
      v4 = (const char *)qword_2A138;
    else
      v4 = (char *)&word_2A128 + 1;
    v148 = dword_2A120;
    v150 = 0LL;
    v151 = 0LL;
    v149 = 0LL;
    v5 = strlen(v4);
    if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v6 = v5;
    if ( v5 >= 0x17 )
    {
      v15 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v7 = (char *)operator new(v15);
      v150 = v6;
      v151 = v7;
      v149 = v15 | 1;
    }
    else
    {
      v7 = (char *)&v149 + 1;
      LOBYTE(v149) = 2 * v5;
      if ( !v5 )
      {
LABEL_19:
        v7[v6] = 0;
        if ( (g3::logLevel(&v148) & 1) == 0 )
        {
          v20 = 0;
          if ( (v149 & 1) == 0 )
            goto LABEL_48;
          goto LABEL_25;
        }
        v146 = 0LL;
        v147 = 0LL;
        v145 = 0LL;
        v16 = TAG;
        v17 = strlen((const char *)TAG);
        if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v18 = v17;
        if ( v17 >= 0x17 )
        {
          v31 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v19 = (char *)operator new(v31);
          v146 = v18;
          v147 = v19;
          v145 = v31 | 1;
        }
        else
        {
          v19 = (char *)&v145 + 1;
          LOBYTE(v145) = 2 * v17;
          if ( !v17 )
          {
LABEL_46:
            v19[v18] = 0;
            v20 = g3::logTag(&v145);
            if ( (v145 & 1) != 0 )
            {
              operator delete(v147);
              if ( (v149 & 1) == 0 )
              {
LABEL_48:
                if ( (v20 & 1) != 0 )
                  goto LABEL_49;
                return (unsigned int)-1;
              }
            }
            else if ( (v149 & 1) == 0 )
            {
              goto LABEL_48;
            }
LABEL_25:
            operator delete(v151);
            if ( (v20 & 1) != 0 )
            {
LABEL_49:
              LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
              LogCapture::capturef((LogCapture *)v152, "msg length is too long: %d", (unsigned int)v3);
LABEL_159:
              LogCapture::~LogCapture((LogCapture *)v152);
              return (unsigned int)-1;
            }
            return (unsigned int)-1;
          }
        }
        memcpy(v19, v16, v18);
        goto LABEL_46;
      }
    }
    memcpy(v7, v4, v6);
    goto LABEL_19;
  }
  if ( *(_DWORD *)(a1 + 4) == -1 )
  {
    if ( (word_2A128 & 1) != 0 )
      v21 = (const char *)qword_2A138;
    else
      v21 = (char *)&word_2A128 + 1;
    v141 = dword_2A120;
    v143 = 0LL;
    v144 = 0LL;
    v142 = 0LL;
    v22 = strlen(v21);
    if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v23 = v22;
    if ( v22 >= 0x17 )
    {
      v32 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v24 = (char *)operator new(v32);
      v143 = v23;
      v144 = v24;
      v142 = v32 | 1;
    }
    else
    {
      v24 = (char *)&v142 + 1;
      LOBYTE(v142) = 2 * v22;
      if ( !v22 )
      {
LABEL_54:
        v24[v23] = 0;
        if ( (g3::logLevel(&v141) & 1) == 0 )
        {
          v37 = 0;
          if ( (v142 & 1) == 0 )
            goto LABEL_157;
          goto LABEL_60;
        }
        v139 = 0LL;
        v140 = 0LL;
        v138 = 0LL;
        v33 = TAG;
        v34 = strlen((const char *)TAG);
        if ( v34 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v35 = v34;
        if ( v34 >= 0x17 )
        {
          v85 = (v34 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v36 = (char *)operator new(v85);
          v139 = v35;
          v140 = v36;
          v138 = v85 | 1;
        }
        else
        {
          v36 = (char *)&v138 + 1;
          LOBYTE(v138) = 2 * v34;
          if ( !v34 )
          {
LABEL_155:
            v36[v35] = 0;
            v37 = g3::logTag(&v138);
            if ( (v138 & 1) != 0 )
            {
              operator delete(v140);
              if ( (v142 & 1) == 0 )
              {
LABEL_157:
                if ( (v37 & 1) == 0 )
                  return (unsigned int)-1;
                goto LABEL_158;
              }
            }
            else if ( (v142 & 1) == 0 )
            {
              goto LABEL_157;
            }
LABEL_60:
            operator delete(v144);
            if ( (v37 & 1) == 0 )
              return (unsigned int)-1;
LABEL_158:
            LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)v152, "esp module not initialized");
            goto LABEL_159;
          }
        }
        memcpy(v36, v33, v35);
        goto LABEL_155;
      }
    }
    memcpy(v24, v21, v23);
    goto LABEL_54;
  }
  if ( (word_2A148 & 1) != 0 )
    v9 = (const char *)qword_2A158;
  else
    v9 = (char *)&word_2A148 + 1;
  v134 = dword_2A140;
  v136 = 0LL;
  v137 = 0LL;
  v135 = 0LL;
  v12 = strlen(v9);
  if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v13 = v12;
  v100 = v3;
  if ( v12 >= 0x17 )
  {
    v25 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v14 = (char *)operator new(v25);
    v136 = v13;
    v137 = v14;
    v135 = v25 | 1;
    goto LABEL_35;
  }
  v14 = (char *)&v135 + 1;
  LOBYTE(v135) = 2 * v12;
  if ( v12 )
LABEL_35:
    memcpy(v14, v9, v13);
  v14[v13] = 0;
  if ( (g3::logLevel(&v134) & 1) == 0 )
  {
    v30 = 0;
    if ( (v135 & 1) == 0 )
      goto LABEL_66;
    goto LABEL_42;
  }
  v132 = 0LL;
  v133 = 0LL;
  v131 = 0LL;
  v26 = TAG;
  v27 = strlen((const char *)TAG);
  if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v28 = v27;
  if ( v27 >= 0x17 )
  {
    v39 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v29 = (char *)operator new(v39);
    v132 = v28;
    v133 = v29;
    v131 = v39 | 1;
    goto LABEL_63;
  }
  v29 = (char *)&v131 + 1;
  LOBYTE(v131) = 2 * v27;
  if ( v27 )
LABEL_63:
    memcpy(v29, v26, v28);
  v29[v28] = 0;
  v30 = g3::logTag(&v131);
  if ( (v131 & 1) == 0 )
  {
    if ( (v135 & 1) == 0 )
      goto LABEL_66;
LABEL_42:
    operator delete(v137);
    if ( (v30 & 1) != 0 )
      goto LABEL_67;
    goto LABEL_68;
  }
  operator delete(v133);
  if ( (v135 & 1) != 0 )
    goto LABEL_42;
LABEL_66:
  if ( (v30 & 1) != 0 )
  {
LABEL_67:
    LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
    v40 = std::__put_character_sequence<char,std::char_traits<char>>(v153, (__int64)"send msg length ", 16LL);
    std::ostream::operator<<(v40);
    LogCapture::~LogCapture((LogCapture *)v152);
  }
LABEL_68:
  v99 = (std::mutex *)(a1 + 328);
  std::mutex::lock((std::mutex *)(a1 + 328));
  v41 = *(_QWORD *)(a1 + 32);
  if ( (a3 & 1) != 0 )
    v42 = 30069;
  else
    v42 = -9510;
  *(_WORD *)(v41 + 4) = v42;
  v101 = a2;
  *(_BYTE *)(v41 + 2) = v100;
  v43 = *(_DWORD *)(a1 + 20);
  *(_WORD *)(v41 + 6) = 0;
  *(_BYTE *)(v41 + 3) = v43;
  v44 = pudutech::ESP32::crc16(
          (pudutech::ESP32 *)v41,
          (unsigned __int8 *)*a2,
          (unsigned __int8 *)(*((_DWORD *)a2 + 2) - (unsigned int)*a2));
  v45 = 0LL;
  v46 = 0;
  *(_WORD *)(v41 + 6) = v44;
  while ( 1 )
  {
    v47 = write(*(_DWORD *)(a1 + 4), (const void *)(v41 + v45), 12 - v45);
    if ( v47 < 1 )
    {
      if ( (word_2A188 & 1) != 0 )
        v59 = (const char *)qword_2A198;
      else
        v59 = (char *)&word_2A188 + 1;
      v127 = dword_2A180;
      v129 = 0LL;
      v130 = 0LL;
      v128 = 0LL;
      v60 = strlen(v59);
      if ( v60 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v61 = v60;
      if ( v60 >= 0x17 )
      {
        v79 = (v60 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v62 = (char *)operator new(v79);
        v129 = v61;
        v130 = v62;
        v128 = v79 | 1;
      }
      else
      {
        v62 = (char *)&v128 + 1;
        LOBYTE(v128) = 2 * v60;
        if ( !v60 )
        {
LABEL_142:
          v62[v61] = 0;
          if ( (g3::logLevel(&v127) & 1) == 0 )
          {
            v84 = 0;
            if ( (v128 & 1) == 0 )
              goto LABEL_166;
            goto LABEL_148;
          }
          v125 = 0LL;
          v126 = 0LL;
          v124 = 0LL;
          v80 = TAG;
          v81 = strlen((const char *)TAG);
          if ( v81 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v82 = v81;
          if ( v81 >= 0x17 )
          {
            v86 = (v81 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v83 = (char *)operator new(v86);
            v125 = v82;
            v126 = v83;
            v124 = v86 | 1;
          }
          else
          {
            v83 = (char *)&v124 + 1;
            LOBYTE(v124) = 2 * v81;
            if ( !v81 )
            {
LABEL_164:
              v83[v82] = 0;
              v84 = g3::logTag(&v124);
              if ( (v124 & 1) != 0 )
              {
                operator delete(v126);
                if ( (v128 & 1) == 0 )
                {
LABEL_166:
                  if ( (v84 & 1) != 0 )
                    goto LABEL_167;
                  goto LABEL_169;
                }
              }
              else if ( (v128 & 1) == 0 )
              {
                goto LABEL_166;
              }
LABEL_148:
              operator delete(v130);
              if ( (v84 & 1) != 0 )
              {
LABEL_167:
                LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
                LogCapture::capturef((LogCapture *)v152, "write failed");
LABEL_168:
                LogCapture::~LogCapture((LogCapture *)v152);
              }
LABEL_169:
              v38 = -1;
              goto LABEL_170;
            }
          }
          memcpy(v83, v80, v82);
          goto LABEL_164;
        }
      }
      memcpy(v62, v59, v61);
      goto LABEL_142;
    }
    if ( (word_2A148 & 1) != 0 )
      v48 = (const char *)qword_2A158;
    else
      v48 = (char *)&word_2A148 + 1;
    v120 = dword_2A140;
    v121 = 0LL;
    v122 = 0LL;
    v123 = 0LL;
    v49 = strlen(v48);
    if ( v49 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v50 = v49;
    if ( v49 >= 0x17 )
    {
      v52 = (v49 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v51 = (char *)operator new(v52);
      v122 = v50;
      v123 = v51;
      v121 = v52 | 1;
LABEL_82:
      memcpy(v51, v48, v50);
      goto LABEL_83;
    }
    v51 = (char *)&v121 + 1;
    LOBYTE(v121) = 2 * v49;
    if ( v49 )
      goto LABEL_82;
LABEL_83:
    v51[v50] = 0;
    if ( (g3::logLevel(&v120) & 1) == 0 )
    {
      v57 = 0;
      if ( (v121 & 1) == 0 )
        goto LABEL_95;
      goto LABEL_89;
    }
    v118 = 0LL;
    v119 = 0LL;
    v117 = 0LL;
    v53 = TAG;
    v54 = strlen((const char *)TAG);
    if ( v54 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v55 = v54;
    if ( v54 >= 0x17 )
    {
      v58 = (v54 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v56 = (char *)operator new(v58);
      v118 = v55;
      v119 = v56;
      v117 = v58 | 1;
LABEL_92:
      memcpy(v56, v53, v55);
      goto LABEL_93;
    }
    v56 = (char *)&v117 + 1;
    LOBYTE(v117) = 2 * v54;
    if ( v54 )
      goto LABEL_92;
LABEL_93:
    v56[v55] = 0;
    v57 = g3::logTag(&v117);
    if ( (v117 & 1) != 0 )
    {
      operator delete(v119);
      if ( (v121 & 1) == 0 )
      {
LABEL_95:
        if ( (v57 & 1) == 0 )
          goto LABEL_97;
        goto LABEL_96;
      }
    }
    else if ( (v121 & 1) == 0 )
    {
      goto LABEL_95;
    }
LABEL_89:
    operator delete(v123);
    if ( (v57 & 1) == 0 )
      goto LABEL_97;
LABEL_96:
    LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v152, "write head length %d", (unsigned int)v47);
    LogCapture::~LogCapture((LogCapture *)v152);
LABEL_97:
    v46 += v47;
    if ( v46 == 12 )
      break;
    v41 = *(_QWORD *)(a1 + 32);
    v45 = v46;
  }
  v63 = v100;
  if ( (int)v100 < 1 )
  {
    v38 = 12;
    goto LABEL_170;
  }
  v64 = 0;
  dest = *v101;
  while ( 2 )
  {
    v65 = v63;
    v66 = write(*(_DWORD *)(a1 + 4), &dest[v64], (int)v63 - v64);
    v67 = v66;
    if ( v66 < 1 )
    {
      if ( (v66 & 0x80000000) == 0 )
        goto LABEL_136;
      if ( (word_2A188 & 1) != 0 )
        v88 = (const char *)qword_2A198;
      else
        v88 = (char *)&word_2A188 + 1;
      v106 = dword_2A180;
      v108 = 0LL;
      v109 = 0LL;
      v107 = 0LL;
      v89 = strlen(v88);
      if ( v89 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v90 = v89;
      if ( v89 >= 0x17 )
      {
        v92 = (v89 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v91 = (char *)operator new(v92);
        v108 = v90;
        v109 = v91;
        v107 = v92 | 1;
      }
      else
      {
        v91 = (char *)&v107 + 1;
        LOBYTE(v107) = 2 * v89;
        if ( !v89 )
        {
LABEL_183:
          v91[v90] = 0;
          if ( (g3::logLevel(&v106) & 1) == 0 )
          {
            v97 = 0;
            if ( (v107 & 1) == 0 )
              goto LABEL_195;
            goto LABEL_189;
          }
          v104 = 0LL;
          v105 = 0LL;
          v103 = 0LL;
          v93 = TAG;
          v94 = strlen((const char *)TAG);
          if ( v94 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v95 = v94;
          if ( v94 >= 0x17 )
          {
            v98 = (v94 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v96 = (char *)operator new(v98);
            v104 = v95;
            v105 = v96;
            v103 = v98 | 1;
          }
          else
          {
            v96 = (char *)&v103 + 1;
            LOBYTE(v103) = 2 * v94;
            if ( !v94 )
            {
LABEL_193:
              v96[v95] = 0;
              v97 = g3::logTag(&v103);
              if ( (v103 & 1) != 0 )
              {
                operator delete(v105);
                if ( (v107 & 1) == 0 )
                {
LABEL_195:
                  if ( (v97 & 1) == 0 )
                    goto LABEL_169;
                  goto LABEL_196;
                }
              }
              else if ( (v107 & 1) == 0 )
              {
                goto LABEL_195;
              }
LABEL_189:
              operator delete(v109);
              if ( (v97 & 1) == 0 )
                goto LABEL_169;
LABEL_196:
              LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
              LogCapture::capturef((LogCapture *)v152, "write failed");
              goto LABEL_168;
            }
          }
          memcpy(v96, v93, v95);
          goto LABEL_193;
        }
      }
      memcpy(v91, v88, v90);
      goto LABEL_183;
    }
    if ( (word_2A148 & 1) != 0 )
      v68 = (const char *)qword_2A158;
    else
      v68 = (char *)&word_2A148 + 1;
    v113 = dword_2A140;
    v114 = 0LL;
    v115 = 0LL;
    v116 = 0LL;
    v69 = strlen(v68);
    if ( v69 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v70 = v69;
    if ( v69 >= 0x17 )
    {
      v72 = (v69 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v71 = (char *)operator new(v72);
      v115 = v70;
      v116 = v71;
      v114 = v72 | 1;
      goto LABEL_121;
    }
    v71 = (char *)&v114 + 1;
    LOBYTE(v114) = 2 * v69;
    if ( v69 )
LABEL_121:
      memcpy(v71, v68, v70);
    v71[v70] = 0;
    if ( (g3::logLevel(&v113) & 1) != 0 )
    {
      v111 = 0LL;
      v112 = 0LL;
      v110 = 0LL;
      v73 = TAG;
      v74 = strlen((const char *)TAG);
      if ( v74 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v75 = v74;
      if ( v74 >= 0x17 )
      {
        v78 = (v74 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v76 = (char *)operator new(v78);
        v111 = v75;
        v112 = v76;
        v110 = v78 | 1;
      }
      else
      {
        v76 = (char *)&v110 + 1;
        LOBYTE(v110) = 2 * v74;
        if ( !v74 )
          goto LABEL_130;
      }
      memcpy(v76, v73, v75);
LABEL_130:
      v76[v75] = 0;
      v77 = g3::logTag(&v110);
      v63 = v65;
      if ( (v110 & 1) != 0 )
        operator delete(v112);
    }
    else
    {
      v77 = 0;
      v63 = v65;
    }
    v64 += v67;
    if ( (v114 & 1) != 0 )
      operator delete(v116);
    if ( (v77 & 1) != 0 )
    {
      LogCapture::LogCapture((LogCapture *)v152, (const char *)TAG, (const LEVELS *)&dword_2A140, "", 6, 0LL);
      LogCapture::capturef((LogCapture *)v152, "write msg length %d", v67);
      LogCapture::~LogCapture((LogCapture *)v152);
    }
LABEL_136:
    if ( v64 < (int)v63 )
      continue;
    break;
  }
  if ( v64 == -1 )
    v38 = -1;
  else
    v38 = v64 + 12;
LABEL_170:
  std::mutex::unlock(v99);
  return v38;
}
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A140: using guessed type int dword_2A140;
// 2A148: using guessed type __int16 word_2A148;
// 2A158: using guessed type __int64 qword_2A158;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;
// C4AC: using guessed type char var_1A8[8];

//----- (000000000000D504) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 48LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// D504: using guessed type char var_60[8];

//----- (000000000000D6D0) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::crc16(pudutech::ESP32 *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  __int64 v3; // x9
  unsigned int v4; // w8
  __int16 v5; // w11
  __int16 v6; // w8
  __int16 v7; // w11
  bool v8; // zf
  __int16 v9; // w8
  __int16 v10; // w11
  __int16 v11; // w8
  __int16 v12; // w11
  __int16 v13; // w8
  __int16 v14; // w11
  __int16 v15; // w8
  __int16 v16; // w11
  __int16 v17; // w8
  __int16 v18; // w11
  __int16 v19; // w8
  unsigned __int16 v20; // w11
  unsigned __int16 v21; // w8
  int v22; // w11
  __int16 v23; // t1
  __int16 v24; // w8
  __int16 v25; // w10
  __int16 v26; // w8
  __int16 v27; // w10
  __int16 v28; // w8
  __int16 v29; // w10
  __int16 v30; // w8
  __int16 v31; // w10
  __int16 v32; // w8
  __int16 v33; // w10
  __int16 v34; // w8
  __int16 v35; // w10
  __int16 v36; // w8
  unsigned __int16 v37; // w10
  unsigned __int16 v38; // w8

  v3 = 0LL;
  LOWORD(v4) = -1;
  do
  {
    v5 = *((unsigned __int8 *)this + v3++);
    v6 = v4 ^ (v5 << 8);
    v7 = 2 * v6;
    v8 = (v6 & 0x8000) == 0;
    v9 = (2 * v6) ^ 0x1021;
    if ( v8 )
      v9 = v7;
    v10 = 2 * v9;
    v8 = (v9 & 0x8000) == 0;
    v11 = (2 * v9) ^ 0x1021;
    if ( v8 )
      v11 = v10;
    v12 = 2 * v11;
    v8 = (v11 & 0x8000) == 0;
    v13 = (2 * v11) ^ 0x1021;
    if ( v8 )
      v13 = v12;
    v14 = 2 * v13;
    v8 = (v13 & 0x8000) == 0;
    v15 = (2 * v13) ^ 0x1021;
    if ( v8 )
      v15 = v14;
    v16 = 2 * v15;
    v8 = (v15 & 0x8000) == 0;
    v17 = (2 * v15) ^ 0x1021;
    if ( v8 )
      v17 = v16;
    v18 = 2 * v17;
    v8 = (v17 & 0x8000) == 0;
    v19 = (2 * v17) ^ 0x1021;
    if ( v8 )
      v19 = v18;
    v20 = 2 * v19;
    v8 = (v19 & 0x8000) == 0;
    v21 = (2 * v19) ^ 0x1021;
    if ( v8 )
      v21 = v20;
    v22 = 2 * v21;
    v8 = (v21 & 0x8000) == 0;
    v4 = v22 ^ 0x1021;
    if ( v8 )
      v4 = v22;
  }
  while ( (_DWORD)v3 != 12 );
  while ( (_DWORD)a3 )
  {
    v23 = *a2++;
    LODWORD(a3) = (_DWORD)a3 - 1;
    v24 = v4 ^ (v23 << 8);
    v25 = 2 * v24;
    v8 = (v24 & 0x8000) == 0;
    v26 = (2 * v24) ^ 0x1021;
    if ( v8 )
      v26 = v25;
    v27 = 2 * v26;
    v8 = (v26 & 0x8000) == 0;
    v28 = (2 * v26) ^ 0x1021;
    if ( v8 )
      v28 = v27;
    v29 = 2 * v28;
    v8 = (v28 & 0x8000) == 0;
    v30 = (2 * v28) ^ 0x1021;
    if ( v8 )
      v30 = v29;
    v31 = 2 * v30;
    v8 = (v30 & 0x8000) == 0;
    v32 = (2 * v30) ^ 0x1021;
    if ( v8 )
      v32 = v31;
    v33 = 2 * v32;
    v8 = (v32 & 0x8000) == 0;
    v34 = (2 * v32) ^ 0x1021;
    if ( v8 )
      v34 = v33;
    v35 = 2 * v34;
    v8 = (v34 & 0x8000) == 0;
    v36 = (2 * v34) ^ 0x1021;
    if ( v8 )
      v36 = v35;
    v37 = 2 * v36;
    v8 = (v36 & 0x8000) == 0;
    v38 = (2 * v36) ^ 0x1021;
    if ( v8 )
      v38 = v37;
    if ( (v38 & 0x8000) != 0 )
      v4 = (2 * v38) ^ 0x1021;
    else
      v4 = 2 * v38;
  }
  return v4;
}

//----- (000000000000D810) ----------------------------------------------------
bool __fastcall pudutech::ESP32::hasHardwareResponsed(pudutech::ESP32 *this)
{
  return *((int *)this + 6) < 2 || *((_BYTE *)this + 1) != 0;
}

//----- (000000000000D834) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::getEspFirmwareVersion(pudutech::ESP32 *this)
{
  if ( *((int *)this + 6) < 2 )
    return 0LL;
  else
    return *((unsigned int *)this + 7);
}

//----- (000000000000D850) ----------------------------------------------------
bool __fastcall pudutech::ESP32::connectStatus(pudutech::ESP32 *this)
{
  return *((_DWORD *)this + 1) != -1;
}

//----- (000000000000D860) ----------------------------------------------------
bool __fastcall pudutech::ESP32::checkHardwareHandshake(pudutech::ESP32 *this)
{
  pudutech::ESP32 *v1; // x19
  _BOOL8 result; // x0
  pthread_t *v3; // x20
  std::__thread_struct *v4; // x22
  std::__thread_struct **v5; // x0
  std::__ndk1 *v6; // x0
  const char *v7; // x2
  std::thread *v8; // x21
  __int64 v9; // x0
  unsigned int v10; // w0
  const char *v11; // x23
  unsigned int v12; // w20
  size_t v13; // x0
  size_t v14; // x21
  char *v15; // x24
  unsigned __int64 v16; // x25
  const void *v17; // x21
  size_t v18; // x0
  size_t v19; // x24
  char *v20; // x23
  char v21; // w21
  unsigned __int64 v22; // x27
  std::chrono::steady_clock *v23; // x21
  char v24; // w8
  const char *v25; // x24
  size_t v26; // x0
  size_t v27; // x23
  char *v28; // x27
  unsigned __int64 v29; // x25
  const void *v30; // x24
  size_t v31; // x0
  size_t v32; // x23
  char *v33; // x27
  char v34; // w23
  unsigned __int64 v35; // x25
  unsigned int v36; // w23
  const char *v37; // x23
  size_t v38; // x0
  size_t v39; // x21
  char *v40; // x24
  unsigned __int64 v41; // x25
  const void *v42; // x21
  size_t v43; // x0
  size_t v44; // x23
  char *v45; // x24
  char v46; // w21
  unsigned __int64 v47; // x25
  _QWORD *v48; // x21
  int *v49; // x0
  char *v50; // x23
  __int64 v51; // x0
  __int64 v52; // x8
  __int64 v53; // x9
  __int64 v54; // x23
  unsigned __int64 v55; // x9
  size_t v56; // x20
  size_t v57; // x2
  const char *v58; // x21
  size_t v59; // x0
  size_t v60; // x20
  char *v61; // x23
  unsigned __int64 v62; // x24
  const void *v63; // x20
  size_t v64; // x0
  size_t v65; // x21
  char *v66; // x23
  char v67; // w20
  unsigned __int64 v68; // x24
  _QWORD *v69; // x0
  const char *v70; // x22
  size_t v71; // x0
  size_t v72; // x21
  char *v73; // x23
  unsigned __int64 v74; // x24
  const void *v75; // x21
  size_t v76; // x0
  size_t v77; // x22
  char *v78; // x23
  char v79; // w21
  unsigned __int64 v80; // x24
  const char *v81; // x21
  size_t v82; // x0
  size_t v83; // x20
  char *v84; // x22
  unsigned __int64 v85; // x23
  const void *v86; // x20
  size_t v87; // x0
  size_t v88; // x21
  char *v89; // x22
  char v90; // w20
  unsigned __int64 v91; // x23
  int v92; // w8
  const char *v93; // x21
  size_t v94; // x0
  size_t v95; // x20
  char *v96; // x22
  unsigned __int64 v97; // x23
  const void *v98; // x20
  size_t v99; // x0
  size_t v100; // x21
  char *v101; // x22
  char v102; // w20
  unsigned __int64 v103; // x23
  _QWORD *v104; // x0
  _OWORD *v105; // [xsp+20h] [xbp-480h]
  std::chrono::steady_clock *v106; // [xsp+40h] [xbp-460h]
  unsigned __int64 v107; // [xsp+70h] [xbp-430h] BYREF
  size_t v108; // [xsp+78h] [xbp-428h]
  void *v109; // [xsp+80h] [xbp-420h]
  int v110; // [xsp+88h] [xbp-418h] BYREF
  unsigned __int64 v111; // [xsp+90h] [xbp-410h] BYREF
  size_t v112; // [xsp+98h] [xbp-408h]
  void *v113; // [xsp+A0h] [xbp-400h]
  unsigned __int64 v114; // [xsp+A8h] [xbp-3F8h] BYREF
  size_t v115; // [xsp+B0h] [xbp-3F0h]
  void *v116; // [xsp+B8h] [xbp-3E8h]
  int v117; // [xsp+C0h] [xbp-3E0h] BYREF
  unsigned __int64 v118; // [xsp+C8h] [xbp-3D8h] BYREF
  size_t v119; // [xsp+D0h] [xbp-3D0h]
  void *v120; // [xsp+D8h] [xbp-3C8h]
  unsigned __int64 v121; // [xsp+E0h] [xbp-3C0h] BYREF
  size_t v122; // [xsp+E8h] [xbp-3B8h]
  void *v123; // [xsp+F0h] [xbp-3B0h]
  int v124; // [xsp+F8h] [xbp-3A8h] BYREF
  unsigned __int64 v125; // [xsp+100h] [xbp-3A0h] BYREF
  size_t v126; // [xsp+108h] [xbp-398h]
  void *v127; // [xsp+110h] [xbp-390h]
  unsigned __int64 v128; // [xsp+118h] [xbp-388h] BYREF
  size_t v129; // [xsp+120h] [xbp-380h]
  void *v130; // [xsp+128h] [xbp-378h]
  int v131; // [xsp+130h] [xbp-370h] BYREF
  unsigned __int64 v132; // [xsp+138h] [xbp-368h] BYREF
  size_t v133; // [xsp+140h] [xbp-360h]
  void *v134; // [xsp+148h] [xbp-358h]
  unsigned __int64 v135; // [xsp+150h] [xbp-350h] BYREF
  size_t v136; // [xsp+158h] [xbp-348h]
  void *v137; // [xsp+160h] [xbp-340h]
  int v138; // [xsp+168h] [xbp-338h] BYREF
  unsigned __int64 v139; // [xsp+170h] [xbp-330h] BYREF
  size_t v140; // [xsp+178h] [xbp-328h]
  void *v141; // [xsp+180h] [xbp-320h]
  unsigned __int64 v142; // [xsp+188h] [xbp-318h] BYREF
  size_t v143; // [xsp+190h] [xbp-310h]
  void *v144; // [xsp+198h] [xbp-308h]
  int v145; // [xsp+1A0h] [xbp-300h] BYREF
  unsigned __int64 v146; // [xsp+1A8h] [xbp-2F8h] BYREF
  size_t v147; // [xsp+1B0h] [xbp-2F0h]
  void *v148; // [xsp+1B8h] [xbp-2E8h]
  unsigned __int64 v149; // [xsp+1C0h] [xbp-2E0h] BYREF
  size_t v150; // [xsp+1C8h] [xbp-2D8h]
  void *v151; // [xsp+1D0h] [xbp-2D0h]
  int v152; // [xsp+1D8h] [xbp-2C8h] BYREF
  unsigned __int64 v153; // [xsp+1E0h] [xbp-2C0h] BYREF
  size_t v154; // [xsp+1E8h] [xbp-2B8h]
  void *v155; // [xsp+1F0h] [xbp-2B0h]
  __int64 v156; // [xsp+1F8h] [xbp-2A8h] BYREF
  _QWORD v157[40]; // [xsp+200h] [xbp-2A0h] BYREF
  char src[252]; // [xsp+344h] [xbp-15Ch] BYREF
  __int64 v159; // [xsp+440h] [xbp-60h]

  v1 = this;
  v159 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *((_DWORD *)this + 6) == 1 )
  {
    result = 1LL;
    *((_BYTE *)v1 + 1) = 1;
    return result;
  }
  if ( !*((_QWORD *)this + 5) )
  {
    v3 = (pthread_t *)operator new(8uLL);
    v4 = (std::__thread_struct *)operator new(8uLL);
    std::__thread_struct::__thread_struct(v4);
    v5 = (std::__thread_struct **)operator new(0x10uLL);
    *v5 = v4;
    v5[1] = v1;
    v6 = (std::__ndk1 *)pthread_create(v3, 0LL, (void *(*)(void *))sub_1525C, v5);
    if ( (_DWORD)v6 )
    {
      std::__throw_system_error(v6, (int)"thread constructor failed", v7);
      goto LABEL_231;
    }
    v8 = (std::thread *)*((_QWORD *)v1 + 5);
    *((_QWORD *)v1 + 5) = v3;
    if ( v8 )
    {
      std::thread::~thread(v8);
      operator delete(v8);
      v3 = (pthread_t *)*((_QWORD *)v1 + 5);
    }
    this = (pudutech::ESP32 *)std::thread::detach((std::thread *)v3);
  }
  v106 = (std::chrono::steady_clock *)std::chrono::steady_clock::now(this);
  std::chrono::steady_clock::now(v106);
  LODWORD(v9) = *((_DWORD *)v1 + 1);
  if ( (_DWORD)v9 == -1 )
    goto LABEL_169;
  v105 = (_OWORD *)((char *)v1 + 56);
  do
  {
    if ( !*(_BYTE *)v1 )
      break;
    do
    {
      v10 = read(v9, (char *)v1 + *((int *)v1 + 77) + 56, 250LL - *((int *)v1 + 77));
      if ( (word_2A128 & 1) != 0 )
        v11 = (const char *)qword_2A138;
      else
        v11 = (char *)&word_2A128 + 1;
      v12 = v10;
      v152 = dword_2A120;
      v154 = 0LL;
      v155 = 0LL;
      v153 = 0LL;
      v13 = strlen(v11);
      if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v14 = v13;
      if ( v13 >= 0x17 )
      {
        v16 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v15 = (char *)operator new(v16);
        v154 = v14;
        v155 = v15;
        v153 = v16 | 1;
LABEL_19:
        memcpy(v15, v11, v14);
        goto LABEL_20;
      }
      v15 = (char *)&v153 + 1;
      LOBYTE(v153) = 2 * v13;
      if ( v13 )
        goto LABEL_19;
LABEL_20:
      v15[v14] = 0;
      v9 = g3::logLevel(&v152);
      if ( (v9 & 1) == 0 )
      {
        v21 = 0;
        if ( (v153 & 1) == 0 )
          goto LABEL_31;
        goto LABEL_70;
      }
      v150 = 0LL;
      v151 = 0LL;
      v149 = 0LL;
      v17 = TAG;
      v18 = strlen((const char *)TAG);
      if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v19 = v18;
      if ( v18 >= 0x17 )
      {
        v22 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v20 = (char *)operator new(v22);
        v150 = v19;
        v151 = v20;
        v149 = v22 | 1;
LABEL_28:
        memcpy(v20, v17, v19);
        goto LABEL_29;
      }
      v20 = (char *)&v149 + 1;
      LOBYTE(v149) = 2 * v18;
      if ( v18 )
        goto LABEL_28;
LABEL_29:
      v20[v19] = 0;
      v9 = g3::logTag(&v149);
      v21 = v9;
      if ( (v149 & 1) != 0 )
      {
        operator delete(v151);
        if ( (v153 & 1) == 0 )
        {
LABEL_31:
          if ( (v21 & 1) == 0 )
            goto LABEL_32;
          goto LABEL_71;
        }
      }
      else if ( (v153 & 1) == 0 )
      {
        goto LABEL_31;
      }
LABEL_70:
      operator delete(v155);
      if ( (v21 & 1) == 0 )
      {
LABEL_32:
        if ( (v12 & 0x80000000) == 0 )
          goto LABEL_33;
        goto LABEL_72;
      }
LABEL_71:
      LogCapture::LogCapture((LogCapture *)&v156, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      LogCapture::capturef(
        (LogCapture *)&v156,
        "when wait handshake, read from ESP length %d buf offest %d, head length %lu",
        v12,
        *((unsigned int *)v1 + 77),
        *((_QWORD *)v1 + 1));
      LogCapture::~LogCapture((LogCapture *)&v156);
      if ( (v12 & 0x80000000) == 0 )
      {
LABEL_33:
        *((_DWORD *)v1 + 77) += v12;
        if ( !v12 )
        {
          v9 = std::chrono::steady_clock::now((std::chrono::steady_clock *)v9);
          if ( v9 - (__int64)v106 >= 2000000000 )
          {
            v23 = (std::chrono::steady_clock *)v9;
            pudutech::ESP32::resetDevice(v1);
            while ( 2 )
            {
              v24 = *(_BYTE *)v1;
LABEL_37:
              if ( !v24 )
              {
LABEL_88:
                v106 = v23;
                goto LABEL_89;
              }
              if ( (word_2A128 & 1) != 0 )
                v25 = (const char *)qword_2A138;
              else
                v25 = (char *)&word_2A128 + 1;
              v138 = dword_2A120;
              v139 = 0LL;
              v140 = 0LL;
              v141 = 0LL;
              v26 = strlen(v25);
              if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
                std::__basic_string_common<true>::__throw_length_error();
              v27 = v26;
              if ( v26 >= 0x17 )
              {
                v29 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                v28 = (char *)operator new(v29);
                v140 = v27;
                v141 = v28;
                v139 = v29 | 1;
              }
              else
              {
                v28 = (char *)&v139 + 1;
                LOBYTE(v139) = 2 * v26;
                if ( !v26 )
                {
LABEL_47:
                  v28[v27] = 0;
                  if ( (g3::logLevel(&v138) & 1) == 0 )
                  {
                    v34 = 0;
                    if ( (v139 & 1) == 0 )
                      goto LABEL_58;
                    goto LABEL_61;
                  }
                  v136 = 0LL;
                  v137 = 0LL;
                  v135 = 0LL;
                  v30 = TAG;
                  v31 = strlen((const char *)TAG);
                  if ( v31 >= 0xFFFFFFFFFFFFFFF0LL )
                    std::__basic_string_common<true>::__throw_length_error();
                  v32 = v31;
                  if ( v31 >= 0x17 )
                  {
                    v35 = (v31 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                    v33 = (char *)operator new(v35);
                    v136 = v32;
                    v137 = v33;
                    v135 = v35 | 1;
                  }
                  else
                  {
                    v33 = (char *)&v135 + 1;
                    LOBYTE(v135) = 2 * v31;
                    if ( !v31 )
                    {
LABEL_56:
                      v33[v32] = 0;
                      v34 = g3::logTag(&v135);
                      if ( (v135 & 1) != 0 )
                      {
                        operator delete(v137);
                        if ( (v139 & 1) != 0 )
                          goto LABEL_61;
LABEL_58:
                        if ( (v34 & 1) != 0 )
                          goto LABEL_62;
                      }
                      else
                      {
                        if ( (v139 & 1) == 0 )
                          goto LABEL_58;
LABEL_61:
                        operator delete(v141);
                        if ( (v34 & 1) != 0 )
                        {
LABEL_62:
                          LogCapture::LogCapture(
                            (LogCapture *)&v156,
                            (const char *)TAG,
                            (const LEVELS *)&dword_2A120,
                            "",
                            6,
                            0LL);
                          std::__put_character_sequence<char,std::char_traits<char>>(
                            v157,
                            (__int64)"when wait handshake, block reopen ESP",
                            37LL);
                          LogCapture::~LogCapture((LogCapture *)&v156);
                        }
                      }
                      v9 = pudutech::ESP32::openDev(v1);
                      if ( (v9 & 1) != 0 )
                        goto LABEL_88;
                      v24 = 0;
                      if ( *(_BYTE *)v1 )
                      {
                        v36 = -1;
                        do
                        {
                          v156 = 50000000LL;
                          v9 = std::this_thread::sleep_for(&v156);
                          ++v36;
                        }
                        while ( v36 < 0x28 && *(_BYTE *)v1 );
                        continue;
                      }
                      goto LABEL_37;
                    }
                  }
                  memcpy(v33, v30, v32);
                  goto LABEL_56;
                }
              }
              break;
            }
            memcpy(v28, v25, v27);
            goto LABEL_47;
          }
        }
LABEL_89:
        if ( *((_QWORD *)v1 + 1) <= (unsigned __int64)*((int *)v1 + 77) )
          goto LABEL_103;
        goto LABEL_100;
      }
LABEL_72:
      v145 = dword_2A180;
      if ( (word_2A188 & 1) != 0 )
        v37 = (const char *)qword_2A198;
      else
        v37 = (char *)&word_2A188 + 1;
      v146 = 0LL;
      v147 = 0LL;
      v148 = 0LL;
      v38 = strlen(v37);
      if ( v38 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v39 = v38;
      if ( v38 >= 0x17 )
      {
        v41 = (v38 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v40 = (char *)operator new(v41);
        v147 = v39;
        v148 = v40;
        v146 = v41 | 1;
LABEL_80:
        memcpy(v40, v37, v39);
        goto LABEL_81;
      }
      v40 = (char *)&v146 + 1;
      LOBYTE(v146) = 2 * v38;
      if ( v38 )
        goto LABEL_80;
LABEL_81:
      v40[v39] = 0;
      if ( (g3::logLevel(&v145) & 1) != 0 )
      {
        v143 = 0LL;
        v144 = 0LL;
        v142 = 0LL;
        v42 = TAG;
        v43 = strlen((const char *)TAG);
        if ( v43 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v44 = v43;
        if ( v43 >= 0x17 )
        {
          v47 = (v43 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v45 = (char *)operator new(v47);
          v143 = v44;
          v144 = v45;
          v142 = v47 | 1;
        }
        else
        {
          v45 = (char *)&v142 + 1;
          LOBYTE(v142) = 2 * v43;
          if ( !v43 )
          {
LABEL_93:
            v45[v44] = 0;
            v46 = g3::logTag(&v142);
            if ( (v142 & 1) != 0 )
            {
              operator delete(v144);
              if ( (v146 & 1) == 0 )
              {
LABEL_95:
                if ( (v46 & 1) == 0 )
                  goto LABEL_100;
LABEL_99:
                LogCapture::LogCapture((LogCapture *)&v156, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
                v48 = std::__put_character_sequence<char,std::char_traits<char>>(
                        v157,
                        (__int64)"read ESP error when wait hand shake msg, err ",
                        45LL);
                v49 = (int *)__errno(v48);
                v50 = strerror(*v49);
                v51 = strlen(v50);
                std::__put_character_sequence<char,std::char_traits<char>>(v48, (__int64)v50, v51);
                LogCapture::~LogCapture((LogCapture *)&v156);
                goto LABEL_100;
              }
            }
            else if ( (v146 & 1) == 0 )
            {
              goto LABEL_95;
            }
            goto LABEL_98;
          }
        }
        memcpy(v45, v42, v44);
        goto LABEL_93;
      }
      v46 = 0;
      if ( (v146 & 1) == 0 )
        goto LABEL_95;
LABEL_98:
      operator delete(v148);
      if ( (v46 & 1) != 0 )
        goto LABEL_99;
LABEL_100:
      v9 = *((unsigned int *)v1 + 1);
    }
    while ( (_DWORD)v9 != -1 && *(_BYTE *)v1 );
    if ( (v12 & 0x80000000) != 0 )
    {
      if ( (word_2A188 & 1) != 0 )
        v70 = (const char *)qword_2A198;
      else
        v70 = (char *)&word_2A188 + 1;
      v131 = dword_2A180;
      v133 = 0LL;
      v134 = 0LL;
      v132 = 0LL;
      v71 = strlen(v70);
      if ( v71 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_231;
      v72 = v71;
      if ( v71 >= 0x17 )
      {
        v74 = (v71 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v73 = (char *)operator new(v74);
        v133 = v72;
        v134 = v73;
        v132 = v74 | 1;
      }
      else
      {
        v73 = (char *)&v132 + 1;
        LOBYTE(v132) = 2 * v71;
        if ( !v71 )
        {
LABEL_152:
          v73[v72] = 0;
          if ( (g3::logLevel(&v131) & 1) == 0 )
          {
            v79 = 0;
            if ( (v132 & 1) == 0 )
              goto LABEL_163;
            goto LABEL_166;
          }
          v129 = 0LL;
          v130 = 0LL;
          v128 = 0LL;
          v75 = TAG;
          v76 = strlen((const char *)TAG);
          if ( v76 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v77 = v76;
          if ( v76 >= 0x17 )
          {
            v80 = (v76 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v78 = (char *)operator new(v80);
            v129 = v77;
            v130 = v78;
            v128 = v80 | 1;
          }
          else
          {
            v78 = (char *)&v128 + 1;
            LOBYTE(v128) = 2 * v76;
            if ( !v76 )
            {
LABEL_161:
              v78[v77] = 0;
              v79 = g3::logTag(&v128);
              if ( (v128 & 1) != 0 )
              {
                operator delete(v130);
                if ( (v132 & 1) == 0 )
                {
LABEL_163:
                  if ( (v79 & 1) == 0 )
                    break;
                  goto LABEL_167;
                }
              }
              else if ( (v132 & 1) == 0 )
              {
                goto LABEL_163;
              }
LABEL_166:
              operator delete(v134);
              if ( (v79 & 1) == 0 )
                break;
LABEL_167:
              LogCapture::LogCapture((LogCapture *)&v156, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
              LogCapture::capturef(
                (LogCapture *)&v156,
                "read from ESP fail with ret %d, fd is %d",
                v12,
                *((unsigned int *)v1 + 1));
LABEL_168:
              LogCapture::~LogCapture((LogCapture *)&v156);
              break;
            }
          }
          memcpy(v78, v75, v77);
          goto LABEL_161;
        }
      }
      memcpy(v73, v70, v72);
      goto LABEL_152;
    }
LABEL_103:
    v52 = *((int *)v1 + 77);
    v53 = *((_QWORD *)v1 + 1);
    if ( v53 == v52 )
    {
      LODWORD(v54) = 0;
      goto LABEL_113;
    }
    v54 = 0LL;
    v55 = v52 - v53;
    while ( *((unsigned __int8 *)v1 + v54 + 56) != 170 || *((_BYTE *)v1 + v54 + 57) != 85 )
    {
      if ( v55 <= ++v54 )
        goto LABEL_113;
    }
    if ( *((_BYTE *)v1 + (unsigned int)(v54 + 4) + 56) == 117 && *((_BYTE *)v1 + (unsigned int)(v54 + 5) + 56) == 117 )
    {
      v92 = *((_DWORD *)v1 + 16);
      *((_BYTE *)v1 + 1) = 1;
      *((_DWORD *)v1 + 7) = v92;
      *((_QWORD *)v1 + 39) = std::chrono::steady_clock::now((std::chrono::steady_clock *)v9);
      *((_DWORD *)v1 + 77) = 0;
      *(_OWORD *)((char *)v1 + 290) = 0u;
      *(_OWORD *)((char *)v1 + 264) = 0u;
      *(_OWORD *)((char *)v1 + 280) = 0u;
      *(_OWORD *)((char *)v1 + 232) = 0u;
      *(_OWORD *)((char *)v1 + 248) = 0u;
      *(_OWORD *)((char *)v1 + 200) = 0u;
      *(_OWORD *)((char *)v1 + 216) = 0u;
      *(_OWORD *)((char *)v1 + 168) = 0u;
      *(_OWORD *)((char *)v1 + 184) = 0u;
      *(_OWORD *)((char *)v1 + 136) = 0u;
      *(_OWORD *)((char *)v1 + 152) = 0u;
      *(_OWORD *)((char *)v1 + 104) = 0u;
      *(_OWORD *)((char *)v1 + 120) = 0u;
      *(_OWORD *)((char *)v1 + 72) = 0u;
      *(_OWORD *)((char *)v1 + 88) = 0u;
      *v105 = 0u;
      v124 = dword_2A120;
      if ( (word_2A128 & 1) != 0 )
        v93 = (const char *)qword_2A138;
      else
        v93 = (char *)&word_2A128 + 1;
      v126 = 0LL;
      v127 = 0LL;
      v125 = 0LL;
      v94 = strlen(v93);
      if ( v94 < 0xFFFFFFFFFFFFFFF0LL )
      {
        v95 = v94;
        if ( v94 >= 0x17 )
        {
          v97 = (v94 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v96 = (char *)operator new(v97);
          v126 = v95;
          v127 = v96;
          v125 = v97 | 1;
        }
        else
        {
          v96 = (char *)&v125 + 1;
          LOBYTE(v125) = 2 * v94;
          if ( !v94 )
          {
LABEL_204:
            v96[v95] = 0;
            if ( (g3::logLevel(&v124) & 1) == 0 )
            {
              v102 = 0;
              if ( (v125 & 1) == 0 )
                goto LABEL_215;
              goto LABEL_218;
            }
            v122 = 0LL;
            v123 = 0LL;
            v121 = 0LL;
            v98 = TAG;
            v99 = strlen((const char *)TAG);
            if ( v99 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v100 = v99;
            if ( v99 >= 0x17 )
            {
              v103 = (v99 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v101 = (char *)operator new(v103);
              v122 = v100;
              v123 = v101;
              v121 = v103 | 1;
            }
            else
            {
              v101 = (char *)&v121 + 1;
              LOBYTE(v121) = 2 * v99;
              if ( !v99 )
              {
LABEL_213:
                v101[v100] = 0;
                v102 = g3::logTag(&v121);
                if ( (v121 & 1) != 0 )
                {
                  operator delete(v123);
                  if ( (v125 & 1) == 0 )
                  {
LABEL_215:
                    if ( (v102 & 1) == 0 )
                      break;
LABEL_219:
                    LogCapture::LogCapture(
                      (LogCapture *)&v156,
                      (const char *)TAG,
                      (const LEVELS *)&dword_2A120,
                      "",
                      6,
                      0LL);
                    v104 = std::__put_character_sequence<char,std::char_traits<char>>(
                             v157,
                             (__int64)"receive hardware response, esp has finished connecting, used ",
                             61LL);
                    std::ostream::operator<<(v104);
                    goto LABEL_168;
                  }
                }
                else if ( (v125 & 1) == 0 )
                {
                  goto LABEL_215;
                }
LABEL_218:
                operator delete(v127);
                if ( (v102 & 1) == 0 )
                  break;
                goto LABEL_219;
              }
            }
            memcpy(v101, v98, v100);
            goto LABEL_213;
          }
        }
        memcpy(v96, v93, v95);
        goto LABEL_204;
      }
LABEL_231:
      std::__basic_string_common<true>::__throw_length_error();
    }
    LODWORD(v54) = v54 + 2;
LABEL_113:
    v56 = v52 - (int)v54;
    if ( (unsigned int)v56 <= 0xF9 )
      v57 = 250 - v56;
    else
      v57 = 0LL;
    memset(&src[v56], 0, v57);
    memcpy(src, (char *)v1 + (int)v54 + 56, v56);
    memcpy(v105, src, v56);
    *((_DWORD *)v1 + 77) -= v54;
    v117 = dword_2A120;
    if ( (word_2A128 & 1) != 0 )
      v58 = (const char *)qword_2A138;
    else
      v58 = (char *)&word_2A128 + 1;
    v119 = 0LL;
    v120 = 0LL;
    v118 = 0LL;
    v59 = strlen(v58);
    if ( v59 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v60 = v59;
    if ( v59 >= 0x17 )
    {
      v62 = (v59 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v61 = (char *)operator new(v62);
      v119 = v60;
      v120 = v61;
      v118 = v62 | 1;
LABEL_124:
      memcpy(v61, v58, v60);
      goto LABEL_125;
    }
    v61 = (char *)&v118 + 1;
    LOBYTE(v118) = 2 * v59;
    if ( v59 )
      goto LABEL_124;
LABEL_125:
    v61[v60] = 0;
    if ( (g3::logLevel(&v117) & 1) == 0 )
    {
      v67 = 0;
      if ( (v118 & 1) == 0 )
        goto LABEL_136;
      goto LABEL_139;
    }
    v115 = 0LL;
    v116 = 0LL;
    v114 = 0LL;
    v63 = TAG;
    v64 = strlen((const char *)TAG);
    if ( v64 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v65 = v64;
    if ( v64 >= 0x17 )
    {
      v68 = (v64 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v66 = (char *)operator new(v68);
      v115 = v65;
      v116 = v66;
      v114 = v68 | 1;
LABEL_133:
      memcpy(v66, v63, v65);
      goto LABEL_134;
    }
    v66 = (char *)&v114 + 1;
    LOBYTE(v114) = 2 * v64;
    if ( v64 )
      goto LABEL_133;
LABEL_134:
    v66[v65] = 0;
    v67 = g3::logTag(&v114);
    if ( (v114 & 1) != 0 )
    {
      operator delete(v116);
      if ( (v118 & 1) != 0 )
        goto LABEL_139;
LABEL_136:
      if ( (v67 & 1) != 0 )
        goto LABEL_140;
    }
    else
    {
      if ( (v118 & 1) == 0 )
        goto LABEL_136;
LABEL_139:
      operator delete(v120);
      if ( (v67 & 1) != 0 )
      {
LABEL_140:
        LogCapture::LogCapture((LogCapture *)&v156, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
        v69 = std::__put_character_sequence<char,std::char_traits<char>>(
                v157,
                (__int64)"received msg is not hardware hand shake, can continue? ",
                55LL);
        std::ostream::operator<<(v69);
        LogCapture::~LogCapture((LogCapture *)&v156);
      }
    }
    LODWORD(v9) = *((_DWORD *)v1 + 1);
  }
  while ( (_DWORD)v9 != -1 );
LABEL_169:
  if ( (word_2A128 & 1) != 0 )
    v81 = (const char *)qword_2A138;
  else
    v81 = (char *)&word_2A128 + 1;
  v110 = dword_2A120;
  v112 = 0LL;
  v113 = 0LL;
  v111 = 0LL;
  v82 = strlen(v81);
  if ( v82 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v83 = v82;
  if ( v82 >= 0x17 )
  {
    v85 = (v82 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v84 = (char *)operator new(v85);
    v112 = v83;
    v113 = v84;
    v111 = v85 | 1;
    goto LABEL_177;
  }
  v84 = (char *)&v111 + 1;
  LOBYTE(v111) = 2 * v82;
  if ( v82 )
LABEL_177:
    memcpy(v84, v81, v83);
  v84[v83] = 0;
  if ( (g3::logLevel(&v110) & 1) == 0 )
  {
    v90 = 0;
    if ( (v111 & 1) == 0 )
      goto LABEL_189;
    goto LABEL_192;
  }
  v108 = 0LL;
  v109 = 0LL;
  v107 = 0LL;
  v86 = TAG;
  v87 = strlen((const char *)TAG);
  if ( v87 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v88 = v87;
  if ( v87 >= 0x17 )
  {
    v91 = (v87 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v89 = (char *)operator new(v91);
    v108 = v88;
    v109 = v89;
    v107 = v91 | 1;
    goto LABEL_186;
  }
  v89 = (char *)&v107 + 1;
  LOBYTE(v107) = 2 * v87;
  if ( v87 )
LABEL_186:
    memcpy(v89, v86, v88);
  v89[v88] = 0;
  v90 = g3::logTag(&v107);
  if ( (v107 & 1) != 0 )
  {
    operator delete(v109);
    if ( (v111 & 1) != 0 )
      goto LABEL_192;
LABEL_189:
    if ( (v90 & 1) != 0 )
      goto LABEL_193;
  }
  else
  {
    if ( (v111 & 1) == 0 )
      goto LABEL_189;
LABEL_192:
    operator delete(v113);
    if ( (v90 & 1) != 0 )
    {
LABEL_193:
      LogCapture::LogCapture((LogCapture *)&v156, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      LogCapture::capturef((LogCapture *)&v156, "finish thread to wait hardware response");
      LogCapture::~LogCapture((LogCapture *)&v156);
    }
  }
  return *((_BYTE *)v1 + 1) != 0;
}
// DB44: variable 'v9' is possibly undefined
// E8B8: variable 'v7' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 7A80: using guessed type __int64 __fastcall std::this_thread::sleep_for(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (000000000000EB10) ----------------------------------------------------
_BYTE *__fastcall pudutech::ESP32::delayLoops(_BYTE *this, int a2)
{
  _BYTE *v2; // x19
  int v3; // w21
  int v4; // w22
  __int64 v5[2]; // [xsp+0h] [xbp-40h] BYREF

  v2 = this;
  v3 = -1;
  v4 = 20 * a2;
  v5[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  do
  {
    if ( !*v2 )
      break;
    v5[0] = 50000000LL;
    this = (_BYTE *)std::this_thread::sleep_for(v5);
    ++v3;
  }
  while ( v3 < v4 );
  return this;
}
// 7A80: using guessed type __int64 __fastcall std::this_thread::sleep_for(_QWORD);

//----- (000000000000EB98) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 40LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// EB98: using guessed type char var_60[8];

//----- (000000000000ED64) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 24LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// ED64: using guessed type char var_60[8];

//----- (000000000000EF30) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::getErrorCode(pudutech::ESP32 *this)
{
  std::chrono::steady_clock *v2; // x0
  __int64 v3; // x0

  v2 = (std::chrono::steady_clock *)sub_EFC8(1, *((_DWORD *)this + 6) == 2);
  if ( (_DWORD)v2 == -1 )
    return 2LL;
  v3 = std::chrono::steady_clock::now(v2);
  if ( v3 - *((_QWORD *)this + 39) > 0x12A15343FLL )
    return 4LL;
  if ( *((_BYTE *)this + 2) == 3 )
    return 3LL;
  if ( v3 - *((_QWORD *)this + 40) <= 500999999 )
    return 1LL;
  return 5LL;
}

//----- (000000000000EFC8) ----------------------------------------------------
__int64 __fastcall sub_EFC8(int a1, char a2)
{
  const char *v3; // x0
  DIR *v4; // x19
  struct dirent *v5; // x24
  const char *v6; // x27
  size_t v7; // x0
  size_t v8; // x25
  char *v9; // x23
  unsigned __int64 v10; // x28
  const void *v11; // x25
  size_t v12; // x0
  size_t v13; // x27
  char *v14; // x23
  char v15; // w25
  unsigned __int8 *p_d_type; // x23
  unsigned __int64 v17; // x28
  const char *v18; // x0
  __int64 *v19; // x0
  __int128 v20; // q0
  __int64 *v21; // x0
  __int128 v22; // q0
  __int64 *v23; // x0
  __int128 v24; // q0
  __int64 v25; // x8
  const char *v26; // x25
  size_t v27; // x0
  size_t v28; // x24
  char *v29; // x23
  const char *v30; // x25
  size_t v31; // x0
  size_t v32; // x24
  char *v33; // x23
  unsigned __int64 v34; // x27
  const void *v35; // x24
  size_t v36; // x0
  size_t v37; // x25
  char *v38; // x23
  char v39; // w24
  unsigned __int64 v40; // x27
  const void *v41; // x24
  size_t v42; // x0
  size_t v43; // x25
  char *v44; // x23
  char v45; // w24
  unsigned __int64 v46; // x27
  int v47; // w23
  unsigned __int64 v48; // x27
  LogCapture *v49; // x0
  __int64 v50; // x2
  const char *v51; // x3
  __int64 v52; // x8
  __int64 v53; // x8
  unsigned __int64 v54; // x11
  _BYTE *v55; // x8
  unsigned __int64 v56; // x11
  _BYTE *v57; // x8
  unsigned __int64 v58; // x11
  _BYTE *v59; // x8
  const char *v60; // x25
  size_t v61; // x0
  size_t v62; // x24
  char *v63; // x23
  unsigned __int64 v64; // x27
  const void *v65; // x24
  size_t v66; // x0
  size_t v67; // x25
  char *v68; // x23
  char v69; // w24
  unsigned __int64 v70; // x27
  const char *v71; // x2
  const char *v72; // x25
  size_t v73; // x0
  size_t v74; // x24
  char *v75; // x23
  unsigned __int64 v76; // x27
  const void *v77; // x24
  size_t v78; // x0
  size_t v79; // x25
  char *v80; // x23
  char v81; // w24
  unsigned __int64 v82; // x27
  const char *v83; // x2
  const char *v84; // x25
  size_t v85; // x0
  size_t v86; // x24
  char *v87; // x23
  unsigned __int64 v88; // x27
  const void *v89; // x24
  size_t v90; // x0
  size_t v91; // x25
  char *v92; // x23
  char v93; // w24
  unsigned __int64 v94; // x27
  const char *v95; // x2
  unsigned __int64 v96; // x2
  unsigned __int64 v97; // x11
  char *v98; // x0
  unsigned __int8 *v99; // x1
  __int64 v100; // x8
  unsigned __int8 *v101; // x9
  unsigned __int64 v102; // x2
  unsigned __int64 v103; // x11
  char *v104; // x0
  unsigned __int8 *v105; // x1
  __int64 v106; // x8
  unsigned __int8 *v107; // x9
  __int64 *v108; // x0
  __int128 v109; // q0
  __int64 v110; // x8
  __int64 v111; // x8
  unsigned __int64 v112; // x9
  unsigned __int64 v113; // x11
  int v114; // w24
  _BYTE *v115; // x8
  const char *v116; // x25
  size_t v117; // x0
  size_t v118; // x24
  char *v119; // x23
  __int64 *v120; // x0
  __int128 v121; // q0
  __int64 v122; // x8
  unsigned __int64 v123; // x27
  const void *v124; // x24
  size_t v125; // x0
  size_t v126; // x25
  char *v127; // x23
  char v128; // w24
  __int64 v129; // x8
  unsigned __int64 v130; // x9
  unsigned __int64 v131; // x11
  _BYTE *v132; // x8
  unsigned __int64 v133; // x27
  const char *v134; // x2
  size_t v135; // x0
  size_t v136; // x24
  char *v137; // x23
  unsigned __int64 v138; // x25
  char *v139; // x9
  signed __int64 v140; // x8
  char *v141; // x27
  __int64 v142; // x10
  signed __int64 v143; // x11
  __int64 v144; // x28
  int v145; // w12
  int v146; // w13
  size_t v147; // x23
  char *v148; // x24
  const char *v149; // x24
  size_t v150; // x0
  size_t v151; // x23
  char *v152; // x25
  const char *v153; // x24
  size_t v154; // x0
  size_t v155; // x23
  char *v156; // x25
  unsigned __int64 v157; // x27
  const void *v158; // x23
  size_t v159; // x0
  size_t v160; // x24
  char *v161; // x25
  unsigned __int64 v162; // x27
  const void *v163; // x23
  size_t v164; // x0
  size_t v165; // x24
  char *v166; // x25
  char v167; // w23
  char v168; // w23
  __int64 *v169; // x0
  char v170; // w8
  const char *v171; // x24
  size_t v172; // x0
  size_t v173; // x23
  char *v174; // x25
  unsigned __int64 v175; // x27
  const void *v176; // x23
  size_t v177; // x0
  size_t v178; // x24
  char *v179; // x25
  char v180; // w23
  unsigned __int64 v181; // x27
  const char *v182; // x2
  unsigned __int64 v183; // x27
  const char *v184; // x2
  int v185; // w24
  const char *v186; // x0
  unsigned __int64 v187; // x27
  __int64 v188; // x24
  const char *v189; // x2
  unsigned __int64 v190; // x9
  unsigned __int64 v191; // x27
  size_t v192; // x23
  char *v193; // x28
  char *v194; // x24
  char *v195; // x23
  unsigned int v197; // w20
  const char *v198; // x21
  size_t v199; // x0
  size_t v200; // x20
  char *v201; // x22
  unsigned __int64 v202; // x23
  const void *v203; // x20
  size_t v204; // x0
  char v205; // w20
  size_t v206; // x21
  char *v207; // x22
  unsigned __int64 v208; // x23
  const char *v209; // x2
  void *v210; // [xsp+8h] [xbp-DA8h]
  char v211; // [xsp+14h] [xbp-D9Ch]
  int v212; // [xsp+18h] [xbp-D98h]
  __int64 v213; // [xsp+18h] [xbp-D98h]
  unsigned __int64 v214; // [xsp+1D8h] [xbp-BD8h] BYREF
  size_t v215; // [xsp+1E0h] [xbp-BD0h]
  void *v216; // [xsp+1E8h] [xbp-BC8h]
  int v217; // [xsp+1F0h] [xbp-BC0h] BYREF
  unsigned __int64 v218; // [xsp+1F8h] [xbp-BB8h] BYREF
  size_t v219; // [xsp+200h] [xbp-BB0h]
  void *v220; // [xsp+208h] [xbp-BA8h]
  unsigned __int64 v221; // [xsp+210h] [xbp-BA0h] BYREF
  size_t v222; // [xsp+218h] [xbp-B98h]
  void *v223; // [xsp+220h] [xbp-B90h]
  int v224; // [xsp+228h] [xbp-B88h] BYREF
  unsigned __int64 v225; // [xsp+230h] [xbp-B80h] BYREF
  size_t v226; // [xsp+238h] [xbp-B78h]
  void *v227; // [xsp+240h] [xbp-B70h]
  unsigned __int64 v228; // [xsp+248h] [xbp-B68h] BYREF
  size_t v229; // [xsp+250h] [xbp-B60h]
  void *v230; // [xsp+258h] [xbp-B58h]
  int v231; // [xsp+260h] [xbp-B50h] BYREF
  unsigned __int64 v232; // [xsp+268h] [xbp-B48h] BYREF
  size_t v233; // [xsp+270h] [xbp-B40h]
  void *v234; // [xsp+278h] [xbp-B38h]
  unsigned __int64 v235; // [xsp+280h] [xbp-B30h] BYREF
  size_t v236; // [xsp+288h] [xbp-B28h]
  void *v237; // [xsp+290h] [xbp-B20h]
  int v238; // [xsp+298h] [xbp-B18h] BYREF
  unsigned __int64 v239; // [xsp+2A0h] [xbp-B10h] BYREF
  size_t v240; // [xsp+2A8h] [xbp-B08h]
  void *v241; // [xsp+2B0h] [xbp-B00h]
  __int64 v242; // [xsp+2B8h] [xbp-AF8h] BYREF
  unsigned __int64 v243; // [xsp+2C0h] [xbp-AF0h]
  void *v244; // [xsp+2C8h] [xbp-AE8h]
  __int128 v245; // [xsp+2D0h] [xbp-AE0h] BYREF
  void *v246; // [xsp+2E0h] [xbp-AD0h]
  unsigned __int64 v247; // [xsp+2F0h] [xbp-AC0h] BYREF
  size_t v248; // [xsp+2F8h] [xbp-AB8h]
  void *v249; // [xsp+300h] [xbp-AB0h]
  int v250; // [xsp+308h] [xbp-AA8h] BYREF
  unsigned __int64 v251; // [xsp+310h] [xbp-AA0h] BYREF
  size_t v252; // [xsp+318h] [xbp-A98h]
  void *v253; // [xsp+320h] [xbp-A90h]
  unsigned __int64 v254; // [xsp+328h] [xbp-A88h] BYREF
  size_t v255; // [xsp+330h] [xbp-A80h]
  void *v256; // [xsp+338h] [xbp-A78h]
  int v257; // [xsp+340h] [xbp-A70h] BYREF
  unsigned __int64 v258; // [xsp+348h] [xbp-A68h] BYREF
  size_t v259; // [xsp+350h] [xbp-A60h]
  void *v260; // [xsp+358h] [xbp-A58h]
  unsigned __int64 v261; // [xsp+360h] [xbp-A50h] BYREF
  size_t v262; // [xsp+368h] [xbp-A48h]
  void *v263; // [xsp+370h] [xbp-A40h]
  int v264; // [xsp+378h] [xbp-A38h] BYREF
  unsigned __int64 v265; // [xsp+380h] [xbp-A30h] BYREF
  size_t v266; // [xsp+388h] [xbp-A28h]
  void *v267; // [xsp+390h] [xbp-A20h]
  __int64 v268[2]; // [xsp+398h] [xbp-A18h] BYREF
  void *v269; // [xsp+3A8h] [xbp-A08h]
  __int64 v270; // [xsp+3B0h] [xbp-A00h] BYREF
  unsigned __int64 v271; // [xsp+3B8h] [xbp-9F8h]
  void *v272; // [xsp+3C0h] [xbp-9F0h]
  __int64 v273; // [xsp+3C8h] [xbp-9E8h] BYREF
  unsigned __int64 v274; // [xsp+3D0h] [xbp-9E0h]
  void *v275; // [xsp+3D8h] [xbp-9D8h]
  __int64 v276; // [xsp+3E0h] [xbp-9D0h] BYREF
  unsigned __int64 v277; // [xsp+3E8h] [xbp-9C8h]
  void *v278; // [xsp+3F0h] [xbp-9C0h]
  unsigned __int64 v279; // [xsp+3F8h] [xbp-9B8h] BYREF
  size_t v280; // [xsp+400h] [xbp-9B0h]
  void *v281; // [xsp+408h] [xbp-9A8h]
  int v282; // [xsp+410h] [xbp-9A0h] BYREF
  unsigned __int64 v283; // [xsp+418h] [xbp-998h] BYREF
  size_t v284; // [xsp+420h] [xbp-990h]
  void *v285; // [xsp+428h] [xbp-988h]
  __int128 v286; // [xsp+430h] [xbp-980h] BYREF
  void *v287; // [xsp+440h] [xbp-970h]
  __int128 v288; // [xsp+450h] [xbp-960h] BYREF
  void *v289; // [xsp+460h] [xbp-950h]
  __int128 v290; // [xsp+470h] [xbp-940h] BYREF
  void *v291; // [xsp+480h] [xbp-930h]
  unsigned __int64 v292; // [xsp+490h] [xbp-920h] BYREF
  size_t v293; // [xsp+498h] [xbp-918h]
  void *v294; // [xsp+4A0h] [xbp-910h]
  int v295; // [xsp+4A8h] [xbp-908h] BYREF
  unsigned __int64 v296; // [xsp+4B0h] [xbp-900h] BYREF
  size_t v297; // [xsp+4B8h] [xbp-8F8h]
  void *v298; // [xsp+4C0h] [xbp-8F0h]
  __int64 v299[2]; // [xsp+4C8h] [xbp-8E8h] BYREF
  void *v300; // [xsp+4D8h] [xbp-8D8h]
  unsigned __int64 v301; // [xsp+4E0h] [xbp-8D0h] BYREF
  size_t v302; // [xsp+4E8h] [xbp-8C8h]
  void *v303; // [xsp+4F0h] [xbp-8C0h]
  int v304; // [xsp+4F8h] [xbp-8B8h] BYREF
  unsigned __int64 v305; // [xsp+500h] [xbp-8B0h] BYREF
  size_t v306; // [xsp+508h] [xbp-8A8h]
  void *v307; // [xsp+510h] [xbp-8A0h]
  unsigned __int64 v308; // [xsp+518h] [xbp-898h] BYREF
  size_t v309; // [xsp+520h] [xbp-890h]
  void *v310; // [xsp+528h] [xbp-888h]
  int v311; // [xsp+530h] [xbp-880h] BYREF
  unsigned __int64 v312; // [xsp+538h] [xbp-878h] BYREF
  size_t v313; // [xsp+540h] [xbp-870h]
  void *v314; // [xsp+548h] [xbp-868h]
  __int64 v315; // [xsp+550h] [xbp-860h] BYREF
  unsigned __int64 v316; // [xsp+558h] [xbp-858h]
  void *v317; // [xsp+560h] [xbp-850h]
  unsigned __int8 v318; // [xsp+568h] [xbp-848h]
  _BYTE v319[15]; // [xsp+569h] [xbp-847h] BYREF
  void *v320; // [xsp+578h] [xbp-838h]
  void *v321[3]; // [xsp+580h] [xbp-830h] BYREF
  unsigned __int64 v322; // [xsp+598h] [xbp-818h] BYREF
  size_t v323; // [xsp+5A0h] [xbp-810h]
  void *v324; // [xsp+5A8h] [xbp-808h]
  unsigned __int64 v325; // [xsp+6E0h] [xbp-6D0h] BYREF
  size_t v326; // [xsp+6E8h] [xbp-6C8h]
  char *v327; // [xsp+6F0h] [xbp-6C0h]
  _BYTE v328[168]; // [xsp+6F8h] [xbp-6B8h] BYREF
  __int64 (__fastcall **v329)(); // [xsp+7A0h] [xbp-610h] BYREF
  __int64 v330[3]; // [xsp+838h] [xbp-578h] BYREF
  _BYTE v331[168]; // [xsp+850h] [xbp-560h] BYREF
  __int64 (__fastcall **v332)(); // [xsp+8F8h] [xbp-4B8h] BYREF
  __int64 v333[3]; // [xsp+990h] [xbp-420h] BYREF
  _BYTE v334[168]; // [xsp+9A8h] [xbp-408h] BYREF
  __int64 (__fastcall **v335)(); // [xsp+A50h] [xbp-360h] BYREF
  __int64 v336[2]; // [xsp+AE8h] [xbp-2C8h] BYREF
  void *v337; // [xsp+AF8h] [xbp-2B8h]
  _BYTE v338[168]; // [xsp+B00h] [xbp-2B0h] BYREF
  __int64 (__fastcall **v339)(); // [xsp+BA8h] [xbp-208h] BYREF
  __int128 buf[18]; // [xsp+C40h] [xbp-170h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  LOBYTE(v321[0]) = 30;
  BYTE1(v321[2]) = 0;
  WORD1(v321[2]) = 0;
  HIDWORD(v321[2]) = 0;
  strcpy((char *)v321 + 1, "/sys/class/tty/");
  *(_QWORD *)&v319[7] = 0LL;
  v320 = 0LL;
  v318 = 16;
  *(_QWORD *)v319 = 0x3036616534633031LL;
  v316 = 0LL;
  v315 = 0LL;
  v317 = 0LL;
  if ( (a2 & 1) != 0 )
    std::string::assign(&v315, "CP2102 USB to UART Bridge Controller", 0x24uLL);
  else
    std::string::assign(&v315, "CP2102N USB to UART Bridge Controller", 0x25uLL);
  if ( ((__int64)v321[0] & 1) != 0 )
    v3 = (const char *)v321[2];
  else
    v3 = (char *)v321 + 1;
  v4 = opendir(v3);
  if ( !v4 )
  {
    if ( (word_2A1A8 & 1) != 0 )
      v198 = (const char *)qword_2A1B8;
    else
      v198 = (char *)&word_2A1A8 + 1;
    v311 = dword_2A1A0;
    v314 = 0LL;
    v313 = 0LL;
    v312 = 0LL;
    v199 = strlen(v198);
    if ( v199 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v200 = v199;
    if ( v199 >= 0x17 )
    {
      v202 = (v199 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v201 = (char *)operator new(v202);
      v314 = v201;
      v312 = v202 | 1;
      v313 = v200;
    }
    else
    {
      v201 = (char *)&v312 + 1;
      LOBYTE(v312) = 2 * v199;
      if ( !v199 )
      {
LABEL_512:
        v201[v200] = 0;
        if ( (g3::logLevel(&v311) & 1) == 0 )
        {
          v205 = 0;
          goto LABEL_516;
        }
        v310 = 0LL;
        v309 = 0LL;
        v308 = 0LL;
        v203 = TAG;
        v204 = strlen((const char *)TAG);
        if ( v204 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v206 = v204;
        if ( v204 >= 0x17 )
        {
          v208 = (v204 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v207 = (char *)operator new(v208);
          v310 = v207;
          v308 = v208 | 1;
          v309 = v206;
        }
        else
        {
          v207 = (char *)&v308 + 1;
          LOBYTE(v308) = 2 * v204;
          if ( !v204 )
          {
LABEL_524:
            v207[v206] = 0;
            v205 = g3::logTag(&v308);
            if ( (v308 & 1) != 0 )
            {
              operator delete(v310);
              if ( (v312 & 1) != 0 )
              {
LABEL_526:
                operator delete(v314);
                if ( (v205 & 1) == 0 )
                  goto LABEL_531;
LABEL_527:
                LogCapture::LogCapture((LogCapture *)v336, (const char *)TAG, (const LEVELS *)&dword_2A1A0, "", 6, 0LL);
                if ( ((__int64)v321[0] & 1) != 0 )
                  v209 = (const char *)v321[2];
                else
                  v209 = (char *)v321 + 1;
                LogCapture::capturef((LogCapture *)v336, "open dir error,path:%s", v209);
                LogCapture::~LogCapture((LogCapture *)v336);
LABEL_531:
                exit(0);
              }
LABEL_517:
              if ( (v205 & 1) == 0 )
                goto LABEL_531;
              goto LABEL_527;
            }
LABEL_516:
            if ( (v312 & 1) != 0 )
              goto LABEL_526;
            goto LABEL_517;
          }
        }
        memcpy(v207, v203, v206);
        goto LABEL_524;
      }
    }
    memcpy(v201, v198, v200);
    goto LABEL_512;
  }
  while ( 1 )
  {
    v5 = readdir(v4);
    if ( !v5 )
      break;
    if ( (word_2A128 & 1) != 0 )
      v6 = (const char *)qword_2A138;
    else
      v6 = (char *)&word_2A128 + 1;
    v304 = dword_2A120;
    v305 = 0LL;
    v306 = 0LL;
    v307 = 0LL;
    v7 = strlen(v6);
    if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v8 = v7;
    if ( v7 >= 0x17 )
    {
      v10 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v9 = (char *)operator new(v10);
      v307 = v9;
      v305 = v10 | 1;
      v306 = v8;
LABEL_17:
      memcpy(v9, v6, v8);
      goto LABEL_18;
    }
    v9 = (char *)&v305 + 1;
    LOBYTE(v305) = 2 * v7;
    if ( v7 )
      goto LABEL_17;
LABEL_18:
    v9[v8] = 0;
    if ( (g3::logLevel(&v304) & 1) == 0 )
    {
      v15 = 0;
      if ( (v305 & 1) != 0 )
        goto LABEL_24;
      goto LABEL_30;
    }
    v11 = TAG;
    v303 = 0LL;
    v302 = 0LL;
    v301 = 0LL;
    v12 = strlen((const char *)TAG);
    if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v13 = v12;
    if ( v12 >= 0x17 )
    {
      v17 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v14 = (char *)operator new(v17);
      v303 = v14;
      v301 = v17 | 1;
      v302 = v13;
LABEL_27:
      memcpy(v14, v11, v13);
      goto LABEL_28;
    }
    v14 = (char *)&v301 + 1;
    LOBYTE(v301) = 2 * v12;
    if ( v12 )
      goto LABEL_27;
LABEL_28:
    v14[v13] = 0;
    v15 = g3::logTag(&v301);
    if ( (v301 & 1) != 0 )
    {
      operator delete(v303);
      if ( (v305 & 1) != 0 )
      {
LABEL_24:
        operator delete(v307);
        if ( (v15 & 1) != 0 )
          goto LABEL_31;
        goto LABEL_25;
      }
    }
    else if ( (v305 & 1) != 0 )
    {
      goto LABEL_24;
    }
LABEL_30:
    if ( (v15 & 1) != 0 )
    {
LABEL_31:
      LogCapture::LogCapture((LogCapture *)v336, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      p_d_type = &v5->d_type;
      LogCapture::capturef((LogCapture *)v336, "dir type %d, dir name %s", v5->d_type, v5->d_name);
      LogCapture::~LogCapture((LogCapture *)v336);
      goto LABEL_32;
    }
LABEL_25:
    p_d_type = &v5->d_type;
LABEL_32:
    if ( *p_d_type == 10 )
    {
      sub_13144(v5->d_name, (unsigned __int8 *)v321, v299);
      memset(&buf[14], 0, 32);
      if ( (v299[0] & 1) != 0 )
        v18 = (const char *)v300;
      else
        v18 = (char *)v299 + 1;
      memset(buf, 0, 224);
      if ( readlink(v18, (char *)buf, 0x100uLL) == -1 )
      {
        v295 = dword_2A120;
        if ( (word_2A128 & 1) != 0 )
          v30 = (const char *)qword_2A138;
        else
          v30 = (char *)&word_2A128 + 1;
        v296 = 0LL;
        v297 = 0LL;
        v298 = 0LL;
        v31 = strlen(v30);
        if ( v31 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v32 = v31;
        if ( v31 >= 0x17 )
        {
          v40 = (v31 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v33 = (char *)operator new(v40);
          v298 = v33;
          v296 = v40 | 1;
          v297 = v32;
        }
        else
        {
          v33 = (char *)&v296 + 1;
          LOBYTE(v296) = 2 * v31;
          if ( !v31 )
          {
LABEL_74:
            v33[v32] = 0;
            if ( (g3::logLevel(&v295) & 1) == 0 )
            {
              v45 = 0;
              if ( (v296 & 1) == 0 )
                goto LABEL_106;
              goto LABEL_80;
            }
            v41 = TAG;
            v294 = 0LL;
            v293 = 0LL;
            v292 = 0LL;
            v42 = strlen((const char *)TAG);
            if ( v42 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v43 = v42;
            if ( v42 >= 0x17 )
            {
              v48 = (v42 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v44 = (char *)operator new(v48);
              v294 = v44;
              v292 = v48 | 1;
              v293 = v43;
            }
            else
            {
              v44 = (char *)&v292 + 1;
              LOBYTE(v292) = 2 * v42;
              if ( !v42 )
              {
LABEL_104:
                v44[v43] = 0;
                v45 = g3::logTag(&v292);
                if ( (v292 & 1) != 0 )
                {
                  operator delete(v294);
                  if ( (v296 & 1) != 0 )
                    goto LABEL_80;
LABEL_106:
                  if ( (v45 & 1) != 0 )
                    goto LABEL_107;
                }
                else
                {
                  if ( (v296 & 1) == 0 )
                    goto LABEL_106;
LABEL_80:
                  operator delete(v298);
                  if ( (v45 & 1) != 0 )
                  {
LABEL_107:
                    v49 = LogCapture::LogCapture(
                            (LogCapture *)v336,
                            (const char *)TAG,
                            (const LEVELS *)&dword_2A120,
                            "",
                            6,
                            0LL);
                    v50 = *(unsigned int *)__errno(v49);
                    if ( (v299[0] & 1) != 0 )
                      v51 = (const char *)v300;
                    else
                      v51 = (char *)v299 + 1;
                    LogCapture::capturef((LogCapture *)v336, "readlink error,errno=%d, path=%s", v50, v51);
                    LogCapture::~LogCapture((LogCapture *)v336);
                  }
                }
                v47 = 2;
                if ( (v299[0] & 1) == 0 )
                  goto LABEL_94;
LABEL_93:
                operator delete(v300);
                goto LABEL_94;
              }
            }
            memcpy(v44, v41, v43);
            goto LABEL_104;
          }
        }
        memcpy(v33, v30, v32);
        goto LABEL_74;
      }
      sub_13144((char *)buf, (unsigned __int8 *)v321, v336);
      v19 = std::string::append(v336, "/../../../../idProduct", 0x16uLL);
      v20 = *(_OWORD *)v19;
      v291 = (void *)v19[2];
      v290 = v20;
      v19[1] = 0LL;
      v19[2] = 0LL;
      *v19 = 0LL;
      if ( (v336[0] & 1) != 0 )
        operator delete(v337);
      sub_13144((char *)buf, (unsigned __int8 *)v321, v336);
      v21 = std::string::append(v336, "/../../../../idVendor", 0x15uLL);
      v22 = *(_OWORD *)v21;
      v289 = (void *)v21[2];
      v288 = v22;
      v21[1] = 0LL;
      v21[2] = 0LL;
      *v21 = 0LL;
      if ( (v336[0] & 1) != 0 )
        operator delete(v337);
      sub_13144((char *)buf, (unsigned __int8 *)v321, v336);
      v23 = std::string::append(v336, "/../../../../product", 0x14uLL);
      v24 = *(_OWORD *)v23;
      v287 = (void *)v23[2];
      v286 = v24;
      v23[1] = 0LL;
      v23[2] = 0LL;
      *v23 = 0LL;
      if ( (v336[0] & 1) != 0 )
        operator delete(v337);
      sub_13250((__int64)v336, (__int64)&v290, 8);
      sub_13250((__int64)v333, (__int64)&v288, 8);
      sub_13250((__int64)v330, (__int64)&v286, 8);
      v25 = *(_QWORD *)(v336[0] - 24);
      if ( (v338[v25 + 8] & 5) != 0
        || (v334[*(_QWORD *)(v333[0] - 24) + 8] & 5) != 0
        || (v331[*(_QWORD *)(v330[0] - 24) + 8] & 5) != 0 )
      {
        v282 = dword_2A120;
        if ( (word_2A128 & 1) != 0 )
          v26 = (const char *)qword_2A138;
        else
          v26 = (char *)&word_2A128 + 1;
        v283 = 0LL;
        v284 = 0LL;
        v285 = 0LL;
        v27 = strlen(v26);
        if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v28 = v27;
        if ( v27 >= 0x17 )
        {
          v34 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v29 = (char *)operator new(v34);
          v285 = v29;
          v283 = v34 | 1;
          v284 = v28;
        }
        else
        {
          v29 = (char *)&v283 + 1;
          LOBYTE(v283) = 2 * v27;
          if ( !v27 )
          {
LABEL_64:
            v29[v28] = 0;
            if ( (g3::logLevel(&v282) & 1) == 0 )
            {
              v39 = 0;
              if ( (v283 & 1) == 0 )
                goto LABEL_86;
              goto LABEL_70;
            }
            v35 = TAG;
            v281 = 0LL;
            v280 = 0LL;
            v279 = 0LL;
            v36 = strlen((const char *)TAG);
            if ( v36 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v37 = v36;
            if ( v36 >= 0x17 )
            {
              v46 = (v36 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v38 = (char *)operator new(v46);
              v281 = v38;
              v279 = v46 | 1;
              v280 = v37;
            }
            else
            {
              v38 = (char *)&v279 + 1;
              LOBYTE(v279) = 2 * v36;
              if ( !v36 )
              {
LABEL_84:
                v38[v37] = 0;
                v39 = g3::logTag(&v279);
                if ( (v279 & 1) != 0 )
                {
                  operator delete(v281);
                  if ( (v283 & 1) != 0 )
                    goto LABEL_70;
LABEL_86:
                  if ( (v39 & 1) != 0 )
                    goto LABEL_87;
                }
                else
                {
                  if ( (v283 & 1) == 0 )
                    goto LABEL_86;
LABEL_70:
                  operator delete(v285);
                  if ( (v39 & 1) != 0 )
                  {
LABEL_87:
                    LogCapture::LogCapture(
                      (LogCapture *)&v325,
                      (const char *)TAG,
                      (const LEVELS *)&dword_2A120,
                      "",
                      6,
                      0LL);
                    LogCapture::capturef((LogCapture *)&v325, "stream open fail");
                    LogCapture::~LogCapture((LogCapture *)&v325);
                  }
                }
                v47 = 2;
                goto LABEL_89;
              }
            }
            memcpy(v38, v35, v37);
            goto LABEL_84;
          }
        }
        memcpy(v29, v26, v28);
        goto LABEL_64;
      }
      v277 = 0LL;
      v276 = 0LL;
      v278 = 0LL;
      std::string::__init<std::istreambuf_iterator<char>>(&v276, *(_QWORD **)&v338[v25 + 16], 0LL);
      v52 = *(_QWORD *)(v333[0] - 24);
      v275 = 0LL;
      v274 = 0LL;
      v273 = 0LL;
      std::string::__init<std::istreambuf_iterator<char>>(&v273, *(_QWORD **)&v334[v52 + 16], 0LL);
      v53 = *(_QWORD *)(v330[0] - 24);
      v272 = 0LL;
      v271 = 0LL;
      v270 = 0LL;
      std::string::__init<std::istreambuf_iterator<char>>(&v270, *(_QWORD **)&v331[v53 + 16], 0LL);
      if ( (v276 & 1) != 0 )
        v54 = v277;
      else
        v54 = (unsigned __int64)(unsigned __int8)v276 >> 1;
      if ( v54 )
      {
        if ( (v276 & 1) != 0 )
        {
          --v277;
          v55 = (char *)v278 + v277;
        }
        else
        {
          v55 = (char *)&v276 + ((unsigned __int64)(unsigned __int8)v276 >> 1);
          LOBYTE(v276) = 2 * (((unsigned __int8)v276 >> 1) - 1);
        }
        *v55 = 0;
      }
      if ( (v273 & 1) != 0 )
        v56 = v274;
      else
        v56 = (unsigned __int64)(unsigned __int8)v273 >> 1;
      if ( v56 )
      {
        if ( (v273 & 1) != 0 )
        {
          --v274;
          v57 = (char *)v275 + v274;
        }
        else
        {
          v57 = (char *)&v273 + ((unsigned __int64)(unsigned __int8)v273 >> 1);
          LOBYTE(v273) = 2 * (((unsigned __int8)v273 >> 1) - 1);
        }
        *v57 = 0;
      }
      if ( (v270 & 1) != 0 )
        v58 = v271;
      else
        v58 = (unsigned __int64)(unsigned __int8)v270 >> 1;
      if ( v58 )
      {
        if ( (v270 & 1) != 0 )
        {
          --v271;
          v59 = (char *)v272 + v271;
        }
        else
        {
          v59 = (char *)&v270 + ((unsigned __int64)(unsigned __int8)v270 >> 1);
          LOBYTE(v270) = 2 * (((unsigned __int8)v270 >> 1) - 1);
        }
        *v59 = 0;
      }
      std::operator+<char>((unsigned __int8 *)&v273, (unsigned __int8 *)&v276, v268);
      v264 = dword_2A120;
      if ( (word_2A128 & 1) != 0 )
        v60 = (const char *)qword_2A138;
      else
        v60 = (char *)&word_2A128 + 1;
      v265 = 0LL;
      v266 = 0LL;
      v267 = 0LL;
      v61 = strlen(v60);
      if ( v61 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v62 = v61;
      if ( v61 >= 0x17 )
      {
        v64 = (v61 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v63 = (char *)operator new(v64);
        v267 = v63;
        v265 = v64 | 1;
        v266 = v62;
LABEL_147:
        memcpy(v63, v60, v62);
        goto LABEL_148;
      }
      v63 = (char *)&v265 + 1;
      LOBYTE(v265) = 2 * v61;
      if ( v61 )
        goto LABEL_147;
LABEL_148:
      v63[v62] = 0;
      if ( (g3::logLevel(&v264) & 1) == 0 )
      {
        v69 = 0;
        if ( (v265 & 1) == 0 )
          goto LABEL_160;
        goto LABEL_154;
      }
      v65 = TAG;
      v263 = 0LL;
      v262 = 0LL;
      v261 = 0LL;
      v66 = strlen((const char *)TAG);
      if ( v66 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v67 = v66;
      if ( v66 >= 0x17 )
      {
        v70 = (v66 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v68 = (char *)operator new(v70);
        v263 = v68;
        v261 = v70 | 1;
        v262 = v67;
LABEL_157:
        memcpy(v68, v65, v67);
        goto LABEL_158;
      }
      v68 = (char *)&v261 + 1;
      LOBYTE(v261) = 2 * v66;
      if ( v66 )
        goto LABEL_157;
LABEL_158:
      v68[v67] = 0;
      v69 = g3::logTag(&v261);
      if ( (v261 & 1) != 0 )
      {
        operator delete(v263);
        if ( (v265 & 1) == 0 )
        {
LABEL_160:
          if ( (v69 & 1) == 0 )
            goto LABEL_165;
          goto LABEL_161;
        }
      }
      else if ( (v265 & 1) == 0 )
      {
        goto LABEL_160;
      }
LABEL_154:
      operator delete(v267);
      if ( (v69 & 1) == 0 )
        goto LABEL_165;
LABEL_161:
      LogCapture::LogCapture((LogCapture *)&v325, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      if ( (v268[0] & 1) != 0 )
        v71 = (const char *)v269;
      else
        v71 = (char *)v268 + 1;
      LogCapture::capturef((LogCapture *)&v325, "tmp_dev_vid: %s", v71);
      LogCapture::~LogCapture((LogCapture *)&v325);
LABEL_165:
      v257 = dword_2A120;
      if ( (word_2A128 & 1) != 0 )
        v72 = (const char *)qword_2A138;
      else
        v72 = (char *)&word_2A128 + 1;
      v258 = 0LL;
      v259 = 0LL;
      v260 = 0LL;
      v73 = strlen(v72);
      if ( v73 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v74 = v73;
      if ( v73 >= 0x17 )
      {
        v76 = (v73 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v75 = (char *)operator new(v76);
        v260 = v75;
        v258 = v76 | 1;
        v259 = v74;
LABEL_173:
        memcpy(v75, v72, v74);
        goto LABEL_174;
      }
      v75 = (char *)&v258 + 1;
      LOBYTE(v258) = 2 * v73;
      if ( v73 )
        goto LABEL_173;
LABEL_174:
      v75[v74] = 0;
      if ( (g3::logLevel(&v257) & 1) == 0 )
      {
        v81 = 0;
        if ( (v258 & 1) == 0 )
          goto LABEL_188;
        goto LABEL_180;
      }
      v77 = TAG;
      v256 = 0LL;
      v255 = 0LL;
      v254 = 0LL;
      v78 = strlen((const char *)TAG);
      if ( v78 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v79 = v78;
      if ( v78 >= 0x17 )
      {
        v82 = (v78 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v80 = (char *)operator new(v82);
        v256 = v80;
        v254 = v82 | 1;
        v255 = v79;
LABEL_185:
        memcpy(v80, v77, v79);
        goto LABEL_186;
      }
      v80 = (char *)&v254 + 1;
      LOBYTE(v254) = 2 * v78;
      if ( v78 )
        goto LABEL_185;
LABEL_186:
      v80[v79] = 0;
      v81 = g3::logTag(&v254);
      if ( (v254 & 1) != 0 )
      {
        operator delete(v256);
        if ( (v258 & 1) == 0 )
        {
LABEL_188:
          if ( (v81 & 1) == 0 )
            goto LABEL_193;
          goto LABEL_189;
        }
      }
      else if ( (v258 & 1) == 0 )
      {
        goto LABEL_188;
      }
LABEL_180:
      operator delete(v260);
      if ( (v81 & 1) == 0 )
        goto LABEL_193;
LABEL_189:
      LogCapture::LogCapture((LogCapture *)&v325, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      if ( (v318 & 1) != 0 )
        v83 = (const char *)v320;
      else
        v83 = v319;
      LogCapture::capturef((LogCapture *)&v325, "dev_vid:%s", v83);
      LogCapture::~LogCapture((LogCapture *)&v325);
LABEL_193:
      v250 = dword_2A120;
      if ( (word_2A128 & 1) != 0 )
        v84 = (const char *)qword_2A138;
      else
        v84 = (char *)&word_2A128 + 1;
      v251 = 0LL;
      v252 = 0LL;
      v253 = 0LL;
      v85 = strlen(v84);
      if ( v85 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v86 = v85;
      if ( v85 >= 0x17 )
      {
        v88 = (v85 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v87 = (char *)operator new(v88);
        v253 = v87;
        v251 = v88 | 1;
        v252 = v86;
LABEL_201:
        memcpy(v87, v84, v86);
        goto LABEL_202;
      }
      v87 = (char *)&v251 + 1;
      LOBYTE(v251) = 2 * v85;
      if ( v85 )
        goto LABEL_201;
LABEL_202:
      v87[v86] = 0;
      if ( (g3::logLevel(&v250) & 1) == 0 )
      {
        v93 = 0;
        if ( (v251 & 1) == 0 )
          goto LABEL_216;
        goto LABEL_208;
      }
      v89 = TAG;
      v249 = 0LL;
      v248 = 0LL;
      v247 = 0LL;
      v90 = strlen((const char *)TAG);
      if ( v90 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v91 = v90;
      if ( v90 >= 0x17 )
      {
        v94 = (v90 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v92 = (char *)operator new(v94);
        v249 = v92;
        v247 = v94 | 1;
        v248 = v91;
LABEL_213:
        memcpy(v92, v89, v91);
        goto LABEL_214;
      }
      v92 = (char *)&v247 + 1;
      LOBYTE(v247) = 2 * v90;
      if ( v90 )
        goto LABEL_213;
LABEL_214:
      v92[v91] = 0;
      v93 = g3::logTag(&v247);
      if ( (v247 & 1) != 0 )
      {
        operator delete(v249);
        if ( (v251 & 1) == 0 )
        {
LABEL_216:
          if ( (v93 & 1) == 0 )
            goto LABEL_221;
          goto LABEL_217;
        }
      }
      else if ( (v251 & 1) == 0 )
      {
        goto LABEL_216;
      }
LABEL_208:
      operator delete(v253);
      if ( (v93 & 1) == 0 )
        goto LABEL_221;
LABEL_217:
      LogCapture::LogCapture((LogCapture *)&v325, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      if ( (v270 & 1) != 0 )
        v95 = (const char *)v272;
      else
        v95 = (char *)&v270 + 1;
      LogCapture::capturef((LogCapture *)&v325, "pro_name:%s", v95);
      LogCapture::~LogCapture((LogCapture *)&v325);
LABEL_221:
      if ( (v268[0] & 1) != 0 )
        v96 = v268[1];
      else
        v96 = (unsigned __int64)LOBYTE(v268[0]) >> 1;
      if ( (v318 & 1) != 0 )
        v97 = *(_QWORD *)&v319[7];
      else
        v97 = (unsigned __int64)v318 >> 1;
      if ( v96 != v97 )
        goto LABEL_423;
      if ( (v268[0] & 1) != 0 )
        v98 = (char *)v269;
      else
        v98 = (char *)v268 + 1;
      if ( (v318 & 1) != 0 )
        v99 = (unsigned __int8 *)v320;
      else
        v99 = v319;
      if ( (v268[0] & 1) != 0 )
      {
        if ( v96 && memcmp(v98, v99, v96) )
          goto LABEL_423;
      }
      else if ( v96 )
      {
        v100 = -(__int64)((unsigned __int64)LOBYTE(v268[0]) >> 1);
        v101 = (unsigned __int8 *)v268 + 1;
        while ( *v101 == *v99 )
        {
          ++v101;
          ++v100;
          ++v99;
          if ( !v100 )
            goto LABEL_244;
        }
        goto LABEL_423;
      }
LABEL_244:
      if ( (v315 & 1) != 0 )
        v102 = v316;
      else
        v102 = (unsigned __int64)(unsigned __int8)v315 >> 1;
      if ( (v270 & 1) != 0 )
        v103 = v271;
      else
        v103 = (unsigned __int64)(unsigned __int8)v270 >> 1;
      if ( v102 != v103 )
        goto LABEL_423;
      if ( (v315 & 1) != 0 )
        v104 = (char *)v317;
      else
        v104 = (char *)&v315 + 1;
      if ( (v270 & 1) != 0 )
        v105 = (unsigned __int8 *)v272;
      else
        v105 = (unsigned __int8 *)&v270 + 1;
      if ( (v315 & 1) != 0 )
      {
        if ( v102 && memcmp(v104, v105, v102) )
          goto LABEL_423;
      }
      else if ( v102 )
      {
        v106 = -(__int64)((unsigned __int64)(unsigned __int8)v315 >> 1);
        v107 = (unsigned __int8 *)&v315 + 1;
        while ( *v107 == *v105 )
        {
          ++v107;
          ++v106;
          ++v105;
          if ( !v106 )
            goto LABEL_265;
        }
LABEL_423:
        v47 = 0;
        goto LABEL_424;
      }
LABEL_265:
      if ( !a1 )
      {
        sub_13144((char *)buf, (unsigned __int8 *)v321, (__int64 *)&v325);
        v120 = std::string::append((__int64 *)&v325, "/../../../../devnum", 0x13uLL);
        v121 = *(_OWORD *)v120;
        v246 = (void *)v120[2];
        v245 = v121;
        v120[1] = 0LL;
        v120[2] = 0LL;
        *v120 = 0LL;
        if ( (v325 & 1) != 0 )
          operator delete(v327);
        sub_13250((__int64)&v325, (__int64)&v245, 8);
        v122 = *(_QWORD *)(v325 - 24);
        if ( (v328[v122 + 8] & 5) != 0 )
          goto LABEL_287;
        v243 = 0LL;
        v242 = 0LL;
        v244 = 0LL;
        std::string::__init<std::istreambuf_iterator<char>>(&v242, *(_QWORD **)&v328[v122 + 16], 0LL);
        v129 = v243;
        v130 = (unsigned __int64)(unsigned __int8)v242 >> 1;
        if ( (v242 & 1) != 0 )
          v131 = v243;
        else
          v131 = (unsigned __int64)(unsigned __int8)v242 >> 1;
        v114 = v242 & 1;
        if ( !v131 )
          goto LABEL_304;
        if ( (v242 & 1) != 0 )
        {
          --v243;
          v132 = (char *)v244 + v129 - 1;
        }
        else
        {
          v132 = (char *)&v242 + v130;
          LOBYTE(v242) = 2 * (v130 - 1);
        }
        *v132 = 0;
        v231 = dword_2A120;
        if ( (word_2A128 & 1) != 0 )
          v149 = (const char *)qword_2A138;
        else
          v149 = (char *)&word_2A128 + 1;
        v232 = 0LL;
        v233 = 0LL;
        v234 = 0LL;
        v150 = strlen(v149);
        if ( v150 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v151 = v150;
        if ( v150 >= 0x17 )
        {
          v157 = (v150 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v152 = (char *)operator new(v157);
          v234 = v152;
          v232 = v157 | 1;
          v233 = v151;
        }
        else
        {
          v152 = (char *)&v232 + 1;
          LOBYTE(v232) = 2 * v150;
          if ( !v150 )
          {
LABEL_360:
            v152[v151] = 0;
            if ( (g3::logLevel(&v231) & 1) != 0 )
            {
              v158 = TAG;
              v230 = 0LL;
              v229 = 0LL;
              v228 = 0LL;
              v159 = strlen((const char *)TAG);
              if ( v159 >= 0xFFFFFFFFFFFFFFF0LL )
                std::__basic_string_common<true>::__throw_length_error();
              v160 = v159;
              if ( v159 >= 0x17 )
              {
                v181 = (v159 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                v161 = (char *)operator new(v181);
                v230 = v161;
                v228 = v181 | 1;
                v229 = v160;
              }
              else
              {
                v161 = (char *)&v228 + 1;
                LOBYTE(v228) = 2 * v159;
                if ( !v159 )
                {
LABEL_398:
                  v161[v160] = 0;
                  v167 = g3::logTag(&v228);
                  if ( (v228 & 1) != 0 )
                  {
                    operator delete(v230);
                    if ( (v232 & 1) == 0 )
                      goto LABEL_400;
                  }
                  else if ( (v232 & 1) == 0 )
                  {
                    goto LABEL_400;
                  }
LABEL_373:
                  operator delete(v234);
                  if ( (v167 & 1) == 0 )
                    goto LABEL_415;
                  goto LABEL_401;
                }
              }
              memcpy(v161, v158, v160);
              goto LABEL_398;
            }
            v167 = 0;
            if ( (v232 & 1) != 0 )
              goto LABEL_373;
LABEL_400:
            if ( (v167 & 1) == 0 )
              goto LABEL_415;
LABEL_401:
            LogCapture::LogCapture((LogCapture *)&v322, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
            if ( (v242 & 1) != 0 )
              v182 = (const char *)v244;
            else
              v182 = (char *)&v242 + 1;
            LogCapture::capturef((LogCapture *)&v322, "get devnum success::%s", v182);
LABEL_414:
            LogCapture::~LogCapture((LogCapture *)&v322);
LABEL_415:
            v185 = v242 & 1;
            if ( v185 )
              v186 = (const char *)v244;
            else
              v186 = (char *)&v242 + 1;
            v47 = 1;
            v212 = atoi(v186);
            if ( !v185 )
              goto LABEL_420;
            goto LABEL_419;
          }
        }
        memcpy(v152, v149, v151);
        goto LABEL_360;
      }
      if ( a1 != 1 )
      {
        if ( a1 != 2 )
          goto LABEL_423;
        sub_13144((char *)buf, (unsigned __int8 *)v321, (__int64 *)&v325);
        v108 = std::string::append((__int64 *)&v325, "/../../../../busnum", 0x13uLL);
        v109 = *(_OWORD *)v108;
        v246 = (void *)v108[2];
        v245 = v109;
        v108[1] = 0LL;
        v108[2] = 0LL;
        *v108 = 0LL;
        if ( (v325 & 1) != 0 )
          operator delete(v327);
        sub_13250((__int64)&v325, (__int64)&v245, 8);
        v110 = *(_QWORD *)(v325 - 24);
        if ( (v328[v110 + 8] & 5) == 0 )
        {
          v243 = 0LL;
          v242 = 0LL;
          v244 = 0LL;
          std::string::__init<std::istreambuf_iterator<char>>(&v242, *(_QWORD **)&v328[v110 + 16], 0LL);
          v111 = v243;
          v112 = (unsigned __int64)(unsigned __int8)v242 >> 1;
          if ( (v242 & 1) != 0 )
            v113 = v243;
          else
            v113 = (unsigned __int64)(unsigned __int8)v242 >> 1;
          v114 = v242 & 1;
          if ( v113 )
          {
            if ( (v242 & 1) != 0 )
            {
              --v243;
              v115 = (char *)v244 + v111 - 1;
            }
            else
            {
              v115 = (char *)&v242 + v112;
              LOBYTE(v242) = 2 * (v112 - 1);
            }
            *v115 = 0;
            v238 = dword_2A120;
            if ( (word_2A128 & 1) != 0 )
              v153 = (const char *)qword_2A138;
            else
              v153 = (char *)&word_2A128 + 1;
            v239 = 0LL;
            v240 = 0LL;
            v241 = 0LL;
            v154 = strlen(v153);
            if ( v154 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v155 = v154;
            if ( v154 >= 0x17 )
            {
              v162 = (v154 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v156 = (char *)operator new(v162);
              v241 = v156;
              v239 = v162 | 1;
              v240 = v155;
            }
            else
            {
              v156 = (char *)&v239 + 1;
              LOBYTE(v239) = 2 * v154;
              if ( !v154 )
              {
LABEL_367:
                v156[v155] = 0;
                if ( (g3::logLevel(&v238) & 1) == 0 )
                {
                  v168 = 0;
                  if ( (v239 & 1) == 0 )
                    goto LABEL_409;
                  goto LABEL_376;
                }
                v163 = TAG;
                v237 = 0LL;
                v236 = 0LL;
                v235 = 0LL;
                v164 = strlen((const char *)TAG);
                if ( v164 >= 0xFFFFFFFFFFFFFFF0LL )
                  std::__basic_string_common<true>::__throw_length_error();
                v165 = v164;
                if ( v164 >= 0x17 )
                {
                  v183 = (v164 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                  v166 = (char *)operator new(v183);
                  v237 = v166;
                  v235 = v183 | 1;
                  v236 = v165;
                }
                else
                {
                  v166 = (char *)&v235 + 1;
                  LOBYTE(v235) = 2 * v164;
                  if ( !v164 )
                  {
LABEL_407:
                    v166[v165] = 0;
                    v168 = g3::logTag(&v235);
                    if ( (v235 & 1) != 0 )
                    {
                      operator delete(v237);
                      if ( (v239 & 1) != 0 )
                        goto LABEL_376;
LABEL_409:
                      if ( (v168 & 1) != 0 )
                        goto LABEL_410;
                    }
                    else
                    {
                      if ( (v239 & 1) == 0 )
                        goto LABEL_409;
LABEL_376:
                      operator delete(v241);
                      if ( (v168 & 1) != 0 )
                      {
LABEL_410:
                        LogCapture::LogCapture(
                          (LogCapture *)&v322,
                          (const char *)TAG,
                          (const LEVELS *)&dword_2A120,
                          "",
                          6,
                          0LL);
                        if ( (v242 & 1) != 0 )
                          v184 = (const char *)v244;
                        else
                          v184 = (char *)&v242 + 1;
                        LogCapture::capturef((LogCapture *)&v322, "get busnum success::%s", v184);
                        goto LABEL_414;
                      }
                    }
                    goto LABEL_415;
                  }
                }
                memcpy(v166, v163, v165);
                goto LABEL_407;
              }
            }
            memcpy(v156, v153, v155);
            goto LABEL_367;
          }
LABEL_304:
          v47 = 4;
          if ( !v114 )
          {
LABEL_420:
            v325 = (unsigned __int64)off_296D8;
            v329 = off_29728;
            v327 = (char *)off_29700;
            std::filebuf::~filebuf((__int64)v328);
            std::ios_base::~ios_base((std::ios_base *)&v329);
            if ( (v245 & 1) != 0 )
              operator delete(v246);
            if ( v47 == 4 )
              goto LABEL_423;
LABEL_424:
            if ( (v268[0] & 1) == 0 )
              goto LABEL_425;
            goto LABEL_462;
          }
LABEL_419:
          operator delete(v244);
          goto LABEL_420;
        }
LABEL_287:
        v47 = 2;
        goto LABEL_420;
      }
      v224 = dword_2A120;
      if ( (word_2A128 & 1) != 0 )
        v116 = (const char *)qword_2A138;
      else
        v116 = (char *)&word_2A128 + 1;
      v225 = 0LL;
      v226 = 0LL;
      v227 = 0LL;
      v117 = strlen(v116);
      if ( v117 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v118 = v117;
      if ( v117 >= 0x17 )
      {
        v123 = (v117 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v119 = (char *)operator new(v123);
        v227 = v119;
        v225 = v123 | 1;
        v226 = v118;
LABEL_289:
        memcpy(v119, v116, v118);
        goto LABEL_290;
      }
      v119 = (char *)&v225 + 1;
      LOBYTE(v225) = 2 * v117;
      if ( v117 )
        goto LABEL_289;
LABEL_290:
      v119[v118] = 0;
      if ( (g3::logLevel(&v224) & 1) == 0 )
      {
        v128 = 0;
        if ( (v225 & 1) == 0 )
          goto LABEL_310;
        goto LABEL_296;
      }
      v124 = TAG;
      v223 = 0LL;
      v222 = 0LL;
      v221 = 0LL;
      v125 = strlen((const char *)TAG);
      if ( v125 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v126 = v125;
      if ( v125 >= 0x17 )
      {
        v133 = (v125 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v127 = (char *)operator new(v133);
        v223 = v127;
        v221 = v133 | 1;
        v222 = v126;
LABEL_307:
        memcpy(v127, v124, v126);
        goto LABEL_308;
      }
      v127 = (char *)&v221 + 1;
      LOBYTE(v221) = 2 * v125;
      if ( v125 )
        goto LABEL_307;
LABEL_308:
      v127[v126] = 0;
      v128 = g3::logTag(&v221);
      if ( (v221 & 1) != 0 )
      {
        operator delete(v223);
        if ( (v225 & 1) == 0 )
        {
LABEL_310:
          if ( (v128 & 1) == 0 )
            goto LABEL_315;
          goto LABEL_311;
        }
      }
      else if ( (v225 & 1) == 0 )
      {
        goto LABEL_310;
      }
LABEL_296:
      operator delete(v227);
      if ( (v128 & 1) == 0 )
        goto LABEL_315;
LABEL_311:
      LogCapture::LogCapture((LogCapture *)&v325, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
      if ( (v318 & 1) != 0 )
        v134 = (const char *)v320;
      else
        v134 = v319;
      LogCapture::capturef((LogCapture *)&v325, "get devid success::%s", v134);
      LogCapture::~LogCapture((LogCapture *)&v325);
LABEL_315:
      v323 = 0LL;
      v322 = 0LL;
      v324 = 0LL;
      v135 = strlen((const char *)buf);
      if ( v135 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v136 = v135;
      if ( v135 >= 0x17 )
      {
        v138 = (v135 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v137 = (char *)operator new(v138);
        v324 = v137;
        v322 = v138 | 1;
        v323 = v136;
LABEL_320:
        memcpy(v137, buf, v136);
        goto LABEL_321;
      }
      v137 = (char *)&v322 + 1;
      LOBYTE(v322) = 2 * v135;
      if ( v135 )
        goto LABEL_320;
LABEL_321:
      v137[v136] = 0;
      v139 = (char *)v324;
      if ( (v322 & 1) != 0 )
      {
        v140 = v323;
      }
      else
      {
        v139 = (char *)&v322 + 1;
        v140 = (unsigned __int64)(unsigned __int8)v322 >> 1;
      }
      if ( v140 < 6 )
      {
LABEL_325:
        v47 = 2;
        if ( (v322 & 1) == 0 )
          goto LABEL_424;
        goto LABEL_461;
      }
      v141 = &v139[v140];
      v142 = 1LL;
      v143 = v140;
      while ( v139[--v143] != 66 )
      {
LABEL_332:
        ++v142;
        --v141;
        if ( v143 == 5 )
          goto LABEL_325;
      }
      v144 = 0LL;
      while ( v144 != -5 )
      {
        v145 = (unsigned __int8)v141[v144 - 2];
        v146 = (unsigned __int8)aDevTtyusb[v144-- + 9];
        if ( v145 != v146 )
          goto LABEL_332;
      }
      v47 = 2;
      if ( v142 != -5 && v140 - v142 != 4 )
      {
        v147 = v142 + 5;
        v326 = 0LL;
        v325 = 0LL;
        v327 = 0LL;
        if ( v140 < (unsigned __int64)(v140 - v142 - 5) )
          std::__basic_string_common<true>::__throw_out_of_range();
        if ( v147 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v213 = v140 - v142 - 5;
        if ( v147 >= 0x17 )
        {
          v148 = (char *)operator new((v142 + 21) & 0xFFFFFFFFFFFFFFF0LL);
          v327 = v148;
          v325 = (v147 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v326 = v147;
        }
        else
        {
          v148 = (char *)&v325 + 1;
          LOBYTE(v325) = 2 * v147;
        }
        memcpy(v148, v141 - 6, v147);
        v148[v147] = 0;
        v169 = std::string::insert((__int64 *)&v325, 0LL, "/dev/", 5uLL);
        v170 = *(_BYTE *)v169;
        *v169 = 0LL;
        v211 = v170;
        v210 = (void *)v169[2];
        v169[1] = 0LL;
        v169[2] = 0LL;
        if ( (v325 & 1) != 0 )
          operator delete(v327);
        v217 = dword_2A120;
        if ( (word_2A128 & 1) != 0 )
          v171 = (const char *)qword_2A138;
        else
          v171 = (char *)&word_2A128 + 1;
        v218 = 0LL;
        v219 = 0LL;
        v220 = 0LL;
        v172 = strlen(v171);
        if ( v172 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v173 = v172;
        if ( v172 >= 0x17 )
        {
          v175 = (v172 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v174 = (char *)operator new(v175);
          v220 = v174;
          v218 = v175 | 1;
          v219 = v173;
        }
        else
        {
          v174 = (char *)&v218 + 1;
          LOBYTE(v218) = 2 * v172;
          if ( !v172 )
          {
LABEL_390:
            v174[v173] = 0;
            if ( (g3::logLevel(&v217) & 1) != 0 )
            {
              v176 = TAG;
              v215 = 0LL;
              v216 = 0LL;
              v214 = 0LL;
              v177 = strlen((const char *)TAG);
              if ( v177 >= 0xFFFFFFFFFFFFFFF0LL )
                std::__basic_string_common<true>::__throw_length_error();
              v178 = v177;
              if ( v177 >= 0x17 )
              {
                v187 = (v177 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                v179 = (char *)operator new(v187);
                v215 = v178;
                v216 = v179;
                v214 = v187 | 1;
              }
              else
              {
                v179 = (char *)&v214 + 1;
                LOBYTE(v214) = 2 * v177;
                if ( !v177 )
                  goto LABEL_435;
              }
              memcpy(v179, v176, v178);
LABEL_435:
              v179[v178] = 0;
              v180 = g3::logTag(&v214);
              if ( (v214 & 1) != 0 )
                operator delete(v216);
            }
            else
            {
              v180 = 0;
            }
            v188 = v213;
            if ( (v218 & 1) != 0 )
              operator delete(v220);
            if ( (v180 & 1) != 0 )
            {
              LogCapture::LogCapture((LogCapture *)&v325, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
              if ( (v322 & 1) != 0 )
                v189 = (const char *)v324;
              else
                v189 = (char *)&v322 + 1;
              LogCapture::capturef((LogCapture *)&v325, "tty_path:%s", v189);
              LogCapture::~LogCapture((LogCapture *)&v325);
              v188 = v213;
            }
            v190 = v323;
            v191 = v188 + 6;
            v326 = 0LL;
            if ( (v322 & 1) == 0 )
              v190 = (unsigned __int64)(unsigned __int8)v322 >> 1;
            v192 = v190 - v191;
            v325 = 0LL;
            v327 = 0LL;
            if ( v190 < v191 )
              std::__basic_string_common<true>::__throw_out_of_range();
            if ( (v322 & 1) != 0 )
              v193 = (char *)v324;
            else
              v193 = (char *)&v322 + 1;
            if ( v192 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            if ( v192 >= 0x17 )
            {
              v194 = (char *)operator new((v192 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v327 = v194;
              v325 = (v192 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v326 = v192;
            }
            else
            {
              v194 = (char *)&v325 + 1;
              LOBYTE(v325) = 2 * v192;
              if ( !v192 )
              {
LABEL_456:
                v194[v192] = 0;
                if ( (v325 & 1) != 0 )
                {
                  v195 = v327;
                  v212 = atoi(v327);
                  operator delete(v195);
                  if ( (v211 & 1) != 0 )
LABEL_458:
                    operator delete(v210);
                }
                else
                {
                  v212 = atoi((const char *)&v325 + 1);
                  if ( (v211 & 1) != 0 )
                    goto LABEL_458;
                }
                v47 = 1;
                goto LABEL_460;
              }
            }
            memcpy(v194, &v193[v191], v192);
            goto LABEL_456;
          }
        }
        memcpy(v174, v171, v173);
        goto LABEL_390;
      }
LABEL_460:
      if ( (v322 & 1) == 0 )
        goto LABEL_424;
LABEL_461:
      operator delete(v324);
      if ( (v268[0] & 1) == 0 )
      {
LABEL_425:
        if ( (v270 & 1) == 0 )
          goto LABEL_426;
        goto LABEL_463;
      }
LABEL_462:
      operator delete(v269);
      if ( (v270 & 1) == 0 )
      {
LABEL_426:
        if ( (v273 & 1) != 0 )
          goto LABEL_464;
        goto LABEL_427;
      }
LABEL_463:
      operator delete(v272);
      if ( (v273 & 1) != 0 )
      {
LABEL_464:
        operator delete(v275);
        if ( (v276 & 1) == 0 )
          goto LABEL_89;
        goto LABEL_465;
      }
LABEL_427:
      if ( (v276 & 1) == 0 )
        goto LABEL_89;
LABEL_465:
      operator delete(v278);
LABEL_89:
      v330[0] = (__int64)off_296D8;
      v332 = off_29728;
      v330[2] = (__int64)off_29700;
      std::filebuf::~filebuf((__int64)v331);
      std::ios_base::~ios_base((std::ios_base *)&v332);
      v333[0] = (__int64)off_296D8;
      v335 = off_29728;
      v333[2] = (__int64)off_29700;
      std::filebuf::~filebuf((__int64)v334);
      std::ios_base::~ios_base((std::ios_base *)&v335);
      v336[0] = (__int64)off_296D8;
      v339 = off_29728;
      v337 = off_29700;
      std::filebuf::~filebuf((__int64)v338);
      std::ios_base::~ios_base((std::ios_base *)&v339);
      if ( (v286 & 1) != 0 )
      {
        operator delete(v287);
        if ( (v288 & 1) == 0 )
        {
LABEL_91:
          if ( (v290 & 1) != 0 )
            goto LABEL_98;
          goto LABEL_92;
        }
      }
      else if ( (v288 & 1) == 0 )
      {
        goto LABEL_91;
      }
      operator delete(v289);
      if ( (v290 & 1) != 0 )
      {
LABEL_98:
        operator delete(v291);
        if ( (v299[0] & 1) == 0 )
          goto LABEL_94;
        goto LABEL_93;
      }
LABEL_92:
      if ( (v299[0] & 1) != 0 )
        goto LABEL_93;
LABEL_94:
      if ( (v47 | 2) != 2 )
      {
        v197 = v212;
        goto LABEL_469;
      }
    }
  }
  v197 = -1;
LABEL_469:
  closedir(v4);
  if ( (v315 & 1) == 0 )
  {
    if ( (v318 & 1) == 0 )
      goto LABEL_471;
LABEL_475:
    operator delete(v320);
    if ( ((__int64)v321[0] & 1) == 0 )
      return v197;
LABEL_472:
    operator delete(v321[2]);
    return v197;
  }
  operator delete(v317);
  if ( (v318 & 1) != 0 )
    goto LABEL_475;
LABEL_471:
  if ( ((__int64)v321[0] & 1) != 0 )
    goto LABEL_472;
  return v197;
}
// 10688: conditional instruction was optimized away because x8.8>=6
// 10730: conditional instruction was optimized away because x10.8!=FFFFFFFFFFFFFFFB
// 10F44: variable 'v212' is possibly undefined
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;
// 2A1A0: using guessed type int dword_2A1A0;
// 2A1A8: using guessed type __int16 word_2A1A8;
// 2A1B8: using guessed type __int64 qword_2A1B8;

//----- (0000000000011998) ----------------------------------------------------
__int64 __fastcall pudutech::ESP32::set_interface_attribs(pudutech::ESP32 *this, int fd, speed_t a3, int a4)
{
  const char *v7; // x20
  size_t v8; // x0
  size_t v9; // x19
  char *v10; // x21
  __int64 result; // x0
  const char *v12; // x20
  size_t v13; // x0
  size_t v14; // x19
  char *v15; // x21
  unsigned __int64 v16; // x22
  const void *v17; // x19
  size_t v18; // x0
  size_t v19; // x20
  char *v20; // x21
  char v21; // w19
  unsigned __int64 v22; // x22
  LogCapture *v23; // x0
  unsigned int *v24; // x0
  unsigned __int64 v25; // x22
  const void *v26; // x19
  size_t v27; // x0
  size_t v28; // x20
  char *v29; // x21
  char v30; // w19
  unsigned __int64 v31; // x22
  LogCapture *v32; // x0
  unsigned int *v33; // x0
  unsigned __int64 v34; // [xsp+8h] [xbp-218h] BYREF
  size_t v35; // [xsp+10h] [xbp-210h]
  void *v36; // [xsp+18h] [xbp-208h]
  int v37; // [xsp+20h] [xbp-200h] BYREF
  unsigned __int64 v38; // [xsp+28h] [xbp-1F8h] BYREF
  size_t v39; // [xsp+30h] [xbp-1F0h]
  void *v40; // [xsp+38h] [xbp-1E8h]
  unsigned __int64 v41; // [xsp+40h] [xbp-1E0h] BYREF
  size_t v42; // [xsp+48h] [xbp-1D8h]
  void *v43; // [xsp+50h] [xbp-1D0h]
  int v44; // [xsp+58h] [xbp-1C8h] BYREF
  unsigned __int64 v45; // [xsp+60h] [xbp-1C0h] BYREF
  size_t v46; // [xsp+68h] [xbp-1B8h]
  void *v47; // [xsp+70h] [xbp-1B0h]
  char v48[328]; // [xsp+78h] [xbp-1A8h] BYREF
  struct termios termios_p; // [xsp+1C0h] [xbp-60h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  memset(&termios_p, 0, 36);
  if ( !tcgetattr(fd, &termios_p) )
  {
    cfsetospeed(&termios_p, a3);
    cfsetispeed(&termios_p, a3);
    *(_WORD *)&termios_p.c_cc[5] = 261;
    termios_p.c_iflag &= 0xFFFFE2FF;
    termios_p.c_oflag = 0;
    *(_QWORD *)&termios_p.c_cflag = a4 & 0x7FFFF70F | termios_p.c_cflag & 0x7FFFF40F | 0x8B0;
    result = tcsetattr(fd, 0, &termios_p);
    if ( !(_DWORD)result )
      return result;
    if ( (word_2A188 & 1) != 0 )
      v12 = (const char *)qword_2A198;
    else
      v12 = (char *)&word_2A188 + 1;
    v37 = dword_2A180;
    v39 = 0LL;
    v40 = 0LL;
    v38 = 0LL;
    v13 = strlen(v12);
    if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_56:
      std::__basic_string_common<true>::__throw_length_error();
    v14 = v13;
    if ( v13 >= 0x17 )
    {
      v25 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v15 = (char *)operator new(v25);
      v39 = v14;
      v40 = v15;
      v38 = v25 | 1;
    }
    else
    {
      v15 = (char *)&v38 + 1;
      LOBYTE(v38) = 2 * v13;
      if ( !v13 )
      {
LABEL_37:
        v15[v14] = 0;
        if ( (g3::logLevel(&v37) & 1) == 0 )
        {
          v30 = 0;
          if ( (v38 & 1) == 0 )
            goto LABEL_48;
          goto LABEL_51;
        }
        v35 = 0LL;
        v36 = 0LL;
        v34 = 0LL;
        v26 = TAG;
        v27 = strlen((const char *)TAG);
        if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v28 = v27;
        if ( v27 >= 0x17 )
        {
          v31 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v29 = (char *)operator new(v31);
          v35 = v28;
          v36 = v29;
          v34 = v31 | 1;
        }
        else
        {
          v29 = (char *)&v34 + 1;
          LOBYTE(v34) = 2 * v27;
          if ( !v27 )
          {
LABEL_46:
            v29[v28] = 0;
            v30 = g3::logTag(&v34);
            if ( (v34 & 1) != 0 )
            {
              operator delete(v36);
              if ( (v38 & 1) == 0 )
              {
LABEL_48:
                if ( (v30 & 1) == 0 )
                  return 0xFFFFFFFFLL;
                goto LABEL_52;
              }
            }
            else if ( (v38 & 1) == 0 )
            {
              goto LABEL_48;
            }
LABEL_51:
            operator delete(v40);
            if ( (v30 & 1) == 0 )
              return 0xFFFFFFFFLL;
LABEL_52:
            v32 = LogCapture::LogCapture((LogCapture *)v48, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
            v33 = (unsigned int *)__errno(v32);
            LogCapture::capturef((LogCapture *)v48, "error %d from tcsetattr", *v33);
            goto LABEL_53;
          }
        }
        memcpy(v29, v26, v28);
        goto LABEL_46;
      }
    }
    memcpy(v15, v12, v14);
    goto LABEL_37;
  }
  if ( (word_2A188 & 1) != 0 )
    v7 = (const char *)qword_2A198;
  else
    v7 = (char *)&word_2A188 + 1;
  v44 = dword_2A180;
  v46 = 0LL;
  v47 = 0LL;
  v45 = 0LL;
  v8 = strlen(v7);
  if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_56;
  v9 = v8;
  if ( v8 >= 0x17 )
  {
    v16 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = (char *)operator new(v16);
    v46 = v9;
    v47 = v10;
    v45 = v16 | 1;
    goto LABEL_18;
  }
  v10 = (char *)&v45 + 1;
  LOBYTE(v45) = 2 * v8;
  if ( v8 )
LABEL_18:
    memcpy(v10, v7, v9);
  v10[v9] = 0;
  if ( (g3::logLevel(&v44) & 1) != 0 )
  {
    v42 = 0LL;
    v43 = 0LL;
    v41 = 0LL;
    v17 = TAG;
    v18 = strlen((const char *)TAG);
    if ( v18 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v19 = v18;
    if ( v18 >= 0x17 )
    {
      v22 = (v18 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v20 = (char *)operator new(v22);
      v42 = v19;
      v43 = v20;
      v41 = v22 | 1;
    }
    else
    {
      v20 = (char *)&v41 + 1;
      LOBYTE(v41) = 2 * v18;
      if ( !v18 )
      {
LABEL_28:
        v20[v19] = 0;
        v21 = g3::logTag(&v41);
        if ( (v41 & 1) != 0 )
        {
          operator delete(v43);
          if ( (v45 & 1) == 0 )
          {
LABEL_30:
            if ( (v21 & 1) == 0 )
              return 0xFFFFFFFFLL;
            goto LABEL_34;
          }
        }
        else if ( (v45 & 1) == 0 )
        {
          goto LABEL_30;
        }
        goto LABEL_33;
      }
    }
    memcpy(v20, v17, v19);
    goto LABEL_28;
  }
  v21 = 0;
  if ( (v45 & 1) == 0 )
    goto LABEL_30;
LABEL_33:
  operator delete(v47);
  if ( (v21 & 1) != 0 )
  {
LABEL_34:
    v23 = LogCapture::LogCapture((LogCapture *)v48, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
    v24 = (unsigned int *)__errno(v23);
    LogCapture::capturef((LogCapture *)v48, "error %d from tcgetattr", *v24);
LABEL_53:
    LogCapture::~LogCapture((LogCapture *)v48);
  }
  return 0xFFFFFFFFLL;
}
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (0000000000011E98) ----------------------------------------------------
void __fastcall pudutech::ESP32::set_blocking(pudutech::ESP32 *this, int fd, cc_t a3)
{
  const char *v5; // x20
  size_t v6; // x0
  size_t v7; // x19
  char *v8; // x21
  const char *v9; // x20
  size_t v10; // x0
  size_t v11; // x19
  char *v12; // x21
  unsigned __int64 v13; // x22
  const void *v14; // x19
  size_t v15; // x0
  size_t v16; // x20
  char *v17; // x21
  char v18; // w19
  unsigned __int64 v19; // x22
  LogCapture *v20; // x0
  unsigned int *v21; // x0
  unsigned __int64 v22; // x22
  const void *v23; // x19
  size_t v24; // x0
  size_t v25; // x20
  char *v26; // x21
  char v27; // w19
  unsigned __int64 v28; // x22
  LogCapture *v29; // x0
  unsigned int *v30; // x0
  unsigned __int64 v31; // [xsp+8h] [xbp-218h] BYREF
  size_t v32; // [xsp+10h] [xbp-210h]
  void *v33; // [xsp+18h] [xbp-208h]
  int v34; // [xsp+20h] [xbp-200h] BYREF
  unsigned __int64 v35; // [xsp+28h] [xbp-1F8h] BYREF
  size_t v36; // [xsp+30h] [xbp-1F0h]
  void *v37; // [xsp+38h] [xbp-1E8h]
  unsigned __int64 v38; // [xsp+40h] [xbp-1E0h] BYREF
  size_t v39; // [xsp+48h] [xbp-1D8h]
  void *v40; // [xsp+50h] [xbp-1D0h]
  int v41; // [xsp+58h] [xbp-1C8h] BYREF
  unsigned __int64 v42; // [xsp+60h] [xbp-1C0h] BYREF
  size_t v43; // [xsp+68h] [xbp-1B8h]
  void *v44; // [xsp+70h] [xbp-1B0h]
  char v45[328]; // [xsp+78h] [xbp-1A8h] BYREF
  struct termios termios_p; // [xsp+1C0h] [xbp-60h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  memset(&termios_p, 0, 36);
  if ( !tcgetattr(fd, &termios_p) )
  {
    termios_p.c_cc[6] = a3;
    termios_p.c_cc[5] = 5;
    if ( !tcsetattr(fd, 0, &termios_p) )
      return;
    if ( (word_2A188 & 1) != 0 )
      v9 = (const char *)qword_2A198;
    else
      v9 = (char *)&word_2A188 + 1;
    v34 = dword_2A180;
    v36 = 0LL;
    v37 = 0LL;
    v35 = 0LL;
    v10 = strlen(v9);
    if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_55:
      std::__basic_string_common<true>::__throw_length_error();
    v11 = v10;
    if ( v10 >= 0x17 )
    {
      v22 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v12 = (char *)operator new(v22);
      v36 = v11;
      v37 = v12;
      v35 = v22 | 1;
    }
    else
    {
      v12 = (char *)&v35 + 1;
      LOBYTE(v35) = 2 * v10;
      if ( !v10 )
      {
LABEL_37:
        v12[v11] = 0;
        if ( (g3::logLevel(&v34) & 1) == 0 )
        {
          v27 = 0;
          if ( (v35 & 1) == 0 )
            goto LABEL_48;
          goto LABEL_51;
        }
        v32 = 0LL;
        v33 = 0LL;
        v31 = 0LL;
        v23 = TAG;
        v24 = strlen((const char *)TAG);
        if ( v24 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v25 = v24;
        if ( v24 >= 0x17 )
        {
          v28 = (v24 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v26 = (char *)operator new(v28);
          v32 = v25;
          v33 = v26;
          v31 = v28 | 1;
        }
        else
        {
          v26 = (char *)&v31 + 1;
          LOBYTE(v31) = 2 * v24;
          if ( !v24 )
          {
LABEL_46:
            v26[v25] = 0;
            v27 = g3::logTag(&v31);
            if ( (v31 & 1) != 0 )
            {
              operator delete(v33);
              if ( (v35 & 1) == 0 )
              {
LABEL_48:
                if ( (v27 & 1) == 0 )
                  return;
LABEL_52:
                v29 = LogCapture::LogCapture(
                        (LogCapture *)v45,
                        (const char *)TAG,
                        (const LEVELS *)&dword_2A180,
                        "",
                        6,
                        0LL);
                v30 = (unsigned int *)__errno(v29);
                LogCapture::capturef((LogCapture *)v45, "error %d setting term attributes", *v30);
                goto LABEL_53;
              }
            }
            else if ( (v35 & 1) == 0 )
            {
              goto LABEL_48;
            }
LABEL_51:
            operator delete(v37);
            if ( (v27 & 1) == 0 )
              return;
            goto LABEL_52;
          }
        }
        memcpy(v26, v23, v25);
        goto LABEL_46;
      }
    }
    memcpy(v12, v9, v11);
    goto LABEL_37;
  }
  if ( (word_2A188 & 1) != 0 )
    v5 = (const char *)qword_2A198;
  else
    v5 = (char *)&word_2A188 + 1;
  v41 = dword_2A180;
  v43 = 0LL;
  v44 = 0LL;
  v42 = 0LL;
  v6 = strlen(v5);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_55;
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v13 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v13);
    v43 = v7;
    v44 = v8;
    v42 = v13 | 1;
    goto LABEL_18;
  }
  v8 = (char *)&v42 + 1;
  LOBYTE(v42) = 2 * v6;
  if ( v6 )
LABEL_18:
    memcpy(v8, v5, v7);
  v8[v7] = 0;
  if ( (g3::logLevel(&v41) & 1) == 0 )
  {
    v18 = 0;
    if ( (v42 & 1) == 0 )
      goto LABEL_30;
    goto LABEL_33;
  }
  v39 = 0LL;
  v40 = 0LL;
  v38 = 0LL;
  v14 = TAG;
  v15 = strlen((const char *)TAG);
  if ( v15 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v16 = v15;
  if ( v15 >= 0x17 )
  {
    v19 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v17 = (char *)operator new(v19);
    v39 = v16;
    v40 = v17;
    v38 = v19 | 1;
    goto LABEL_27;
  }
  v17 = (char *)&v38 + 1;
  LOBYTE(v38) = 2 * v15;
  if ( v15 )
LABEL_27:
    memcpy(v17, v14, v16);
  v17[v16] = 0;
  v18 = g3::logTag(&v38);
  if ( (v38 & 1) == 0 )
  {
    if ( (v42 & 1) == 0 )
      goto LABEL_30;
LABEL_33:
    operator delete(v44);
    if ( (v18 & 1) == 0 )
      return;
    goto LABEL_34;
  }
  operator delete(v40);
  if ( (v42 & 1) != 0 )
    goto LABEL_33;
LABEL_30:
  if ( (v18 & 1) == 0 )
    return;
LABEL_34:
  v20 = LogCapture::LogCapture((LogCapture *)v45, (const char *)TAG, (const LEVELS *)&dword_2A180, "", 6, 0LL);
  v21 = (unsigned int *)__errno(v20);
  LogCapture::capturef((LogCapture *)v45, "error %d from tggetattr", *v21);
LABEL_53:
  LogCapture::~LogCapture((LogCapture *)v45);
}
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 79E0: using guessed type __int64 __fastcall __errno(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A180: using guessed type int dword_2A180;
// 2A188: using guessed type __int16 word_2A188;
// 2A198: using guessed type __int64 qword_2A198;

//----- (0000000000012344) ----------------------------------------------------
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  size_t v6; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x22
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24
  void *v12; // x1
  unsigned __int64 v14; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v6 = strlen(a1);
  v7 = *a2;
  if ( (v7 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v7 >> 1;
  v9 = v8 + v6;
  if ( v8 + v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v10 = v6;
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * v6;
    v11 = (char *)a3 + 1;
    if ( !v6 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v14 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v11 = (void *)operator new(v14);
  a3[1] = v10;
  a3[2] = (__int64)v11;
  *a3 = v14 | 1;
  if ( v10 )
LABEL_7:
    memcpy(v11, a1, v10);
LABEL_8:
  *((_BYTE *)v11 + v10) = 0;
  if ( (v7 & 1) != 0 )
    v12 = (void *)*((_QWORD *)a2 + 2);
  else
    v12 = a2 + 1;
  return std::string::append(a3, v12, v8);
}

//----- (0000000000012440) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  sub_12454("basic_string");
}

//----- (0000000000012454) ----------------------------------------------------
void __fastcall __noreturn sub_12454(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_124A4(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::length_error,
    (void (__fastcall *)(void *))&std::length_error::~length_error);
}

//----- (00000000000124A4) ----------------------------------------------------
__int64 __fastcall sub_124A4(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::length_error + 16;
  return result;
}

//----- (00000000000124D4) ----------------------------------------------------
void __fastcall `non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        __int64 a1)
{
  __int64 v1; // x20
  std::ios_base *v2; // x19
  char v3; // w9

  *(_QWORD *)(a1 - 16) = off_29430;
  v1 = a1 - 16;
  *(_QWORD *)(a1 + 112) = off_29480;
  v2 = (std::ios_base *)(a1 + 112);
  v3 = *(_BYTE *)(a1 + 72);
  *(_QWORD *)a1 = off_29458;
  *(_QWORD *)(a1 + 8) = off_295A8;
  if ( (v3 & 1) != 0 )
    operator delete(*(void **)(a1 + 88));
  *(_QWORD *)(v1 + 24) = off_29650;
  std::locale::~locale((std::locale *)(v1 + 32));
  std::ios_base::~ios_base(v2);
}
// 29430: using guessed type __int64 (__fastcall *off_29430[2])();
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (000000000001254C) ----------------------------------------------------
void __fastcall `virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        _QWORD *a1)
{
  char *v1; // x20
  char v2; // w9

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  *(_QWORD *)v1 = off_29430;
  *((_QWORD *)v1 + 16) = off_29480;
  v2 = v1[88];
  *((_QWORD *)v1 + 2) = off_29458;
  *((_QWORD *)v1 + 3) = off_295A8;
  if ( (v2 & 1) != 0 )
    operator delete(*((void **)v1 + 13));
  *((_QWORD *)v1 + 3) = off_29650;
  std::locale::~locale((std::locale *)(v1 + 32));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 128));
}
// 29430: using guessed type __int64 (__fastcall *off_29430[2])();
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (00000000000125CC) ----------------------------------------------------
void __fastcall std::istream::~istream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 16));
}

//----- (00000000000125D4) ----------------------------------------------------
void __fastcall std::istream::~istream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 16));
  operator delete((void *)a1);
}

//----- (00000000000125FC) ----------------------------------------------------
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1)
{
  std::ios_base::~ios_base((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 16));
}

//----- (0000000000012610) ----------------------------------------------------
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1)
{
  char *v1; // x19

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  std::ios_base::~ios_base((std::ios_base *)(v1 + 16));
  operator delete(v1);
}

//----- (0000000000012640) ----------------------------------------------------
void __fastcall std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        char *a1)
{
  char v1; // w10

  v1 = a1[88];
  *(_QWORD *)a1 = off_29430;
  *((_QWORD *)a1 + 16) = off_29480;
  *((_QWORD *)a1 + 2) = off_29458;
  *((_QWORD *)a1 + 3) = off_295A8;
  if ( (v1 & 1) != 0 )
    operator delete(*((void **)a1 + 13));
  *((_QWORD *)a1 + 3) = off_29650;
  std::locale::~locale((std::locale *)(a1 + 32));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 128));
  operator delete(a1);
}
// 29430: using guessed type __int64 (__fastcall *off_29430[2])();
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (00000000000126BC) ----------------------------------------------------
void __fastcall `non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        __int64 a1)
{
  _QWORD *v1; // x19
  std::ios_base *v2; // x20
  char v3; // w9

  *(_QWORD *)(a1 - 16) = off_29430;
  v1 = (_QWORD *)(a1 - 16);
  *(_QWORD *)(a1 + 112) = off_29480;
  v2 = (std::ios_base *)(a1 + 112);
  v3 = *(_BYTE *)(a1 + 72);
  *(_QWORD *)a1 = off_29458;
  *(_QWORD *)(a1 + 8) = off_295A8;
  if ( (v3 & 1) != 0 )
    operator delete(*(void **)(a1 + 88));
  v1[3] = off_29650;
  std::locale::~locale((std::locale *)(v1 + 4));
  std::ios_base::~ios_base(v2);
  operator delete(v1);
}
// 29430: using guessed type __int64 (__fastcall *off_29430[2])();
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (000000000001273C) ----------------------------------------------------
void __fastcall `virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(
        _QWORD *a1)
{
  char *v1; // x19
  char v2; // w9

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  *(_QWORD *)v1 = off_29430;
  *((_QWORD *)v1 + 16) = off_29480;
  v2 = v1[88];
  *((_QWORD *)v1 + 2) = off_29458;
  *((_QWORD *)v1 + 3) = off_295A8;
  if ( (v2 & 1) != 0 )
    operator delete(*((void **)v1 + 13));
  *((_QWORD *)v1 + 3) = off_29650;
  std::locale::~locale((std::locale *)(v1 + 32));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 128));
  operator delete(v1);
}
// 29430: using guessed type __int64 (__fastcall *off_29430[2])();
// 29458: using guessed type __int64 (__fastcall *off_29458[2])();
// 29480: using guessed type __int64 (__fastcall *off_29480[2])();
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (00000000000127C4) ----------------------------------------------------
void __fastcall std::stringbuf::~stringbuf(__int64 a1)
{
  char v1; // w8

  v1 = *(_BYTE *)(a1 + 64);
  *(_QWORD *)a1 = off_295A8;
  if ( (v1 & 1) != 0 )
    operator delete(*(void **)(a1 + 80));
  *(_QWORD *)a1 = off_29650;
  std::locale::~locale((std::locale *)(a1 + 8));
}
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (0000000000012814) ----------------------------------------------------
void __fastcall std::stringbuf::~stringbuf(void **a1)
{
  char v1; // w8

  v1 = *((_BYTE *)a1 + 64);
  *a1 = off_295A8;
  if ( (v1 & 1) != 0 )
    operator delete(a1[10]);
  *a1 = off_29650;
  std::locale::~locale((std::locale *)(a1 + 1));
  operator delete(a1);
}
// 295A8: using guessed type __int64 (__fastcall *off_295A8[8])();
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (0000000000012874) ----------------------------------------------------
__int64 __fastcall std::stringbuf::seekoff(__int64 a1, __int64 a2, int a3, char a4)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 v7; // x10
  __int64 v8; // x11
  __int64 v9; // x11

  v4 = *(_QWORD *)(a1 + 88);
  v5 = *(_QWORD *)(a1 + 48);
  if ( v4 < v5 )
  {
    v4 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 88) = v5;
  }
  if ( (a4 & 0x18) == 0 )
    return 0LL;
  if ( a3 == 1 && (a4 & 0x18) == 24 )
    return 0LL;
  if ( !v4 )
  {
    v7 = 0LL;
    if ( a3 )
      goto LABEL_15;
    goto LABEL_13;
  }
  if ( (*(_BYTE *)(a1 + 64) & 1) != 0 )
  {
    v7 = v4 - *(_QWORD *)(a1 + 80);
    if ( a3 )
      goto LABEL_15;
LABEL_13:
    v8 = 0LL;
    goto LABEL_22;
  }
  v7 = v4 - (a1 + 65);
  if ( !a3 )
    goto LABEL_13;
LABEL_15:
  if ( a3 == 2 )
  {
    v8 = v7;
  }
  else
  {
    if ( a3 != 1 )
      return 0LL;
    if ( (a4 & 8) != 0 )
      v8 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
    else
      v8 = v5 - *(_QWORD *)(a1 + 40);
  }
LABEL_22:
  v9 = v8 + a2;
  if ( v9 < 0 || v7 < v9 )
    return 0LL;
  if ( !v9 )
  {
LABEL_30:
    if ( (a4 & 8) != 0 )
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + v9;
      *(_QWORD *)(a1 + 32) = v4;
    }
    if ( (a4 & 0x10) != 0 )
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40) + (int)v9;
    return 0LL;
  }
  if ( (a4 & 8) == 0 || *(_QWORD *)(a1 + 24) )
  {
    if ( (a4 & 0x10) != 0 && !v5 )
      return 0LL;
    goto LABEL_30;
  }
  return 0LL;
}

//----- (00000000000129A4) ----------------------------------------------------
__int64 __fastcall sub_129A4(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 32LL))(a1, a3, 0LL);
}

//----- (00000000000129B8) ----------------------------------------------------
__int64 std::streambuf::sync()
{
  return 0LL;
}

//----- (00000000000129C0) ----------------------------------------------------
__int64 std::streambuf::showmanyc()
{
  return 0LL;
}

//----- (00000000000129C8) ----------------------------------------------------
__int64 __fastcall std::streambuf::xsgetn(_QWORD *a1, char *dest, __int64 a3)
{
  __int64 i; // x19
  char *v7; // x1
  unsigned __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x23
  int v11; // w0

  if ( a3 < 1 )
    return 0LL;
  for ( i = 0LL; i < a3; i += v10 )
  {
    v7 = (char *)a1[3];
    v8 = a1[4];
    if ( (unsigned __int64)v7 >= v8 )
    {
      v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 80LL))(a1);
      if ( v11 == -1 )
        return i;
      *dest++ = v11;
      v10 = 1LL;
    }
    else
    {
      v9 = v8 - (_QWORD)v7;
      if ( a3 - i < v9 )
        v9 = a3 - i;
      if ( v9 >= 0x7FFFFFFF )
        v10 = 0x7FFFFFFFLL;
      else
        v10 = v9;
      if ( v10 )
      {
        memcpy(dest, v7, v10);
        v7 = (char *)a1[3];
      }
      dest += v10;
      a1[3] = &v7[(int)v10];
    }
  }
  return i;
}

//----- (0000000000012A8C) ----------------------------------------------------
__int64 __fastcall std::stringbuf::underflow(__int64 a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 v2; // x9
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x8

  v1 = *(_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 48);
  if ( v1 < v2 )
  {
    v1 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 88) = v2;
  }
  if ( (*(_BYTE *)(a1 + 96) & 8) == 0 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 32);
  if ( v4 < v1 )
  {
    v4 = v1;
    *(_QWORD *)(a1 + 32) = v1;
  }
  v5 = *(unsigned __int8 **)(a1 + 24);
  if ( (unsigned __int64)v5 >= v4 )
    return 0xFFFFFFFFLL;
  else
    return *v5;
}

//----- (0000000000012AE4) ----------------------------------------------------
__int64 __fastcall std::streambuf::uflow(_QWORD *a1)
{
  __int64 result; // x0
  unsigned __int8 *v3; // x8

  result = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 72LL))(a1);
  if ( (_DWORD)result != -1 )
  {
    v3 = (unsigned __int8 *)a1[3];
    a1[3] = v3 + 1;
    return *v3;
  }
  return result;
}

//----- (0000000000012B24) ----------------------------------------------------
__int64 __fastcall std::stringbuf::pbackfail(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x9
  unsigned __int64 v3; // x10
  __int64 result; // x0
  unsigned __int64 v6; // x10
  _BYTE *v7; // x10
  int v8; // t1

  v2 = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(a1 + 48);
  result = a2;
  if ( v2 < v3 )
  {
    v2 = v3;
    *(_QWORD *)(a1 + 88) = v3;
  }
  v6 = *(_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) >= v6 )
    return 0xFFFFFFFFLL;
  if ( a2 == -1 )
  {
    result = 0LL;
    *(_QWORD *)(a1 + 24) = v6 - 1;
    *(_QWORD *)(a1 + 32) = v2;
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 96) & 0x10) != 0 )
    {
      v7 = (_BYTE *)(v6 - 1);
    }
    else
    {
      v8 = *(unsigned __int8 *)(v6 - 1);
      v7 = (_BYTE *)(v6 - 1);
      if ( v8 != (unsigned __int8)a2 )
        return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 24) = v7;
    *(_QWORD *)(a1 + 32) = v2;
    *v7 = a2;
  }
  return result;
}

//----- (0000000000012B94) ----------------------------------------------------
__int64 __fastcall std::streambuf::xsputn(_QWORD *a1, unsigned __int8 *src, __int64 a3)
{
  __int64 v6; // x21
  char *v7; // x0
  unsigned __int64 v8; // x8
  signed __int64 v9; // x8
  size_t v10; // x23

  if ( a3 < 1 )
    return 0LL;
  v6 = 0LL;
  do
  {
    while ( 1 )
    {
      v7 = (char *)a1[6];
      v8 = a1[7];
      if ( (unsigned __int64)v7 < v8 )
        break;
      if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(*a1 + 104LL))(a1, *src) != -1 )
      {
        ++src;
        if ( ++v6 < a3 )
          continue;
      }
      return v6;
    }
    v9 = v8 - (_QWORD)v7;
    if ( a3 - v6 >= v9 )
      v10 = v9;
    else
      v10 = a3 - v6;
    if ( v10 )
    {
      memcpy(v7, src, v10);
      v7 = (char *)a1[6];
    }
    src += v10;
    v6 += v10;
    a1[6] = &v7[v10];
  }
  while ( v6 < a3 );
  return v6;
}

//----- (0000000000012C58) ----------------------------------------------------
__int64 __fastcall std::stringbuf::overflow(_QWORD *a1, int a2)
{
  char *v2; // x8
  char *v3; // x24
  __int64 v4; // x22
  __int64 v5; // x23
  unsigned __int8 v6; // w19
  unsigned __int64 v8; // x10
  __int64 *v9; // x26
  _BYTE *v10; // x25
  __int64 result; // x0
  __int64 v12; // x27
  __int64 v13; // x28
  _BYTE *v14; // x21
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  size_t v17; // x1
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x8
  __int64 v20; // x9
  char *v21; // x11
  unsigned __int64 v22; // x8
  bool v23; // cf
  __int64 *v24; // x10
  __int64 v25; // x10
  char *v26; // x12
  _BYTE *v27; // [xsp+8h] [xbp-58h] BYREF

  if ( a2 == -1 )
    return 0LL;
  v3 = (char *)a1[6];
  v2 = (char *)a1[7];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a2;
  if ( v3 == v2 )
  {
    v10 = a1 + 12;
    if ( (a1[12] & 0x10) == 0 )
      return 0xFFFFFFFFLL;
    v9 = a1 + 11;
    v12 = a1[11];
    v13 = a1[5];
    v14 = a1 + 8;
    std::string::push_back(a1 + 8, 0);
    v15 = (unsigned __int8)*v14;
    if ( (v15 & 1) != 0 )
    {
      v18 = a1[9];
      v16 = (a1[8] & 0xFFFFFFFFFFFFFFFELL) - 1;
      v17 = v16 - v18;
      if ( v16 <= v18 )
      {
LABEL_9:
        if ( (v15 & 1) != 0 )
        {
          *(_BYTE *)(a1[10] + v16) = 0;
          a1[9] = v16;
        }
        else
        {
          v14[v16 + 1] = 0;
          *v14 = 2 * v16;
        }
LABEL_14:
        v19 = (unsigned __int8)*v14;
        v20 = v12 - v13;
        if ( (v19 & 1) != 0 )
        {
          v22 = a1[9];
          v21 = (char *)a1[10];
        }
        else
        {
          v21 = (char *)a1 + 65;
          v22 = v19 >> 1;
        }
        v2 = &v21[v22];
        v3 = &v3[(_QWORD)v21 - v13];
        v8 = (unsigned __int64)&v21[v20];
        a1[6] = v3;
        a1[7] = v2;
        a1[5] = v21;
        a1[11] = &v21[v20];
        goto LABEL_18;
      }
    }
    else
    {
      v16 = 22LL;
      v17 = 22 - (v15 >> 1);
      if ( v15 >> 1 >= 0x16 )
        goto LABEL_9;
    }
    std::string::append(a1 + 8, v17, 0);
    goto LABEL_14;
  }
  v9 = a1 + 11;
  v8 = a1[11];
  v10 = a1 + 12;
LABEL_18:
  v23 = (unsigned __int64)(v3 + 1) >= v8;
  v24 = (__int64 *)&v27;
  v27 = v3 + 1;
  if ( !v23 )
    v24 = v9;
  v25 = *v24;
  *v9 = v25;
  if ( (*v10 & 8) != 0 )
  {
    if ( (a1[8] & 1) != 0 )
      v26 = (char *)a1[10];
    else
      v26 = (char *)a1 + 65;
    a1[2] = v26;
    a1[3] = &v26[v5 - v4];
    a1[4] = v25;
  }
  if ( v3 == v2 )
    return (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*a1 + 104LL))(a1, v6);
  result = v6;
  a1[6] = v3 + 1;
  *v3 = v6;
  return result;
}

//----- (0000000000012E38) ----------------------------------------------------
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  *a1 = off_29650;
  std::locale::~locale((std::locale *)(a1 + 1));
}
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (0000000000012E4C) ----------------------------------------------------
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  *a1 = off_29650;
  std::locale::~locale((std::locale *)(a1 + 1));
  operator delete(a1);
}
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();

//----- (0000000000012E80) ----------------------------------------------------
__int64 std::streambuf::seekoff()
{
  return 0LL;
}

//----- (0000000000012E8C) ----------------------------------------------------
__int64 std::streambuf::seekpos()
{
  return 0LL;
}

//----- (0000000000012E98) ----------------------------------------------------
__int64 std::streambuf::underflow()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000012EA0) ----------------------------------------------------
__int64 std::streambuf::pbackfail()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000012EA8) ----------------------------------------------------
__int64 std::streambuf::overflow()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000012EB0) ----------------------------------------------------
void __fastcall std::string::push_back(__int64 *a1, char a2)
{
  unsigned __int64 v2; // x8
  __int64 v5; // x25
  size_t v6; // x21
  char *v7; // x23
  void *v8; // x22
  unsigned __int64 v9; // x8
  __int64 v10; // x24
  char *v11; // x8

  v2 = *(unsigned __int8 *)a1;
  if ( (v2 & 1) != 0 )
  {
    v5 = a1[1];
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v5 != v6 )
      goto LABEL_3;
LABEL_6:
    if ( v6 == -17LL )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v2 & 1) != 0 )
      v8 = (void *)a1[2];
    else
      v8 = (char *)a1 + 1;
    if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v10 = -17LL;
    }
    else
    {
      if ( v6 + 1 >= 2 * v6 )
        v9 = v6 + 1;
      else
        v9 = 2 * v6;
      if ( v9 >= 0x17 )
        v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v10 = 23LL;
    }
    v7 = (char *)operator new(v10);
    memcpy(v7, v8, v6);
    if ( v6 != 22 )
      operator delete(v8);
    a1[2] = (__int64)v7;
    *a1 = v10 | 1;
    goto LABEL_22;
  }
  v5 = v2 >> 1;
  v6 = 22LL;
  if ( v2 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v2 & 1) != 0 )
  {
    v7 = (char *)a1[2];
LABEL_22:
    a1[1] = v5 + 1;
    goto LABEL_23;
  }
  *(_BYTE *)a1 = 2 * v5 + 2;
  v7 = (char *)a1 + 1;
LABEL_23:
  v11 = &v7[v5];
  *v11 = a2;
  v11[1] = 0;
}

//----- (0000000000012FDC) ----------------------------------------------------
void __fastcall __noreturn sub_12FDC(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (0000000000012FE8) ----------------------------------------------------
__int64 *__fastcall std::string::append(__int64 *a1, size_t n, int c)
{
  unsigned __int64 v4; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  __int64 v9; // x9
  void *v10; // x23
  unsigned __int64 v11; // x8
  __int64 v12; // x24
  void *v13; // x0
  __int64 v14; // x25
  char *v15; // x23
  __int64 v16; // x8

  if ( n )
  {
    v4 = *(unsigned __int8 *)a1;
    if ( (v4 & 1) != 0 )
    {
      v9 = *a1;
      v7 = a1[1];
      v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    }
    else
    {
      v7 = v4 >> 1;
      v8 = 22LL;
      LOBYTE(v9) = *(_BYTE *)a1;
    }
    if ( v8 - v7 < n )
    {
      if ( -17LL - v8 < v7 + n - v8 )
        std::__basic_string_common<true>::__throw_length_error();
      if ( (v4 & 1) != 0 )
        v10 = (void *)a1[2];
      else
        v10 = (char *)a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
        v12 = -17LL;
      }
      else
      {
        v11 = 2 * v8;
        if ( v7 + n >= 2 * v8 )
          v11 = v7 + n;
        if ( v11 >= 0x17 )
          v12 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        else
          v12 = 23LL;
      }
      v13 = (void *)operator new(v12);
      v14 = (__int64)v13;
      if ( v7 )
        memcpy(v13, v10, v7);
      if ( v8 != 22 )
        operator delete(v10);
      LOBYTE(v9) = v12 | 1;
      a1[2] = v14;
      *a1 = v12 | 1;
    }
    if ( (v9 & 1) != 0 )
      v15 = (char *)a1[2];
    else
      v15 = (char *)a1 + 1;
    memset(&v15[v7], c, n);
    v16 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v16;
    else
      *(_BYTE *)a1 = 2 * v16;
    v15[v16] = 0;
  }
  return a1;
}

//----- (0000000000013144) ----------------------------------------------------
__int64 *__usercall sub_13144@<X0>(char *s@<X1>, unsigned __int8 *a2@<X0>, __int64 *a3@<X8>)
{
  unsigned __int64 v4; // x8
  size_t v7; // x21
  size_t v8; // x22
  const void *v9; // x23
  size_t v10; // x0
  unsigned __int64 v11; // x8
  void *v12; // x24
  unsigned __int64 v14; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v4 = *a2;
  if ( (v4 & 1) != 0 )
  {
    v7 = *((_QWORD *)a2 + 1);
    v10 = strlen(s);
    v9 = (const void *)*((_QWORD *)a2 + 2);
    v8 = v10;
  }
  else
  {
    v7 = v4 >> 1;
    v8 = strlen(s);
    v9 = a2 + 1;
  }
  v11 = v7 + v8;
  if ( v7 + v8 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  if ( v11 > 0x16 )
  {
    v14 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (void *)operator new(v14);
    a3[1] = v7;
    a3[2] = (__int64)v12;
    *a3 = v14 | 1;
    if ( !v7 )
      goto LABEL_8;
    goto LABEL_7;
  }
  *(_BYTE *)a3 = 2 * v7;
  v12 = (char *)a3 + 1;
  if ( v7 )
LABEL_7:
    memcpy(v12, v9, v7);
LABEL_8:
  *((_BYTE *)v12 + v7) = 0;
  return std::string::append(a3, s, v8);
}

//----- (0000000000013250) ----------------------------------------------------
FILE *__fastcall sub_13250(__int64 a1, __int64 a2, int a3)
{
  __int64 v6; // x20
  const char *v7; // x0
  FILE *result; // x0
  const char *v9; // x1

  v6 = a1 + 24;
  *(_QWORD *)(a1 + 192) = off_29778;
  *(_QWORD *)(a1 + 16) = off_29700;
  *(_OWORD *)a1 = (unsigned __int64)off_29750;
  std::ios_base::init((std::ios_base *)(a1 + 192), (void *)(a1 + 24));
  *(_QWORD *)(a1 + 328) = 0LL;
  *(_DWORD *)(a1 + 336) = -1;
  *(_QWORD *)a1 = off_296D8;
  *(_QWORD *)(a1 + 192) = off_29728;
  *(_QWORD *)(a1 + 16) = off_29700;
  std::filebuf::basic_filebuf(v6);
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v7 = *(const char **)(a2 + 16);
  else
    v7 = (const char *)(a2 + 1);
  if ( *(_QWORD *)(a1 + 144) )
    return (FILE *)std::ios_base::clear(
                     (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL)),
                     *(_DWORD *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL) + 32) | 4u);
  v9 = "w";
  switch ( a3 & 0xFFFFFFFD )
  {
    case 1u:
    case 0x11u:
      v9 = "a";
      break;
    case 5u:
    case 0x15u:
      v9 = "ab";
      break;
    case 8u:
      v9 = "r";
      break;
    case 9u:
    case 0x19u:
      v9 = "a+";
      break;
    case 0xCu:
      v9 = "rb";
      break;
    case 0xDu:
    case 0x1Du:
      v9 = "a+b";
      break;
    case 0x10u:
    case 0x30u:
      break;
    case 0x14u:
    case 0x34u:
      v9 = "wb";
      break;
    case 0x18u:
      v9 = "r+";
      break;
    case 0x1Cu:
      v9 = "r+b";
      break;
    case 0x38u:
      v9 = "w+";
      break;
    case 0x3Cu:
      v9 = "w+b";
      break;
    default:
      return (FILE *)std::ios_base::clear(
                       (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL)),
                       *(_DWORD *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL) + 32) | 4u);
  }
  result = fopen(v7, v9);
  *(_QWORD *)(a1 + 144) = result;
  if ( !result )
    return (FILE *)std::ios_base::clear(
                     (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL)),
                     *(_DWORD *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL) + 32) | 4u);
  *(_DWORD *)(a1 + 176) = a3;
  if ( (a3 & 2) != 0 )
  {
    result = (FILE *)fseek(result, 0LL, 2);
    if ( (_DWORD)result )
    {
      fclose(*(FILE **)(a1 + 144));
      *(_QWORD *)(a1 + 144) = 0LL;
      return (FILE *)std::ios_base::clear(
                       (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL)),
                       *(_DWORD *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24LL) + 32) | 4u);
    }
  }
  return result;
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();
// 29750: using guessed type __int64 (__fastcall *[2])();
// 29778: using guessed type __int64 (__fastcall *[2])();

//----- (0000000000013434) ----------------------------------------------------
__int64 *__usercall std::operator+<char>@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  unsigned __int64 v3; // x26
  unsigned __int64 v5; // x8
  size_t v6; // x21
  bool v7; // zf
  size_t v8; // x22
  unsigned __int64 v9; // x8
  const void *v10; // x23
  void *v12; // x24
  void *v13; // x1
  unsigned __int64 v15; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v3 = *a2;
  v5 = *a1;
  if ( (v3 & 1) != 0 )
    v6 = *((_QWORD *)a2 + 1);
  else
    v6 = v3 >> 1;
  v7 = (v5 & 1) == 0;
  if ( (v5 & 1) != 0 )
    v8 = *((_QWORD *)a1 + 1);
  else
    v8 = v5 >> 1;
  v9 = v6 + v8;
  if ( v7 )
    v10 = a1 + 1;
  else
    v10 = (const void *)*((_QWORD *)a1 + 2);
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * v8;
    v12 = (char *)a3 + 1;
    if ( !v8 )
      goto LABEL_14;
    goto LABEL_13;
  }
  v15 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v12 = (void *)operator new(v15);
  a3[1] = v8;
  a3[2] = (__int64)v12;
  *a3 = v15 | 1;
  if ( v8 )
LABEL_13:
    memcpy(v12, v10, v8);
LABEL_14:
  *((_BYTE *)v12 + v8) = 0;
  if ( (v3 & 1) != 0 )
    v13 = (void *)*((_QWORD *)a2 + 2);
  else
    v13 = a2 + 1;
  return std::string::append(a3, v13, v6);
}

//----- (000000000001353C) ----------------------------------------------------
void __fastcall std::fstream::~fstream(_QWORD *a1)
{
  std::ios_base *v1; // x19

  *a1 = off_296D8;
  a1[24] = off_29728;
  v1 = (std::ios_base *)(a1 + 24);
  a1[2] = off_29700;
  std::filebuf::~filebuf((__int64)(a1 + 3));
  std::ios_base::~ios_base(v1);
}
// 296D8: using guessed type __int64 (__fastcall *[2])();
// 29700: using guessed type __int64 (__fastcall *[2])();
// 29728: using guessed type __int64 (__fastcall *[2])();

//----- (0000000000013584) ----------------------------------------------------
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x25
  _BYTE *v7; // x22
  void *v8; // x22
  unsigned __int64 v9; // x8
  __int64 v10; // x23
  void *v11; // x24

  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 >= n )
    {
LABEL_3:
      if ( (*(_BYTE *)a1 & 1) != 0 )
      {
        v7 = (_BYTE *)a1[2];
        if ( !n )
          goto LABEL_12;
      }
      else
      {
        v7 = (char *)a1 + 1;
        if ( !n )
        {
LABEL_12:
          v7[n] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = n;
          else
            *(_BYTE *)a1 = 2 * n;
          return a1;
        }
      }
      memmove(v7, src, n);
      goto LABEL_12;
    }
  }
  else
  {
    v6 = 22LL;
    if ( n <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v6 < n - v6 )
    std::__basic_string_common<true>::__throw_length_error();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v8 = (void *)a1[2];
  else
    v8 = (char *)a1 + 1;
  if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v10 = -17LL;
  }
  else
  {
    v9 = 2 * v6;
    if ( 2 * v6 <= n )
      v9 = n;
    if ( v9 >= 0x17 )
      v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v10 = 23LL;
  }
  v11 = (void *)operator new(v10);
  memcpy(v11, src, n);
  if ( v6 != 22 )
    operator delete(v8);
  a1[1] = n;
  a1[2] = (__int64)v11;
  *a1 = v10 | 1;
  *((_BYTE *)v11 + n) = 0;
  return a1;
}

//----- (00000000000136D4) ----------------------------------------------------
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  unsigned __int64 v3; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  void *v10; // x23
  char *v11; // x23
  unsigned __int64 v12; // x8
  __int64 v13; // x24
  __int64 v14; // x8
  char *v15; // x8
  char *v16; // x0
  char *v17; // x25

  v3 = *(unsigned __int8 *)a1;
  if ( (v3 & 1) != 0 )
  {
    v7 = a1[1];
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v7 = v3 >> 1;
    v8 = 22LL;
  }
  if ( v8 - v7 < n )
  {
    v9 = v7 + n;
    if ( -18LL - v8 < v7 + n - v8 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v3 & 1) != 0 )
      v10 = (void *)a1[2];
    else
      v10 = (char *)a1 + 1;
    if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v13 = -17LL;
    }
    else
    {
      v12 = 2 * v8;
      if ( v9 >= 2 * v8 )
        v12 = v7 + n;
      if ( v12 >= 0x17 )
        v13 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v13 = 23LL;
    }
    v16 = (char *)operator new(v13);
    v17 = v16;
    if ( v7 )
      memcpy(v16, v10, v7);
    memcpy(&v17[v7], src, n);
    if ( v8 != 22 )
      operator delete(v10);
    *a1 = v13 | 1;
    v15 = &v17[v9];
    a1[1] = v9;
    a1[2] = (__int64)v17;
    goto LABEL_29;
  }
  if ( n )
  {
    if ( (v3 & 1) != 0 )
      v11 = (char *)a1[2];
    else
      v11 = (char *)a1 + 1;
    memcpy(&v11[v7], src, n);
    v14 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v14;
    else
      *(_BYTE *)a1 = 2 * v14;
    v15 = &v11[v14];
LABEL_29:
    *v15 = 0;
  }
  return a1;
}

//----- (0000000000013854) ----------------------------------------------------
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1)
{
  const std::locale *v1; // x20
  char has_facet; // w21
  _QWORD v5[2]; // [xsp+0h] [xbp-40h] BYREF

  v1 = (const std::locale *)(a1 + 8);
  v5[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)a1 = off_29650;
  std::locale::locale((std::locale *)(a1 + 8));
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_BYTE *)(a1 + 162) = 0;
  *(_WORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_QWORD *)a1 = off_297B0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  std::locale::locale((std::locale *)v5, v1);
  has_facet = std::locale::has_facet(v5, &std::codecvt<char,char,mbstate_t>::id);
  std::locale::~locale((std::locale *)v5);
  if ( (has_facet & 1) != 0 )
  {
    std::locale::locale((std::locale *)v5, v1);
    *(_QWORD *)(a1 + 128) = std::locale::use_facet(v5, &std::codecvt<char,char,mbstate_t>::id);
    std::locale::~locale((std::locale *)v5);
    *(_BYTE *)(a1 + 162) = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 128) + 56LL))(*(_QWORD *)(a1 + 128)) & 1;
  }
  return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0LL, 4096LL);
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 7BF0: using guessed type __int64 __fastcall std::locale::has_facet(_QWORD, _QWORD);
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();
// 297B0: using guessed type __int64 (__fastcall *off_297B0[3])();

//----- (00000000000139AC) ----------------------------------------------------
void __fastcall std::filebuf::~filebuf(__int64 a1)
{
  FILE *v1; // x20
  void *v3; // x0
  void *v4; // x0

  v1 = *(FILE **)(a1 + 120);
  *(_QWORD *)a1 = off_297B0;
  if ( v1 )
  {
    std::filebuf::sync(a1);
    if ( !fclose(v1) )
      *(_QWORD *)(a1 + 120) = 0LL;
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 24LL))(a1, 0LL, 0LL);
  }
  if ( *(_BYTE *)(a1 + 160) )
  {
    v3 = *(void **)(a1 + 64);
    if ( v3 )
      operator delete[](v3);
  }
  if ( *(_BYTE *)(a1 + 161) )
  {
    v4 = *(void **)(a1 + 104);
    if ( v4 )
      operator delete[](v4);
  }
  *(_QWORD *)a1 = off_29650;
  std::locale::~locale((std::locale *)(a1 + 8));
}
// 29650: using guessed type __int64 (__fastcall *off_29650[8])();
// 297B0: using guessed type __int64 (__fastcall *[3])();

//----- (0000000000013A8C) ----------------------------------------------------
void __fastcall std::fstream::~fstream(_QWORD *a1)
{
  std::ios_base *v2; // x20

  *a1 = off_296D8;
  a1[24] = off_29728;
  v2 = (std::ios_base *)(a1 + 24);
  a1[2] = off_29700;
  std::filebuf::~filebuf((__int64)(a1 + 3));
  std::ios_base::~ios_base(v2);
  operator delete(a1);
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();

//----- (0000000000013AE0) ----------------------------------------------------
void __fastcall `non-virtual thunk to'std::fstream::~fstream(_QWORD *a1)
{
  std::ios_base *v1; // x19

  *(a1 - 2) = off_296D8;
  a1[22] = off_29728;
  v1 = (std::ios_base *)(a1 + 22);
  *a1 = off_29700;
  std::filebuf::~filebuf((__int64)(a1 + 1));
  std::ios_base::~ios_base(v1);
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();

//----- (0000000000013B24) ----------------------------------------------------
void __fastcall `non-virtual thunk to'std::fstream::~fstream(_QWORD *a1)
{
  _QWORD *v1; // x19
  std::ios_base *v2; // x20

  *(a1 - 2) = off_296D8;
  v1 = a1 - 2;
  a1[22] = off_29728;
  v2 = (std::ios_base *)(a1 + 22);
  *a1 = off_29700;
  std::filebuf::~filebuf((__int64)(a1 + 1));
  std::ios_base::~ios_base(v2);
  operator delete(v1);
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();

//----- (0000000000013B74) ----------------------------------------------------
void __fastcall `virtual thunk to'std::fstream::~fstream(_QWORD *a1)
{
  _QWORD *v1; // x8
  std::ios_base *v2; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_296D8;
  v1[24] = off_29728;
  v2 = (std::ios_base *)(v1 + 24);
  v1[2] = off_29700;
  std::filebuf::~filebuf((__int64)(v1 + 3));
  std::ios_base::~ios_base(v2);
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();

//----- (0000000000013BC8) ----------------------------------------------------
void __fastcall `virtual thunk to'std::fstream::~fstream(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_296D8;
  v1[24] = off_29728;
  v1[2] = off_29700;
  std::filebuf::~filebuf((__int64)(v1 + 3));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 24));
  operator delete(v1);
}
// 296D8: using guessed type __int64 (__fastcall *off_296D8[2])();
// 29700: using guessed type __int64 (__fastcall *off_29700[2])();
// 29728: using guessed type __int64 (__fastcall *off_29728[2])();

//----- (0000000000013C24) ----------------------------------------------------
void __fastcall std::filebuf::~filebuf(void *a1)
{
  std::filebuf::~filebuf((__int64)a1);
  operator delete(a1);
}

//----- (0000000000013C48) ----------------------------------------------------
void __fastcall std::filebuf::imbue(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  char v5; // w0
  int v6; // w8
  void *v7; // x0
  char v8; // w8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x0
  __int64 v12; // x8
  unsigned __int64 v13; // x0

  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1);
  v4 = std::locale::use_facet(a2, &std::codecvt<char,char,mbstate_t>::id);
  *(_QWORD *)(a1 + 128) = v4;
  LODWORD(a2) = *(unsigned __int8 *)(a1 + 162);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 56LL))(v4);
  *(_BYTE *)(a1 + 162) = v5 & 1;
  if ( (_DWORD)a2 != (v5 & 1) )
  {
    v6 = *(unsigned __int8 *)(a1 + 160);
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    if ( (v5 & 1) != 0 )
    {
      if ( v6 )
      {
        v7 = *(void **)(a1 + 64);
        if ( v7 )
          operator delete[](v7);
      }
      v8 = *(_BYTE *)(a1 + 161);
      v9 = *(_QWORD *)(a1 + 104);
      v10 = *(_QWORD *)(a1 + 112);
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 112) = 0LL;
      *(_BYTE *)(a1 + 160) = v8;
      *(_QWORD *)(a1 + 96) = v10;
      *(_QWORD *)(a1 + 104) = 0LL;
      *(_QWORD *)(a1 + 64) = v9;
    }
    else if ( v6 || (v12 = *(_QWORD *)(a1 + 64), v12 == a1 + 88) )
    {
      v11 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 112) = v11;
      *(_QWORD *)(a1 + 104) = operator new[](v11);
      *(_BYTE *)(a1 + 161) = 1;
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 96);
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 104) = v12;
      *(_QWORD *)(a1 + 112) = v13;
      *(_QWORD *)(a1 + 64) = operator new[](v13);
      *(_BYTE *)(a1 + 160) = 1;
    }
  }
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);

//----- (0000000000013D38) ----------------------------------------------------
__int64 __fastcall std::filebuf::setbuf(__int64 a1, __int64 a2, signed __int64 a3)
{
  int v3; // w8
  void *v7; // x0
  void *v8; // x0
  int v9; // w22
  int v10; // w22
  unsigned __int64 v12; // x0

  v3 = *(unsigned __int8 *)(a1 + 160);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if ( v3 )
  {
    v7 = *(void **)(a1 + 64);
    if ( v7 )
      operator delete[](v7);
  }
  if ( *(_BYTE *)(a1 + 161) )
  {
    v8 = *(void **)(a1 + 104);
    if ( v8 )
      operator delete[](v8);
  }
  *(_QWORD *)(a1 + 96) = a3;
  if ( (unsigned __int64)a3 < 9 )
  {
    v10 = *(unsigned __int8 *)(a1 + 162);
    *(_QWORD *)(a1 + 64) = a1 + 88;
    *(_QWORD *)(a1 + 96) = 8LL;
    *(_BYTE *)(a1 + 160) = 0;
    if ( v10 )
      goto LABEL_12;
  }
  else
  {
    v9 = *(unsigned __int8 *)(a1 + 162);
    if ( a2 && *(_BYTE *)(a1 + 162) )
    {
      *(_QWORD *)(a1 + 64) = a2;
      *(_BYTE *)(a1 + 160) = 0;
LABEL_12:
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 104) = 0LL;
      *(_QWORD *)(a1 + 112) = 0LL;
      return a1;
    }
    *(_QWORD *)(a1 + 64) = operator new[](a3);
    *(_BYTE *)(a1 + 160) = 1;
    if ( v9 )
      goto LABEL_12;
  }
  if ( a3 <= 8 )
    v12 = 8LL;
  else
    v12 = a3;
  *(_QWORD *)(a1 + 112) = v12;
  if ( a2 )
  {
    *(_QWORD *)(a1 + 104) = a2;
    *(_BYTE *)(a1 + 161) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = operator new[](v12);
    *(_BYTE *)(a1 + 161) = 1;
  }
  return a1;
}
// 13E14: conditional instruction was optimized away because x0.8>=8

//----- (0000000000013E38) ----------------------------------------------------
__int64 __fastcall std::filebuf::seekoff(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // x0
  int v7; // w0
  __int64 v8; // x8
  int v9; // w22
  int v10; // w0
  __off_t v11; // x1

  v4 = *(_QWORD *)(a1 + 128);
  if ( !v4 )
    sub_146A4();
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 48LL))(v4);
  v8 = *(_QWORD *)(a1 + 120);
  if ( v8 )
  {
    v9 = v7;
    if ( a2 && v7 < 1 )
      return 0LL;
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1);
    v8 = 0LL;
    if ( !v10 && a3 <= 2 )
    {
      if ( v9 <= 0 )
        v11 = 0LL;
      else
        v11 = v9 * a2;
      if ( !fseeko(*(FILE **)(a1 + 120), v11, a3) )
      {
        ftello(*(FILE **)(a1 + 120));
        return *(_QWORD *)(a1 + 136);
      }
      return 0LL;
    }
  }
  return v8;
}

//----- (0000000000013EF8) ----------------------------------------------------
__int64 __fastcall std::filebuf::seekpos(__int64 a1, __int64 a2, __off_t a3)
{
  if ( !*(_QWORD *)(a1 + 120)
    || (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1)
    || fseeko(*(FILE **)(a1 + 120), a3, 0) )
  {
    return 0LL;
  }
  *(_QWORD *)(a1 + 136) = a2;
  return a2;
}

//----- (0000000000013F68) ----------------------------------------------------
__int64 __fastcall std::filebuf::sync(__int64 a1)
{
  __int64 v2; // x0
  int v3; // w8
  int v4; // w21
  __int64 v5; // x20
  unsigned int v6; // w20
  int v7; // w21
  const void *v8; // x0
  __int64 v9; // x22
  int v10; // w0
  __int64 v11; // x8
  __int64 v13[2]; // [xsp+0h] [xbp-40h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0;
  v2 = *(_QWORD *)(a1 + 128);
  if ( !v2 )
    sub_146A4();
  v3 = *(_DWORD *)(a1 + 156);
  if ( (v3 & 0x10) == 0 )
  {
    if ( (v3 & 8) != 0 )
    {
      v13[0] = *(_QWORD *)(a1 + 144);
      if ( *(_BYTE *)(a1 + 162) )
      {
        v4 = 0;
        v5 = *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24);
      }
      else
      {
        v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48LL))(v2);
        v5 = *(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72);
        if ( v10 < 1 )
        {
          if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32) )
          {
            v4 = 0;
          }
          else
          {
            v4 = 1;
            v5 = *(_QWORD *)(a1 + 72)
               + v5
               - (*(int (__fastcall **)(_QWORD, __int64 *, _QWORD))(**(_QWORD **)(a1 + 128) + 64LL))(
                   *(_QWORD *)(a1 + 128),
                   v13,
                   *(_QWORD *)(a1 + 64))
               - *(_QWORD *)(a1 + 64);
          }
        }
        else
        {
          v4 = 0;
          v5 += (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) * v10;
        }
      }
      if ( fseeko(*(FILE **)(a1 + 120), -v5, 1) )
        return (unsigned int)-1;
      if ( v4 )
        *(_QWORD *)(a1 + 136) = v13[0];
      v11 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 156) = 0;
      *(_QWORD *)(a1 + 24) = 0LL;
      *(_QWORD *)(a1 + 32) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
      *(_QWORD *)(a1 + 72) = v11;
      *(_QWORD *)(a1 + 80) = v11;
    }
    return 0;
  }
  if ( *(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 40)
    || (v6 = -1, (*(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 104LL))(a1, 0xFFFFFFFFLL) != -1) )
  {
    while ( 1 )
    {
      v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, __int64 *))(**(_QWORD **)(a1 + 128) + 40LL))(
             *(_QWORD *)(a1 + 128),
             a1 + 136,
             *(_QWORD *)(a1 + 64),
             *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 96),
             v13);
      v8 = *(const void **)(a1 + 64);
      v9 = v13[0] - (_QWORD)v8;
      if ( fwrite(v8, 1uLL, v13[0] - (_QWORD)v8, *(FILE **)(a1 + 120)) != v9 )
        break;
      if ( v7 != 1 )
      {
        if ( v7 == 2 || fflush(*(FILE **)(a1 + 120)) )
          return (unsigned int)-1;
        return 0;
      }
    }
    return (unsigned int)-1;
  }
  return v6;
}

//----- (0000000000014158) ----------------------------------------------------
__int64 __fastcall std::filebuf::underflow(__int64 a1)
{
  int v2; // w8
  __int64 v3; // x9
  bool v4; // zf
  __int64 v5; // x8
  __int64 v6; // x10
  __int64 v7; // x8
  int v8; // w9
  unsigned __int8 *v9; // x8
  __int64 v10; // x20
  __int64 result; // x0
  char **v12; // x24
  unsigned __int8 *v13; // x9
  size_t v14; // x0
  unsigned __int8 *v15; // x8
  __int64 v16; // x9
  _BYTE *v17; // x1
  _BYTE *v18; // x9
  __int64 v19; // x8
  void *v20; // x0
  __int64 v21; // x9
  __int64 v22; // x10
  __int64 v23; // x8
  FILE *v24; // x3
  __int64 v25; // x9
  size_t v26; // x2
  size_t v27; // x0
  size_t v28; // x8
  __int64 v29; // x0
  __int64 v30; // x2
  __int64 v31; // x10
  size_t v32; // x3
  unsigned __int8 *v33; // [xsp+8h] [xbp-48h] BYREF
  char v34; // [xsp+14h] [xbp-3Ch] BYREF
  _BYTE v35[11]; // [xsp+15h] [xbp-3Bh] BYREF

  *(_QWORD *)&v35[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  if ( (*(_BYTE *)(a1 + 156) & 8) != 0 )
  {
    v9 = *(unsigned __int8 **)(a1 + 24);
    v8 = 0;
    if ( v9 )
      goto LABEL_8;
  }
  else
  {
    v2 = *(unsigned __int8 *)(a1 + 162);
    v3 = 96LL;
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    v4 = v2 == 0;
    v5 = 64LL;
    if ( v4 )
      v3 = 112LL;
    *(_QWORD *)(a1 + 56) = 0LL;
    if ( v4 )
      v5 = 104LL;
    v6 = *(_QWORD *)(a1 + v5);
    v7 = *(_QWORD *)(a1 + v3);
    *(_DWORD *)(a1 + 156) = 8;
    v8 = 1;
    v9 = (unsigned __int8 *)(v6 + v7);
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = v9;
    *(_QWORD *)(a1 + 32) = v9;
    if ( v9 )
    {
LABEL_8:
      if ( v8 )
        goto LABEL_9;
LABEL_14:
      v13 = *(unsigned __int8 **)(a1 + 32);
      if ( (unsigned __int64)((__int64)&v13[-*(_QWORD *)(a1 + 16)] / 2) >= 4 )
        v10 = 4LL;
      else
        v10 = (__int64)&v13[-*(_QWORD *)(a1 + 16)] / 2;
      if ( v9 != v13 )
        goto LABEL_10;
      goto LABEL_18;
    }
  }
  v9 = v35;
  *(_QWORD *)(a1 + 16) = &v34;
  *(_QWORD *)(a1 + 24) = v35;
  *(_QWORD *)(a1 + 32) = v35;
  if ( !v8 )
    goto LABEL_14;
LABEL_9:
  v10 = 0LL;
  if ( v9 != *(unsigned __int8 **)(a1 + 32) )
  {
LABEL_10:
    result = *v9;
    v12 = (char **)(a1 + 16);
    goto LABEL_36;
  }
LABEL_18:
  v12 = (char **)(a1 + 16);
  memmove(*(void **)(a1 + 16), &v9[-v10], v10);
  if ( *(_BYTE *)(a1 + 162) )
  {
    v14 = fread(
            (void *)(*(_QWORD *)(a1 + 16) + v10),
            1uLL,
            *(_QWORD *)(a1 + 32) - v10 - *(_QWORD *)(a1 + 16),
            *(FILE **)(a1 + 120));
    if ( v14 )
    {
      v15 = (unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v10);
      v16 = (__int64)&v15[v14];
LABEL_34:
      *(_QWORD *)(a1 + 24) = v15;
      *(_QWORD *)(a1 + 32) = v16;
      result = *v15;
      goto LABEL_36;
    }
  }
  else
  {
    v17 = *(_BYTE **)(a1 + 72);
    v18 = *(_BYTE **)(a1 + 80);
    if ( v18 != v17 )
    {
      memmove(*(void **)(a1 + 64), v17, v18 - v17);
      v17 = *(_BYTE **)(a1 + 72);
      v18 = *(_BYTE **)(a1 + 80);
    }
    v19 = *(_QWORD *)(a1 + 64);
    v20 = (void *)(v19 + v18 - v17);
    *(_QWORD *)(a1 + 72) = v20;
    if ( v19 == a1 + 88 )
      v21 = 8LL;
    else
      v21 = *(_QWORD *)(a1 + 96);
    v22 = *(_QWORD *)(a1 + 136);
    v23 = v19 + v21;
    v25 = *(_QWORD *)(a1 + 112);
    v24 = *(FILE **)(a1 + 120);
    *(_QWORD *)(a1 + 80) = v23;
    *(_QWORD *)(a1 + 144) = v22;
    if ( v23 - (__int64)v20 >= (unsigned __int64)(v25 - v10) )
      v26 = v25 - v10;
    else
      v26 = v23 - (_QWORD)v20;
    v27 = fread(v20, 1uLL, v26, v24);
    if ( v27 )
    {
      v28 = v27;
      v29 = *(_QWORD *)(a1 + 128);
      if ( !v29 )
        sub_146A4();
      v30 = *(_QWORD *)(a1 + 64);
      v31 = *(_QWORD *)(a1 + 112);
      v32 = *(_QWORD *)(a1 + 72) + v28;
      *(_QWORD *)(a1 + 80) = v32;
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, size_t, __int64, __int64, __int64, unsigned __int8 **))(*(_QWORD *)v29 + 32LL))(
             v29,
             a1 + 136,
             v30,
             v32,
             a1 + 72,
             *(_QWORD *)(a1 + 16) + v10,
             *(_QWORD *)(a1 + 16) + v31,
             &v33) == 3 )
      {
        v15 = *(unsigned __int8 **)(a1 + 64);
        v16 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)(a1 + 16) = v15;
        goto LABEL_34;
      }
      v16 = (__int64)v33;
      v15 = (unsigned __int8 *)&(*v12)[v10];
      if ( v33 != v15 )
        goto LABEL_34;
    }
  }
  result = 0xFFFFFFFFLL;
LABEL_36:
  if ( *v12 == &v34 )
  {
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  return result;
}
// 14158: using guessed type unsigned __int8 *var_48;

//----- (00000000000143E0) ----------------------------------------------------
__int64 __fastcall std::filebuf::pbackfail(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x9
  __int64 result; // x0
  _BYTE *v5; // x9
  int v6; // t1

  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) >= v2 )
    return 0xFFFFFFFFLL;
  result = a2;
  if ( a2 == -1 )
  {
    result = 0LL;
    *(_QWORD *)(a1 + 24) = v2 - 1;
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 152) & 0x10) != 0 )
    {
      v5 = (_BYTE *)(v2 - 1);
    }
    else
    {
      v6 = *(unsigned __int8 *)(v2 - 1);
      v5 = (_BYTE *)(v2 - 1);
      if ( v6 != (unsigned __int8)a2 )
        return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 24) = v5;
    *v5 = a2;
  }
  return result;
}

//----- (0000000000014440) ----------------------------------------------------
__int64 __fastcall std::filebuf::overflow(__int64 a1, unsigned int a2)
{
  unsigned __int64 v4; // x8
  char *v5; // x2
  char **v6; // x25
  __int64 v7; // x26
  __int64 *v8; // x27
  char *v9; // x3
  char *v10; // x28
  size_t v11; // x21
  FILE *v12; // x3
  char *v13; // x0
  __int64 v15; // x0
  unsigned int v16; // w0
  char *v17; // x8
  unsigned int v18; // w22
  const void *v19; // x0
  __int64 v20; // x3
  __int64 v21; // x0
  unsigned int v22; // w0
  char *v23; // [xsp+0h] [xbp-70h]
  __int64 v24; // [xsp+8h] [xbp-68h]
  char v25; // [xsp+14h] [xbp-5Ch] BYREF
  _BYTE v26[11]; // [xsp+15h] [xbp-5Bh] BYREF

  *(_QWORD *)&v26[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  if ( (*(_BYTE *)(a1 + 156) & 0x10) != 0 )
  {
    v6 = (char **)(a1 + 40);
    v5 = *(char **)(a1 + 40);
    v8 = (__int64 *)(a1 + 56);
    v7 = *(_QWORD *)(a1 + 56);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    if ( v4 < 9 )
    {
      *(_QWORD *)(a1 + 40) = 0LL;
      v6 = (char **)(a1 + 40);
      v5 = 0LL;
      v7 = 0LL;
      *(_QWORD *)(a1 + 56) = 0LL;
      v8 = (__int64 *)(a1 + 56);
      *(_QWORD *)(a1 + 48) = 0LL;
    }
    else
    {
      if ( *(_BYTE *)(a1 + 162) )
      {
        v5 = *(char **)(a1 + 64);
      }
      else
      {
        v5 = *(char **)(a1 + 104);
        v4 = *(_QWORD *)(a1 + 112);
      }
      v7 = (__int64)&v5[v4 - 1];
      v6 = (char **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v5;
      *(_QWORD *)(a1 + 48) = v5;
      v8 = (__int64 *)(a1 + 56);
      *(_QWORD *)(a1 + 56) = v7;
    }
    *(_DWORD *)(a1 + 156) = 16;
  }
  v9 = *(char **)(a1 + 48);
  v10 = v5;
  if ( a2 != -1 )
  {
    if ( !v9 )
    {
      v9 = &v25;
      *(_QWORD *)(a1 + 40) = &v25;
      *(_QWORD *)(a1 + 48) = &v25;
      *(_QWORD *)(a1 + 56) = v26;
    }
    *v9 = a2;
    v5 = *(char **)(a1 + 40);
    v9 = (char *)(*(_QWORD *)(a1 + 48) + 1LL);
    *(_QWORD *)(a1 + 48) = v9;
  }
  v11 = v9 - v5;
  if ( v9 == v5 )
    goto LABEL_20;
  if ( *(_BYTE *)(a1 + 162) )
  {
    v12 = *(FILE **)(a1 + 120);
    v13 = v5;
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 64);
    v15 = *(_QWORD *)(a1 + 128);
    if ( !v15 )
LABEL_35:
      sub_146A4();
    v16 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 24LL))(v15, a1 + 136);
    v17 = *(char **)(a1 + 40);
    if ( v23 == v17 )
      return 0xFFFFFFFFLL;
    v18 = v16;
    while ( v18 != 3 )
    {
      if ( v18 > 1 )
        return 0xFFFFFFFFLL;
      v19 = *(const void **)(a1 + 64);
      if ( fwrite(v19, 1uLL, v24 - (_QWORD)v19, *(FILE **)(a1 + 120)) != v24 - (_QWORD)v19 )
        return 0xFFFFFFFFLL;
      if ( v18 != 1 )
        goto LABEL_19;
      v20 = *(_QWORD *)(a1 + 48);
      *v6 = v23;
      *v8 = v20;
      v21 = *(_QWORD *)(a1 + 128);
      *(_QWORD *)(a1 + 48) = v20;
      if ( !v21 )
        goto LABEL_35;
      v22 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v21 + 24LL))(v21, a1 + 136);
      v17 = *(char **)(a1 + 40);
      v18 = v22;
      if ( v23 == v17 )
        return 0xFFFFFFFFLL;
    }
    v12 = *(FILE **)(a1 + 120);
    v13 = v17;
    v11 = *(_QWORD *)(a1 + 48) - (_QWORD)v17;
  }
  if ( fwrite(v13, 1uLL, v11, v12) != v11 )
    return 0xFFFFFFFFLL;
LABEL_19:
  *(_QWORD *)(a1 + 48) = v10;
  *v6 = v10;
  *v8 = v7;
LABEL_20:
  if ( a2 == -1 )
    return 0LL;
  else
    return a2;
}
// 145B8: variable 'v23' is possibly undefined

//----- (00000000000146A4) ----------------------------------------------------
void __noreturn sub_146A4()
{
  std::bad_cast *exception; // x19

  exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
  std::bad_cast::bad_cast(exception);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::bad_cast,
    (void (__fastcall *)(void *))&std::bad_cast::~bad_cast);
}

//----- (00000000000146D8) ----------------------------------------------------
void __fastcall std::string::__init<std::istreambuf_iterator<char>>(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  char *v6; // x8
  char v7; // w1
  __int64 v8; // x8

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  while ( !a2 || a2[3] != a2[4] )
  {
    if ( !a3 )
      goto LABEL_13;
LABEL_6:
    if ( a3[3] == a3[4] && (*(unsigned int (__fastcall **)(_QWORD *))(*a3 + 72LL))(a3) == -1 )
      goto LABEL_13;
    if ( a2 )
      return;
LABEL_15:
    v6 = (char *)a2[3];
    if ( v6 == (char *)a2[4] )
      v7 = (*(__int64 (__fastcall **)(_QWORD *))(*a2 + 72LL))(a2);
    else
      v7 = *v6;
    std::string::push_back(a1, v7);
    v8 = a2[3];
    if ( v8 == a2[4] )
      (*(void (__fastcall **)(_QWORD *))(*a2 + 80LL))(a2);
    else
      a2[3] = v8 + 1;
  }
  if ( (*(unsigned int (__fastcall **)(_QWORD *))(*a2 + 72LL))(a2) == -1 )
    a2 = 0LL;
  if ( a3 )
    goto LABEL_6;
LABEL_13:
  if ( a2 )
  {
    a3 = 0LL;
    goto LABEL_15;
  }
}

//----- (00000000000147F8) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  sub_1480C("basic_string");
}

//----- (000000000001480C) ----------------------------------------------------
void __fastcall __noreturn sub_1480C(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1485C(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::out_of_range,
    (void (__fastcall *)(void *))&std::out_of_range::~out_of_range);
}

//----- (000000000001485C) ----------------------------------------------------
__int64 __fastcall sub_1485C(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::out_of_range + 16;
  return result;
}

//----- (000000000001488C) ----------------------------------------------------
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  unsigned __int64 v4; // x8
  char *v6; // x21
  size_t v9; // x27
  unsigned __int64 v10; // x28
  unsigned __int64 v11; // x23
  char *v12; // x8
  char *v13; // x23
  unsigned __int64 v14; // x8
  __int64 v15; // x24
  char *v16; // x22
  __int64 v18; // x8
  char *v19; // x8
  char *v20; // x0
  char *v21; // x25
  char *srca; // [xsp+8h] [xbp-58h]

  v4 = *(unsigned __int8 *)a1;
  v6 = src;
  if ( (v4 & 1) != 0 )
  {
    v9 = a1[1];
    if ( v9 < a2 )
      goto LABEL_44;
  }
  else
  {
    v9 = v4 >> 1;
    if ( v4 >> 1 < a2 )
LABEL_44:
      std::__basic_string_common<true>::__throw_out_of_range();
  }
  if ( (v4 & 1) != 0 )
    v10 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v10 = 22LL;
  if ( v10 - v9 < n )
  {
    v11 = v9 + n;
    if ( -18LL - v10 < v9 + n - v10 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v4 & 1) != 0 )
      v12 = (char *)a1[2];
    else
      v12 = (char *)a1 + 1;
    srca = v12;
    if ( v10 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v15 = -17LL;
    }
    else
    {
      v14 = 2 * v10;
      if ( v11 >= 2 * v10 )
        v14 = v9 + n;
      if ( v14 >= 0x17 )
        v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v15 = 23LL;
    }
    v20 = (char *)operator new(v15);
    v21 = v20;
    if ( a2 )
      memcpy(v20, srca, a2);
    memcpy(&v21[a2], v6, n);
    if ( v9 != a2 )
      memcpy(&v21[a2 + n], &srca[a2], v9 - a2);
    if ( v10 != 22 )
      operator delete(srca);
    *a1 = v15 | 1;
    v19 = &v21[v11];
    a1[1] = v11;
    a1[2] = (__int64)v21;
LABEL_42:
    *v19 = 0;
    return a1;
  }
  if ( n )
  {
    if ( (v4 & 1) != 0 )
      v13 = (char *)a1[2];
    else
      v13 = (char *)a1 + 1;
    v16 = &v13[a2];
    if ( v9 != a2 )
    {
      if ( &v13[v9] > src && v16 <= src )
        v6 = &src[n];
      memmove(&v16[n], v16, v9 - a2);
    }
    memmove(v16, v6, n);
    v18 = v9 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v18;
    else
      *(_BYTE *)a1 = 2 * v18;
    v19 = &v13[v18];
    goto LABEL_42;
  }
  return a1;
}

//----- (0000000000014A88) ----------------------------------------------------
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x8
  char *v5; // x9
  _QWORD *v6; // x0
  __int64 v9; // x22
  int v10; // w5
  __int64 v11; // x23
  int v12; // w26
  __int64 v13; // x0
  unsigned __int8 v14; // w24
  __int64 v15; // x2
  char v17[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v18; // [xsp+8h] [xbp-58h]
  _QWORD v19[2]; // [xsp+10h] [xbp-50h] BYREF

  v19[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17[0] = 0;
  v18 = a1;
  v4 = (_QWORD *)(*a1 - 24LL);
  v5 = (char *)a1 + *v4;
  if ( !*((_DWORD *)v5 + 8) )
  {
    v6 = (_QWORD *)*((_QWORD *)v5 + 17);
    if ( v6 )
    {
      std::ostream::flush(v6);
      v4 = (_QWORD *)(*a1 - 24LL);
    }
    v17[0] = 1;
    v9 = (__int64)a1 + *v4;
    v10 = *(_DWORD *)(v9 + 144);
    v11 = *(_QWORD *)(v9 + 40);
    v12 = *(_DWORD *)(v9 + 8);
    if ( v10 == -1 )
    {
      std::ios_base::getloc(v19, (std::ios_base *)v9);
      v13 = std::locale::use_facet(v19, &std::ctype<char>::id);
      v14 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 56LL))(v13, 32LL);
      std::locale::~locale((std::locale *)v19);
      v10 = v14;
      *(_DWORD *)(v9 + 144) = v14;
    }
    if ( (v12 & 0xB0) == 32 )
      v15 = a2 + a3;
    else
      v15 = a2;
    if ( !sub_14C2C(v11, a2, v15, a2 + a3, v9, v10) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v17);
  return a1;
}
// 7BB0: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 14A88: using guessed type char var_60[8];

//----- (0000000000014C2C) ----------------------------------------------------
__int64 __fastcall sub_14C2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c)
{
  __int64 v6; // x19
  __int64 v7; // x8
  __int64 v8; // x25
  bool v10; // cc
  signed __int64 v11; // x8
  signed __int64 v15; // x23
  char *v16; // x25
  void *v17; // x1
  __int64 v18; // x24
  __int64 v19; // x22
  unsigned __int64 v21; // [xsp+0h] [xbp-70h] BYREF
  __int64 v22; // [xsp+8h] [xbp-68h]
  void *v23; // [xsp+10h] [xbp-60h]
  __int64 v24; // [xsp+18h] [xbp-58h]

  v6 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v7 = *(_QWORD *)(a5 + 24);
    v8 = a3 - a2;
    v10 = v7 <= a4 - a2;
    v11 = v7 - (a4 - a2);
    if ( v10 )
      v15 = 0LL;
    else
      v15 = v11;
    if ( v8 >= 1 && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96LL))(a1) != v8 )
      return 0LL;
    if ( v15 >= 1 )
    {
      v21 = 0LL;
      v22 = 0LL;
      v23 = 0LL;
      if ( (unsigned __int64)v15 >= 0x17 )
      {
        v16 = (char *)operator new((v15 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v22 = v15;
        v23 = v16;
        v21 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)&v21 + 1;
        LOBYTE(v21) = 2 * v15;
      }
      memset(v16, c, v15);
      v16[v15] = 0;
      v17 = (v21 & 1) != 0 ? v23 : (char *)&v21 + 1;
      v18 = (*(__int64 (__fastcall **)(__int64, void *, signed __int64))(*(_QWORD *)v6 + 96LL))(v6, v17, v15);
      if ( (v21 & 1) != 0 )
        operator delete(v23);
      if ( v18 != v15 )
        return 0LL;
    }
    v19 = a4 - a3;
    if ( v19 < 1 || (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 96LL))(v6, a3, v19) == v19 )
      *(_QWORD *)(a5 + 24) = 0LL;
    else
      return 0LL;
  }
  return v6;
}

//----- (0000000000014DE0) ----------------------------------------------------
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  __int64 v1; // x8
  __int64 v2; // x19
  __int64 v3; // x0
  std::ios_base *v4; // x0

  v1 = *(_QWORD *)(result + 8) + *(_QWORD *)(**(_QWORD **)(result + 8) - 24LL);
  if ( *(_QWORD *)(v1 + 40) )
  {
    if ( !*(_DWORD *)(v1 + 32) && (*(_BYTE *)(v1 + 9) & 0x20) != 0 )
    {
      v2 = result;
      result = std::uncaught_exception();
      if ( (result & 1) == 0 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL) + 40LL);
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
        if ( (_DWORD)result == -1 )
        {
          v4 = (std::ios_base *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL));
          return std::ios_base::clear(v4, *((_DWORD *)v4 + 8) | 1u);
        }
      }
    }
  }
  return result;
}

//----- (0000000000014E80) ----------------------------------------------------
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  char v6[8]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD *v7; // [xsp+10h] [xbp-30h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (_QWORD *)(*a1 - 24LL);
  if ( *(_QWORD *)((char *)a1 + *v2 + 40) )
  {
    v6[0] = 0;
    v7 = a1;
    v3 = (char *)a1 + *v2;
    if ( !*((_DWORD *)v3 + 8) )
    {
      v4 = (_QWORD *)*((_QWORD *)v3 + 17);
      if ( v4 )
      {
        std::ostream::flush(v4);
        v2 = (_QWORD *)(*a1 - 24LL);
      }
      v6[0] = 1;
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)((char *)a1 + *v2 + 40) + 48LL))(*(_QWORD *)((char *)a1 + *v2 + 40)) == -1 )
        std::ios_base::clear(
          (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
          *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 1);
    }
    std::ostream::sentry::~sentry((__int64)v6);
  }
  return a1;
}
// 14E80: using guessed type char var_38[8];

//----- (0000000000014FA0) ----------------------------------------------------
unsigned __int64 __usercall std::stringbuf::str@<X0>(unsigned __int64 result@<X0>, unsigned __int64 *a2@<X8>)
{
  int v2; // w9
  char *v4; // x21
  unsigned __int64 v5; // x8
  char *v6; // x23
  unsigned __int64 v7; // x22
  char *v8; // x19
  char *v9; // x8
  char *v10; // x23
  char *v11; // x21
  char *v12; // x8
  _OWORD *v13; // x11
  __int128 *v14; // x12
  unsigned __int64 v15; // x13
  __int128 v16; // q0
  __int128 v17; // q1
  char v18; // t1
  _OWORD *v19; // x11
  __int128 *v20; // x12
  unsigned __int64 v21; // x13
  __int128 v22; // q0
  __int128 v23; // q1
  char v24; // t1

  v2 = *(_DWORD *)(result + 96);
  if ( (v2 & 0x10) != 0 )
  {
    v4 = *(char **)(result + 88);
    v5 = *(_QWORD *)(result + 48);
    if ( (unsigned __int64)v4 < v5 )
    {
      v4 = *(char **)(result + 48);
      *(_QWORD *)(result + 88) = v5;
    }
    v6 = *(char **)(result + 40);
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    v7 = v4 - v6;
    if ( (unsigned __int64)(v4 - v6) < 0xFFFFFFFFFFFFFFF0LL )
    {
      if ( v7 > 0x16 )
      {
        result = operator new((v7 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        a2[1] = v7;
        a2[2] = result;
        *a2 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v8 = (char *)result;
        if ( v6 == v4 )
          goto LABEL_34;
      }
      else
      {
        *(_BYTE *)a2 = 2 * v7;
        v8 = (char *)a2 + 1;
        if ( v6 == v4 )
          goto LABEL_34;
      }
      if ( v7 >= 0x20 )
      {
        if ( v8 >= v4 || (v9 = v8, v6 >= &v8[v7]) )
        {
          v13 = v8 + 16;
          v9 = &v8[v7 & 0xFFFFFFFFFFFFFFE0LL];
          v14 = (__int128 *)(v6 + 16);
          v15 = v7 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v16 = *(v14 - 1);
            v17 = *v14;
            v15 -= 32LL;
            v14 += 2;
            *(v13 - 1) = v16;
            *v13 = v17;
            v13 += 2;
          }
          while ( v15 );
          v6 += v7 & 0xFFFFFFFFFFFFFFE0LL;
          if ( (v7 & 0xFFFFFFFFFFFFFFE0LL) == v7 )
            goto LABEL_33;
        }
      }
      else
      {
        v9 = v8;
      }
      do
      {
        v18 = *v6++;
        *v9++ = v18;
      }
      while ( v4 != v6 );
      goto LABEL_33;
    }
LABEL_35:
    std::__basic_string_common<true>::__throw_length_error();
  }
  if ( (v2 & 8) == 0 )
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    return result;
  }
  v10 = *(char **)(result + 16);
  v11 = *(char **)(result + 32);
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  v7 = v11 - v10;
  if ( (unsigned __int64)(v11 - v10) >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_35;
  if ( v7 > 0x16 )
  {
    result = operator new((v7 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    a2[1] = v7;
    a2[2] = result;
    *a2 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v8 = (char *)result;
    if ( v10 == v11 )
      goto LABEL_34;
    goto LABEL_14;
  }
  *(_BYTE *)a2 = 2 * v7;
  v8 = (char *)a2 + 1;
  if ( v10 != v11 )
  {
LABEL_14:
    if ( v7 >= 0x20 )
    {
      if ( v8 >= v11 || (v12 = v8, v10 >= &v8[v7]) )
      {
        v19 = v8 + 16;
        v12 = &v8[v7 & 0xFFFFFFFFFFFFFFE0LL];
        v20 = (__int128 *)(v10 + 16);
        v21 = v7 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v22 = *(v20 - 1);
          v23 = *v20;
          v21 -= 32LL;
          v20 += 2;
          *(v19 - 1) = v22;
          *v19 = v23;
          v19 += 2;
        }
        while ( v21 );
        v10 += v7 & 0xFFFFFFFFFFFFFFE0LL;
        if ( v7 == (v7 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_33;
      }
    }
    else
    {
      v12 = v8;
    }
    do
    {
      v24 = *v10++;
      *v12++ = v24;
    }
    while ( v11 != v10 );
LABEL_33:
    v8 += v7;
  }
LABEL_34:
  *v8 = 0;
  return result;
}

//----- (00000000000151B4) ----------------------------------------------------
void __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(a1);
}

//----- (00000000000151D8) ----------------------------------------------------
void __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::__on_zero_shared(__int64 a1)
{
  _QWORD *v1; // x19
  std::thread *v2; // x20
  void *v3; // x0

  v1 = *(_QWORD **)(a1 + 24);
  if ( v1 )
  {
    std::mutex::~mutex((std::mutex *)(v1 + 41));
    v2 = (std::thread *)v1[5];
    v1[5] = 0LL;
    if ( v2 )
    {
      std::thread::~thread(v2);
      operator delete(v2);
    }
    v3 = (void *)v1[4];
    v1[4] = 0LL;
    if ( v3 )
      operator delete(v3);
    operator delete(v1);
  }
}

//----- (000000000001523C) ----------------------------------------------------
__int64 __fastcall std::__shared_ptr_pointer<pudutech::ESP32  *>::__get_deleter(__int64 a1, __int64 a2)
{
  if ( *(char **)(a2 + 8) == "NSt6__ndk114default_deleteIN8pudutech5ESP32EEE" )
    return a1 + 24;
  else
    return 0LL;
}

//----- (000000000001525C) ----------------------------------------------------
__int64 __fastcall sub_1525C(std::__ndk1 *a1)
{
  pthread_key_t *v2; // x0
  const void *v3; // x1
  __int64 v4; // x20
  const char *v5; // x27
  size_t v6; // x0
  size_t v7; // x26
  char *v8; // x28
  unsigned __int64 v9; // x19
  const void *v10; // x26
  size_t v11; // x0
  size_t v12; // x27
  char *v13; // x28
  char v14; // w26
  unsigned __int64 v15; // x19
  char *v16; // x26
  unsigned int v17; // w19
  std::thread *v18; // x21
  std::__thread_struct *v19; // x20
  std::__thread_struct **v21; // [xsp+8h] [xbp-1F8h]
  unsigned __int64 v22; // [xsp+18h] [xbp-1E8h] BYREF
  size_t v23; // [xsp+20h] [xbp-1E0h]
  void *v24; // [xsp+28h] [xbp-1D8h]
  int v25; // [xsp+30h] [xbp-1D0h] BYREF
  unsigned __int64 v26; // [xsp+38h] [xbp-1C8h] BYREF
  size_t v27; // [xsp+40h] [xbp-1C0h]
  void *v28; // [xsp+48h] [xbp-1B8h]
  __int64 v29; // [xsp+50h] [xbp-1B0h] BYREF
  char *v30; // [xsp+58h] [xbp-1A8h] BYREF
  __int64 v31[42]; // [xsp+60h] [xbp-1A0h] BYREF

  v31[40] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (pthread_key_t *)std::__thread_local_data(a1);
  v3 = *(const void **)a1;
  *(_QWORD *)a1 = 0LL;
  pthread_setspecific(*v2, v3);
  v4 = *((_QWORD *)a1 + 1);
  v21 = (std::__thread_struct **)a1;
  if ( *(_BYTE *)v4 )
  {
    while ( 1 )
    {
      if ( (word_2A128 & 1) != 0 )
        v5 = (const char *)qword_2A138;
      else
        v5 = (char *)&word_2A128 + 1;
      v25 = dword_2A120;
      v26 = 0LL;
      v27 = 0LL;
      v28 = 0LL;
      v6 = strlen(v5);
      if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v7 = v6;
      if ( v6 >= 0x17 )
        break;
      v8 = (char *)&v26 + 1;
      LOBYTE(v26) = 2 * v6;
      if ( v6 )
        goto LABEL_10;
LABEL_11:
      v8[v7] = 0;
      if ( (g3::logLevel(&v25) & 1) == 0 )
      {
        v14 = 0;
        if ( (v26 & 1) == 0 )
          goto LABEL_22;
        goto LABEL_25;
      }
      v23 = 0LL;
      v24 = 0LL;
      v22 = 0LL;
      v10 = TAG;
      v11 = strlen((const char *)TAG);
      if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v12 = v11;
      if ( v11 >= 0x17 )
      {
        v15 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v13 = (char *)operator new(v15);
        v23 = v12;
        v24 = v13;
        v22 = v15 | 1;
LABEL_19:
        memcpy(v13, v10, v12);
        goto LABEL_20;
      }
      v13 = (char *)&v22 + 1;
      LOBYTE(v22) = 2 * v11;
      if ( v11 )
        goto LABEL_19;
LABEL_20:
      v13[v12] = 0;
      v14 = g3::logTag(&v22);
      if ( (v22 & 1) != 0 )
      {
        operator delete(v24);
        if ( (v26 & 1) == 0 )
        {
LABEL_22:
          if ( (v14 & 1) == 0 )
            goto LABEL_27;
LABEL_26:
          LogCapture::LogCapture((LogCapture *)&v30, (const char *)TAG, (const LEVELS *)&dword_2A120, "", 6, 0LL);
          std::__put_character_sequence<char,std::char_traits<char>>(v31, (__int64)"send hand shake to esp", 22LL);
          LogCapture::~LogCapture((LogCapture *)&v30);
          goto LABEL_27;
        }
      }
      else if ( (v26 & 1) == 0 )
      {
        goto LABEL_22;
      }
LABEL_25:
      operator delete(v28);
      if ( (v14 & 1) != 0 )
        goto LABEL_26;
LABEL_27:
      v16 = (char *)operator new(1uLL);
      *v16 = 0;
      v31[1] = (__int64)(v16 + 1);
      v30 = v16;
      v31[0] = (__int64)(v16 + 1);
      pudutech::ESP32::sendMsg(v4, &v30, 1);
      if ( *(_BYTE *)(v4 + 1) )
      {
        v17 = -1;
        do
        {
          if ( !*(_BYTE *)v4 )
            break;
          v29 = 50000000LL;
          std::this_thread::sleep_for(&v29);
          ++v17;
        }
        while ( v17 < 0x28 );
      }
      else
      {
        v29 = 200000000LL;
        std::this_thread::sleep_for(&v29);
      }
      operator delete(v16);
      if ( !*(_BYTE *)v4 )
        goto LABEL_34;
    }
    v9 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)operator new(v9);
    v27 = v7;
    v28 = v8;
    v26 = v9 | 1;
LABEL_10:
    memcpy(v8, v5, v7);
    goto LABEL_11;
  }
LABEL_34:
  v18 = *(std::thread **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0LL;
  if ( v18 )
  {
    std::thread::~thread(v18);
    operator delete(v18);
  }
  if ( v21 )
  {
    v19 = *v21;
    *v21 = 0LL;
    if ( v19 )
    {
      std::__thread_struct::~__thread_struct(v19);
      operator delete(v19);
    }
    operator delete(v21);
  }
  return 0LL;
}
// 76E0: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 76F0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 7960: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 7A80: using guessed type __int64 __fastcall std::this_thread::sleep_for(_QWORD);
// 2A008: using guessed type void *TAG;
// 2A120: using guessed type int dword_2A120;
// 2A128: using guessed type __int16 word_2A128;
// 2A138: using guessed type __int64 qword_2A138;

//----- (0000000000015668) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(
        std::__shared_weak_count *this)
{
  void *v2; // x0

  v2 = (void *)*((_QWORD *)this + 3);
  *(_QWORD *)this = off_29898;
  if ( v2 )
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(this);
}
// 29898: using guessed type __int64 (__fastcall *[2])(std::__shared_weak_count *this);

//----- (00000000000156A8) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(
        std::__shared_weak_count *this)
{
  void *v2; // x0

  v2 = (void *)*((_QWORD *)this + 3);
  *(_QWORD *)this = off_29898;
  if ( v2 )
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(this);
  operator delete(this);
}
// 29898: using guessed type __int64 (__fastcall *off_29898[2])(std::__shared_weak_count *this);

//----- (00000000000156F0) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(__int64 a1)
{
  void *v2; // x0

  v2 = *(void **)(a1 + 24);
  if ( v2 )
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

//----- (000000000001570C) ----------------------------------------------------
__int64 __fastcall sendMsg(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w0
  __int64 v6; // x21
  char *v7; // x8
  __int64 v8; // x9
  void *v9; // x4
  unsigned int v10; // w19
  void *v12; // [xsp+0h] [xbp-40h] BYREF
  char *v13; // [xsp+8h] [xbp-38h]
  char *v14; // [xsp+10h] [xbp-30h]
  __int64 v15; // [xsp+18h] [xbp-28h]

  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  v6 = v5;
  v12 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  if ( v5 )
  {
    if ( v5 < 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v7 = (char *)operator new(v5);
    v14 = &v7[v6];
    v8 = -v6;
    v12 = v7;
    v13 = v7;
    do
    {
      *v7 = 0;
      ++v8;
      v7 = ++v13;
    }
    while ( v8 );
    v9 = v12;
  }
  else
  {
    v9 = 0LL;
  }
  (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, void *))(*(_QWORD *)a1 + 1600LL))(
    a1,
    a3,
    0LL,
    (unsigned int)v6,
    v9);
  v10 = pudutech::ESP32::sendMsg(esp, (char **)&v12, 0);
  if ( v12 )
  {
    v13 = (char *)v12;
    operator delete(v12);
  }
  return v10;
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015838) ----------------------------------------------------
__int64 __fastcall readMsg(__int64 a1)
{
  __int64 v2; // x19
  std::__shared_weak_count *v3; // x20
  unsigned __int64 *v4; // x8
  unsigned __int64 v5; // x9
  _DWORD *v7; // [xsp+8h] [xbp-38h] BYREF
  std::__shared_weak_count *v8; // [xsp+10h] [xbp-30h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  pudutech::ESP32::readMsg((pudutech::ESP32 *)esp, (__int64)&v7);
  if ( v7 )
  {
    v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(a1, (unsigned int)(v7[2] - *v7));
    (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 1664LL))(
      a1,
      v2,
      0LL,
      v7[2] - (unsigned int)*(_QWORD *)v7);
    v3 = v8;
    if ( !v8 )
      return v2;
  }
  else
  {
    v2 = 0LL;
    v3 = v8;
    if ( !v8 )
      return v2;
  }
  v4 = (unsigned __int64 *)((char *)v3 + 8);
  do
    v5 = __ldaxr(v4);
  while ( __stlxr(v5 - 1, v4) );
  if ( !v5 )
  {
    (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v3 + 16LL))(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v2;
}
// 2A280: using guessed type __int64 esp;

//----- (000000000001597C) ----------------------------------------------------
__int64 __fastcall openESP(int a1, int a2, int a3, int a4)
{
  return pudutech::ESP32::openESP((pudutech::ESP32 *)esp, a3, a4) & 1;
}
// 2A280: using guessed type __int64 esp;

//----- (00000000000159A8) ----------------------------------------------------
__int64 closeESP()
{
  return pudutech::ESP32::closeESP((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (00000000000159B8) ----------------------------------------------------
bool checkHardwareHandshake()
{
  return pudutech::ESP32::checkHardwareHandshake((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (00000000000159DC) ----------------------------------------------------
bool hasHardwareResponsed()
{
  return pudutech::ESP32::hasHardwareResponsed((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A00) ----------------------------------------------------
bool connectStatus()
{
  return pudutech::ESP32::connectStatus((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A24) ----------------------------------------------------
__int64 __fastcall resetChannel(int a1, int a2, int a3)
{
  return pudutech::ESP32::resetChannel((pudutech::ESP32 *)esp, a3) & 1;
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A4C) ----------------------------------------------------
__int64 getChannel()
{
  return pudutech::ESP32::getChannel((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A5C) ----------------------------------------------------
__int64 getEspFirmwareVersion()
{
  return pudutech::ESP32::getEspFirmwareVersion((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A6C) ----------------------------------------------------
__int64 getErrorCode()
{
  return (unsigned __int8)pudutech::ESP32::getErrorCode((pudutech::ESP32 *)esp);
}
// 2A280: using guessed type __int64 esp;

//----- (0000000000015A90) ----------------------------------------------------
__int64 __fastcall registerPuduNativeClass(_JNIEnv *a1)
{
  jclass v2; // x0
  __int64 v3; // x8
  __int64 v4; // x9
  std::__shared_weak_count *v5; // x19
  unsigned __int64 *v6; // x8
  unsigned __int64 v7; // x9
  std::__shared_weak_count *v8; // x19
  unsigned __int64 *v9; // x8
  unsigned __int64 v10; // x9
  __int64 v12; // [xsp+8h] [xbp-28h] BYREF
  unsigned __int64 *v13; // [xsp+10h] [xbp-20h]
  __int64 v14; // [xsp+18h] [xbp-18h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = a1->functions->FindClass(a1, "com/pudutech/schedulerlib/connection/ESPScheduleNative");
  if ( !v2
    || (((__int64 (__fastcall *)(_JNIEnv *, jclass, char **, __int64))a1->functions->RegisterNatives)(
          a1,
          v2,
          moduleMethods,
          11LL) & 0x80000000) != 0 )
  {
    return 0xFFFFFFFFLL;
  }
  pudutech::ESP32::create(&v12);
  v3 = v12;
  v4 = (__int64)v13;
  v12 = 0LL;
  v13 = 0LL;
  v5 = (std::__shared_weak_count *)qword_2A288;
  esp = v3;
  qword_2A288 = v4;
  if ( v5 )
  {
    v6 = (unsigned __int64 *)((char *)v5 + 8);
    do
      v7 = __ldaxr(v6);
    while ( __stlxr(v7 - 1, v6) );
    if ( !v7 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v5 + 16LL))(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = (std::__shared_weak_count *)v13;
  if ( v13 )
  {
    v9 = v13 + 1;
    do
      v10 = __ldaxr(v9);
    while ( __stlxr(v10 - 1, v9) );
    if ( !v10 )
    {
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v8 + 16LL))(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return 0LL;
}
// 2A018: using guessed type char *moduleMethods[2];
// 2A280: using guessed type __int64 esp;
// 2A288: using guessed type __int64 qword_2A288;'

//----- (0000000000015BA8) ----------------------------------------------------
jint JNI_OnLoad(JavaVM *vm, void *reserved)
{
  jint v2; // w19
  _JNIEnv *v4[2]; // [xsp+0h] [xbp-20h] BYREF

  v4[1] = *(_JNIEnv **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = 65542;
  if ( (*vm)->GetEnv(vm, (void **)v4, 65542LL) )
    return -1;
  registerPuduNativeClass(v4[0]);
  return v2;
}

//----- (0000000000015C20) ----------------------------------------------------
void __noreturn std::__vector_base_common<true>::__throw_length_error()
{
  sub_12454("vector");
}

// nfuncs=348 queued=173 decompiled=173 lumina nreq=0 worse=0 better=0
// ALL OK, 173 function(s) have been successfully decompiled
