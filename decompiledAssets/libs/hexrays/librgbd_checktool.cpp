/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_125E0();
float __fastcall Eigen::internal::tridiagonalization_inplace_selector<Eigen::Matrix<float,3,3,0,3,3>,3,false>::run<Eigen::Matrix<float,3,1,0,3,1>,Eigen::Matrix<float,2,1,0,2,1>>(__int64 a1, float *a2, float *a3, char a4);
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(float a1, float a2, float a3, float a4, float a5, float a6, float a7, __int64 a8, float *a9);
// __int64 __fastcall cv::FileStorage::FileStorage(_QWORD, _QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
// _QWORD cv::Mat::deallocate(cv::Mat *__hidden this); idb
// int system(const char *command);
void __fastcall std::vector<ground_filter::plane_base>::__append(__int64 *a1, unsigned __int64 a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg>>(char **a1, __int64 a2);
_QWORD *__fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(_QWORD *a1, __int64 *a2);
void __fastcall Eigen::Matrix<bool,-1,-1,0,-1,-1>::Matrix<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>,Eigen::Matrix<bool,-1,-1,0,-1,-1>>>(unsigned __int64 *a1, _QWORD *a2);
// void __usercall getColorDepthImage(const cv::Mat *a1@<X0>, int a2@<W1>, int a3@<W2>, __int64 a4@<X8>);
// _QWORD __fastcall std::logic_error::logic_error(std::logic_error *__hidden this, const char *); idb
// void *__fastcall __cxa_begin_catch(void *);
__int64 __fastcall CAPE::judgPlaneValid(float a1, float a2, float a3, __int64 a4, float *a5, float *a6);
__int64 __fastcall feasibal_region::feasibal_region::run(feasibal_region::feasibal_region *this, const feasibal_region::RunInputParam *a2, feasibal_region::RunOutputParam *a3);
// long double __usercall feasibal_region::ground_process::getExtrinsic@<Q0>(feasibal_region::ground_process *this@<X0>, __int64 a2@<X8>);
// _QWORD LogCapture::capturef(LogCapture *__hidden this, const char *, ...); idb
// _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this); idb
// int __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
__int64 __fastcall std::filebuf::sync(__int64 a1);
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int128 *a2, __int64 a3, int a4, double a5);
void __fastcall std::string::push_back(__int64 *a1, char a2);
// void __fastcall operator delete[](void *); idb
// __int64 __fastcall cv::write(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall cv::write(_QWORD, _QWORD, _QWORD); weak
unsigned __int64 __fastcall std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 __fastcall feasibal_region::ground_process::init(__int64 a1, __int64 a2);
// __int64 __fastcall std::locale::has_facet(_QWORD, _QWORD); weak
// _QWORD __fastcall operator new(unsigned __int64); idb
void __fastcall Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize(__int64 a1, __int64 a2, __int64 a3);
// int access(const char *name, int type);
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n);
void __noreturn std::__basic_string_common<true>::__throw_length_error();
// void sincos(double x, double *sinx, double *cosx);
// float atanf(float x);
__int64 __fastcall ground_filter::Plane_Seg::judgPointsValid(float *a1, float **a2);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
// float atan2f(float y, float x);
// _QWORD std::__shared_weak_count::__release_weak(std::__shared_weak_count *__hidden this); idb
// void *malloc(size_t size);
__int64 __fastcall cv::Mat_<unsigned char>::Mat_(__int64 a1, int a2, int a3, _BYTE *a4);
void __fastcall feasibal_region::feasibal_region::attemtpRead<std::string>(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// _QWORD __fastcall cv::read(cv *__hidden this, const cv::FileNode *, int *, int); idb
void __fastcall std::vector<int>::__push_back_slow_path<int const&>(__int64 a1, _DWORD *a2);
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
__int64 __fastcall feasibal_region::ground_process::processSlopeBasePlane(__int64 a1, __int64 a2, float *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, __int64 *a7);
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromPlane(__int64 a1, __int64 a2);
__int64 *__fastcall feasibal_region::PreParamInfo::PreParamInfo(feasibal_region::PreParamInfo *this);
// __int64 lrintf(float x);
__int64 __fastcall std::random_device::random_device(_DWORD *a1, __int64 a2);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD); weak
float __fastcall PlaneSeg::fitPlane(PlaneSeg *this);
void __fastcall std::vector<PlaneSeg>::__push_back_slow_path<PlaneSeg const&>(void ***a1, __int64 a2);
// int mkdir(const char *path, __mode_t mode);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(char **a1, _DWORD *a2, unsigned __int64 a3, char *a4);
// _QWORD __fastcall std::__throw_system_error(std::__ndk1 *__hidden this, int, const char *); idb
void __fastcall std::vector<bool>::reserve(__int64 *a1, unsigned __int64 a2);
char *__fastcall _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, const void **a7, char **a8, __int64 a9, _BYTE *a10);
// void sincosf(float x, float *sinx, float *cosx);
// _QWORD *__fastcall cv::operator&(_QWORD *__return_ptr, _QWORD, _QWORD); weak
__int64 __fastcall feasibal_region::ground_process::planeProcess(feasibal_region::ground_process *this);
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2);
// __int64 __fastcall cv::minMaxLoc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// struct dirent *readdir(DIR *dirp);
// void __fastcall operator delete(void *); idb
// __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD); weak
// int lstat(const char *file, struct stat *buf);
// _QWORD *__fastcall cv::operator==(_QWORD *__return_ptr, _QWORD, double); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// _QWORD __fastcall cv::MatConstIterator::seek(cv::MatConstIterator *__hidden this, __int64, bool); idb
// void __usercall CAPE::process_modify_opt(int *a1@<X0>, _QWORD *a2@<X1>, unsigned int *a3@<X2>, __int64 a4@<X4>, __int64 a5@<X6>, __int64 a6@<X8>);
void __fastcall Histogram::~Histogram(Histogram *this); // idb
// int close(int fd);
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3);
// double pow(double x, double y);
// _QWORD cv::FileNode::type(cv::FileNode *__hidden this); idb
// _QWORD __fastcall cv::read(cv *__hidden this, const cv::FileNode *, float *, float); idb
__int64 __fastcall CAPE::swapPlanes(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5);
__int64 __fastcall checktool::saveResults(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall feasibal_region::ground_process::run(feasibal_region::ground_process *this, const feasibal_region::GroundProcessRunInData *a2, feasibal_region::GroundProcessRunOutData *a3); // idb
// _QWORD __fastcall cv::MatConstIterator::seek(cv::MatConstIterator *__hidden this, const int *, bool); idb
// _QWORD *__fastcall cv::Mat::ones(_QWORD *__hidden __return_ptr, cv::Mat *__hidden this, int, int, int); idb
// _QWORD __fastcall cv::Mat::create(cv::Mat *__hidden this, int, const int *, int); idb
__int64 __fastcall std::istream::tellg(_QWORD *a1);
// __int64 __fastcall cv::transpose(_QWORD, _QWORD); weak
// _QWORD __fastcall operator new[](unsigned __int64); idb
// _QWORD std::uncaught_exception(void); idb
// LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *); weak
// void __usercall ground_filter::Plane_Seg::getPointCloudOnIndexes(_QWORD *a1@<X0>, __int64 *a2@<X1>, _QWORD *a3@<X8>);
// __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD); weak
// void free(void *ptr);
void __fastcall gte::NISymmetricEigensolver3x3<float>::operator()(__int64 a1, int a2, __int64 a3, float32x2_t *a4, float a5, float a6, float a7, float a8, float a9, float a10);
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg> const&>(__int64 a1, _QWORD *a2);
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
void __fastcall feasibal_region::RunInputParam::~RunInputParam(feasibal_region::RunInputParam *this, void *a2);
__int64 *__fastcall std::getline<char,std::char_traits<char>,std::allocator<char>>(__int64 *a1, __int64 a2, char a3);
// void *__fastcall __cxa_allocate_exception(size_t thrown_size);
// _QWORD *std::ios_base::getloc(_QWORD *__hidden __return_ptr, std::ios_base *__hidden this); idb
// _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD); weak
void __fastcall PlaneSeg::updatePlaneSeg(__int64 a1, _QWORD *a2, int a3, int a4, int a5);
// cv *__usercall feasibal_region::rotationMatrixFromAxisAndAngle@<X0>(double *a1@<X0>, double a3@<D0>, __int64 a2@<X8>);
// __int64 __errno(void); weak
// int fflush(FILE *stream);
void __fastcall std::vector<int>::__emplace_back_slow_path<int &>(__int64 a1, _DWORD *a2);
// void _Unwind_Resume(struct _Unwind_Exception *);
// void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(float *a2@<X1>, __int64 *a3@<X2>, float a9@<S0>, __int64 a1@<X0>, int a4@<W3>, int a5@<W4>, unsigned __int8 a6@<W5>, int a7@<W6>, __int64 a8@<X8>);
__int64 __fastcall CAPE::judgeValidBasedImage(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, unsigned int *a4, unsigned int *a5);
// int closedir(DIR *dirp);
// int open(const char *file, int oflag, ...);
// double acos(double x);
// __int64 __fastcall cv::projectPoints(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double); weak
// __int64 __fastcall cv::rectangle(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int strcmp(const char *s1, const char *s2);
void __fastcall std::filebuf::~filebuf(__int64 a1);
void *__fastcall ground_filter::Plane_Seg::Plane_Seg(ground_filter::Plane_Seg *this, char a2, float a3);
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,-1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3, __int64 a4);
// cv *__usercall checktool::getExtrinsicParameters@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X2>, __int64 a3@<X8>);
__int64 __fastcall feasibal_region::feasibal_region::readParam(float32x2_t *a1, __int64 a2);
void __fastcall feasibal_region::GroundProcessRunInData::~GroundProcessRunInData(feasibal_region::GroundProcessRunInData *this, void *a2);
__int64 *__fastcall std::vector<cv::Mat>::__swap_out_circular_buffer(__int64 *result, _QWORD *a2);
__int64 __fastcall CAPE::RegionGrowing(__int64 result, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, _QWORD *a6, _QWORD *a7, unsigned int a8, long double a9, unsigned __int16 a10, float *a11);
// _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD); weak
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
// _QWORD __fastcall std::locale::locale(std::locale *__hidden this, const std::locale *); idb
void __fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix(__int64 *a1, __int64 *a2);
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int64 *a2);
bool __fastcall ground_filter::Plane_Seg::segPlane(char **a1, float32x2_t *a2, __int64 *a3, int a4);
void __fastcall CAPE::getConnectedComponents(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(__int64 a1, __int64 a2);
bool __fastcall isRotationMatrix(cv::Mat *a1);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(char **a1, _DWORD *a2, unsigned __int64 a3, char *a4);
cv::Mat *__fastcall cv::Mat::operator=(cv::Mat *this, cv::Mat *a2);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
__int64 __fastcall Eigen::SelfAdjointEigenSolver<Eigen::Matrix<float,3,3,0,3,3>>::compute(__int64 a1, float *a2, char a3);
__int64 __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(__int64 a1, __int64 a2, float *a3, __int64 a4);
void __fastcall std::vector<Eigen::Transform<float,3,1,0>>::__push_back_slow_path<Eigen::Transform<float,3,1,0> const&>(__int64 a1, _OWORD *a2);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, float a2);
// void __fastcall __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (__fastcall *)(void *));
char *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(__int64 a1, char *a2, char *a3);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
void __fastcall PlaneSeg::~PlaneSeg(void **this);
__int64 __fastcall feasibal_region::ground_process::set_calib(__int64 a1, __int128 *a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<bool,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
// void *memmove(void *dest, const void *src, size_t n);
// __int64 __fastcall cv::divide(_QWORD, _QWORD, _QWORD, _QWORD, double); weak
// void *memset(void *s, int c, size_t n);
// void __usercall Histogram::getPointsFromMostFrequentBin(Histogram *this@<X0>, int64x2_t *a2@<X8>);
// int fseeko(FILE *stream, __off_t off, int whence);
// __int64 __fastcall cv::operator<<(_QWORD, _QWORD); weak
float32x4_t *__fastcall std::vector<int>::assign(float32x4_t **a1, unsigned __int64 a2, const float *a3);
// _QWORD *__fastcall cv::operator-(_QWORD *__return_ptr, _QWORD, _QWORD); weak
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1);
__int64 __fastcall ground_filter::Plane_Seg::judgPlaneValid(__int64 a1, float *a2, float *a3, float a4);
// _QWORD std::bad_alloc::bad_alloc(std::bad_alloc *__hidden this); idb
// time_t time(time_t *timer);
// __int64 __fastcall cv::Mat::convertTo(_QWORD, _QWORD, _QWORD, double, double); weak
// double sin(double x);
cv *__fastcall feasibal_region::feasibal_region::attemtpRead<cv::Mat>(__int64 a1, __int64 a2, const cv::FileNode *a3, __int64 a4);
// int __fastcall __cxa_finalize(void *);
// _QWORD std::locale::locale(std::locale *__hidden this); idb
void __fastcall feasibal_region::RunOutputParam::~RunOutputParam(feasibal_region::RunOutputParam *this, void *a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
void __fastcall std::vector<std::vector<Eigen::Matrix<float,3,1,0,3,1>>>::__push_back_slow_path<std::vector<Eigen::Matrix<float,3,1,0,3,1>> const&>(signed __int64 **a1, char **a2);
// __int64 __fastcall cv::circle(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __usercall rotationMatrixToEulerAngles(cv::Mat *a1@<X0>, __int64 a2@<X8>);
unsigned __int64 __fastcall std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(_QWORD *a1);
void __fastcall std::vector<cv::Point_<int>>::__push_back_slow_path<cv::Point_<int>>(__int64 a1, _QWORD *a2);
void __fastcall CAPE::CAPE(CAPE *this, int a2, int a3, int a4, int a5, char a6, float a7, float a8, float a9);
// _QWORD __fastcall cv::Mat::copySize(cv::Mat *__hidden this, const cv::Mat *); idb
// __int64 __fastcall cv::read(_QWORD, _QWORD, _QWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// __int64 __fastcall cv::imwrite(_QWORD, _QWORD, _QWORD); weak
// void __cxa_end_catch(void);
// __off_t ftello(FILE *stream);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::insert(unsigned __int64 *a1, char *a2, _DWORD *a3);
// __int64 __fastcall cv::imshow(_QWORD, _QWORD); weak
// _QWORD *__fastcall cv::operator-(_QWORD *__return_ptr, _QWORD, _QWORD); weak
// _QWORD __fastcall std::runtime_error::runtime_error(std::runtime_error *__hidden this, const char *); idb
// void __fastcall LogCapture::~LogCapture(LogCapture *__hidden this); idb
long double __fastcall feasibal_region::ground_process::ground_process(feasibal_region::ground_process *this);
__int64 __fastcall PlaneSeg::operator=(__int64 a1, __int64 a2);
// int fclose(FILE *stream);
// double atan2(double y, double x);
// int fprintf(FILE *stream, const char *format, ...);
_QWORD *__fastcall std::vector<std::vector<int>>::vector(_QWORD *result, unsigned __int64 a2);
void __fastcall std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>(__int64 *a1, cv::Mat *a2);
// __int64 __fastcall cv::cvtColor(_QWORD, _QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall std::vector<bool>::__construct_at_end<std::__bit_iterator<std::vector<bool>,false,0ul>>(_QWORD *result, __int64 a2, __int64 a3);
// double cos(double x);
__int64 __fastcall CAPE::updateDefaultPlane(__int64 result, _DWORD *a2, float a3);
// _QWORD *__fastcall cv::Mat::eye(_QWORD *__hidden __return_ptr, cv::Mat *__hidden this, int, int, int); idb
__int64 __fastcall ground_filter::Plane_Seg::optimizePlaneCoef(float32x2_t *a1, __int64 *a2, unsigned __int32 *a3, float32x2_t *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
float __fastcall PlaneSeg::expandSegment(int *a1, __int64 *a2);
// _QWORD __fastcall cv::read(cv *__hidden this, const cv::FileNode *, cv::Mat *, const cv::Mat *); idb
// _QWORD *__fastcall cv::imread(_QWORD *__return_ptr, _QWORD, _QWORD); weak
// void __fastcall std::locale::~locale(std::locale *__hidden this); idb
__int64 __fastcall checktool::getNearEdge(__int64 a1, __int64 *a2, int a3);
void __fastcall feasibal_region::PreParamInfo::~PreParamInfo(void **this, void *a2);
// _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD); weak
__int64 __fastcall std::random_device::operator()(int *a1);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
// void __fastcall cv::FileStorage::~FileStorage(cv::FileStorage *__hidden this); idb
// __int64 __fastcall cv::Mat::setTo(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall CAPE::set_extrinsic(__int64 result, _DWORD *a2, _DWORD *a3);
// __int64 __fastcall cv::error(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
// float cosf(float x);
// _QWORD __fastcall std::ios_base::init(std::ios_base *__hidden this, void *); idb
// void __usercall checktool::getPointCloud(float *a1@<X1>, _QWORD *a4@<X8>, double a5@<D0>, __int64 a2@<X2>, int a3@<W3>);
__int64 *__fastcall std::vector<ground_filter::plane_base>::assign<ground_filter::plane_base*>(__int64 *result, char *a2, char *a3);
// __int64 __fastcall cv::putText(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double); weak
// _QWORD *__fastcall cv::getTextSize(_QWORD *__return_ptr, _QWORD, _QWORD, _QWORD, _QWORD, double); weak
feasibal_region *__fastcall feasibal_region::feasibal_region::feasibal_region(feasibal_region::feasibal_region *this); // idb
__int64 __fastcall feasibal_region::PreParamInfo::operator=(__int64 a1, __int128 *a2);
// _QWORD *__fastcall cv::FileStorage::operator[](_QWORD *__return_ptr, _QWORD); weak
void __fastcall cv::MatExpr::~MatExpr(cv::MatExpr *this, void *a2);
void __fastcall Histogram::Histogram(Histogram *this, int a2);
__int64 __fastcall CAPE::getBestPlane(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, const int *a4);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
void __fastcall CAPE::~CAPE(CAPE *this); // idb
// float acosf(float x);
float32x4_t *__fastcall Histogram::initHistogram(__int64 a1, __int64 *a2, __int64 *a3);
// __int64 __fastcall g3::logLevel(_QWORD); weak
void __fastcall std::__split_buffer<cv::Mat>::~__split_buffer(__int64 a1, void *a2);
// _QWORD *__fastcall std::to_string(_QWORD *__hidden __return_ptr, std::__ndk1 *__hidden this, unsigned int); idb
// double log(double x);
char *__fastcall _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, const void **a7, char **a8, __int64 a9, _BYTE *a10);
__int64 __fastcall feasibal_region::ground_process::pointCloudProcess(__int64 a1, __int64 a2);
// _QWORD cv::noArray(cv *__hidden this); idb
// _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, double); weak
// _QWORD __fastcall std::ios_base::clear(std::ios_base *__hidden this, unsigned int); idb
// _QWORD cv::FileStorage::release(cv::FileStorage *__hidden this); idb
// _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, double); weak
void __fastcall std::vector<int>::__push_back_slow_path<int>(__int64 a1, _DWORD *a2);
// int sscanf(const char *s, const char *format, ...);
// _QWORD __fastcall cv::waitKey(cv *__hidden this, int); idb
void __fastcall std::vector<cv::Vec<int,4>>::__push_back_slow_path<cv::Vec<int,4> const&>(__int64 a1, _OWORD *a2);
void __noreturn std::__vector_base_common<true>::__throw_length_error();
void __fastcall ground_filter::Plane_Seg::computeRoots(__int64 a1, float *a2, __int64 a3);
__int64 __fastcall ground_filter::Plane_Seg::segPlane(float32x2_t *a1, float **a2, _QWORD *a3, float32x2_t *a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8, int a9);
// _QWORD std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *__hidden this); idb
// struct tm *localtime(const time_t *timer);
__int64 __fastcall cv::Mat_<int>::Mat_(__int64 a1, int a2, int a3, int *a4);
// __int64 __usercall eulerAnglestoRotationMtx@<X0>(__int64 a1@<X0>, __int64 a2@<X8>);
// void __usercall ground_filter::Plane_Seg::run(float32x2_t *a1@<X0>, _QWORD *a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, __int64 a6@<X5>, unsigned __int32 *a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, float a10@<S0>);
void __fastcall std::random_device::~random_device(std::random_device *this); // idb
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(__int64 a1, __int64 *a2);
__int64 __fastcall feasibal_region::ground_process::getPlaneFromExtrinsic(__int64 a1, float32x2_t *a2, float *a3);
// FILE *fopen(const char *filename, const char *modes);
// unsigned __int64 __usercall std::__copy_unaligned<std::vector<bool>,false>@<X0>(unsigned __int64 result@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, __int64 a4@<X8>);
// __int64 __fastcall cv::write(_QWORD, _QWORD, double); weak
// _QWORD cv::FileStorage::isOpened(cv::FileStorage *__hidden this); idb
void __fastcall feasibal_region::ground_process::~ground_process(feasibal_region::ground_process *this); // idb
__int64 __fastcall feasibal_region::ground_process::groundProcess(feasibal_region::ground_process *this); // idb
// _QWORD *__fastcall cv::operator>(_QWORD *__return_ptr, _QWORD, double); weak
// void *memcpy(void *dest, const void *src, size_t n);
// _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD); weak
__int64 __fastcall ground_filter::plane_base::operator=(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT_(__int64 a1, float32x2_t *a2, __int64 a3, __int64 a4);
// _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD); weak
// void __usercall CAPE::imageScore(CAPE *this@<X0>, const cv::Mat *a2@<X1>, const int *a3@<X2>, float32x4_t **a4@<X8>);
void __fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::__push_back_slow_path<Eigen::Matrix<float,4,1,0,4,1>>(__int64 a1, _OWORD *a2);
void __fastcall feasibal_region::RunInputParam::RunInputParam(feasibal_region::RunInputParam *this, __int64 a2, __int64 a3, int a4);
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(float a1, float a2, float a3, float a4, float a5, float a6, int32x2_t a7, __int64 a8, float *a9, float *a10);
// void __fastcall std::ios_base::~ios_base(std::ios_base *__hidden this); idb
// _QWORD __fastcall cv::fastFree(cv *__hidden this, void *); idb
// __int64 __fastcall g3::logTag(_QWORD); weak
__int64 __fastcall feasibal_region::feasibal_region::WriteCameraParam(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall Histogram::removePoint(_QWORD *this, int a2);
__int64 __fastcall ground_filter::plane_base::plane_base(__int64 result, __int64 a2);
__int64 __fastcall feasibal_region::getDirectorySize(__int64 a1);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, long double a2);
float32x4_t *__fastcall Eigen::internal::apply_rotation_in_the_plane<Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,float>(float32x4_t *result, unsigned __int64 *a2, _DWORD *a3, double a4, double a5);
// __int64 __fastcall __register_atfork(_QWORD, _QWORD, _QWORD, _QWORD); weak
// long double __fastcall cv::norm(_QWORD, _QWORD, _QWORD, _QWORD); weak
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2);
// __int64 __fastcall cv::medianBlur(_QWORD, _QWORD, _QWORD); weak
// _QWORD *__fastcall cv::Mat::zeros(_QWORD *__hidden __return_ptr, cv::Mat *__hidden this, int, int, int); idb
// int rand(void);
signed __int64 __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector(signed __int64 *a1, char **a2);
// float32x2_t __usercall feasibal_region::ground_process::getTFMatrix@<D0>(float *a1@<X1>, float32x2_t *a2@<X2>, float32x2_t *a3@<X8>);
void __fastcall std::vector<cv::Vec<unsigned char,3>>::__push_back_slow_path<cv::Vec<unsigned char,3> const&>(__int64 a1, _BYTE *a2);
cv *__fastcall feasibal_region::depth2color(feasibal_region *this, cv::Mat *a2, const cv::Mat *a3, double a4, double a5);
// void __fastcall std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *__hidden this); idb
// _QWORD *__fastcall cv::Mat::reshape(_QWORD *__hidden __return_ptr, cv::Mat *__hidden this, int, int, const int *); idb
__int64 __fastcall feasibal_region::feasibal_region::readParam(__int64 a1, __int64 a2, _DWORD *a3, int a4, double a5);
// size_t strlen(const char *s);
// int sprintf(char *s, const char *format, ...);
// __int64 __fastcall cv::applyColorMap(_QWORD, _QWORD, _QWORD); weak
float __fastcall ground_filter::Plane_Seg::computeMeanAndCovarianceMatrix(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
// __int64 __fastcall cv::countNonZero(_QWORD); weak
void __fastcall ground_filter::Plane_Seg::~Plane_Seg(ground_filter::Plane_Seg *this, void *a2);
// void __noreturn std::terminate(void); idb
// DIR *opendir(const char *name);
void __fastcall std::vector<cv::Vec<float,3>>::__push_back_slow_path<cv::Vec<float,3> const&>(__int64 a1, __int64 a2);
void __fastcall feasibal_region::GroundProcessRunOutData::~GroundProcessRunOutData(feasibal_region::GroundProcessRunOutData *this, void *a2);
// int posix_memalign(void **memptr, size_t alignment, size_t size);
__int64 __fastcall feasibal_region::ground_process::init_data_pre(__int64 a1, __int64 a2);
_QWORD *__fastcall std::ostream::put(_QWORD *a1, unsigned __int8 a2);
// __int64 __fastcall cv::resize(_QWORD, _QWORD, _QWORD, _QWORD, double, double); weak
char *__fastcall std::vector<float>::insert(unsigned __int64 *a1, unsigned __int64 src, char *a3);
void __fastcall std::__split_buffer<ground_filter::plane_base>::~__split_buffer(__int64 a1, void *a2);
// _QWORD *__fastcall std::to_string(_QWORD *__hidden __return_ptr, std::__ndk1 *__hidden this, int); idb
void start();
void sub_1399C();
void sub_139B8();
void sub_139D4();
void sub_139F0();
void sub_13A0C();
void sub_13A28();
void sub_13A44();
void sub_13A60();
__int64 sub_13A7C();
__int64 sub_13D20();
__int64 sub_13FC4();
__int64 sub_14268();
__int64 sub_1450C();
__int64 sub_147B0();
__int64 (*__fastcall sub_147C4(__int64 (*result)(void)))(void);
__int64 __fastcall sub_147D0(void *a1);
__int64 __fastcall sub_147EC(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::string::~string(__int64 a1);
void __fastcall LEVELS::~LEVELS(void **this);
void __fastcall checktool::checktool(checktool *this);
bool __fastcall isRotationMatrix(cv::Mat *a1);
void __fastcall cv::MatExpr::~MatExpr(cv::MatExpr *this, void *a2);
// void __usercall rotationMatrixToEulerAngles(cv::Mat *a1@<X0>, __int64 a2@<X8>);
// __int64 __usercall eulerAnglestoRotationMtx@<X0>(__int64 a1@<X0>, __int64 a2@<X8>);
__int64 __fastcall checktool::init(__int64 a1, __int64 a2, int a3, int a4);
// void __usercall checktool::runcheck(feasibal_region::feasibal_region *a1@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, _BYTE *a4@<X3>, __int64 a5@<X8>);
void __fastcall feasibal_region::RunInputParam::RunInputParam(feasibal_region::RunInputParam *this, __int64 a2, __int64 a3, int a4);
cv::Mat *__fastcall cv::Mat::operator=(cv::Mat *this, cv::Mat *a2);
// cv *__usercall checktool::getExtrinsicParameters@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X2>, __int64 a3@<X8>);
__int64 __fastcall checktool::getNearEdge(__int64 a1, __int64 *a2, int a3);
// void __usercall checktool::getPointCloud(float *a1@<X1>, __int64 a2@<X2>, int a3@<W3>, _QWORD *a4@<X8>, double a5@<D0>);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, long double a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
// void __usercall getColorDepthImage(const cv::Mat *a1@<X0>, int a2@<W1>, int a3@<W2>, __int64 a4@<X8>);
__int64 __fastcall checktool::saveResults(__int64 a1, unsigned __int8 *a2);
void __fastcall ground_filter::Plane_Seg::~Plane_Seg(ground_filter::Plane_Seg *this, void *a2);
void __fastcall sub_1FD5C(void **a1, void *a2);
void __fastcall feasibal_region::RunOutputParam::~RunOutputParam(feasibal_region::RunOutputParam *this, void *a2);
void __fastcall feasibal_region::RunInputParam::~RunInputParam(feasibal_region::RunInputParam *this, void *a2);
// __int64 *__usercall sub_20140@<X0>(char *s@<X1>, unsigned __int8 *a2@<X0>, __int64 *a3@<X8>);
__int64 __fastcall sub_2024C(__int64 a1, char *s);
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::static_delete(__int64 a1, void **a2);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::copy_from_value(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::clone(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::get_size();
void **cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::type();
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::print(int a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::copy_from_value(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::clone(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::move(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::small_any_policy<char const*>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::small_any_policy<char const*>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<char const*>::get_size();
void *cvflann::anyimpl::typed_base_any_policy<char const*>::type();
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<char const*>::print(__int64 a1, _QWORD *a2, const char **a3);
void __fastcall cvflann::anyimpl::small_any_policy<int>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<int>::clone(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<int>::move(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::small_any_policy<int>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::small_any_policy<int>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<int>::get_size();
void *cvflann::anyimpl::typed_base_any_policy<int>::type();
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<int>::print(__int64 a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::small_any_policy<float>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<float>::clone(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<float>::move(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::small_any_policy<float>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::small_any_policy<float>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<float>::get_size();
void *cvflann::anyimpl::typed_base_any_policy<float>::type();
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<float>::print(__int64 a1, _QWORD *a2, float *a3);
void __fastcall cvflann::anyimpl::small_any_policy<bool>::copy_from_value(__int64 a1, _BYTE *a2, _BYTE *a3);
void __fastcall cvflann::anyimpl::small_any_policy<bool>::clone(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<bool>::move(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::small_any_policy<bool>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::small_any_policy<bool>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<bool>::get_size();
void *cvflann::anyimpl::typed_base_any_policy<bool>::type();
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<bool>::print(__int64 a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::static_delete(__int64 a1, void **a2);
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::copy_from_value(__int64 a1, _DWORD *a2, _QWORD *a3);
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::clone(__int64 a1, _DWORD **a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::move(__int64 a1, _DWORD **a2, _DWORD **a3);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::flann_algorithm_t>::get_size();
void **cvflann::anyimpl::typed_base_any_policy<cvflann::flann_algorithm_t>::type();
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::print(__int64 a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::static_delete(__int64 a1, void **a2);
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::copy_from_value(__int64 a1, _DWORD *a2, _QWORD *a3);
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::clone(__int64 a1, _DWORD **a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::move(__int64 a1, _DWORD **a2, _DWORD **a3);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::flann_centers_init_t>::get_size();
void **cvflann::anyimpl::typed_base_any_policy<cvflann::flann_centers_init_t>::type();
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::print(__int64 a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::clone(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::move(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<unsigned int>::get_size();
void *cvflann::anyimpl::typed_base_any_policy<unsigned int>::type();
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<unsigned int>::print(__int64 a1, _QWORD *a2);
void __fastcall cvflann::anyimpl::big_any_policy<std::string>::static_delete(__int64 a1, void **a2);
size_t *__fastcall cvflann::anyimpl::big_any_policy<std::string>::copy_from_value(__int64 a1, __int128 *a2, size_t **a3);
size_t *__fastcall cvflann::anyimpl::big_any_policy<std::string>::clone(__int64 a1, __int128 **a2, size_t **a3);
__int64 *__fastcall cvflann::anyimpl::big_any_policy<std::string>::move(__int64 a1, __int64 **a2, __int64 **a3);
__int64 __fastcall cvflann::anyimpl::big_any_policy<std::string>::get_value(__int64 a1, __int64 a2);
__int64 __fastcall cvflann::anyimpl::big_any_policy<std::string>::get_value(__int64 a1, __int64 a2);
__int64 cvflann::anyimpl::typed_base_any_policy<std::string>::get_size();
void **cvflann::anyimpl::typed_base_any_policy<std::string>::type();
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<std::string>::print(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall __noreturn sub_20AC4(void *a1);
char *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(__int64 a1, char *a2, char *a3);
void __noreturn std::__vector_base_common<true>::__throw_length_error();
void __fastcall __noreturn sub_20E70(const char *a1);
__int64 __fastcall sub_20EC0(std::logic_error *a1, const char *a2);
void __noreturn std::__basic_string_common<true>::__throw_length_error();
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_210A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c);
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result);
_QWORD *__fastcall std::ostream::flush(_QWORD *a1);
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n);
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n);
_QWORD *__fastcall std::ostream::put(_QWORD *a1, unsigned __int8 a2);
void __fastcall std::vector<int>::__push_back_slow_path<int const&>(__int64 a1, _DWORD *a2);
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2);
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2);
void __fastcall std::vector<Eigen::Transform<float,3,1,0>>::__push_back_slow_path<Eigen::Transform<float,3,1,0> const&>(__int64 a1, _OWORD *a2);
void __fastcall std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>(__int64 *a1, cv::Mat *a2);
__int64 *__fastcall std::vector<cv::Mat>::__swap_out_circular_buffer(__int64 *result, _QWORD *a2);
void __fastcall std::__split_buffer<cv::Mat>::~__split_buffer(__int64 a1, void *a2);
void __fastcall std::vector<cv::Vec<float,3>>::__push_back_slow_path<cv::Vec<float,3> const&>(__int64 a1, __int64 a2);
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n);
void __noreturn std::__basic_string_common<true>::__throw_out_of_range();
void __fastcall __noreturn sub_228A8(const char *a1);
__int64 __fastcall sub_228F8(std::logic_error *a1, const char *a2);
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(__int64 a1, __int64 a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, float a2);
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1);
void *__fastcall ground_filter::Plane_Seg::Plane_Seg(ground_filter::Plane_Seg *this, char a2, float a3);
__int64 __fastcall ground_filter::Plane_Seg::judgPointsValid(float *a1, float **a2);
__int64 __fastcall ground_filter::Plane_Seg::judgPlaneValid(__int64 a1, float *a2, float *a3, float a4);
float __fastcall ground_filter::Plane_Seg::getVectorAngle(__int64 a1, float *a2, float *a3);
// void __usercall ground_filter::Plane_Seg::run(float32x2_t *a1@<X0>, _QWORD *a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, __int64 a6@<X5>, unsigned __int32 *a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, float a10@<S0>, char **a11);
// void __usercall ground_filter::Plane_Seg::run(float32x2_t *a1@<X0>, _QWORD *a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, __int64 a6@<X5>, unsigned __int32 *a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, float a10@<S0>);
__int64 __fastcall ground_filter::Plane_Seg::segPlane(float32x2_t *a1, float **a2, _QWORD *a3, float32x2_t *a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8, int a9);
__int64 __fastcall ground_filter::Plane_Seg::getIndication(__int64 this, float *a2, float *a3);
__int64 __fastcall ground_filter::Plane_Seg::getPointInfo(__int64 result, _DWORD *a2, _QWORD *a3);
// float64x2_t __usercall ground_filter::Plane_Seg::getTFMatrix@<Q0>(double *a1@<X1>, float64x2_t *a2@<X2>, float64x2_t *a3@<X8>);
__int64 __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(__int64 a1, __int64 a2, float *a3, __int64 a4);
__int64 __fastcall ground_filter::Plane_Seg::optimizePlaneCoef(float32x2_t *a1, __int64 *a2, unsigned __int32 *a3, float32x2_t *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall ground_filter::Plane_Seg::detectPlane(float32x2_t *a1, __int64 *a2, float32x2_t *a3, _QWORD *a4, __int64 a5, int a6);
// void __usercall ground_filter::Plane_Seg::getPointCloudOnIndexes(_QWORD *a1@<X0>, __int64 *a2@<X1>, _QWORD *a3@<X8>);
bool __fastcall ground_filter::Plane_Seg::segPlane(char **a1, float32x2_t *a2, __int64 *a3, int a4);
signed __int64 __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector(signed __int64 *a1, char **a2);
float __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(float result, __int64 a2, __int64 a3, float *a4);
bool __fastcall ground_filter::Plane_Seg::validSeedPlaneFrom3Points(__int64 a1, float *a2);
float __fastcall ground_filter::Plane_Seg::computeMeanAndCovarianceMatrix(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
// void __usercall ground_filter::Plane_Seg::eigen33(__int64 a1@<X0>, float *a2@<X1>, float *a3@<X2>, __int64 a4@<X3>, unsigned __int32 *a5@<X8>);
void __fastcall ground_filter::Plane_Seg::computeRoots(__int64 a1, float *a2, __int64 a3);
float __fastcall ground_filter::Plane_Seg::computeRoots2(__int64 a1, float *a2, float *a3, __int64 a4);
char *__fastcall ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, const void **a7, char **a8, __int64 a9, _BYTE *a10);
char *__fastcall ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, const void **a7, char **a8, __int64 a9, _BYTE *a10);
__int64 *__fastcall std::vector<ground_filter::plane_base>::assign<ground_filter::plane_base*>(__int64 *result, char *a2, char *a3);
__int64 __fastcall ground_filter::plane_base::operator=(__int64 a1, __int64 a2);
__int64 __fastcall ground_filter::plane_base::plane_base(__int64 result, __int64 a2);
void __fastcall std::vector<int>::__push_back_slow_path<int>(__int64 a1, _DWORD *a2);
unsigned __int64 __fastcall std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(__int64 a1, __int64 a2, unsigned __int64 *a3);
unsigned __int64 __fastcall std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(_QWORD *a1);
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(__int64 a1, __int64 *a2);
__int64 __fastcall Eigen::SelfAdjointEigenSolver<Eigen::Matrix<float,3,3,0,3,3>>::compute(__int64 a1, float *a2, char a3);
float __fastcall Eigen::internal::tridiagonalization_inplace_selector<Eigen::Matrix<float,3,3,0,3,3>,3,false>::run<Eigen::Matrix<float,3,1,0,3,1>,Eigen::Matrix<float,2,1,0,2,1>>(__int64 a1, float *a2, float *a3, char a4);
float32x4_t *__fastcall Eigen::internal::apply_rotation_in_the_plane<Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,float>(float32x4_t *result, unsigned __int64 *a2, _DWORD *a3, double a4, double a5);
__int64 __fastcall feasibal_region::getDirectorySize(__int64 a1);
bool __fastcall feasibal_region::cleanDirectory(__int64 a1);
long double __fastcall feasibal_region::ground_process::ground_process(feasibal_region::ground_process *this);
__int64 *__fastcall feasibal_region::PreParamInfo::PreParamInfo(feasibal_region::PreParamInfo *this);
void __fastcall std::ofstream::~ofstream(_QWORD *a1);
void __fastcall feasibal_region::PreParamInfo::~PreParamInfo(void **this, void *a2);
__int64 __fastcall feasibal_region::ground_process::init(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::PreParamInfo::operator=(__int64 a1, __int128 *a2);
__int64 __fastcall feasibal_region::ground_process::init_data_pre(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromPlane(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::ground_process::getPlaneFromExtrinsic(__int64 a1, float32x2_t *a2, float *a3);
__int64 __fastcall feasibal_region::ground_process::set_calib(__int64 a1, __int128 *a2);
__int64 __fastcall std::istream::tellg(_QWORD *a1);
void __fastcall std::ifstream::~ifstream(_QWORD *a1);
double __fastcall feasibal_region::norm_vec(double *a1);
double __fastcall feasibal_region::dot_vec(__int64 a1, __int64 a2);
// cv *__usercall feasibal_region::rotationMatrixFromAxisAndAngle@<X0>(double *a1@<X0>, __int64 a2@<X8>, double a3@<D0>);
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT(__int64 a1, float32x2_t *a2, __int64 a3, __int64 a4);
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT_(__int64 a1, float32x2_t *a2, __int64 a3, __int64 a4);
// float32x2_t __usercall feasibal_region::ground_process::getTFMatrix@<D0>(float *a1@<X1>, float32x2_t *a2@<X2>, float32x2_t *a3@<X8>);
// float __usercall feasibal_region::rotationMatrixFromAxisAndAngle@<S0>(float *a1@<X0>, float *a2@<X8>, float a3@<S0>);
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromYPR(int32x2_t *a1, float *a2, float32x2_t *a3);
float __fastcall feasibal_region::ground_process::getVectorAngle(__int64 a1, __int64 a2, __int64 a3);
// float __usercall feasibal_region::ground_process::getPlanePoints@<S0>(float *a1@<X1>, _QWORD *a2@<X8>);
cv *__fastcall feasibal_region::depth2color(feasibal_region *this, cv::Mat *a2, const cv::Mat *a3, double a4, double a5);
// long double __usercall feasibal_region::ground_process::getExtrinsic@<Q0>(feasibal_region::ground_process *this@<X0>, __int64 a2@<X8>);
__int64 __fastcall feasibal_region::ground_process::run(feasibal_region::ground_process *this, const feasibal_region::GroundProcessRunInData *a2, feasibal_region::GroundProcessRunOutData *a3); // idb
__int64 __fastcall feasibal_region::ground_process::pointCloudProcess(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::ground_process::planeProcess(feasibal_region::ground_process *this);
__int64 __fastcall feasibal_region::ground_process::groundProcess(feasibal_region::ground_process *this); // idb
float __fastcall feasibal_region::ground_process::getVectorAngle(__int64 a1, float *a2, float *a3);
// void __usercall feasibal_region::ground_process::getCellBelongPlaneCloudPoints(__int64 a1@<X0>, float *a2@<X1>, __int64 *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, _QWORD *a7@<X8>, float a8@<S0>);
// void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(__int64 a1@<X0>, float *a2@<X1>, __int64 *a3@<X2>, int a4@<W3>, int a5@<W4>, unsigned __int8 a6@<W5>, int a7@<W6>, __int64 a8@<X8>, float a9@<S0>);
// void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(__int64 a1@<X0>, float *a2@<X1>, __int64 *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, _QWORD *a7@<X8>, float a8@<S0>);
__int64 __fastcall feasibal_region::ground_process::showPtOnImage(float *a1, __int64 a2);
__int64 __fastcall feasibal_region::get_neighbourhood_plane_idx(__int64 a1, int a2, __int64 a3);
__int64 __fastcall feasibal_region::ground_process::processSlopeBasePlane(__int64 a1, __int64 a2, float *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, __int64 *a7);
_QWORD *__fastcall std::vector<std::vector<int>>::vector(_QWORD *result, unsigned __int64 a2);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(char **a1, _DWORD *a2, unsigned __int64 a3, char *a4);
// void __usercall feasibal_region::ground_process::imageScore(const cv::Mat *a1@<X1>, const int *a2@<X2>, float32x4_t **a3@<X8>);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(char **a1, _DWORD *a2, unsigned __int64 a3, char *a4);
_DWORD *__fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::insert(unsigned __int64 *a1, char *a2, _DWORD *a3);
__int64 __fastcall feasibal_region::ground_process::optimizeOrganizePointCloudByCell(__int64 a1, __int64 a2, float a3, double a4, double a5);
__int64 __fastcall feasibal_region::createDirectory(unsigned __int8 *a1);
char *__fastcall std::vector<float>::insert(unsigned __int64 *a1, unsigned __int64 src, char *a3);
__int64 __fastcall cv::Mat_<unsigned char>::Mat_(__int64 a1, int a2, int a3, _BYTE *a4);
__int64 feasibal_region::ground_process::viewDreamVis();
// cv *__usercall feasibal_region::ground_process::drawResult@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, unsigned int a4@<W3>, __int64 a5@<X8>);
void __fastcall feasibal_region::ground_process::organizePointCloudByCell(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4);
void __fastcall feasibal_region::ground_process::projectPointCloud(float a1, float a2, float a3, float a4, double a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 *a12);
void __fastcall feasibal_region::ground_process::fillPointCloud(double a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
void __fastcall `virtual thunk to'std::ofstream::~ofstream(_QWORD *a1);
void __fastcall std::ostream::~ostream(__int64 a1);
void __fastcall std::ostream::~ostream(__int64 a1);
void __fastcall `virtual thunk to'std::ostream::~ostream(_QWORD *a1);
void __fastcall `virtual thunk to'std::ostream::~ostream(_QWORD *a1);
void __fastcall std::ofstream::~ofstream(_QWORD *a1);
void __fastcall `virtual thunk to'std::ofstream::~ofstream(_QWORD *a1);
void __fastcall std::filebuf::~filebuf(__int64 a1);
void __fastcall std::filebuf::~filebuf(void *a1);
void __fastcall std::filebuf::imbue(__int64 a1, __int64 a2);
__int64 __fastcall std::filebuf::setbuf(__int64 a1, __int64 a2, signed __int64 a3);
__int64 __fastcall std::filebuf::seekoff(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall std::filebuf::seekpos(__int64 a1, __int64 a2, __off_t a3);
__int64 __fastcall std::filebuf::sync(__int64 a1);
__int64 std::streambuf::showmanyc();
__int64 __fastcall std::streambuf::xsgetn(_QWORD *a1, char *dest, __int64 a3);
__int64 __fastcall std::filebuf::underflow(__int64 a1);
__int64 __fastcall std::streambuf::uflow(_QWORD *a1);
__int64 __fastcall std::filebuf::pbackfail(__int64 a1, unsigned int a2);
__int64 __fastcall std::streambuf::xsputn(_QWORD *a1, unsigned __int8 *src, __int64 a3);
__int64 __fastcall std::filebuf::overflow(__int64 a1, unsigned int a2);
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
void __fastcall std::streambuf::~streambuf(_QWORD *a1);
__int64 std::streambuf::seekoff();
__int64 std::streambuf::seekpos();
__int64 std::streambuf::sync();
__int64 std::streambuf::underflow();
__int64 std::streambuf::pbackfail();
__int64 std::streambuf::overflow();
void __noreturn sub_3F59C();
void __fastcall `virtual thunk to'std::ifstream::~ifstream(_QWORD *a1);
void __fastcall std::istream::~istream(__int64 a1);
void __fastcall std::istream::~istream(__int64 a1);
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1);
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1);
void __fastcall std::ifstream::~ifstream(_QWORD *a1);
void __fastcall `virtual thunk to'std::ifstream::~ifstream(_QWORD *a1);
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1);
__int64 *__fastcall std::getline<char,std::char_traits<char>,std::allocator<char>>(__int64 *a1, __int64 a2, char a3);
void __fastcall std::string::push_back(__int64 *a1, char a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::vector<cv::Vec<unsigned char,3>>::__push_back_slow_path<cv::Vec<unsigned char,3> const&>(__int64 a1, _BYTE *a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3);
void __fastcall std::vector<bool>::reserve(__int64 *a1, unsigned __int64 a2);
_QWORD *__fastcall std::vector<bool>::__construct_at_end<std::__bit_iterator<std::vector<bool>,false,0ul>>(_QWORD *result, __int64 a2, __int64 a3);
// unsigned __int64 __usercall std::__copy_unaligned<std::vector<bool>,false>@<X0>(unsigned __int64 result@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, __int64 a4@<X8>);
void __fastcall std::vector<std::vector<Eigen::Matrix<float,3,1,0,3,1>>>::__push_back_slow_path<std::vector<Eigen::Matrix<float,3,1,0,3,1>> const&>(signed __int64 **a1, char **a2);
void __fastcall std::vector<cv::Point_<int>>::__push_back_slow_path<cv::Point_<int>>(__int64 a1, _QWORD *a2);
void __fastcall sub_406E0(_BYTE **a1, _DWORD *a2);
void __fastcall std::vector<cv::Vec<int,4>>::__push_back_slow_path<cv::Vec<int,4> const&>(__int64 a1, _OWORD *a2);
void __fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::__push_back_slow_path<Eigen::Matrix<float,4,1,0,4,1>>(__int64 a1, _OWORD *a2);
feasibal_region *__fastcall feasibal_region::feasibal_region::feasibal_region(feasibal_region::feasibal_region *this); // idb
__int64 __fastcall feasibal_region::feasibal_region::WriteCameraParam(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall feasibal_region::feasibal_region::readParam(float32x2_t *a1, __int64 a2);
void __fastcall feasibal_region::feasibal_region::attemtpRead<std::string>(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
cv *__fastcall feasibal_region::feasibal_region::attemtpRead<cv::Mat>(__int64 a1, __int64 a2, const cv::FileNode *a3, __int64 a4);
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int64 *a2);
__int64 __fastcall feasibal_region::feasibal_region::readParam(__int64 a1, __int64 a2, _DWORD *a3, int a4, double a5);
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int128 *a2, __int64 a3, int a4, double a5);
__int64 __fastcall feasibal_region::feasibal_region::setIRCameraMatrix(__int64 a1, __int64 a2);
__int64 __fastcall feasibal_region::feasibal_region::run(feasibal_region::feasibal_region *this, const feasibal_region::RunInputParam *a2, feasibal_region::RunOutputParam *a3);
void __fastcall feasibal_region::GroundProcessRunOutData::~GroundProcessRunOutData(feasibal_region::GroundProcessRunOutData *this, void *a2);
void __fastcall feasibal_region::GroundProcessRunInData::~GroundProcessRunInData(feasibal_region::GroundProcessRunInData *this, void *a2);
__int64 __fastcall feasibal_region::feasibal_region::release(feasibal_region::feasibal_region *this); // idb
// float64x2_t __usercall feasibal_region::feasibal_region::getTFMatrix@<Q0>(double *a1@<X1>, float64x2_t *a2@<X2>, float64x2_t *a3@<X8>);
void __fastcall feasibal_region::ground_process::~ground_process(feasibal_region::ground_process *this); // idb
void __fastcall CAPE::CAPE(CAPE *this, int a2, int a3, int a4, int a5, char a6, float a7, float a8, float a9);
__int64 __fastcall cv::Mat_<int>::Mat_(__int64 a1, int a2, int a3, int *a4);
__int64 __fastcall CAPE::set_extrinsic(__int64 result, _DWORD *a2, _DWORD *a3);
__int64 __fastcall CAPE::updateDefaultPlane(__int64 result, _DWORD *a2, float a3);
// void __usercall CAPE::process_modify_opt(int *a1@<X0>, _QWORD *a2@<X1>, unsigned int *a3@<X2>, __int64 a4@<X4>, __int64 a5@<X6>, __int64 a6@<X8>);
__int64 __fastcall CAPE::RegionGrowing(__int64 result, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, _QWORD *a6, _QWORD *a7, unsigned int a8, long double a9, unsigned __int16 a10, float *a11);
void __fastcall Eigen::Matrix<bool,-1,-1,0,-1,-1>::Matrix<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>,Eigen::Matrix<bool,-1,-1,0,-1,-1>>>(unsigned __int64 *a1, _QWORD *a2);
void __fastcall CAPE::getConnectedComponents(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall CAPE::getBestPlane(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, const int *a4);
__int64 __fastcall CAPE::swapPlanes(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5);
__int64 __fastcall CAPE::judgPlaneValid(float a1, float a2, float a3, __int64 a4, float *a5, float *a6);
__int64 __fastcall CAPE::judgeValidBasedImage(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, unsigned int *a4, unsigned int *a5);
// void __usercall CAPE::imageScore(CAPE *this@<X0>, const cv::Mat *a2@<X1>, const int *a3@<X2>, float32x4_t **a4@<X8>);
float __fastcall CAPE::getVectorAngle(__int64 a1, float *a2, float *a3);
__int64 __fastcall PlaneSeg::operator=(__int64 a1, __int64 a2);
double __fastcall CAPE::iou(__int64 a1, int *a2, int *a3);
void __fastcall CAPE::~CAPE(CAPE *this); // idb
void __fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix(__int64 *a1, __int64 *a2);
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,-1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3, __int64 a4);
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace(void **a1);
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace(void **a1);
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::__on_zero_shared(__int64 a1);
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg>>(char **a1, __int64 a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg> const&>(__int64 a1, _QWORD *a2);
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<bool,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::vector<PlaneSeg>::__push_back_slow_path<PlaneSeg const&>(void ***a1, __int64 a2);
void __fastcall std::vector<ground_filter::plane_base>::__append(__int64 *a1, unsigned __int64 a2);
void __fastcall std::__split_buffer<ground_filter::plane_base>::~__split_buffer(__int64 a1, void *a2);
void __fastcall Histogram::Histogram(Histogram *this, int a2);
float32x4_t *__fastcall std::vector<int>::assign(float32x4_t **a1, unsigned __int64 a2, const float *a3);
float32x4_t *__fastcall Histogram::initHistogram(__int64 a1, __int64 *a2, __int64 *a3);
// void __usercall Histogram::getPointsFromMostFrequentBin(Histogram *this@<X0>, int64x2_t *a2@<X8>);
_QWORD *__fastcall Histogram::removePoint(_QWORD *this, int a2);
void __fastcall Histogram::~Histogram(Histogram *this); // idb
void __fastcall std::vector<int>::__emplace_back_slow_path<int &>(__int64 a1, _DWORD *a2);
__int64 __fastcall PlaneSeg::updatePlaneSeg(__int64 result, float a2, float a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _DWORD *a8, __int64 a9, int a10, char a11);
float __fastcall getValueOfsubMatrix(_QWORD *a1, int a2, int a3, int a4, int a5);
void __fastcall PlaneSeg::updatePlaneSeg(__int64 a1, _QWORD *a2, int a3, int a4, int a5);
_QWORD *__fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(_QWORD *a1, __int64 *a2);
float __fastcall PlaneSeg::fitPlane(PlaneSeg *this);
float __fastcall PlaneSeg::expandSegment(int *a1, __int64 *a2);
long double __fastcall PlaneSeg::clearPoints(PlaneSeg *this);
void __fastcall gte::NISymmetricEigensolver3x3<float>::operator()(__int64 a1, int a2, __int64 a3, float32x2_t *a4, float a5, float a6, float a7, float a8, float a9, float a10);
void __fastcall PlaneSeg::~PlaneSeg(void **this);
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(float a1, float a2, float a3, float a4, float a5, float a6, float a7, __int64 a8, float *a9);
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(float a1, float a2, float a3, float a4, float a5, float a6, int32x2_t a7, __int64 a8, float *a9, float *a10);
unsigned __int64 __fastcall std::__next_prime(unsigned __int64 this);
__int64 __fastcall sub_53B70(std::runtime_error *a1, const char *a2);
__int64 __fastcall std::random_device::random_device(_DWORD *a1, __int64 a2);
// __int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>);
void __fastcall std::random_device::~random_device(std::random_device *this); // idb
__int64 __fastcall std::random_device::operator()(int *a1);
double __fastcall std::random_device::entropy(std::random_device *this);
// void __fastcall std::overflow_error::~overflow_error(std::overflow_error *__hidden this); idb
// void __fastcall std::out_of_range::~out_of_range(std::out_of_range *__hidden this); idb
// void __fastcall std::bad_cast::~bad_cast(std::bad_cast *__hidden this); idb
// void __fastcall std::length_error::~length_error(std::length_error *__hidden this); idb
// void __fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *__hidden this); idb

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_5 = '\x01'; // weak
__int16 word_3C = 25; // weak
__int128 xmmword_53EB0 = 0x1E0000000000000021LL; // weak
__int128 xmmword_53EC0 = 0x340000000000000041LL; // weak
__int128 xmmword_54730 = 0x3000000020000000100000000LL; // weak
__int128 xmmword_54740 = 0x7FFFFFFFFFFFFFFF0000000000000000LL; // weak
__int128 xmmword_54750 = 0x200000000000000040LL; // weak
__int128 xmmword_54760 = 4294967296LL; // weak
__int128 xmmword_54770 = 0x1FFFFFFFF00000000FFFFFFFFLL; // weak
__int128 xmmword_54780 = 1065353216LL; // weak
__int128 xmmword_547A0 = 0x43490000000000000000000043490000LL; // weak
__int128 xmmword_547B0 = 0x3F8000000000000000000000LL; // weak
__int128 xmmword_547C0 = 0x406FE000000000000000000000000000LL; // weak
__int128 xmmword_547D0 = 4643176031446892544LL; // weak
__int128 xmmword_54DC0 = 0x3FE73333333333330000000000000000LL; // weak
__int128 xmmword_54DD0 = 0x270000000000000031LL; // weak
__int128 xmmword_54DE0 = 0x180000000000000021LL; // weak
__int128 xmmword_54FB0 = 0xBF800000000000000000000000000000LL; // weak
unsigned int dword_551AC[24] =
{
  0u,
  2u,
  3u,
  5u,
  7u,
  11u,
  13u,
  17u,
  19u,
  23u,
  29u,
  31u,
  37u,
  41u,
  43u,
  47u,
  53u,
  59u,
  61u,
  67u,
  71u,
  73u,
  79u,
  83u
}; // weak
unsigned int dword_5526C[24] =
{
  1u,
  11u,
  13u,
  17u,
  19u,
  23u,
  29u,
  31u,
  37u,
  41u,
  43u,
  47u,
  53u,
  59u,
  61u,
  67u,
  71u,
  73u,
  79u,
  83u,
  89u,
  97u,
  101u,
  103u
}; // weak
void *`typeinfo for'cvflann::anyimpl::empty_any = &cv::read; // weak
void *`typeinfo for'cvflann::flann_algorithm_t = &cv::FileStorage::operator[]; // weak
void *`typeinfo for'cvflann::flann_centers_init_t = &cv::FileStorage::operator[]; // weak
void *`typeinfo for'std::string = &cv::Mat::eye; // weak
__int64 (__fastcall *off_6DF38[2])() = { &std::ofstream::~ofstream, &std::ofstream::~ofstream }; // weak
__int64 (__fastcall *off_6DF60[2])() =
{
  &`virtual thunk to'std::ofstream::~ofstream,
  &`virtual thunk to'std::ofstream::~ofstream
}; // weak
__int64 (__fastcall *off_6DF88[2])() = { &std::ostream::~ostream, &std::ostream::~ostream }; // weak
__int64 (__fastcall *off_6DFB0[2])() =
{
  &`virtual thunk to'std::ostream::~ostream,
  &`virtual thunk to'std::ostream::~ostream
}; // weak
__int64 (__fastcall *off_6E028[3])() = { &std::filebuf::~filebuf, &std::filebuf::~filebuf, &std::filebuf::imbue }; // weak
__int64 (__fastcall *off_6E0D0[8])() =
{
  &std::streambuf::~streambuf,
  &std::streambuf::~streambuf,
  &std::streambuf::imbue,
  &std::streambuf::setbuf,
  &std::streambuf::seekoff,
  &std::streambuf::seekpos,
  &std::streambuf::sync,
  &std::streambuf::showmanyc
}; // weak
__int64 (__fastcall *off_6E158[2])() = { &std::ifstream::~ifstream, &std::ifstream::~ifstream }; // weak
__int64 (__fastcall *off_6E180[2])() =
{
  &`virtual thunk to'std::ifstream::~ifstream,
  &`virtual thunk to'std::ifstream::~ifstream
}; // weak
__int64 (__fastcall *off_6E1A8[2])() = { &std::istream::~istream, &std::istream::~istream }; // weak
__int64 (__fastcall *off_6E1D0[2])() =
{
  &`virtual thunk to'std::istream::~istream,
  &`virtual thunk to'std::istream::~istream
}; // weak
__int64 (__fastcall *off_6E230[3])() =
{
  &std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace,
  &std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace,
  &std::__shared_ptr_emplace<PlaneSeg>::__on_zero_shared
}; // weak
void *off_6F000 = &off_6F000; // weak
_UNKNOWN colormap; // weak
int dword_6FC50; // weak
__int16 word_6FC58; // weak
_UNKNOWN unk_6FC5A; // weak
_UNKNOWN unk_6FC62; // weak
__int64 qword_6FC68; // weak
int dword_6FC70; // weak
__int16 word_6FC78; // weak
_UNKNOWN unk_6FC7A; // weak
_UNKNOWN unk_6FC82; // weak
__int64 qword_6FC88; // weak
int dword_6FC90; // weak
__int16 word_6FC98; // weak
_UNKNOWN unk_6FC9A; // weak
_UNKNOWN unk_6FCA2; // weak
__int64 qword_6FCA8; // weak
int dword_6FCB0; // weak
__int16 word_6FCB8; // weak
_UNKNOWN unk_6FCBA; // weak
_UNKNOWN unk_6FCC2; // weak
__int64 qword_6FCC8; // weak
int dword_6FCD0; // weak
__int16 word_6FCD8; // weak
_UNKNOWN unk_6FCDA; // weak
_UNKNOWN unk_6FCE2; // weak
__int64 qword_6FCE8; // weak
int dword_6FCF0; // weak
__int16 word_6FCF8; // weak
_UNKNOWN unk_6FCFA; // weak
_UNKNOWN unk_6FD02; // weak
__int64 qword_6FD08; // weak
int dword_6FD10; // weak
char byte_6FD18; // weak
_UNKNOWN unk_6FD19; // weak
_UNKNOWN unk_6FD21; // weak
__int64 qword_6FD28; // weak
int dword_6FD30; // weak
char byte_6FD38; // weak
_UNKNOWN unk_6FD39; // weak
_UNKNOWN unk_6FD41; // weak
_UNKNOWN unk_6FD45; // weak
_UNKNOWN unk_6FD4D; // weak
char byte_6FD4F; // weak
int dword_6FD50; // weak
char byte_6FD58; // weak
_BYTE algn_6FD59[7]; // weak
_UNKNOWN unk_6FD69; // weak
_UNKNOWN unk_6FD6D; // weak
char byte_6FD6F; // weak
__int64 qword_6FD70; // weak
_UNKNOWN unk_6FD78; // weak
__int64 qword_6FD80; // weak
__int64 qword_6FD88; // weak
_UNKNOWN unk_6FD90; // weak
__int64 qword_6FD98; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<char const*>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<int>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<float>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<bool>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_algorithm_t>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_centers_init_t>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<unsigned int>::policy; // weak
__int64 `guard variable for'cvflann::anyimpl::SinglePolicy<std::string>::policy; // weak
int dword_6FDE8; // weak
__int16 word_6FDF0; // weak
_BYTE algn_6FDF2[14]; // weak
__int64 qword_6FE00; // weak
int dword_6FE08; // weak
__int16 word_6FE10; // weak
_BYTE algn_6FE12[14]; // weak
__int64 qword_6FE20; // weak
int dword_6FE28; // weak
__int16 word_6FE30; // weak
_BYTE algn_6FE32[14]; // weak
__int64 qword_6FE40; // weak
int dword_6FE48; // weak
__int16 word_6FE50; // weak
_BYTE algn_6FE52[14]; // weak
__int64 qword_6FE60; // weak
int dword_6FE68; // weak
__int16 word_6FE70; // weak
_BYTE algn_6FE72[14]; // weak
__int64 qword_6FE80; // weak
int dword_6FE88; // weak
__int16 word_6FE90; // weak
_BYTE algn_6FE92[14]; // weak
__int64 qword_6FEA0; // weak
int dword_6FEA8; // weak
char byte_6FEB0; // weak
_BYTE algn_6FEB1[15]; // weak
__int64 qword_6FEC0; // weak
int dword_6FEC8; // weak
char byte_6FED0; // weak
_UNKNOWN unk_6FED1; // weak
_UNKNOWN unk_6FED9; // weak
_UNKNOWN unk_6FEDD; // weak
_UNKNOWN unk_6FEE5; // weak
char byte_6FEE7; // weak
int dword_6FEE8; // weak
char byte_6FEF0; // weak
_BYTE algn_6FEF1[7]; // weak
_UNKNOWN unk_6FF01; // weak
_UNKNOWN unk_6FF05; // weak
char byte_6FF07; // weak
__int64 qword_6FF08; // weak
_UNKNOWN unk_6FF10; // weak
__int64 qword_6FF18; // weak
__int64 qword_6FF20; // weak
_UNKNOWN unk_6FF28; // weak
__int64 qword_6FF30; // weak
int dword_6FF38; // weak
__int16 word_6FF40; // weak
_BYTE algn_6FF42[14]; // weak
__int64 qword_6FF50; // weak
int dword_6FF58; // weak
__int16 word_6FF60; // weak
_BYTE algn_6FF62[14]; // weak
__int64 qword_6FF70; // weak
int dword_6FF78; // weak
__int16 word_6FF80; // weak
_BYTE algn_6FF82[14]; // weak
__int64 qword_6FF90; // weak
int dword_6FF98; // weak
__int16 word_6FFA0; // weak
_BYTE algn_6FFA2[14]; // weak
__int64 qword_6FFB0; // weak
int dword_6FFB8; // weak
__int16 word_6FFC0; // weak
_BYTE algn_6FFC2[14]; // weak
__int64 qword_6FFD0; // weak
int dword_6FFD8; // weak
__int16 word_6FFE0; // weak
_BYTE algn_6FFE2[14]; // weak
__int64 qword_6FFF0; // weak
int dword_6FFF8; // weak
char byte_70000; // weak
_BYTE algn_70001[15]; // weak
__int64 qword_70010; // weak
int dword_70018; // weak
char byte_70020; // weak
_UNKNOWN unk_70021; // weak
_UNKNOWN unk_70029; // weak
_UNKNOWN unk_7002D; // weak
_UNKNOWN unk_70035; // weak
char byte_70037; // weak
int dword_70038; // weak
char byte_70040; // weak
_BYTE algn_70041[7]; // weak
_UNKNOWN unk_70051; // weak
_UNKNOWN unk_70055; // weak
char byte_70057; // weak
__int64 qword_70058; // weak
_UNKNOWN unk_70060; // weak
__int64 qword_70068; // weak
__int64 qword_70070; // weak
_UNKNOWN unk_70078; // weak
__int64 qword_70080; // weak
int dword_70088; // weak
__int16 word_70090; // weak
_BYTE algn_70092[14]; // weak
__int64 qword_700A0; // weak
int dword_700A8; // weak
__int16 word_700B0; // weak
_BYTE algn_700B2[14]; // weak
__int64 qword_700C0; // weak
int dword_700C8; // weak
__int16 word_700D0; // weak
_BYTE algn_700D2[14]; // weak
__int64 qword_700E0; // weak
int dword_700E8; // weak
__int16 word_700F0; // weak
_BYTE algn_700F2[14]; // weak
__int64 qword_70100; // weak
int dword_70108; // weak
__int16 word_70110; // weak
_BYTE algn_70112[14]; // weak
__int64 qword_70120; // weak
int dword_70128; // weak
__int16 word_70130; // weak
_BYTE algn_70132[14]; // weak
__int64 qword_70140; // weak
int dword_70148; // weak
char byte_70150; // weak
_BYTE algn_70151[15]; // weak
__int64 qword_70160; // weak
int dword_70168; // weak
char byte_70170; // weak
_UNKNOWN unk_70171; // weak
_UNKNOWN unk_70179; // weak
_UNKNOWN unk_7017D; // weak
_UNKNOWN unk_70185; // weak
char byte_70187; // weak
int dword_70188; // weak
char byte_70190; // weak
_BYTE algn_70191[7]; // weak
_UNKNOWN unk_701A1; // weak
_UNKNOWN unk_701A5; // weak
char byte_701A7; // weak
__int64 qword_701A8; // weak
_UNKNOWN unk_701B0; // weak
__int64 qword_701B8; // weak
__int64 qword_701C0; // weak
_UNKNOWN unk_701C8; // weak
__int64 qword_701D0; // weak
int dword_701D8; // weak
__int16 word_701E0; // weak
_BYTE algn_701E2[14]; // weak
__int64 qword_701F0; // weak
int dword_701F8; // weak
__int16 word_70200; // weak
_BYTE algn_70202[14]; // weak
__int64 qword_70210; // weak
int dword_70218; // weak
__int16 word_70220; // weak
_BYTE algn_70222[14]; // weak
__int64 qword_70230; // weak
int dword_70238; // weak
__int16 word_70240; // weak
_BYTE algn_70242[14]; // weak
__int64 qword_70250; // weak
int dword_70258; // weak
__int16 word_70260; // weak
_BYTE algn_70262[14]; // weak
__int64 qword_70270; // weak
int dword_70278; // weak
__int16 word_70280; // weak
_BYTE algn_70282[14]; // weak
__int64 qword_70290; // weak
int dword_70298; // weak
char byte_702A0; // weak
_BYTE algn_702A1[15]; // weak
__int64 qword_702B0; // weak
int dword_702B8; // weak
char byte_702C0; // weak
_UNKNOWN unk_702C1; // weak
_UNKNOWN unk_702C9; // weak
_UNKNOWN unk_702CD; // weak
_UNKNOWN unk_702D5; // weak
char byte_702D7; // weak
int dword_702D8; // weak
char byte_702E0; // weak
_BYTE algn_702E1[7]; // weak
_UNKNOWN unk_702F1; // weak
_UNKNOWN unk_702F5; // weak
char byte_702F7; // weak
__int64 qword_702F8; // weak
_UNKNOWN unk_70300; // weak
__int64 qword_70308; // weak
__int64 qword_70310; // weak
_UNKNOWN unk_70318; // weak
__int64 qword_70320; // weak
// extern _UNKNOWN `typeinfo for'std::bad_cast; weak
// extern _UNKNOWN `vtable for'std::overflow_error; weak
// extern struct _IO_FILE *stderr;
// extern _UNKNOWN `typeinfo for'std::out_of_range; weak
// extern _UNKNOWN `typeinfo for'std::bad_alloc; weak
// extern _QWORD std::cout; weak
// extern _UNKNOWN `vtable for'std::out_of_range; weak
// extern _UNKNOWN std::codecvt<char,char,mbstate_t>::id; weak
// extern _UNKNOWN `typeinfo for'std::length_error; weak
// extern _UNKNOWN `typeinfo for'char const*; weak
// extern _UNKNOWN `typeinfo for'float; weak
// extern _UNKNOWN `typeinfo for'unsigned int; weak
// extern _UNKNOWN `typeinfo for'bool; weak
// extern _UNKNOWN `vtable for'std::length_error; weak
// extern _UNKNOWN `typeinfo for'int; weak
// extern _UNKNOWN std::num_put<char,std::ostreambuf_iterator<char>>::id; weak
// extern _UNKNOWN std::ctype<char>::id; weak
// extern _UNKNOWN `typeinfo for'std::overflow_error; weak


//----- (00000000000125E0) ----------------------------------------------------
void sub_125E0()
{
  JUMPOUT(0LL);
}
// 125F0: control flows out of bounds to 0

//----- (0000000000012600) ----------------------------------------------------
// attributes: thunk
float __fastcall Eigen::internal::tridiagonalization_inplace_selector<Eigen::Matrix<float,3,3,0,3,3>,3,false>::run<Eigen::Matrix<float,3,1,0,3,1>,Eigen::Matrix<float,2,1,0,2,1>>(
        __int64 a1,
        float *a2,
        float *a3,
        char a4)
{
  return _ZN5Eigen8internal35tridiagonalization_inplace_selectorINS_6MatrixIfLi3ELi3ELi0ELi3ELi3EEELi3ELb0EE3runINS2_IfLi3ELi1ELi0ELi3ELi1EEENS2_IfLi2ELi1ELi0ELi2ELi1EEEEEvRS3_RT_RT0_b(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000012620) ----------------------------------------------------
// attributes: thunk
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(
        float a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        float a7,
        __int64 a8,
        float *a9)
{
  _ZNK3gte25NISymmetricEigensolver3x3IfE19ComputeEigenvector0EfffffffRNSt6__ndk15arrayIfLm3EEE(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9);
}

//----- (0000000000012640) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  return _ZNSt6__ndk124__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m(a1, a2, a3);
}

//----- (0000000000012670) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<ground_filter::plane_base>::__append(__int64 *a1, unsigned __int64 a2)
{
  _ZNSt6__ndk16vectorIN13ground_filter10plane_baseENS_9allocatorIS2_EEE8__appendEm(a1, a2);
}

//----- (0000000000012680) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLin1ELin1ELi0ELin1ELin1EEEE6resizeEll(a1, a2, a3);
}

//----- (0000000000012690) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg>>(
        char **a1,
        __int64 a2)
{
  _ZNSt6__ndk16vectorINS_10shared_ptrI8PlaneSegEENS_9allocatorIS3_EEE21__push_back_slow_pathIS3_EEvOT_(a1, a2);
}

//----- (00000000000126B0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(
        _QWORD *a1,
        __int64 *a2)
{
  return _ZN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEaSINS_5BlockIS1_Lin1ELin1ELb0EEEEERS1_RKNS_10MatrixBaseIT_EE(a1, a2);
}

//----- (00000000000126C0) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::Matrix<bool,-1,-1,0,-1,-1>::Matrix<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>,Eigen::Matrix<bool,-1,-1,0,-1,-1>>>(
        unsigned __int64 *a1,
        _QWORD *a2)
{
  _ZN5Eigen6MatrixIbLin1ELin1ELi0ELin1ELin1EEC2INS_14CwiseNullaryOpINS_8internal18scalar_constant_opIbEES1_EEEERKNS_10MatrixBaseIT_EE(
    a1,
    a2);
}

//----- (00000000000126D0) ----------------------------------------------------
// attributes: thunk
void __usercall getColorDepthImage(const cv::Mat *a1@<X0>, int a2@<W1>, int a3@<W2>, __int64 a4@<X8>)
{
  _Z18getColorDepthImageRKN2cv3MatEii(a1, a2, a3, a4);
}

//----- (0000000000012700) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::judgPlaneValid(float a1, float a2, float a3, __int64 a4, float *a5, float *a6)
{
  return _ZN4CAPE14judgPlaneValidERKN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEERKNS1_IfLi3ELi1ELi0ELi3ELi1EEEfff(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6);
}

//----- (0000000000012710) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::run(
        feasibal_region::feasibal_region *this,
        const feasibal_region::RunInputParam *a2,
        feasibal_region::RunOutputParam *a3)
{
  return _ZN15feasibal_region15feasibal_region3runERKNS_13RunInputParamERNS_14RunOutputParamE(this, a2, a3);
}

//----- (0000000000012720) ----------------------------------------------------
// attributes: thunk
long double __usercall feasibal_region::ground_process::getExtrinsic@<Q0>(
        feasibal_region::ground_process *this@<X0>,
        __int64 a2@<X8>)
{
  return _ZN15feasibal_region14ground_process12getExtrinsicEv(this, a2);
}

//----- (0000000000012760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::filebuf::sync(__int64 a1)
{
  return _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEE4syncEv(a1);
}

//----- (0000000000012770) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int128 *a2, __int64 a3, int a4, double a5)
{
  return _ZN15feasibal_region15feasibal_region4initEN2cv3MatEdN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEEi(
           a1,
           a2,
           a3,
           a4,
           a5);
}

//----- (0000000000012780) ----------------------------------------------------
// attributes: thunk
void __fastcall std::string::push_back(__int64 *a1, char a2)
{
  _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc(a1, a2);
}

//----- (00000000000127C0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3)
{
  return _ZNSt6__ndk124uniform_int_distributionIlEclINS_23mersenne_twister_engineImLm32ELm624ELm397ELm31ELm2567483615ELm11ELm4294967295ELm7ELm2636928640ELm15ELm4022730752ELm18ELm1812433253EEEEElRT_RKNS1_10param_typeE(
           a1,
           a2,
           a3);
}

//----- (00000000000127D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::init(__int64 a1, __int64 a2)
{
  return _ZN15feasibal_region14ground_process4initERKNS_21GroundProcessInitParaE(a1, a2);
}

//----- (0000000000012800) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  _ZN5Eigen15PlainObjectBaseINS_5ArrayIfLin1ELi1ELi0ELin1ELi1EEEE6resizeEll(a1, a2, a3);
}

//----- (0000000000012820) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm(a1, src, n);
}

//----- (0000000000012830) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_length_errorEv();
}

//----- (0000000000012860) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::Plane_Seg::judgPointsValid(float *a1, float **a2)
{
  return _ZN13ground_filter9Plane_Seg15judgPointsValidERKNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS1_9allocatorIS5_EEEE(
           a1,
           a2);
}

//----- (0000000000012880) ----------------------------------------------------
// attributes: thunk
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  return _ZNSt6__ndk1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EEPKS6_RKS9_(a1, a2, a3);
}

//----- (00000000000128C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall cv::Mat_<unsigned char>::Mat_(__int64 a1, int a2, int a3, _BYTE *a4)
{
  return _ZN2cv4Mat_IhEC2EiiRKh(a1, a2, a3, a4);
}

//----- (00000000000128D0) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::feasibal_region::attemtpRead<std::string>(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  _ZN15feasibal_region15feasibal_region11attemtpReadINSt6__ndk112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEEvRKS8_RT_RN2cv11FileStorageE(
    a1,
    a2,
    a3,
    a4);
}

//----- (00000000000128F0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<int>::__push_back_slow_path<int const&>(__int64 a1, _DWORD *a2)
{
  _ZNSt6__ndk16vectorIiNS_9allocatorIiEEE21__push_back_slow_pathIRKiEEvOT_(a1, a2);
}

//----- (0000000000012900) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKcm(a1, a2, src, n);
}

//----- (0000000000012920) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::processSlopeBasePlane(
        __int64 a1,
        __int64 a2,
        float *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        __int64 *a7)
{
  return _ZN15feasibal_region14ground_process21processSlopeBasePlaneERKN2cv3MatERKN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEERKNSt6__ndk16vectorIfNSA_9allocatorIfEEEERKNSB_INSB_INS6_IfLi3ELi1ELi0ELi3ELi1EEENSC_ISH_EEEENSC_ISJ_EEEERKNSB_IbNSC_IbEEEERKNSB_INS1_6Point_IiEENSC_IST_EEEERKNSB_INS1_7Point3_IiEENSC_ISZ_EEEESN_(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7);
}

//----- (0000000000012930) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromPlane(__int64 a1, __int64 a2)
{
  return _ZN15feasibal_region14ground_process21getExtrinsicFromPlaneERN2cv3VecIfLi4EEE(a1, a2);
}

//----- (0000000000012940) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall feasibal_region::PreParamInfo::PreParamInfo(feasibal_region::PreParamInfo *this)
{
  return _ZN15feasibal_region12PreParamInfoC2Ev(this);
}

//----- (0000000000012960) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::random_device::random_device(_DWORD *a1, __int64 a2)
{
  return _ZNSt6__ndk113random_deviceC2ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(a1, a2);
}

//----- (0000000000012990) ----------------------------------------------------
// attributes: thunk
float __fastcall PlaneSeg::fitPlane(PlaneSeg *this)
{
  return _ZN8PlaneSeg8fitPlaneEv(this);
}

//----- (00000000000129A0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<PlaneSeg>::__push_back_slow_path<PlaneSeg const&>(void ***a1, __int64 a2)
{
  _ZNSt6__ndk16vectorI8PlaneSegNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_(a1, a2);
}

//----- (00000000000129C0) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
        char **a1,
        _DWORD *a2,
        unsigned __int64 a3,
        char *a4)
{
  return _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEE6insertINS_11__wrap_iterIPS3_EEEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr16is_constructibleIS3_NS_15iterator_traitsISC_E9referenceEEE5valueESA_E4typeENS8_IPKS3_EESC_SC_(
           a1,
           a2,
           a3,
           a4);
}

//----- (00000000000129E0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<bool>::reserve(__int64 *a1, unsigned __int64 a2)
{
  _ZNSt6__ndk16vectorIbNS_9allocatorIbEEE7reserveEm(a1, a2);
}

//----- (00000000000129F0) ----------------------------------------------------
// attributes: thunk
char *__fastcall _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6,
        const void **a7,
        char **a8,
        __int64 a9,
        _BYTE *a10)
{
  return ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10);
}

//----- (0000000000012A20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::planeProcess(feasibal_region::ground_process *this)
{
  return _ZN15feasibal_region14ground_process12planeProcessEv(this);
}

//----- (0000000000012A30) ----------------------------------------------------
// attributes: thunk
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2)
{
  return _ZN2cv4Mat_IdEaSERKNS_3MatE(this, a2);
}

//----- (0000000000012AC0) ----------------------------------------------------
// attributes: thunk
void __usercall CAPE::process_modify_opt(
        int *a1@<X0>,
        _QWORD *a2@<X1>,
        unsigned int *a3@<X2>,
        __int64 a4@<X4>,
        __int64 a5@<X6>,
        __int64 a6@<X8>)
{
  _ZN4CAPE18process_modify_optERN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEERiRN2cv3MatERNSt6__ndk16vectorI8PlaneSegNS8_9allocatorISA_EEEERNS1_IfLi4ELi1ELi0ELi4ELi1EEES7_(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6);
}

//----- (0000000000012AD0) ----------------------------------------------------
// attributes: thunk
void __fastcall Histogram::~Histogram(Histogram *this)
{
  _ZN9HistogramD2Ev(this);
}

//----- (0000000000012AF0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE5flushEv(a1);
}

//----- (0000000000012B00) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3)
{
  return _ZN5Eigen12DenseStorageIfLin1ELin1ELi1ELi0EEC2Elll(result, a2, a3);
}

//----- (0000000000012B40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::swapPlanes(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  return _ZN4CAPE10swapPlanesERNSt6__ndk16vectorI8PlaneSegNS0_9allocatorIS2_EEEERN2cv3MatEmm(a1, a2, a3, a4, a5);
}

//----- (0000000000012B50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall checktool::saveResults(__int64 a1, unsigned __int8 *a2)
{
  return _ZN9checktool11saveResultsENSt6__ndk112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE(a1, a2);
}

//----- (0000000000012B60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::run(
        feasibal_region::ground_process *this,
        const feasibal_region::GroundProcessRunInData *a2,
        feasibal_region::GroundProcessRunOutData *a3)
{
  return _ZN15feasibal_region14ground_process3runERKNS_22GroundProcessRunInDataERNS_23GroundProcessRunOutDataE(
           this,
           a2,
           a3);
}

//----- (0000000000012BA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::istream::tellg(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_istreamIcNS_11char_traitsIcEEE5tellgEv(a1);
}

//----- (0000000000012BF0) ----------------------------------------------------
// attributes: thunk
void __usercall ground_filter::Plane_Seg::getPointCloudOnIndexes(_QWORD *a1@<X0>, __int64 *a2@<X1>, _QWORD *a3@<X8>)
{
  _ZN13ground_filter9Plane_Seg22getPointCloudOnIndexesERKNSt6__ndk16vectorIiNS1_9allocatorIiEEEE(a1, a2, a3);
}

//----- (0000000000012C20) ----------------------------------------------------
// attributes: thunk
void __fastcall gte::NISymmetricEigensolver3x3<float>::operator()(
        __int64 a1,
        int a2,
        __int64 a3,
        float32x2_t *a4,
        float a5,
        float a6,
        float a7,
        float a8,
        float a9,
        float a10)
{
  _ZNK3gte25NISymmetricEigensolver3x3IfEclEffffffiRNSt6__ndk15arrayIfLm3EEERNS3_IS4_Lm3EEE(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10);
}

//----- (0000000000012C30) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg> const&>(
        __int64 a1,
        _QWORD *a2)
{
  _ZNSt6__ndk16vectorINS_10shared_ptrI8PlaneSegEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(a1, a2);
}

//----- (0000000000012C40) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  return _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm(a1, src, n);
}

//----- (0000000000012C50) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::RunInputParam::~RunInputParam(feasibal_region::RunInputParam *this, void *a2)
{
  _ZN15feasibal_region13RunInputParamD2Ev(this, a2);
}

//----- (0000000000012C60) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::getline<char,std::char_traits<char>,std::allocator<char>>(__int64 *a1, __int64 a2, char a3)
{
  return _ZNSt6__ndk17getlineIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS_13basic_istreamIT_T0_EES9_RNS_12basic_stringIS6_S7_T1_EES6_(
           a1,
           a2,
           a3);
}

//----- (0000000000012CA0) ----------------------------------------------------
// attributes: thunk
void __fastcall PlaneSeg::updatePlaneSeg(__int64 a1, _QWORD *a2, int a3, int a4, int a5)
{
  _ZN8PlaneSeg14updatePlaneSegERN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEEiii(a1, a2, a3, a4, a5);
}

//----- (0000000000012CB0) ----------------------------------------------------
// attributes: thunk
cv *__usercall feasibal_region::rotationMatrixFromAxisAndAngle@<X0>(double *a1@<X0>, double a3@<D0>, __int64 a2@<X8>)
{
  return _ZN15feasibal_region30rotationMatrixFromAxisAndAngleEN2cv3VecIdLi3EEEd(a1, a2, a3);
}

//----- (0000000000012CF0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<int>::__emplace_back_slow_path<int &>(__int64 a1, _DWORD *a2)
{
  _ZNSt6__ndk16vectorIiNS_9allocatorIiEEE24__emplace_back_slow_pathIJRiEEEvDpOT_(a1, a2);
}

//----- (0000000000012D10) ----------------------------------------------------
// attributes: thunk
void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
        float *a2@<X1>,
        __int64 *a3@<X2>,
        float a9@<S0>,
        __int64 a1@<X0>,
        int a4@<W3>,
        int a5@<W4>,
        unsigned __int8 a6@<W5>,
        int a7@<W6>,
        __int64 a8@<X8>)
{
  _ZN15feasibal_region14ground_process32getCellNotBelongPlaneCloudPointsEN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS1_5ArrayIfLin1ELi1ELi0ELin1ELi1EEEjifbi(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9);
}

//----- (0000000000012D20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::judgeValidBasedImage(
        CAPE *this,
        const cv::Mat *a2,
        const cv::Mat *a3,
        unsigned int *a4,
        unsigned int *a5)
{
  return _ZN4CAPE20judgeValidBasedImageERKN2cv3MatES3_RKjRj(this, a2, a3, a4, a5);
}

//----- (0000000000012D90) ----------------------------------------------------
// attributes: thunk
void __fastcall std::filebuf::~filebuf(__int64 a1)
{
  _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEED2Ev(a1);
}

//----- (0000000000012DA0) ----------------------------------------------------
// attributes: thunk
void *__fastcall ground_filter::Plane_Seg::Plane_Seg(ground_filter::Plane_Seg *this, char a2, float a3)
{
  return _ZN13ground_filter9Plane_SegC2Ebf(this, a2, a3);
}

//----- (0000000000012DB0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,-1,0>::DenseStorage(
        _QWORD *result,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return _ZN5Eigen12DenseStorageIfLin1ELin1ELin1ELi0EEC2Elll(result, a2, a3, a4);
}

//----- (0000000000012DC0) ----------------------------------------------------
// attributes: thunk
cv *__usercall checktool::getExtrinsicParameters@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X2>, __int64 a3@<X8>)
{
  return _ZN9checktool22getExtrinsicParametersERKNSt6__ndk16vectorIN2cv3VecIfLi3EEENS0_9allocatorIS4_EEEERKNS1_INS2_3MatENS5_ISA_EEEE(
           a1,
           a2,
           a3);
}

//----- (0000000000012DD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::readParam(float32x2_t *a1, __int64 a2)
{
  return _ZN15feasibal_region15feasibal_region9readParamERKNSt6__ndk112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE(
           a1,
           a2);
}

//----- (0000000000012DE0) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::GroundProcessRunInData::~GroundProcessRunInData(
        feasibal_region::GroundProcessRunInData *this,
        void *a2)
{
  _ZN15feasibal_region22GroundProcessRunInDataD2Ev(this, a2);
}

//----- (0000000000012DF0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::vector<cv::Mat>::__swap_out_circular_buffer(__int64 *result, _QWORD *a2)
{
  return _ZNSt6__ndk16vectorIN2cv3MatENS_9allocatorIS2_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS2_RS4_EE(
           result,
           a2);
}

//----- (0000000000012E00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::RegionGrowing(
        __int64 result,
        unsigned int a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        _QWORD *a6,
        _QWORD *a7,
        unsigned int a8,
        long double a9,
        unsigned __int16 a10,
        float *a11)
{
  return _ZN4CAPE13RegionGrowingEttPbS0_RNSt6__ndk16vectorINS1_10shared_ptrI8PlaneSegEENS1_9allocatorIS5_EEEERNS2_IfNS6_IfEEEEttPff(
           result,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11);
}

//----- (0000000000012E20) ----------------------------------------------------
// attributes: thunk
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  _ZNSt6__ndk115basic_streambufIcNS_11char_traitsIcEEED2Ev(a1);
}

//----- (0000000000012E40) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix(__int64 *a1, __int64 *a2)
{
  _ZN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEC2ERKS1_(a1, a2);
}

//----- (0000000000012E50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int64 *a2)
{
  return _ZN15feasibal_region15feasibal_region4initERKNSt6__ndk112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE(
           a1,
           a2);
}

//----- (0000000000012E60) ----------------------------------------------------
// attributes: thunk
bool __fastcall ground_filter::Plane_Seg::segPlane(char **a1, float32x2_t *a2, __int64 *a3, int a4)
{
  return _ZN13ground_filter9Plane_Seg8segPlaneERN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEERNSt6__ndk16vectorIiNS5_9allocatorIiEEEEi(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000012E70) ----------------------------------------------------
// attributes: thunk
void __fastcall CAPE::getConnectedComponents(__int64 a1, __int64 a2, __int64 *a3)
{
  _ZN4CAPE22getConnectedComponentsERN2cv3MatERN5Eigen6MatrixIbLin1ELin1ELi0ELin1ELin1EEE(a1, a2, a3);
}

//----- (0000000000012E80) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
        __int64 a1,
        __int64 a2)
{
  _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(
    a1,
    a2);
}

//----- (0000000000012E90) ----------------------------------------------------
// attributes: thunk
bool __fastcall isRotationMatrix(cv::Mat *a1)
{
  return _Z16isRotationMatrixRN2cv3MatE(a1);
}

//----- (0000000000012EA0) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
        char **a1,
        _DWORD *a2,
        unsigned __int64 a3,
        char *a4)
{
  return _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEE6insertINS_11__wrap_iterIPKS3_EEEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr16is_constructibleIS3_NS_15iterator_traitsISD_E9referenceEEE5valueENS8_IPS3_EEE4typeESB_SD_SD_(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000012EB0) ----------------------------------------------------
// attributes: thunk
cv::Mat *__fastcall cv::Mat::operator=(cv::Mat *this, cv::Mat *a2)
{
  return _ZN2cv3MataSEOS0_(this, a2);
}

//----- (0000000000012EC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev(result);
}

//----- (0000000000012ED0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall Eigen::SelfAdjointEigenSolver<Eigen::Matrix<float,3,3,0,3,3>>::compute(
        __int64 a1,
        float *a2,
        char a3)
{
  return _ZN5Eigen22SelfAdjointEigenSolverINS_6MatrixIfLi3ELi3ELi0ELi3ELi3EEEE7computeERKS2_i(a1, a2, a3);
}

//----- (0000000000012EE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(__int64 a1, __int64 a2, float *a3, __int64 a4)
{
  return _ZN13ground_filter9Plane_Seg19getPlaneFrom3PointsERKNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS1_9allocatorIS5_EEEES5_RNS4_IfLi4ELi1ELi0ELi4ELi1EEE(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000012EF0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<Eigen::Transform<float,3,1,0>>::__push_back_slow_path<Eigen::Transform<float,3,1,0> const&>(
        __int64 a1,
        _OWORD *a2)
{
  _ZNSt6__ndk16vectorIN5Eigen9TransformIfLi3ELi1ELi0EEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(a1, a2);
}

//----- (0000000000012F10) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, float a2)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEf(a1, a2);
}

//----- (0000000000012F30) ----------------------------------------------------
// attributes: thunk
char *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
        __int64 a1,
        char *a2,
        char *a3)
{
  return _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEE6assignIPS3_EENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr16is_constructibleIS3_NS_15iterator_traitsISA_E9referenceEEE5valueEvE4typeESA_SA_(
           a1,
           a2,
           a3);
}

//----- (0000000000012F40) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEj(a1);
}

//----- (0000000000012F50) ----------------------------------------------------
// attributes: thunk
void __fastcall PlaneSeg::~PlaneSeg(void **this)
{
  _ZN8PlaneSegD2Ev(this);
}

//----- (0000000000012F60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::set_calib(__int64 a1, __int128 *a2)
{
  return _ZN15feasibal_region14ground_process9set_calibEN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEEf(a1, a2);
}

//----- (0000000000012F70) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<bool,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  _ZN5Eigen15PlainObjectBaseINS_6MatrixIbLin1ELin1ELi0ELin1ELin1EEEE6resizeEll(a1, a2, a3);
}

//----- (0000000000012FB0) ----------------------------------------------------
// attributes: thunk
void __usercall Histogram::getPointsFromMostFrequentBin(Histogram *this@<X0>, int64x2_t *a2@<X8>)
{
  _ZN9Histogram28getPointsFromMostFrequentBinEv(this, a2);
}

//----- (0000000000012FE0) ----------------------------------------------------
// attributes: thunk
float32x4_t *__fastcall std::vector<int>::assign(float32x4_t **a1, unsigned __int64 a2, const float *a3)
{
  return _ZNSt6__ndk16vectorIiNS_9allocatorIiEEE6assignEmRKi(a1, a2, a3);
}

//----- (0000000000013000) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1)
{
  return _ZNSt6__ndk113basic_filebufIcNS_11char_traitsIcEEEC2Ev(a1);
}

//----- (0000000000013010) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::Plane_Seg::judgPlaneValid(__int64 a1, float *a2, float *a3, float a4)
{
  return _ZN13ground_filter9Plane_Seg14judgPlaneValidERKN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEERKNS2_IfLi3ELi1ELi0ELi3ELi1EEEf(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000013060) ----------------------------------------------------
// attributes: thunk
cv *__fastcall feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
        __int64 a1,
        __int64 a2,
        const cv::FileNode *a3,
        __int64 a4)
{
  return _ZN15feasibal_region15feasibal_region11attemtpReadIN2cv3MatEEEvRKNSt6__ndk112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEERT_RNS2_11FileStorageE(
           a1,
           a2,
           a3,
           a4);
}

//----- (0000000000013090) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::RunOutputParam::~RunOutputParam(feasibal_region::RunOutputParam *this, void *a2)
{
  _ZN15feasibal_region14RunOutputParamD2Ev(this, a2);
}

//----- (00000000000130A0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEb(a1);
}

//----- (00000000000130B0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<std::vector<Eigen::Matrix<float,3,1,0,3,1>>>::__push_back_slow_path<std::vector<Eigen::Matrix<float,3,1,0,3,1>> const&>(
        signed __int64 **a1,
        char **a2)
{
  _ZNSt6__ndk16vectorINS0_IN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEEENS4_IS6_EEE21__push_back_slow_pathIRKS6_EEvOT_(
    a1,
    a2);
}

//----- (00000000000130D0) ----------------------------------------------------
// attributes: thunk
void __usercall rotationMatrixToEulerAngles(cv::Mat *a1@<X0>, __int64 a2@<X8>)
{
  _Z27rotationMatrixToEulerAnglesRN2cv3MatE(a1, a2);
}

//----- (00000000000130E0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(
        _QWORD *a1)
{
  return _ZNSt6__ndk125__independent_bits_engineINS_23mersenne_twister_engineImLm32ELm624ELm397ELm31ELm2567483615ELm11ELm4294967295ELm7ELm2636928640ELm15ELm4022730752ELm18ELm1812433253EEEmE6__evalENS_17integral_constantIbLb1EEE(a1);
}

//----- (00000000000130F0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<cv::Point_<int>>::__push_back_slow_path<cv::Point_<int>>(__int64 a1, _QWORD *a2)
{
  _ZNSt6__ndk16vectorIN2cv6Point_IiEENS_9allocatorIS3_EEE21__push_back_slow_pathIS3_EEvOT_(a1, a2);
}

//----- (0000000000013100) ----------------------------------------------------
// attributes: thunk
void __fastcall CAPE::CAPE(CAPE *this, int a2, int a3, int a4, int a5, char a6, float a7, float a8, float a9)
{
  _ZN4CAPEC2Eiiiibfff(this, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (0000000000013170) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::insert(unsigned __int64 *a1, char *a2, _DWORD *a3)
{
  return _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_9allocatorIS3_EEE6insertENS_11__wrap_iterIPKS3_EERS8_(
           a1,
           a2,
           a3);
}

//----- (00000000000131C0) ----------------------------------------------------
// attributes: thunk
long double __fastcall feasibal_region::ground_process::ground_process(feasibal_region::ground_process *this)
{
  return _ZN15feasibal_region14ground_processC2Ev(this);
}

//----- (00000000000131D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall PlaneSeg::operator=(__int64 a1, __int64 a2)
{
  return _ZN8PlaneSegaSERKS_(a1, a2);
}

//----- (0000000000013210) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::vector<std::vector<int>>::vector(_QWORD *result, unsigned __int64 a2)
{
  return _ZNSt6__ndk16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Em(result, a2);
}

//----- (0000000000013220) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>(__int64 *a1, cv::Mat *a2)
{
  _ZNSt6__ndk16vectorIN2cv3MatENS_9allocatorIS2_EEE21__push_back_slow_pathIRKS2_EEvOT_(a1, a2);
}

//----- (0000000000013240) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::vector<bool>::__construct_at_end<std::__bit_iterator<std::vector<bool>,false,0ul>>(
        _QWORD *result,
        __int64 a2,
        __int64 a3)
{
  return _ZNSt6__ndk16vectorIbNS_9allocatorIbEEE18__construct_at_endINS_14__bit_iteratorIS3_Lb0ELm0EEEEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES8_S8_(
           result,
           a2,
           a3);
}

//----- (0000000000013260) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::updateDefaultPlane(__int64 result, _DWORD *a2, float a3)
{
  return _ZN4CAPE18updateDefaultPlaneEN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEEf(result, a2, a3);
}

//----- (0000000000013280) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::Plane_Seg::optimizePlaneCoef(
        float32x2_t *a1,
        __int64 *a2,
        unsigned __int32 *a3,
        float32x2_t *a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  return _ZN13ground_filter9Plane_Seg17optimizePlaneCoefERKNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS1_9allocatorIS5_EEEERKNS4_IfLi4ELi1ELi0ELi4ELi1EEERSB_(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11);
}

//----- (0000000000013290) ----------------------------------------------------
// attributes: thunk
float __fastcall PlaneSeg::expandSegment(int *a1, __int64 *a2)
{
  return _ZN8PlaneSeg13expandSegmentENSt6__ndk110shared_ptrIS_EE(a1, a2);
}

//----- (00000000000132D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall checktool::getNearEdge(__int64 a1, __int64 *a2, int a3)
{
  return _ZN9checktool11getNearEdgeERKNSt6__ndk16vectorIN2cv3MatENS0_9allocatorIS3_EEEEi(a1, a2, a3);
}

//----- (00000000000132E0) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::PreParamInfo::~PreParamInfo(void **this, void *a2)
{
  _ZN15feasibal_region12PreParamInfoD2Ev(this, a2);
}

//----- (0000000000013300) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::random_device::operator()(int *a1)
{
  return _ZNSt6__ndk113random_deviceclEv(a1);
}

//----- (0000000000013310) ----------------------------------------------------
// attributes: thunk
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  _ZN5Eigen15PlainObjectBaseINS_6MatrixIfLin1ELin1ELi0ELin1ELin1EEEE6resizeEll(a1, a2, a3);
}

//----- (0000000000013340) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::set_extrinsic(__int64 result, _DWORD *a2, _DWORD *a3)
{
  return _ZN4CAPE13set_extrinsicEN5Eigen9TransformIfLi3ELi1ELi0EEENS0_6MatrixIfLi4ELi1ELi0ELi4ELi1EEE(result, a2, a3);
}

//----- (0000000000013360) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  _ZNKSt6__ndk121__basic_string_commonILb1EE20__throw_out_of_rangeEv();
}

//----- (0000000000013390) ----------------------------------------------------
// attributes: thunk
void __usercall checktool::getPointCloud(float *a1@<X1>, _QWORD *a4@<X8>, double a5@<D0>, __int64 a2@<X2>, int a3@<W3>)
{
  _ZN9checktool13getPointCloudEN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEEN2cv3MatEi(a1, a2, a3, a4, a5);
}

//----- (00000000000133A0) ----------------------------------------------------
// attributes: thunk
__int64 *__fastcall std::vector<ground_filter::plane_base>::assign<ground_filter::plane_base*>(
        __int64 *result,
        char *a2,
        char *a3)
{
  return _ZNSt6__ndk16vectorIN13ground_filter10plane_baseENS_9allocatorIS2_EEE6assignIPS2_EENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr16is_constructibleIS2_NS_15iterator_traitsIS9_E9referenceEEE5valueEvE4typeES9_S9_(
           result,
           a2,
           a3);
}

//----- (00000000000133D0) ----------------------------------------------------
// attributes: thunk
feasibal_region *__fastcall feasibal_region::feasibal_region::feasibal_region(feasibal_region::feasibal_region *this)
{
  return _ZN15feasibal_region15feasibal_regionC2Ev(this);
}

//----- (00000000000133E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::PreParamInfo::operator=(__int64 a1, __int128 *a2)
{
  return _ZN15feasibal_region12PreParamInfoaSERKS0_(a1, a2);
}

//----- (0000000000013400) ----------------------------------------------------
// attributes: thunk
void __fastcall cv::MatExpr::~MatExpr(cv::MatExpr *this, void *a2)
{
  _ZN2cv7MatExprD2Ev(this, a2);
}

//----- (0000000000013410) ----------------------------------------------------
// attributes: thunk
void __fastcall Histogram::Histogram(Histogram *this, int a2)
{
  _ZN9HistogramC2Ei(this, a2);
}

//----- (0000000000013420) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CAPE::getBestPlane(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, const int *a4)
{
  return _ZN4CAPE12getBestPlaneERKN2cv3MatES3_RKi(this, a2, a3, a4);
}

//----- (0000000000013430) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEi(a1);
}

//----- (0000000000013440) ----------------------------------------------------
// attributes: thunk
void __fastcall CAPE::~CAPE(CAPE *this)
{
  _ZN4CAPED2Ev(this);
}

//----- (0000000000013460) ----------------------------------------------------
// attributes: thunk
float32x4_t *__fastcall Histogram::initHistogram(__int64 a1, __int64 *a2, __int64 *a3)
{
  return _ZN9Histogram13initHistogramERN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEERNSt6__ndk16vectorIbNS4_9allocatorIbEEEE(
           a1,
           a2,
           a3);
}

//----- (0000000000013480) ----------------------------------------------------
// attributes: thunk
void __fastcall std::__split_buffer<cv::Mat>::~__split_buffer(__int64 a1, void *a2)
{
  _ZNSt6__ndk114__split_bufferIN2cv3MatERNS_9allocatorIS2_EEED2Ev(a1, a2);
}

//----- (00000000000134B0) ----------------------------------------------------
// attributes: thunk
char *__fastcall _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6,
        const void **a7,
        char **a8,
        __int64 a9,
        _BYTE *a10)
{
  return ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10);
}

//----- (00000000000134C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::pointCloudProcess(__int64 a1, __int64 a2)
{
  return _ZN15feasibal_region14ground_process17pointCloudProcessEN2cv3MatE(a1, a2);
}

//----- (0000000000013520) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<int>::__push_back_slow_path<int>(__int64 a1, _DWORD *a2)
{
  _ZNSt6__ndk16vectorIiNS_9allocatorIiEEE21__push_back_slow_pathIiEEvOT_(a1, a2);
}

//----- (0000000000013550) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<cv::Vec<int,4>>::__push_back_slow_path<cv::Vec<int,4> const&>(__int64 a1, _OWORD *a2)
{
  _ZNSt6__ndk16vectorIN2cv3VecIiLi4EEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(a1, a2);
}

//----- (0000000000013560) ----------------------------------------------------
// attributes: thunk
void __noreturn std::__vector_base_common<true>::__throw_length_error()
{
  _ZNKSt6__ndk120__vector_base_commonILb1EE20__throw_length_errorEv();
}

//----- (0000000000013570) ----------------------------------------------------
// attributes: thunk
void __fastcall ground_filter::Plane_Seg::computeRoots(__int64 a1, float *a2, __int64 a3)
{
  _ZN13ground_filter9Plane_Seg12computeRootsERKN5Eigen6MatrixIfLi3ELi3ELi0ELi3ELi3EEERNS2_IfLi3ELi1ELi0ELi3ELi1EEE(
    a1,
    a2,
    a3);
}

//----- (0000000000013580) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::Plane_Seg::segPlane(
        float32x2_t *a1,
        float **a2,
        _QWORD *a3,
        float32x2_t *a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8,
        int a9)
{
  return _ZN13ground_filter9Plane_Seg8segPlaneERKNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS1_9allocatorIS5_EEEERNS2_IcNS6_IcEEEERNS4_IfLi4ELi1ELi0ELi4ELi1EEERNS2_IiNS6_IiEEEERS8_S5_fSH_i(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9);
}

//----- (00000000000135B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall cv::Mat_<int>::Mat_(__int64 a1, int a2, int a3, int *a4)
{
  return _ZN2cv4Mat_IiEC2EiiRKi(a1, a2, a3, a4);
}

//----- (00000000000135C0) ----------------------------------------------------
// attributes: thunk
__int64 __usercall eulerAnglestoRotationMtx@<X0>(__int64 a1@<X0>, __int64 a2@<X8>)
{
  return _Z24eulerAnglestoRotationMtxN2cv3MatE(a1, a2);
}

//----- (00000000000135D0) ----------------------------------------------------
// attributes: thunk
void __usercall ground_filter::Plane_Seg::run(
        float32x2_t *a1@<X0>,
        _QWORD *a2@<X1>,
        int a3@<W2>,
        int a4@<W3>,
        int a5@<W4>,
        __int64 a6@<X5>,
        unsigned __int32 *a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        float a10@<S0>)
{
  _ZN13ground_filter9Plane_Seg3runERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEEiiiRKNS1_9TransformIfLi3ELi1ELi0EEERKNS2_IfLi4ELi1ELi0ELi4ELi1EEERKNS2_IfLi3ELi1ELi0ELi3ELi1EEEf(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10);
}

//----- (00000000000135E0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::random_device::~random_device(std::random_device *this)
{
  _ZNSt6__ndk113random_deviceD2Ev(this);
}

//----- (00000000000135F0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(
        __int64 a1,
        __int64 *a2)
{
  _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEE21__push_back_slow_pathIS3_EEvOT_(
    a1,
    a2);
}

//----- (0000000000013600) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::getPlaneFromExtrinsic(__int64 a1, float32x2_t *a2, float *a3)
{
  return _ZN15feasibal_region14ground_process21getPlaneFromExtrinsicERN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEERfb(
           a1,
           a2,
           a3);
}

//----- (0000000000013620) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __usercall std::__copy_unaligned<std::vector<bool>,false>@<X0>(
        unsigned __int64 result@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X8>)
{
  return _ZNSt6__ndk116__copy_unalignedINS_6vectorIbNS_9allocatorIbEEEELb0EEENS_14__bit_iteratorIT_Lb0EXLi0EEEENS5_IS6_XT0_EXLi0EEEES8_S7_(
           result,
           a2,
           a3,
           a4);
}

//----- (0000000000013650) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::ground_process::~ground_process(feasibal_region::ground_process *this)
{
  _ZN15feasibal_region14ground_processD2Ev(this);
}

//----- (0000000000013660) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::groundProcess(feasibal_region::ground_process *this)
{
  return _ZN15feasibal_region14ground_process13groundProcessEv(this);
}

//----- (00000000000136A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::plane_base::operator=(__int64 a1, __int64 a2)
{
  return _ZN13ground_filter10plane_baseaSERKS0_(a1, a2);
}

//----- (00000000000136B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT_(
        __int64 a1,
        float32x2_t *a2,
        __int64 a3,
        __int64 a4)
{
  return _ZN15feasibal_region14ground_process17GetCameraPlaneRT_EN2cv3VecIfLi4EEERNS1_3MatES5_f(a1, a2, a3, a4);
}

//----- (00000000000136D0) ----------------------------------------------------
// attributes: thunk
void __usercall CAPE::imageScore(CAPE *this@<X0>, const cv::Mat *a2@<X1>, const int *a3@<X2>, float32x4_t **a4@<X8>)
{
  _ZN4CAPE10imageScoreERKN2cv3MatERKi(this, a2, a3, a4);
}

//----- (00000000000136E0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::__push_back_slow_path<Eigen::Matrix<float,4,1,0,4,1>>(
        __int64 a1,
        _OWORD *a2)
{
  _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_9allocatorIS3_EEE21__push_back_slow_pathIS3_EEvOT_(
    a1,
    a2);
}

//----- (00000000000136F0) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::RunInputParam::RunInputParam(
        feasibal_region::RunInputParam *this,
        __int64 a2,
        __int64 a3,
        int a4)
{
  _ZN15feasibal_region13RunInputParamC2Ev(this, a2, a3, a4);
}

//----- (0000000000013700) ----------------------------------------------------
// attributes: thunk
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(
        float a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        int32x2_t a7,
        __int64 a8,
        float *a9,
        float *a10)
{
  _ZNK3gte25NISymmetricEigensolver3x3IfE19ComputeEigenvector1EffffffRKNSt6__ndk15arrayIfLm3EEEfRS4_(
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10);
}

//----- (0000000000013740) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::WriteCameraParam(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN15feasibal_region15feasibal_region16WriteCameraParamERKNSt6__ndk112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKN2cv3MatE(
           a1,
           a2,
           a3);
}

//----- (0000000000013750) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall Histogram::removePoint(_QWORD *this, int a2)
{
  return _ZN9Histogram11removePointEi(this, a2);
}

//----- (0000000000013760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ground_filter::plane_base::plane_base(__int64 result, __int64 a2)
{
  return _ZN13ground_filter10plane_baseC2ERKS0_(result, a2);
}

//----- (0000000000013770) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::getDirectorySize(__int64 a1)
{
  return _ZN15feasibal_region16getDirectorySizeENSt6__ndk112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE(a1);
}

//----- (0000000000013780) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, long double a2)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEElsEd(a1, a2);
}

//----- (0000000000013790) ----------------------------------------------------
// attributes: thunk
float32x4_t *__fastcall Eigen::internal::apply_rotation_in_the_plane<Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,float>(
        float32x4_t *result,
        unsigned __int64 *a2,
        _DWORD *a3,
        double a4,
        double a5)
{
  return _ZN5Eigen8internal27apply_rotation_in_the_planeINS_5BlockINS_3MapINS_6MatrixIfLin1ELin1ELi0ELin1ELin1EEELi0ENS_6StrideILi0ELi0EEEEELin1ELi1ELb1EEES9_fEEvRT_RT0_RKNS_14JacobiRotationIT1_EE(
           result,
           a2,
           a3,
           a4,
           a5);
}

//----- (00000000000137C0) ----------------------------------------------------
// attributes: thunk
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2)
{
  return _ZN2cv4Mat_IdEaSEONS_3MatE(this, a2);
}

//----- (0000000000013800) ----------------------------------------------------
// attributes: thunk
signed __int64 __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector(signed __int64 *a1, char **a2)
{
  return _ZNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS_9allocatorIS3_EEEC2ERKS6_(a1, a2);
}

//----- (0000000000013810) ----------------------------------------------------
// attributes: thunk
float32x2_t __usercall feasibal_region::ground_process::getTFMatrix@<D0>(
        float *a1@<X1>,
        float32x2_t *a2@<X2>,
        float32x2_t *a3@<X8>)
{
  return _ZN15feasibal_region14ground_process11getTFMatrixERKN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEES5_(a1, a2, a3);
}

//----- (0000000000013820) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<cv::Vec<unsigned char,3>>::__push_back_slow_path<cv::Vec<unsigned char,3> const&>(
        __int64 a1,
        _BYTE *a2)
{
  _ZNSt6__ndk16vectorIN2cv3VecIhLi3EEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(a1, a2);
}

//----- (0000000000013830) ----------------------------------------------------
// attributes: thunk
cv *__fastcall feasibal_region::depth2color(
        feasibal_region *this,
        cv::Mat *a2,
        const cv::Mat *a3,
        double a4,
        double a5)
{
  return _ZN15feasibal_region11depth2colorERN2cv3MatERKS1_dd(this, a2, a3, a4, a5);
}

//----- (0000000000013860) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::feasibal_region::readParam(__int64 a1, __int64 a2, _DWORD *a3, int a4, double a5)
{
  return _ZN15feasibal_region15feasibal_region9readParamEN2cv3MatEdN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEEi(
           a1,
           a2,
           a3,
           a4,
           a5);
}

//----- (00000000000138A0) ----------------------------------------------------
// attributes: thunk
float __fastcall ground_filter::Plane_Seg::computeMeanAndCovarianceMatrix(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  return _ZN13ground_filter9Plane_Seg30computeMeanAndCovarianceMatrixERKNSt6__ndk16vectorIN5Eigen6MatrixIfLi3ELi1ELi0ELi3ELi1EEENS1_9allocatorIS5_EEEERNS4_IfLi3ELi3ELi0ELi3ELi3EEERNS4_IfLi4ELi1ELi0ELi4ELi1EEE(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11);
}

//----- (00000000000138C0) ----------------------------------------------------
// attributes: thunk
void __fastcall ground_filter::Plane_Seg::~Plane_Seg(ground_filter::Plane_Seg *this, void *a2)
{
  _ZN13ground_filter9Plane_SegD2Ev(this, a2);
}

//----- (00000000000138F0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<cv::Vec<float,3>>::__push_back_slow_path<cv::Vec<float,3> const&>(__int64 a1, __int64 a2)
{
  _ZNSt6__ndk16vectorIN2cv3VecIfLi3EEENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEvOT_(a1, a2);
}

//----- (0000000000013900) ----------------------------------------------------
// attributes: thunk
void __fastcall feasibal_region::GroundProcessRunOutData::~GroundProcessRunOutData(
        feasibal_region::GroundProcessRunOutData *this,
        void *a2)
{
  _ZN15feasibal_region23GroundProcessRunOutDataD2Ev(this, a2);
}

//----- (0000000000013920) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall feasibal_region::ground_process::init_data_pre(__int64 a1, __int64 a2)
{
  return _ZN15feasibal_region14ground_process13init_data_preEN2cv3MatE(a1, a2);
}

//----- (0000000000013930) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::ostream::put(_QWORD *a1, unsigned __int8 a2)
{
  return _ZNSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEE3putEc(a1, a2);
}

//----- (0000000000013950) ----------------------------------------------------
// attributes: thunk
char *__fastcall std::vector<float>::insert(unsigned __int64 *a1, unsigned __int64 src, char *a3)
{
  return _ZNSt6__ndk16vectorIfNS_9allocatorIfEEE6insertENS_11__wrap_iterIPKfEERS5_(a1, src, a3);
}

//----- (0000000000013960) ----------------------------------------------------
// attributes: thunk
void __fastcall std::__split_buffer<ground_filter::plane_base>::~__split_buffer(__int64 a1, void *a2)
{
  _ZNSt6__ndk114__split_bufferIN13ground_filter10plane_baseERNS_9allocatorIS2_EEED2Ev(a1, a2);
}

//----- (0000000000013980) ----------------------------------------------------
void start()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy = 1LL;
}
// 6FDA0: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy;

//----- (000000000001399C) ----------------------------------------------------
void sub_1399C()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<char const*>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<char const*>::policy = 1LL;
}
// 6FDA8: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<char const*>::policy;

//----- (00000000000139B8) ----------------------------------------------------
void sub_139B8()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<int>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<int>::policy = 1LL;
}
// 6FDB0: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<int>::policy;

//----- (00000000000139D4) ----------------------------------------------------
void sub_139D4()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<float>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<float>::policy = 1LL;
}
// 6FDB8: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<float>::policy;

//----- (00000000000139F0) ----------------------------------------------------
void sub_139F0()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<bool>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<bool>::policy = 1LL;
}
// 6FDC0: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<bool>::policy;

//----- (0000000000013A0C) ----------------------------------------------------
void sub_13A0C()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_algorithm_t>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_algorithm_t>::policy = 1LL;
}
// 6FDC8: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_algorithm_t>::policy;

//----- (0000000000013A28) ----------------------------------------------------
void sub_13A28()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_centers_init_t>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_centers_init_t>::policy = 1LL;
}
// 6FDD0: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<cvflann::flann_centers_init_t>::policy;

//----- (0000000000013A44) ----------------------------------------------------
void sub_13A44()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<unsigned int>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<unsigned int>::policy = 1LL;
}
// 6FDD8: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<unsigned int>::policy;

//----- (0000000000013A60) ----------------------------------------------------
void sub_13A60()
{
  if ( (`guard variable for'cvflann::anyimpl::SinglePolicy<std::string>::policy & 1) == 0 )
    `guard variable for'cvflann::anyimpl::SinglePolicy<std::string>::policy = 1LL;
}
// 6FDE0: using guessed type __int64 `guard variable for'cvflann::anyimpl::SinglePolicy<std::string>::policy;

//----- (0000000000013A7C) ----------------------------------------------------
__int64 sub_13A7C()
{
  dword_6FC50 = 100;
  word_6FC58 = 17410;
  unk_6FC62 = 0LL;
  unk_6FC5A = 0LL;
  qword_6FC68 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FC50, &off_6F000);
  dword_6FC70 = 50;
  word_6FC78 = 22018;
  unk_6FC82 = 0LL;
  unk_6FC7A = 0LL;
  qword_6FC88 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FC70, &off_6F000);
  dword_6FC90 = 300;
  word_6FC98 = 18690;
  unk_6FCA2 = 0LL;
  unk_6FC9A = 0LL;
  qword_6FCA8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FC90, &off_6F000);
  dword_6FCB0 = 500;
  word_6FCB8 = 22274;
  unk_6FCC2 = 0LL;
  unk_6FCBA = 0LL;
  qword_6FCC8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FCB0, &off_6F000);
  dword_6FCD0 = 800;
  word_6FCD8 = 17666;
  unk_6FCE2 = 0LL;
  unk_6FCDA = 0LL;
  qword_6FCE8 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FCD0, &off_6F000);
  dword_6FCF0 = 1000;
  word_6FCF8 = 17922;
  unk_6FD02 = 0LL;
  unk_6FCFA = 0LL;
  qword_6FD08 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FCF0, &off_6F000);
  dword_6FD10 = 2000;
  byte_6FD18 = 16;
  unk_6FD19 = 0x54434152544E4F43LL;
  qword_6FD28 = 0LL;
  unk_6FD21 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FD10, &off_6F000);
  dword_6FD30 = 2001;
  byte_6FD38 = 24;
  unk_6FD41 = 1279348295;
  byte_6FD4F = 0;
  unk_6FD4D = 0;
  unk_6FD39 = *(_QWORD *)"FATAL_SIGNAL";
  unk_6FD45 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FD30, &off_6F000);
  dword_6FD50 = 2002;
  byte_6FD58 = 30;
  byte_6FD6F = 0;
  unk_6FD6D = 0;
  strcpy(algn_6FD59, "FATAL_EXCEPTION");
  unk_6FD69 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FD50, &off_6F000);
  unk_6FD78 = 0LL;
  qword_6FD80 = 0LL;
  qword_6FD70 = 16LL;
  *(__int64 *)((char *)&qword_6FD70 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_6FD70, &off_6F000);
  unk_6FD90 = 0x3366252000LL;
  qword_6FD98 = 0LL;
  qword_6FD88 = 24LL;
  *(__int64 *)((char *)&qword_6FD88 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_6FD88, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;
// 6FC50: using guessed type int dword_6FC50;
// 6FC58: using guessed type __int16 word_6FC58;
// 6FC68: using guessed type __int64 qword_6FC68;
// 6FC70: using guessed type int dword_6FC70;
// 6FC78: using guessed type __int16 word_6FC78;
// 6FC88: using guessed type __int64 qword_6FC88;
// 6FC90: using guessed type int dword_6FC90;
// 6FC98: using guessed type __int16 word_6FC98;
// 6FCA8: using guessed type __int64 qword_6FCA8;
// 6FCB0: using guessed type int dword_6FCB0;
// 6FCB8: using guessed type __int16 word_6FCB8;
// 6FCC8: using guessed type __int64 qword_6FCC8;
// 6FCD0: using guessed type int dword_6FCD0;
// 6FCD8: using guessed type __int16 word_6FCD8;
// 6FCE8: using guessed type __int64 qword_6FCE8;
// 6FCF0: using guessed type int dword_6FCF0;
// 6FCF8: using guessed type __int16 word_6FCF8;
// 6FD08: using guessed type __int64 qword_6FD08;
// 6FD10: using guessed type int dword_6FD10;
// 6FD18: using guessed type char byte_6FD18;
// 6FD28: using guessed type __int64 qword_6FD28;
// 6FD30: using guessed type int dword_6FD30;
// 6FD38: using guessed type char byte_6FD38;
// 6FD4F: using guessed type char byte_6FD4F;
// 6FD50: using guessed type int dword_6FD50;
// 6FD58: using guessed type char byte_6FD58;
// 6FD59: using guessed type _BYTE algn_6FD59[7];
// 6FD60: using guessed type __int64 qword_6FD60;
// 6FD68: using guessed type char byte_6FD68;
// 6FD6F: using guessed type char byte_6FD6F;
// 6FD70: using guessed type __int64 qword_6FD70;
// 6FD80: using guessed type __int64 qword_6FD80;
// 6FD88: using guessed type __int64 qword_6FD88;
// 6FD98: using guessed type __int64 qword_6FD98;

//----- (0000000000013D20) ----------------------------------------------------
__int64 sub_13D20()
{
  dword_6FDE8 = 100;
  word_6FDF0 = 17410;
  *(_QWORD *)&algn_6FDF2[8] = 0LL;
  *(_QWORD *)algn_6FDF2 = 0LL;
  qword_6FE00 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FDE8, &off_6F000);
  dword_6FE08 = 50;
  word_6FE10 = 22018;
  *(_QWORD *)&algn_6FE12[8] = 0LL;
  *(_QWORD *)algn_6FE12 = 0LL;
  qword_6FE20 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FE08, &off_6F000);
  dword_6FE28 = 300;
  word_6FE30 = 18690;
  *(_QWORD *)&algn_6FE32[8] = 0LL;
  *(_QWORD *)algn_6FE32 = 0LL;
  qword_6FE40 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FE28, &off_6F000);
  dword_6FE48 = 500;
  word_6FE50 = 22274;
  *(_QWORD *)&algn_6FE52[8] = 0LL;
  *(_QWORD *)algn_6FE52 = 0LL;
  qword_6FE60 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FE48, &off_6F000);
  dword_6FE68 = 800;
  word_6FE70 = 17666;
  *(_QWORD *)&algn_6FE72[8] = 0LL;
  *(_QWORD *)algn_6FE72 = 0LL;
  qword_6FE80 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FE68, &off_6F000);
  dword_6FE88 = 1000;
  word_6FE90 = 17922;
  *(_QWORD *)&algn_6FE92[8] = 0LL;
  *(_QWORD *)algn_6FE92 = 0LL;
  qword_6FEA0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FE88, &off_6F000);
  dword_6FEA8 = 2000;
  byte_6FEB0 = 16;
  *(_QWORD *)algn_6FEB1 = 0x54434152544E4F43LL;
  qword_6FEC0 = 0LL;
  *(_QWORD *)&algn_6FEB1[8] = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FEA8, &off_6F000);
  dword_6FEC8 = 2001;
  byte_6FED0 = 24;
  unk_6FED9 = 1279348295;
  byte_6FEE7 = 0;
  unk_6FEE5 = 0;
  unk_6FED1 = *(_QWORD *)"FATAL_SIGNAL";
  unk_6FEDD = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FEC8, &off_6F000);
  dword_6FEE8 = 2002;
  byte_6FEF0 = 30;
  byte_6FF07 = 0;
  unk_6FF05 = 0;
  strcpy(algn_6FEF1, "FATAL_EXCEPTION");
  unk_6FF01 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FEE8, &off_6F000);
  unk_6FF10 = 0LL;
  qword_6FF18 = 0LL;
  qword_6FF08 = 16LL;
  *(__int64 *)((char *)&qword_6FF08 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_6FF08, &off_6F000);
  unk_6FF28 = 0x3366252000LL;
  qword_6FF30 = 0LL;
  qword_6FF20 = 24LL;
  *(__int64 *)((char *)&qword_6FF20 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_6FF20, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FDF2: using guessed type _BYTE algn_6FDF2[14];
// 6FE00: using guessed type __int64 qword_6FE00;
// 6FE08: using guessed type int dword_6FE08;
// 6FE10: using guessed type __int16 word_6FE10;
// 6FE12: using guessed type _BYTE algn_6FE12[14];
// 6FE20: using guessed type __int64 qword_6FE20;
// 6FE28: using guessed type int dword_6FE28;
// 6FE30: using guessed type __int16 word_6FE30;
// 6FE32: using guessed type _BYTE algn_6FE32[14];
// 6FE40: using guessed type __int64 qword_6FE40;
// 6FE48: using guessed type int dword_6FE48;
// 6FE50: using guessed type __int16 word_6FE50;
// 6FE52: using guessed type _BYTE algn_6FE52[14];
// 6FE60: using guessed type __int64 qword_6FE60;
// 6FE68: using guessed type int dword_6FE68;
// 6FE70: using guessed type __int16 word_6FE70;
// 6FE72: using guessed type _BYTE algn_6FE72[14];
// 6FE80: using guessed type __int64 qword_6FE80;
// 6FE88: using guessed type int dword_6FE88;
// 6FE90: using guessed type __int16 word_6FE90;
// 6FE92: using guessed type _BYTE algn_6FE92[14];
// 6FEA0: using guessed type __int64 qword_6FEA0;
// 6FEA8: using guessed type int dword_6FEA8;
// 6FEB0: using guessed type char byte_6FEB0;
// 6FEB1: using guessed type _BYTE algn_6FEB1[15];
// 6FEC0: using guessed type __int64 qword_6FEC0;
// 6FEC8: using guessed type int dword_6FEC8;
// 6FED0: using guessed type char byte_6FED0;
// 6FEE7: using guessed type char byte_6FEE7;
// 6FEE8: using guessed type int dword_6FEE8;
// 6FEF0: using guessed type char byte_6FEF0;
// 6FEF1: using guessed type _BYTE algn_6FEF1[7];
// 6FEF8: using guessed type __int64 qword_6FEF8;
// 6FF00: using guessed type char byte_6FF00;
// 6FF07: using guessed type char byte_6FF07;
// 6FF08: using guessed type __int64 qword_6FF08;
// 6FF18: using guessed type __int64 qword_6FF18;
// 6FF20: using guessed type __int64 qword_6FF20;
// 6FF30: using guessed type __int64 qword_6FF30;

//----- (0000000000013FC4) ----------------------------------------------------
__int64 sub_13FC4()
{
  dword_6FF38 = 100;
  word_6FF40 = 17410;
  *(_QWORD *)&algn_6FF42[8] = 0LL;
  *(_QWORD *)algn_6FF42 = 0LL;
  qword_6FF50 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FF38, &off_6F000);
  dword_6FF58 = 50;
  word_6FF60 = 22018;
  *(_QWORD *)&algn_6FF62[8] = 0LL;
  *(_QWORD *)algn_6FF62 = 0LL;
  qword_6FF70 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FF58, &off_6F000);
  dword_6FF78 = 300;
  word_6FF80 = 18690;
  *(_QWORD *)&algn_6FF82[8] = 0LL;
  *(_QWORD *)algn_6FF82 = 0LL;
  qword_6FF90 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FF78, &off_6F000);
  dword_6FF98 = 500;
  word_6FFA0 = 22274;
  *(_QWORD *)&algn_6FFA2[8] = 0LL;
  *(_QWORD *)algn_6FFA2 = 0LL;
  qword_6FFB0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FF98, &off_6F000);
  dword_6FFB8 = 800;
  word_6FFC0 = 17666;
  *(_QWORD *)&algn_6FFC2[8] = 0LL;
  *(_QWORD *)algn_6FFC2 = 0LL;
  qword_6FFD0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FFB8, &off_6F000);
  dword_6FFD8 = 1000;
  word_6FFE0 = 17922;
  *(_QWORD *)&algn_6FFE2[8] = 0LL;
  *(_QWORD *)algn_6FFE2 = 0LL;
  qword_6FFF0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FFD8, &off_6F000);
  dword_6FFF8 = 2000;
  byte_70000 = 16;
  *(_QWORD *)algn_70001 = 0x54434152544E4F43LL;
  qword_70010 = 0LL;
  *(_QWORD *)&algn_70001[8] = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_6FFF8, &off_6F000);
  dword_70018 = 2001;
  byte_70020 = 24;
  unk_70029 = 1279348295;
  byte_70037 = 0;
  unk_70035 = 0;
  unk_70021 = *(_QWORD *)"FATAL_SIGNAL";
  unk_7002D = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70018, &off_6F000);
  dword_70038 = 2002;
  byte_70040 = 30;
  byte_70057 = 0;
  unk_70055 = 0;
  strcpy(algn_70041, "FATAL_EXCEPTION");
  unk_70051 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70038, &off_6F000);
  unk_70060 = 0LL;
  qword_70068 = 0LL;
  qword_70058 = 16LL;
  *(__int64 *)((char *)&qword_70058 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_70058, &off_6F000);
  unk_70078 = 0x3366252000LL;
  qword_70080 = 0LL;
  qword_70070 = 24LL;
  *(__int64 *)((char *)&qword_70070 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_70070, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;
// 6FF38: using guessed type int dword_6FF38;
// 6FF40: using guessed type __int16 word_6FF40;
// 6FF42: using guessed type _BYTE algn_6FF42[14];
// 6FF50: using guessed type __int64 qword_6FF50;
// 6FF58: using guessed type int dword_6FF58;
// 6FF60: using guessed type __int16 word_6FF60;
// 6FF62: using guessed type _BYTE algn_6FF62[14];
// 6FF70: using guessed type __int64 qword_6FF70;
// 6FF78: using guessed type int dword_6FF78;
// 6FF80: using guessed type __int16 word_6FF80;
// 6FF82: using guessed type _BYTE algn_6FF82[14];
// 6FF90: using guessed type __int64 qword_6FF90;
// 6FF98: using guessed type int dword_6FF98;
// 6FFA0: using guessed type __int16 word_6FFA0;
// 6FFA2: using guessed type _BYTE algn_6FFA2[14];
// 6FFB0: using guessed type __int64 qword_6FFB0;
// 6FFB8: using guessed type int dword_6FFB8;
// 6FFC0: using guessed type __int16 word_6FFC0;
// 6FFC2: using guessed type _BYTE algn_6FFC2[14];
// 6FFD0: using guessed type __int64 qword_6FFD0;
// 6FFD8: using guessed type int dword_6FFD8;
// 6FFE0: using guessed type __int16 word_6FFE0;
// 6FFE2: using guessed type _BYTE algn_6FFE2[14];
// 6FFF0: using guessed type __int64 qword_6FFF0;
// 6FFF8: using guessed type int dword_6FFF8;
// 70000: using guessed type char byte_70000;
// 70001: using guessed type _BYTE algn_70001[15];
// 70010: using guessed type __int64 qword_70010;
// 70018: using guessed type int dword_70018;
// 70020: using guessed type char byte_70020;
// 70037: using guessed type char byte_70037;
// 70038: using guessed type int dword_70038;
// 70040: using guessed type char byte_70040;
// 70041: using guessed type _BYTE algn_70041[7];
// 70048: using guessed type __int64 qword_70048;
// 70050: using guessed type char byte_70050;
// 70057: using guessed type char byte_70057;
// 70058: using guessed type __int64 qword_70058;
// 70068: using guessed type __int64 qword_70068;
// 70070: using guessed type __int64 qword_70070;
// 70080: using guessed type __int64 qword_70080;

//----- (0000000000014268) ----------------------------------------------------
__int64 sub_14268()
{
  dword_70088 = 100;
  word_70090 = 17410;
  *(_QWORD *)&algn_70092[8] = 0LL;
  *(_QWORD *)algn_70092 = 0LL;
  qword_700A0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70088, &off_6F000);
  dword_700A8 = 50;
  word_700B0 = 22018;
  *(_QWORD *)&algn_700B2[8] = 0LL;
  *(_QWORD *)algn_700B2 = 0LL;
  qword_700C0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_700A8, &off_6F000);
  dword_700C8 = 300;
  word_700D0 = 18690;
  *(_QWORD *)&algn_700D2[8] = 0LL;
  *(_QWORD *)algn_700D2 = 0LL;
  qword_700E0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_700C8, &off_6F000);
  dword_700E8 = 500;
  word_700F0 = 22274;
  *(_QWORD *)&algn_700F2[8] = 0LL;
  *(_QWORD *)algn_700F2 = 0LL;
  qword_70100 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_700E8, &off_6F000);
  dword_70108 = 800;
  word_70110 = 17666;
  *(_QWORD *)&algn_70112[8] = 0LL;
  *(_QWORD *)algn_70112 = 0LL;
  qword_70120 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70108, &off_6F000);
  dword_70128 = 1000;
  word_70130 = 17922;
  *(_QWORD *)&algn_70132[8] = 0LL;
  *(_QWORD *)algn_70132 = 0LL;
  qword_70140 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70128, &off_6F000);
  dword_70148 = 2000;
  byte_70150 = 16;
  *(_QWORD *)algn_70151 = 0x54434152544E4F43LL;
  qword_70160 = 0LL;
  *(_QWORD *)&algn_70151[8] = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70148, &off_6F000);
  dword_70168 = 2001;
  byte_70170 = 24;
  unk_70179 = 1279348295;
  byte_70187 = 0;
  unk_70185 = 0;
  unk_70171 = *(_QWORD *)"FATAL_SIGNAL";
  unk_7017D = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70168, &off_6F000);
  dword_70188 = 2002;
  byte_70190 = 30;
  byte_701A7 = 0;
  unk_701A5 = 0;
  strcpy(algn_70191, "FATAL_EXCEPTION");
  unk_701A1 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70188, &off_6F000);
  unk_701B0 = 0LL;
  qword_701B8 = 0LL;
  qword_701A8 = 16LL;
  *(__int64 *)((char *)&qword_701A8 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_701A8, &off_6F000);
  unk_701C8 = 0x3366252000LL;
  qword_701D0 = 0LL;
  qword_701C0 = 24LL;
  *(__int64 *)((char *)&qword_701C0 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_701C0, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;
// 70088: using guessed type int dword_70088;
// 70090: using guessed type __int16 word_70090;
// 70092: using guessed type _BYTE algn_70092[14];
// 700A0: using guessed type __int64 qword_700A0;
// 700A8: using guessed type int dword_700A8;
// 700B0: using guessed type __int16 word_700B0;
// 700B2: using guessed type _BYTE algn_700B2[14];
// 700C0: using guessed type __int64 qword_700C0;
// 700C8: using guessed type int dword_700C8;
// 700D0: using guessed type __int16 word_700D0;
// 700D2: using guessed type _BYTE algn_700D2[14];
// 700E0: using guessed type __int64 qword_700E0;
// 700E8: using guessed type int dword_700E8;
// 700F0: using guessed type __int16 word_700F0;
// 700F2: using guessed type _BYTE algn_700F2[14];
// 70100: using guessed type __int64 qword_70100;
// 70108: using guessed type int dword_70108;
// 70110: using guessed type __int16 word_70110;
// 70112: using guessed type _BYTE algn_70112[14];
// 70120: using guessed type __int64 qword_70120;
// 70128: using guessed type int dword_70128;
// 70130: using guessed type __int16 word_70130;
// 70132: using guessed type _BYTE algn_70132[14];
// 70140: using guessed type __int64 qword_70140;
// 70148: using guessed type int dword_70148;
// 70150: using guessed type char byte_70150;
// 70151: using guessed type _BYTE algn_70151[15];
// 70160: using guessed type __int64 qword_70160;
// 70168: using guessed type int dword_70168;
// 70170: using guessed type char byte_70170;
// 70187: using guessed type char byte_70187;
// 70188: using guessed type int dword_70188;
// 70190: using guessed type char byte_70190;
// 70191: using guessed type _BYTE algn_70191[7];
// 70198: using guessed type __int64 qword_70198;
// 701A0: using guessed type char byte_701A0;
// 701A7: using guessed type char byte_701A7;
// 701A8: using guessed type __int64 qword_701A8;
// 701B8: using guessed type __int64 qword_701B8;
// 701C0: using guessed type __int64 qword_701C0;
// 701D0: using guessed type __int64 qword_701D0;

//----- (000000000001450C) ----------------------------------------------------
__int64 sub_1450C()
{
  dword_701D8 = 100;
  word_701E0 = 17410;
  *(_QWORD *)&algn_701E2[8] = 0LL;
  *(_QWORD *)algn_701E2 = 0LL;
  qword_701F0 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_701D8, &off_6F000);
  dword_701F8 = 50;
  word_70200 = 22018;
  *(_QWORD *)&algn_70202[8] = 0LL;
  *(_QWORD *)algn_70202 = 0LL;
  qword_70210 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_701F8, &off_6F000);
  dword_70218 = 300;
  word_70220 = 18690;
  *(_QWORD *)&algn_70222[8] = 0LL;
  *(_QWORD *)algn_70222 = 0LL;
  qword_70230 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70218, &off_6F000);
  dword_70238 = 500;
  word_70240 = 22274;
  *(_QWORD *)&algn_70242[8] = 0LL;
  *(_QWORD *)algn_70242 = 0LL;
  qword_70250 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70238, &off_6F000);
  dword_70258 = 800;
  word_70260 = 17666;
  *(_QWORD *)&algn_70262[8] = 0LL;
  *(_QWORD *)algn_70262 = 0LL;
  qword_70270 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70258, &off_6F000);
  dword_70278 = 1000;
  word_70280 = 17922;
  *(_QWORD *)&algn_70282[8] = 0LL;
  *(_QWORD *)algn_70282 = 0LL;
  qword_70290 = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70278, &off_6F000);
  dword_70298 = 2000;
  byte_702A0 = 16;
  *(_QWORD *)algn_702A1 = 0x54434152544E4F43LL;
  qword_702B0 = 0LL;
  *(_QWORD *)&algn_702A1[8] = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_70298, &off_6F000);
  dword_702B8 = 2001;
  byte_702C0 = 24;
  unk_702C9 = 1279348295;
  byte_702D7 = 0;
  unk_702D5 = 0;
  unk_702C1 = *(_QWORD *)"FATAL_SIGNAL";
  unk_702CD = 0LL;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_702B8, &off_6F000);
  dword_702D8 = 2002;
  byte_702E0 = 30;
  byte_702F7 = 0;
  unk_702F5 = 0;
  strcpy(algn_702E1, "FATAL_EXCEPTION");
  unk_702F1 = 0;
  __cxa_atexit((void (__fastcall *)(void *))LEVELS::~LEVELS, &dword_702D8, &off_6F000);
  unk_70300 = 0LL;
  qword_70308 = 0LL;
  qword_702F8 = 16LL;
  *(__int64 *)((char *)&qword_702F8 + 1) = 0x64252F6D252F5925LL;
  __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_702F8, &off_6F000);
  unk_70318 = 0x3366252000LL;
  qword_70320 = 0LL;
  qword_70310 = 24LL;
  *(__int64 *)((char *)&qword_70310 + 1) = *(_QWORD *)"%H:%M:%S %f3";
  return __cxa_atexit((void (__fastcall *)(void *))std::string::~string, &qword_70310, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;
// 701D8: using guessed type int dword_701D8;
// 701E0: using guessed type __int16 word_701E0;
// 701E2: using guessed type _BYTE algn_701E2[14];
// 701F0: using guessed type __int64 qword_701F0;
// 701F8: using guessed type int dword_701F8;
// 70200: using guessed type __int16 word_70200;
// 70202: using guessed type _BYTE algn_70202[14];
// 70210: using guessed type __int64 qword_70210;
// 70218: using guessed type int dword_70218;
// 70220: using guessed type __int16 word_70220;
// 70222: using guessed type _BYTE algn_70222[14];
// 70230: using guessed type __int64 qword_70230;
// 70238: using guessed type int dword_70238;
// 70240: using guessed type __int16 word_70240;
// 70242: using guessed type _BYTE algn_70242[14];
// 70250: using guessed type __int64 qword_70250;
// 70258: using guessed type int dword_70258;
// 70260: using guessed type __int16 word_70260;
// 70262: using guessed type _BYTE algn_70262[14];
// 70270: using guessed type __int64 qword_70270;
// 70278: using guessed type int dword_70278;
// 70280: using guessed type __int16 word_70280;
// 70282: using guessed type _BYTE algn_70282[14];
// 70290: using guessed type __int64 qword_70290;
// 70298: using guessed type int dword_70298;
// 702A0: using guessed type char byte_702A0;
// 702A1: using guessed type _BYTE algn_702A1[15];
// 702B0: using guessed type __int64 qword_702B0;
// 702B8: using guessed type int dword_702B8;
// 702C0: using guessed type char byte_702C0;
// 702D7: using guessed type char byte_702D7;
// 702D8: using guessed type int dword_702D8;
// 702E0: using guessed type char byte_702E0;
// 702E1: using guessed type _BYTE algn_702E1[7];
// 702E8: using guessed type __int64 qword_702E8;
// 702F0: using guessed type char byte_702F0;
// 702F7: using guessed type char byte_702F7;
// 702F8: using guessed type __int64 qword_702F8;
// 70308: using guessed type __int64 qword_70308;
// 70310: using guessed type __int64 qword_70310;
// 70320: using guessed type __int64 qword_70320;

//----- (00000000000147B0) ----------------------------------------------------
__int64 sub_147B0()
{
  return __cxa_finalize(&off_6F000);
}
// 6F000: using guessed type void *off_6F000;

//----- (00000000000147C4) ----------------------------------------------------
__int64 (*__fastcall sub_147C4(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (00000000000147D0) ----------------------------------------------------
__int64 __fastcall sub_147D0(void *a1)
{
  return __cxa_atexit((void (__fastcall *)(void *))sub_147C4, a1, &off_6F000);
}
// 6F000: using guessed type void *off_6F000;

//----- (00000000000147EC) ----------------------------------------------------
__int64 __fastcall sub_147EC(__int64 a1, __int64 a2, __int64 a3)
{
  return __register_atfork(a1, a2, a3, &off_6F000);
}
// 137A0: using guessed type __int64 __fastcall __register_atfork(_QWORD, _QWORD, _QWORD, _QWORD);
// 6F000: using guessed type void *off_6F000;

//----- (00000000000147F8) ----------------------------------------------------
void __fastcall std::string::~string(__int64 a1)
{
  if ( (*(_BYTE *)a1 & 1) != 0 )
    operator delete(*(void **)(a1 + 16));
}

//----- (000000000001480C) ----------------------------------------------------
void __fastcall LEVELS::~LEVELS(void **this)
{
  if ( ((_BYTE)this[1] & 1) != 0 )
    operator delete(this[3]);
}

//----- (0000000000014820) ----------------------------------------------------
void __fastcall checktool::checktool(checktool *this)
{
  feasibal_region::feasibal_region::feasibal_region(this);
  *((_DWORD *)this + 160) = 1124007936;
  *((_OWORD *)this + 43) = 0u;
  *(_OWORD *)((char *)this + 676) = 0u;
  *(_OWORD *)((char *)this + 660) = 0u;
  *(_OWORD *)((char *)this + 644) = 0u;
  *((_DWORD *)this + 184) = 1124007936;
  *((_QWORD *)this + 88) = (char *)this + 648;
  *((_QWORD *)this + 89) = (char *)this + 720;
  *((_QWORD *)this + 91) = 0LL;
  *((_QWORD *)this + 90) = 0LL;
  *(_OWORD *)((char *)this + 756) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *(_OWORD *)((char *)this + 772) = 0u;
  *(_OWORD *)((char *)this + 740) = 0u;
  *((_QWORD *)this + 100) = (char *)this + 744;
  *((_QWORD *)this + 101) = (char *)this + 816;
  *((_QWORD *)this + 102) = 0LL;
  *((_QWORD *)this + 103) = 0LL;
  *((_DWORD *)this + 212) = 0;
  *(_QWORD *)((char *)this + 852) = 0x3EB333333F266666LL;
}

//----- (00000000000148CC) ----------------------------------------------------
bool __fastcall isRotationMatrix(cv::Mat *a1)
{
  void *v2; // x1
  int v3; // w3
  void *v4; // x1
  cv *v5; // x0
  __int64 v6; // x0
  void *v7; // x1
  double v8; // d8
  unsigned int *v9; // x8
  unsigned int v10; // w9
  unsigned int v11; // w9
  _QWORD *v12; // x8
  __int64 v13; // x9
  unsigned int *v14; // x8
  unsigned int v15; // w9
  unsigned int v16; // w9
  _QWORD *v17; // x8
  __int64 v18; // x9
  unsigned int *v19; // x8
  unsigned int v20; // w9
  unsigned int v21; // w9
  _QWORD *v22; // x8
  __int64 v23; // x9
  int v25; // [xsp+10h] [xbp-2F0h] BYREF
  _QWORD *v26; // [xsp+18h] [xbp-2E8h]
  __int64 v27; // [xsp+20h] [xbp-2E0h]
  _QWORD v28[8]; // [xsp+28h] [xbp-2D8h] BYREF
  _QWORD *v29; // [xsp+68h] [xbp-298h]
  cv *v30; // [xsp+70h] [xbp-290h]
  __int64 v31[2]; // [xsp+78h] [xbp-288h] BYREF
  __int64 v32; // [xsp+88h] [xbp-278h] BYREF
  cv::Mat *v33; // [xsp+90h] [xbp-270h]
  __int64 v34; // [xsp+98h] [xbp-268h]
  _QWORD v35[8]; // [xsp+1E8h] [xbp-118h] BYREF
  _QWORD *v36; // [xsp+228h] [xbp-D8h]
  cv *v37; // [xsp+230h] [xbp-D0h]
  __int64 v38[2]; // [xsp+238h] [xbp-C8h] BYREF
  _QWORD v39[8]; // [xsp+248h] [xbp-B8h] BYREF
  _QWORD *v40; // [xsp+288h] [xbp-78h]
  cv *v41; // [xsp+290h] [xbp-70h]
  __int64 v42[3]; // [xsp+298h] [xbp-68h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  LODWORD(v39[0]) = 1124007936;
  memset((char *)v39 + 4, 0, 60);
  v40 = &v39[1];
  v41 = (cv *)v42;
  v42[0] = 0LL;
  v42[1] = 0LL;
  v33 = a1;
  v34 = 0LL;
  LODWORD(v32) = 16842752;
  v35[1] = v39;
  v35[2] = 0LL;
  LODWORD(v35[0]) = 33619968;
  cv::transpose(&v32, v35);
  cv::operator*(&v32, v39, a1);
  LODWORD(v35[0]) = 1124007936;
  memset((char *)v35 + 4, 0, 60);
  v36 = &v35[1];
  v37 = (cv *)v38;
  v38[1] = 0LL;
  v38[0] = 0LL;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v32 + 24LL))(v32, &v32, v35, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v32, v2);
  cv::Mat::eye(&v32, (cv::Mat *)((unsigned int)&dword_0 + 3), 3, v35[0] & 0xFFF, v3);
  LODWORD(v28[0]) = 1124007936;
  memset((char *)v28 + 4, 0, 60);
  v29 = &v28[1];
  v30 = (cv *)v31;
  v31[0] = 0LL;
  v31[1] = 0LL;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v32 + 24LL))(v32, &v32, v28, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v32, v4);
  v34 = 0LL;
  LODWORD(v32) = 16842752;
  v33 = (cv::Mat *)v28;
  v27 = 0LL;
  v25 = 16842752;
  v26 = v35;
  v6 = cv::noArray(v5);
  *(_QWORD *)&v8 = COERCE_UNSIGNED_INT128(cv::norm(&v32, &v25, 4LL, v6));
  if ( v28[7] )
  {
    v9 = (unsigned int *)(v28[7] + 20LL);
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while ( __stlxr(v11, v9) );
    if ( !v11 )
      cv::Mat::deallocate((cv::Mat *)v28);
  }
  v28[7] = 0LL;
  memset(&v28[2], 0, 32);
  if ( SHIDWORD(v28[0]) >= 1 )
  {
    v12 = v29;
    v13 = 0LL;
    do
      *((_DWORD *)v12 + v13++) = 0;
    while ( v13 < SHIDWORD(v28[0]) );
  }
  if ( v30 != (cv *)v31 )
    cv::fastFree(v30, v7);
  if ( v35[7] )
  {
    v14 = (unsigned int *)(v35[7] + 20LL);
    do
    {
      v15 = __ldaxr(v14);
      v16 = v15 - 1;
    }
    while ( __stlxr(v16, v14) );
    if ( !v16 )
      cv::Mat::deallocate((cv::Mat *)v35);
  }
  v35[7] = 0LL;
  memset(&v35[2], 0, 32);
  if ( SHIDWORD(v35[0]) >= 1 )
  {
    v17 = v36;
    v18 = 0LL;
    do
      *((_DWORD *)v17 + v18++) = 0;
    while ( v18 < SHIDWORD(v35[0]) );
  }
  if ( v37 != (cv *)v38 )
    cv::fastFree(v37, v7);
  if ( v39[7] )
  {
    v19 = (unsigned int *)(v39[7] + 20LL);
    do
    {
      v20 = __ldaxr(v19);
      v21 = v20 - 1;
    }
    while ( __stlxr(v21, v19) );
    if ( !v21 )
      cv::Mat::deallocate((cv::Mat *)v39);
  }
  v39[7] = 0LL;
  memset(&v39[2], 0, 32);
  if ( SHIDWORD(v39[0]) >= 1 )
  {
    v22 = v40;
    v23 = 0LL;
    do
      *((_DWORD *)v22 + v23++) = 0;
    while ( v23 < SHIDWORD(v39[0]) );
  }
  if ( v41 != (cv *)v42 )
    cv::fastFree(v41, v7);
  return v8 < 0.000001;
}
// 149B8: variable 'v2' is possibly undefined
// 149D0: variable 'v3' is possibly undefined
// 14A20: variable 'v4' is possibly undefined
// 14A44: variable 'v5' is possibly undefined
// 14ACC: variable 'v7' is possibly undefined
// 0: using guessed type int dword_0;
// 12BB0: using guessed type __int64 __fastcall cv::transpose(_QWORD, _QWORD);
// 136C0: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);
// 137B0: using guessed type long double __fastcall cv::norm(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014E90) ----------------------------------------------------
void __fastcall cv::MatExpr::~MatExpr(cv::MatExpr *this, void *a2)
{
  __int64 v2; // x8
  cv::Mat *v4; // x0
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  __int64 v12; // x8
  unsigned int *v13; // x8
  unsigned int v14; // w9
  unsigned int v15; // w9
  int v16; // w8
  __int64 v17; // x8
  __int64 v18; // x9
  cv *v19; // x0
  __int64 v20; // x8
  unsigned int *v21; // x8
  unsigned int v22; // w9
  unsigned int v23; // w9
  int v24; // w8
  __int64 v25; // x8
  __int64 v26; // x9
  cv *v27; // x0

  v2 = *((_QWORD *)this + 33);
  if ( v2 )
  {
    v4 = (cv::MatExpr *)((char *)this + 208);
    v5 = (unsigned int *)(v2 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate(v4);
  }
  v8 = *((_DWORD *)this + 53);
  *((_QWORD *)this + 33) = 0LL;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  if ( v8 >= 1 )
  {
    v9 = *((_QWORD *)this + 34);
    v10 = 0LL;
    do
      *(_DWORD *)(v9 + 4 * v10++) = 0;
    while ( v10 < *((int *)this + 53) );
  }
  v11 = (cv *)*((_QWORD *)this + 35);
  if ( v11 != (cv::MatExpr *)((char *)this + 288) )
    cv::fastFree(v11, a2);
  v12 = *((_QWORD *)this + 21);
  if ( v12 )
  {
    v13 = (unsigned int *)(v12 + 20);
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while ( __stlxr(v15, v13) );
    if ( !v15 )
      cv::Mat::deallocate((cv::MatExpr *)((char *)this + 112));
  }
  v16 = *((_DWORD *)this + 29);
  *((_QWORD *)this + 21) = 0LL;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  if ( v16 >= 1 )
  {
    v17 = *((_QWORD *)this + 22);
    v18 = 0LL;
    do
      *(_DWORD *)(v17 + 4 * v18++) = 0;
    while ( v18 < *((int *)this + 29) );
  }
  v19 = (cv *)*((_QWORD *)this + 23);
  if ( v19 != (cv::MatExpr *)((char *)this + 192) )
    cv::fastFree(v19, a2);
  v20 = *((_QWORD *)this + 9);
  if ( v20 )
  {
    v21 = (unsigned int *)(v20 + 20);
    do
    {
      v22 = __ldaxr(v21);
      v23 = v22 - 1;
    }
    while ( __stlxr(v23, v21) );
    if ( !v23 )
      cv::Mat::deallocate((cv::MatExpr *)((char *)this + 16));
  }
  v24 = *((_DWORD *)this + 5);
  *((_QWORD *)this + 9) = 0LL;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  if ( v24 >= 1 )
  {
    v25 = *((_QWORD *)this + 10);
    v26 = 0LL;
    do
      *(_DWORD *)(v25 + 4 * v26++) = 0;
    while ( v26 < *((int *)this + 5) );
  }
  v27 = (cv *)*((_QWORD *)this + 11);
  if ( v27 != (cv::MatExpr *)((char *)this + 96) )
    cv::fastFree(v27, a2);
}
// 14F0C: variable 'a2' is possibly undefined

//----- (0000000000015008) ----------------------------------------------------
void __usercall rotationMatrixToEulerAngles(cv::Mat *a1@<X0>, __int64 a2@<X8>)
{
  __int64 *v4; // x8
  double *v5; // x20
  __int64 v6; // x21
  double v7; // d10
  double *v8; // x8
  double v9; // d11
  float v10; // s0
  double v11; // d9
  double v12; // d8
  double v13; // d9
  float v14; // w8
  double *v15; // x20
  float v16; // s0
  float v17; // s0
  float v18; // s1

  if ( isRotationMatrix(a1) )
  {
    v4 = (__int64 *)*((_QWORD *)a1 + 9);
    v5 = (double *)*((_QWORD *)a1 + 2);
    v6 = *v4;
    v7 = *v5;
    v8 = (double *)((char *)v5 + *v4);
    v9 = *v8;
    v10 = sqrt(v7 * v7 + v9 * v9);
    v11 = v10;
    if ( v10 >= 0.000001 )
    {
      v15 = (double *)((char *)v5 + 2 * v6);
      v12 = atan2(v15[1], v15[2]);
      v13 = atan2(-*v15, v11);
      v16 = atan2(v9, v7);
      v14 = v16;
    }
    else
    {
      v12 = atan2(-v8[2], v8[1]);
      v13 = atan2(-*(double *)((char *)v5 + 2 * v6), v11);
      v14 = 0.0;
    }
    v17 = v13;
    v18 = v12;
    *(float *)(a2 + 8) = v14;
    *(float *)a2 = v18;
    *(float *)(a2 + 4) = v17;
    *(_BYTE *)(a2 + 12) = 1;
  }
  else
  {
    *(_QWORD *)(a2 + 5) = 0LL;
    *(_QWORD *)a2 = 0LL;
  }
}

//----- (0000000000015114) ----------------------------------------------------
__int64 __usercall eulerAnglestoRotationMtx@<X0>(__int64 a1@<X0>, __int64 a2@<X8>)
{
  double *v3; // x8
  double v4; // d9
  double v5; // d10
  double v6; // d8
  __int64 v7; // x8
  __int64 v8; // x13
  __int64 v9; // x12
  int64x2_t v10; // q1
  _QWORD *v11; // x13
  __int64 v12; // x14
  int64x2_t v13; // q0
  __int64 v14; // d2
  __int64 v15; // x10
  int *v16; // x11
  __int64 v17; // t1
  double *v18; // x21
  cv::Mat *v19; // x20
  __int64 v20; // x8
  unsigned __int64 v21; // x9
  double *v22; // x8
  double *v23; // x9
  double *v24; // x22
  double v25; // d11
  double *v26; // x21
  double v27; // d10
  double *v28; // x8
  double *v29; // x9
  double *v30; // x8
  void *v31; // x1
  cv *v32; // x0
  __int128 v33; // q0
  unsigned int *v34; // x8
  unsigned int v35; // w9
  unsigned int v36; // w9
  _BYTE *v37; // x8
  __int64 v38; // x9
  double v39; // d10
  __int64 v40; // x8
  __int64 v41; // x13
  __int64 v42; // x12
  int64x2_t v43; // q1
  _QWORD *v44; // x13
  __int64 v45; // x14
  int64x2_t v46; // q0
  __int64 v47; // d2
  __int64 v48; // x10
  int *v49; // x11
  __int64 v50; // t1
  double *v51; // x8
  cv::Mat *v52; // x20
  __int64 v53; // x9
  unsigned __int64 v54; // x10
  double *v55; // x21
  double v56; // d9
  double *v57; // x8
  double *v58; // x9
  double *v59; // x8
  double *v60; // x9
  double *v61; // x8
  double *v62; // x9
  void *v63; // x1
  cv *v64; // x0
  __int128 v65; // q0
  unsigned int *v66; // x8
  unsigned int v67; // w9
  unsigned int v68; // w9
  _BYTE *v69; // x8
  __int64 v70; // x9
  double v71; // d9
  __int64 v72; // x8
  __int64 v73; // x13
  __int64 v74; // x12
  int64x2_t v75; // q1
  _QWORD *v76; // x13
  __int64 v77; // x14
  int64x2_t v78; // q0
  __int64 v79; // d2
  __int64 v80; // x10
  int *v81; // x11
  __int64 v82; // t1
  double *v83; // x21
  cv::Mat *v84; // x20
  __int64 v85; // x22
  unsigned __int64 v86; // x23
  double v87; // d8
  double *v88; // x8
  double *v89; // x9
  double *v90; // x10
  double *v91; // x8
  double *v92; // x9
  double *v93; // x8
  double *v94; // x9
  void *v95; // x1
  cv *v96; // x0
  __int128 v97; // q0
  unsigned int *v98; // x8
  unsigned int v99; // w9
  unsigned int v100; // w9
  _BYTE *v101; // x8
  __int64 v102; // x9
  __int64 v103; // x0
  void *v104; // x1
  void *v105; // x1
  void *v106; // x1
  unsigned int *v107; // x8
  unsigned int v108; // w9
  unsigned int v109; // w9
  __int64 v110; // x8
  __int64 v111; // x9
  unsigned int *v112; // x8
  unsigned int v113; // w9
  unsigned int v114; // w9
  __int64 v115; // x8
  __int64 v116; // x9
  unsigned int *v117; // x8
  unsigned int v118; // w9
  unsigned int v119; // w9
  __int64 v120; // x8
  __int64 v121; // x9
  __int64 result; // x0
  cv::Mat *v123; // [xsp+28h] [xbp-4C8h] BYREF
  __int64 v124; // [xsp+30h] [xbp-4C0h]
  double *v125; // [xsp+38h] [xbp-4B8h]
  __int64 v126; // [xsp+40h] [xbp-4B0h]
  unsigned __int64 v127; // [xsp+48h] [xbp-4A8h]
  int v128[2]; // [xsp+50h] [xbp-4A0h] BYREF
  int *v129; // [xsp+58h] [xbp-498h] BYREF
  __int64 v130; // [xsp+60h] [xbp-490h]
  double *v131; // [xsp+68h] [xbp-488h]
  __int64 v132; // [xsp+70h] [xbp-480h]
  unsigned __int64 v133; // [xsp+78h] [xbp-478h]
  int v134; // [xsp+80h] [xbp-470h] BYREF
  _BYTE v135[60]; // [xsp+84h] [xbp-46Ch] BYREF
  _BYTE *v136; // [xsp+C0h] [xbp-430h]
  cv *v137; // [xsp+C8h] [xbp-428h]
  __int64 v138; // [xsp+D0h] [xbp-420h] BYREF
  __int64 v139; // [xsp+D8h] [xbp-418h]
  _BYTE v140[64]; // [xsp+1E0h] [xbp-310h] BYREF
  __int128 v141; // [xsp+220h] [xbp-2D0h]
  __int64 v142; // [xsp+230h] [xbp-2C0h] BYREF
  __int64 v143; // [xsp+238h] [xbp-2B8h]
  __int128 v144; // [xsp+340h] [xbp-1B0h] BYREF
  __int128 v145; // [xsp+350h] [xbp-1A0h]
  __int128 v146; // [xsp+360h] [xbp-190h]
  __int128 v147; // [xsp+370h] [xbp-180h]
  __int128 v148; // [xsp+380h] [xbp-170h]
  __int64 v149; // [xsp+390h] [xbp-160h] BYREF
  __int64 v150; // [xsp+398h] [xbp-158h]
  __int128 v151; // [xsp+3A0h] [xbp-150h] BYREF
  __int128 v152; // [xsp+3B0h] [xbp-140h]
  __int128 v153; // [xsp+3C0h] [xbp-130h]
  __int128 v154; // [xsp+3D0h] [xbp-120h]
  __int128 v155; // [xsp+3E0h] [xbp-110h]
  __int64 v156; // [xsp+3F0h] [xbp-100h] BYREF
  __int64 v157; // [xsp+3F8h] [xbp-F8h]
  __int128 v158; // [xsp+400h] [xbp-F0h] BYREF
  __int128 v159; // [xsp+410h] [xbp-E0h]
  __int128 v160; // [xsp+420h] [xbp-D0h]
  __int128 v161; // [xsp+430h] [xbp-C0h]
  __int128 v162; // [xsp+440h] [xbp-B0h]
  __int64 v163; // [xsp+450h] [xbp-A0h] BYREF
  __int64 v164; // [xsp+458h] [xbp-98h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = *(double **)(a1 + 16);
  v5 = *v3;
  v4 = v3[1];
  v6 = v3[2];
  v134 = 1124007936;
  memset(v135, 0, sizeof(v135));
  v136 = &v135[4];
  v137 = (cv *)&v138;
  v138 = 0LL;
  v139 = 0LL;
  *(_QWORD *)v128 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)&v134, 2, v128, 6);
  *(_QWORD *)&v151 = &v134;
  if ( *(int *)v135 < 1 )
    v7 = 0LL;
  else
    v7 = *((_QWORD *)v137 + *(_DWORD *)v135 - 1);
  *((_QWORD *)&v151 + 1) = v7;
  *(_QWORD *)&v153 = 0LL;
  v152 = 0uLL;
  if ( (v134 & 0x4000) != 0 )
  {
    *((_QWORD *)&v152 + 1) = *(_QWORD *)&v135[12];
    if ( *(int *)v135 >= 3 )
    {
      if ( *(_DWORD *)v135 == 3 )
      {
        v9 = 0LL;
        v8 = 1LL;
      }
      else
      {
        v9 = *(_DWORD *)v135 & 0xFFFFFFFC;
        v10 = vdupq_n_s64(1uLL);
        v11 = v136 + 8;
        v12 = v9;
        v13 = v10;
        do
        {
          v14 = *(v11 - 1);
          v10.n128_u64[0] *= (int)v14;
          v13.n128_u64[0] *= (int)*v11;
          v12 -= 4LL;
          v10.n128_u64[1] *= SHIDWORD(v14);
          v13.n128_u64[1] *= (int)HIDWORD(*v11);
          v11 += 2;
        }
        while ( v12 );
        v8 = v13.n128_u64[0] * v10.n128_u64[0] * v13.n128_u64[1] * v10.n128_u64[1];
        if ( v9 == *(unsigned int *)v135 )
          goto LABEL_14;
      }
      v15 = *(unsigned int *)v135 - v9;
      v16 = (int *)&v136[4 * v9];
      do
      {
        v17 = *v16++;
        --v15;
        v8 *= v17;
      }
      while ( v15 );
    }
    else
    {
      v8 = *(int *)&v135[8] * (__int64)*(int *)&v135[4];
    }
LABEL_14:
    *(_QWORD *)&v153 = *(_QWORD *)&v135[12] + v8 * v7;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v151, 0LL, 0);
  v18 = (double *)v152;
  *(_QWORD *)v152 = 0x3FF0000000000000LL;
  v19 = (cv::Mat *)v151;
  if ( (_QWORD)v151 )
  {
    *(_QWORD *)&v152 = (char *)v18 + *((_QWORD *)&v151 + 1);
    if ( (unsigned __int64)v18 + *((_QWORD *)&v151 + 1) >= (unsigned __int64)v153 )
    {
      *(_QWORD *)&v152 = v18;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v151, 1LL, 1);
      v19 = (cv::Mat *)v151;
      v18 = (double *)v152;
    }
    else
    {
      v18 = (double *)((char *)v18 + *((_QWORD *)&v151 + 1));
    }
  }
  v20 = *((_QWORD *)&v151 + 1);
  v21 = v153;
  *(_QWORD *)&v144 = v19;
  *((_QWORD *)&v144 + 1) = *((_QWORD *)&v151 + 1);
  *(_QWORD *)&v145 = v18;
  *((_QWORD *)&v145 + 1) = *((_QWORD *)&v152 + 1);
  *(_QWORD *)&v146 = v153;
  *v18 = 0.0;
  if ( !v19 )
  {
    *v18 = cos(v5);
    goto LABEL_51;
  }
  v22 = (double *)((char *)v18 + v20);
  *(_QWORD *)&v145 = v22;
  if ( (unsigned __int64)v22 >= v21 )
  {
    *(_QWORD *)&v145 = v18;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v22 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
  *v22 = 0.0;
  if ( !v19 )
  {
    v23 = v22;
    *v22 = 0.0;
LABEL_30:
    v24 = v23;
    goto LABEL_31;
  }
  v23 = (double *)((char *)v22 + *((_QWORD *)&v144 + 1));
  *(_QWORD *)&v145 = (char *)v22 + *((_QWORD *)&v144 + 1);
  if ( (unsigned __int64)v22 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
  {
    *(_QWORD *)&v145 = v22;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v23 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
  *v23 = 0.0;
  if ( !v19 )
    goto LABEL_30;
  v24 = (double *)((char *)v23 + *((_QWORD *)&v144 + 1));
  *(_QWORD *)&v145 = (char *)v23 + *((_QWORD *)&v144 + 1);
  if ( (unsigned __int64)v23 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
  {
    *(_QWORD *)&v145 = v23;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v24 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
LABEL_31:
  v25 = cos(v5);
  *v24 = v25;
  if ( v19 )
  {
    v26 = (double *)((char *)v24 + *((_QWORD *)&v144 + 1));
    *(_QWORD *)&v145 = (char *)v24 + *((_QWORD *)&v144 + 1);
    if ( (unsigned __int64)v24 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
    {
      *(_QWORD *)&v145 = v24;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
      v26 = (double *)v145;
      v19 = (cv::Mat *)v144;
    }
  }
  else
  {
    v26 = v24;
  }
  v27 = sin(v5);
  *v26 = -v27;
  if ( !v19 )
  {
    v28 = v26;
    *v26 = 0.0;
LABEL_47:
    v29 = v28;
    *v28 = v27;
LABEL_48:
    *v29 = v25;
    goto LABEL_51;
  }
  v28 = (double *)((char *)v26 + *((_QWORD *)&v144 + 1));
  *(_QWORD *)&v145 = (char *)v26 + *((_QWORD *)&v144 + 1);
  if ( (unsigned __int64)v26 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
  {
    *(_QWORD *)&v145 = v26;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v28 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
  *v28 = 0.0;
  if ( !v19 )
    goto LABEL_47;
  v29 = (double *)((char *)v28 + *((_QWORD *)&v144 + 1));
  *(_QWORD *)&v145 = (char *)v28 + *((_QWORD *)&v144 + 1);
  if ( (unsigned __int64)v28 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
  {
    *(_QWORD *)&v145 = v28;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v29 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
  *v29 = v27;
  if ( !v19 )
    goto LABEL_48;
  v30 = (double *)((char *)v29 + *((_QWORD *)&v144 + 1));
  *(_QWORD *)&v145 = (char *)v29 + *((_QWORD *)&v144 + 1);
  if ( (unsigned __int64)v29 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
  {
    *(_QWORD *)&v145 = v29;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
    v30 = (double *)v145;
    v19 = (cv::Mat *)v144;
  }
  *v30 = v25;
  if ( v19 )
  {
    *(_QWORD *)&v145 = (char *)v30 + *((_QWORD *)&v144 + 1);
    if ( (unsigned __int64)v30 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
    {
      *(_QWORD *)&v145 = v30;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
      v19 = (cv::Mat *)v144;
    }
  }
LABEL_51:
  memset(&v140[4], 0, 60);
  *(_QWORD *)&v141 = &v140[8];
  *((_QWORD *)&v141 + 1) = &v142;
  v143 = 0LL;
  v142 = 0LL;
  *(_DWORD *)v140 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v140, v19);
  v159 = *(_OWORD *)&v140[16];
  v160 = *(_OWORD *)&v140[32];
  v158 = *(_OWORD *)v140;
  v161 = *(_OWORD *)&v140[48];
  *(_QWORD *)&v162 = (char *)&v158 + 8;
  *((_QWORD *)&v162 + 1) = &v163;
  v163 = 0LL;
  v164 = 0LL;
  if ( *(int *)&v140[4] > 2 )
  {
    v33 = v141;
    v32 = (cv *)&v142;
    *((_QWORD *)&v141 + 1) = &v142;
    *(_QWORD *)&v141 = &v140[8];
    v162 = v33;
  }
  else
  {
    v32 = (cv *)*((_QWORD *)&v141 + 1);
    v163 = **((_QWORD **)&v141 + 1);
    v164 = *(_QWORD *)(*((_QWORD *)&v141 + 1) + 8LL);
  }
  *(_DWORD *)v140 = 1124007936;
  memset(&v140[4], 0, 60);
  if ( v32 != (cv *)&v142 )
    cv::fastFree(v32, v31);
  if ( *(_QWORD *)&v135[52] )
  {
    v34 = (unsigned int *)(*(_QWORD *)&v135[52] + 20LL);
    do
    {
      v35 = __ldaxr(v34);
      v36 = v35 - 1;
    }
    while ( __stlxr(v36, v34) );
    if ( !v36 )
      cv::Mat::deallocate((cv::Mat *)&v134);
  }
  *(_QWORD *)&v135[52] = 0LL;
  memset(&v135[12], 0, 32);
  if ( *(int *)v135 >= 1 )
  {
    v37 = v136;
    v38 = 0LL;
    do
      *(_DWORD *)&v37[4 * v38++] = 0;
    while ( v38 < *(int *)v135 );
  }
  if ( v137 != (cv *)&v138 )
    cv::fastFree(v137, v31);
  v134 = 1124007936;
  memset(v135, 0, sizeof(v135));
  v136 = &v135[4];
  v137 = (cv *)&v138;
  v138 = 0LL;
  v139 = 0LL;
  *(_QWORD *)v128 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)&v134, 2, v128, 6);
  v39 = cos(v4);
  *(_QWORD *)&v144 = &v134;
  if ( *(int *)v135 < 1 )
    v40 = 0LL;
  else
    v40 = *((_QWORD *)v137 + *(_DWORD *)v135 - 1);
  *((_QWORD *)&v144 + 1) = v40;
  *(_QWORD *)&v146 = 0LL;
  v145 = 0uLL;
  if ( (v134 & 0x4000) != 0 )
  {
    *((_QWORD *)&v145 + 1) = *(_QWORD *)&v135[12];
    if ( *(int *)v135 >= 3 )
    {
      if ( *(_DWORD *)v135 == 3 )
      {
        v42 = 0LL;
        v41 = 1LL;
      }
      else
      {
        v42 = *(_DWORD *)v135 & 0xFFFFFFFC;
        v43 = vdupq_n_s64(1uLL);
        v44 = v136 + 8;
        v45 = v42;
        v46 = v43;
        do
        {
          v47 = *(v44 - 1);
          v43.n128_u64[0] *= (int)v47;
          v46.n128_u64[0] *= (int)*v44;
          v45 -= 4LL;
          v43.n128_u64[1] *= SHIDWORD(v47);
          v46.n128_u64[1] *= (int)HIDWORD(*v44);
          v44 += 2;
        }
        while ( v45 );
        v41 = v46.n128_u64[0] * v43.n128_u64[0] * v46.n128_u64[1] * v43.n128_u64[1];
        if ( v42 == *(unsigned int *)v135 )
          goto LABEL_79;
      }
      v48 = *(unsigned int *)v135 - v42;
      v49 = (int *)&v136[4 * v42];
      do
      {
        v50 = *v49++;
        --v48;
        v41 *= v50;
      }
      while ( v48 );
    }
    else
    {
      v41 = *(int *)&v135[8] * (__int64)*(int *)&v135[4];
    }
LABEL_79:
    *(_QWORD *)&v146 = *(_QWORD *)&v135[12] + v41 * v40;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 0LL, 0);
  v51 = (double *)v145;
  *(double *)v145 = v39;
  v52 = (cv::Mat *)v144;
  if ( (_QWORD)v144 )
  {
    *(_QWORD *)&v145 = (char *)v51 + *((_QWORD *)&v144 + 1);
    if ( (unsigned __int64)v51 + *((_QWORD *)&v144 + 1) >= (unsigned __int64)v146 )
    {
      *(_QWORD *)&v145 = v51;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v144, 1LL, 1);
      v52 = (cv::Mat *)v144;
      v51 = (double *)v145;
    }
    else
    {
      v51 = (double *)((char *)v51 + *((_QWORD *)&v144 + 1));
    }
  }
  v53 = *((_QWORD *)&v144 + 1);
  v54 = v146;
  v129 = (int *)v52;
  v130 = *((_QWORD *)&v144 + 1);
  v131 = v51;
  v132 = *((_QWORD *)&v145 + 1);
  v133 = v146;
  *v51 = 0.0;
  if ( !v52 )
  {
    *v51 = v39;
    goto LABEL_116;
  }
  v55 = (double *)((char *)v51 + v53);
  v131 = (double *)((char *)v51 + v53);
  if ( (unsigned __int64)v51 + v53 >= v54 )
  {
    v131 = v51;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v55 = v131;
    v52 = (cv::Mat *)v129;
  }
  v56 = sin(v4);
  *v55 = v56;
  if ( !v52 )
  {
    v57 = v55;
    *v55 = 0.0;
LABEL_95:
    v58 = v57;
    goto LABEL_96;
  }
  v57 = (double *)((char *)v55 + v130);
  v131 = (double *)((char *)v55 + v130);
  if ( (unsigned __int64)v55 + v130 >= v133 )
  {
    v131 = v55;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v57 = v131;
    v52 = (cv::Mat *)v129;
  }
  *v57 = 0.0;
  if ( !v52 )
    goto LABEL_95;
  v58 = (double *)((char *)v57 + v130);
  v131 = (double *)((char *)v57 + v130);
  if ( (unsigned __int64)v57 + v130 >= v133 )
  {
    v131 = v57;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v58 = v131;
    v52 = (cv::Mat *)v129;
  }
LABEL_96:
  *v58 = 1.0;
  if ( !v52 )
  {
    v59 = v58;
    *v58 = 0.0;
LABEL_103:
    v60 = v59;
    goto LABEL_104;
  }
  v59 = (double *)((char *)v58 + v130);
  v131 = (double *)((char *)v58 + v130);
  if ( (unsigned __int64)v58 + v130 >= v133 )
  {
    v131 = v58;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v59 = v131;
    v52 = (cv::Mat *)v129;
  }
  *v59 = 0.0;
  if ( !v52 )
    goto LABEL_103;
  v60 = (double *)((char *)v59 + v130);
  v131 = (double *)((char *)v59 + v130);
  if ( (unsigned __int64)v59 + v130 >= v133 )
  {
    v131 = v59;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v60 = v131;
    v52 = (cv::Mat *)v129;
  }
LABEL_104:
  *v60 = -v56;
  if ( !v52 )
  {
    v61 = v60;
    *v60 = 0.0;
LABEL_113:
    *v61 = v39;
    goto LABEL_116;
  }
  v61 = (double *)((char *)v60 + v130);
  v131 = (double *)((char *)v60 + v130);
  if ( (unsigned __int64)v60 + v130 >= v133 )
  {
    v131 = v60;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v61 = v131;
    v52 = (cv::Mat *)v129;
  }
  *v61 = 0.0;
  if ( !v52 )
    goto LABEL_113;
  v62 = (double *)((char *)v61 + v130);
  v131 = (double *)((char *)v61 + v130);
  if ( (unsigned __int64)v61 + v130 >= v133 )
  {
    v131 = v61;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
    v62 = v131;
    v52 = (cv::Mat *)v129;
  }
  *v62 = v39;
  if ( v52 )
  {
    v131 = (double *)((char *)v62 + v130);
    if ( (unsigned __int64)v62 + v130 >= v133 )
    {
      v131 = v62;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
      v52 = (cv::Mat *)v129;
    }
  }
LABEL_116:
  memset(&v140[4], 0, 60);
  *(_QWORD *)&v141 = &v140[8];
  *((_QWORD *)&v141 + 1) = &v142;
  v143 = 0LL;
  v142 = 0LL;
  *(_DWORD *)v140 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v140, v52);
  v152 = *(_OWORD *)&v140[16];
  v153 = *(_OWORD *)&v140[32];
  v151 = *(_OWORD *)v140;
  v154 = *(_OWORD *)&v140[48];
  *(_QWORD *)&v155 = (char *)&v151 + 8;
  *((_QWORD *)&v155 + 1) = &v156;
  v157 = 0LL;
  v156 = 0LL;
  if ( *(int *)&v140[4] > 2 )
  {
    v65 = v141;
    v64 = (cv *)&v142;
    *((_QWORD *)&v141 + 1) = &v142;
    *(_QWORD *)&v141 = &v140[8];
    v155 = v65;
  }
  else
  {
    v64 = (cv *)*((_QWORD *)&v141 + 1);
    v156 = **((_QWORD **)&v141 + 1);
    v157 = *(_QWORD *)(*((_QWORD *)&v141 + 1) + 8LL);
  }
  *(_DWORD *)v140 = 1124007936;
  memset(&v140[4], 0, 60);
  if ( v64 != (cv *)&v142 )
    cv::fastFree(v64, v63);
  if ( *(_QWORD *)&v135[52] )
  {
    v66 = (unsigned int *)(*(_QWORD *)&v135[52] + 20LL);
    do
    {
      v67 = __ldaxr(v66);
      v68 = v67 - 1;
    }
    while ( __stlxr(v68, v66) );
    if ( !v68 )
      cv::Mat::deallocate((cv::Mat *)&v134);
  }
  *(_QWORD *)&v135[52] = 0LL;
  memset(&v135[12], 0, 32);
  if ( *(int *)v135 >= 1 )
  {
    v69 = v136;
    v70 = 0LL;
    do
      *(_DWORD *)&v69[4 * v70++] = 0;
    while ( v70 < *(int *)v135 );
  }
  if ( v137 != (cv *)&v138 )
    cv::fastFree(v137, v63);
  v134 = 1124007936;
  memset(v135, 0, sizeof(v135));
  v136 = &v135[4];
  v137 = (cv *)&v138;
  v138 = 0LL;
  v139 = 0LL;
  *(_QWORD *)v128 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)&v134, 2, v128, 6);
  v71 = cos(v6);
  v129 = &v134;
  if ( *(int *)v135 < 1 )
    v72 = 0LL;
  else
    v72 = *((_QWORD *)v137 + *(_DWORD *)v135 - 1);
  v130 = v72;
  v131 = 0LL;
  v132 = 0LL;
  v133 = 0LL;
  if ( (v134 & 0x4000) != 0 )
  {
    v132 = *(_QWORD *)&v135[12];
    if ( *(int *)v135 >= 3 )
    {
      if ( *(_DWORD *)v135 == 3 )
      {
        v74 = 0LL;
        v73 = 1LL;
      }
      else
      {
        v74 = *(_DWORD *)v135 & 0xFFFFFFFC;
        v75 = vdupq_n_s64(1uLL);
        v76 = v136 + 8;
        v77 = v74;
        v78 = v75;
        do
        {
          v79 = *(v76 - 1);
          v75.n128_u64[0] *= (int)v79;
          v78.n128_u64[0] *= (int)*v76;
          v77 -= 4LL;
          v75.n128_u64[1] *= SHIDWORD(v79);
          v78.n128_u64[1] *= (int)HIDWORD(*v76);
          v76 += 2;
        }
        while ( v77 );
        v73 = v78.n128_u64[0] * v75.n128_u64[0] * v78.n128_u64[1] * v75.n128_u64[1];
        if ( v74 == *(unsigned int *)v135 )
          goto LABEL_144;
      }
      v80 = *(unsigned int *)v135 - v74;
      v81 = (int *)&v136[4 * v74];
      do
      {
        v82 = *v81++;
        --v80;
        v73 *= v82;
      }
      while ( v80 );
    }
    else
    {
      v73 = *(int *)&v135[8] * (__int64)*(int *)&v135[4];
    }
LABEL_144:
    v133 = *(_QWORD *)&v135[12] + v73 * v72;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 0LL, 0);
  v83 = v131;
  *v131 = v71;
  v84 = (cv::Mat *)v129;
  if ( v129 )
  {
    v131 = (double *)((char *)v83 + v130);
    if ( (unsigned __int64)v83 + v130 >= v133 )
    {
      v131 = v83;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v129, 1LL, 1);
      v84 = (cv::Mat *)v129;
      v83 = v131;
    }
    else
    {
      v83 = (double *)((char *)v83 + v130);
    }
  }
  v85 = v130;
  v86 = v133;
  v123 = v84;
  v124 = v130;
  v125 = v83;
  v126 = v132;
  v127 = v133;
  v87 = sin(v6);
  *v83 = -v87;
  if ( !v84 )
  {
    *v83 = 1.0;
    goto LABEL_180;
  }
  v88 = (double *)((char *)v83 + v85);
  v125 = (double *)((char *)v83 + v85);
  if ( (unsigned __int64)v83 + v85 >= v86 )
  {
    v125 = v83;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v88 = v125;
    v84 = v123;
  }
  *v88 = 0.0;
  if ( !v84 )
  {
    v89 = v88;
    *v88 = v87;
LABEL_172:
    v90 = v89;
    *v89 = v71;
LABEL_173:
    v91 = v90;
    *v90 = 0.0;
LABEL_174:
    v92 = v91;
    *v91 = 0.0;
LABEL_175:
    v93 = v92;
    *v92 = 0.0;
    goto LABEL_176;
  }
  v89 = (double *)((char *)v88 + v124);
  v125 = (double *)((char *)v88 + v124);
  if ( (unsigned __int64)v88 + v124 >= v127 )
  {
    v125 = v88;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v89 = v125;
    v84 = v123;
  }
  *v89 = v87;
  if ( !v84 )
    goto LABEL_172;
  v90 = (double *)((char *)v89 + v124);
  v125 = (double *)((char *)v89 + v124);
  if ( (unsigned __int64)v89 + v124 >= v127 )
  {
    v125 = v89;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v90 = v125;
    v84 = v123;
  }
  *v90 = v71;
  if ( !v84 )
    goto LABEL_173;
  v91 = (double *)((char *)v90 + v124);
  v125 = (double *)((char *)v90 + v124);
  if ( (unsigned __int64)v90 + v124 >= v127 )
  {
    v125 = v90;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v91 = v125;
    v84 = v123;
  }
  *v91 = 0.0;
  if ( !v84 )
    goto LABEL_174;
  v92 = (double *)((char *)v91 + v124);
  v125 = (double *)((char *)v91 + v124);
  if ( (unsigned __int64)v91 + v124 >= v127 )
  {
    v125 = v91;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v92 = v125;
    v84 = v123;
  }
  *v92 = 0.0;
  if ( !v84 )
    goto LABEL_175;
  v93 = (double *)((char *)v92 + v124);
  v125 = (double *)((char *)v92 + v124);
  if ( (unsigned __int64)v92 + v124 >= v127 )
  {
    v125 = v92;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
    v93 = v125;
    v84 = v123;
  }
  *v93 = 0.0;
  if ( v84 )
  {
    v94 = (double *)((char *)v93 + v124);
    v125 = (double *)((char *)v93 + v124);
    if ( (unsigned __int64)v93 + v124 >= v127 )
    {
      v125 = v93;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
      v94 = v125;
      v84 = v123;
    }
    goto LABEL_177;
  }
LABEL_176:
  v94 = v93;
LABEL_177:
  *v94 = 1.0;
  if ( v84 )
  {
    v125 = (double *)((char *)v94 + v124);
    if ( (unsigned __int64)v94 + v124 >= v127 )
    {
      v125 = v94;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v123, 1LL, 1);
      v84 = v123;
    }
  }
LABEL_180:
  memset(&v140[4], 0, 60);
  *(_QWORD *)&v141 = &v140[8];
  *((_QWORD *)&v141 + 1) = &v142;
  v143 = 0LL;
  v142 = 0LL;
  *(_DWORD *)v140 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v140, v84);
  v145 = *(_OWORD *)&v140[16];
  v146 = *(_OWORD *)&v140[32];
  v144 = *(_OWORD *)v140;
  v147 = *(_OWORD *)&v140[48];
  *(_QWORD *)&v148 = (char *)&v144 + 8;
  *((_QWORD *)&v148 + 1) = &v149;
  v150 = 0LL;
  v149 = 0LL;
  if ( *(int *)&v140[4] > 2 )
  {
    v97 = v141;
    v96 = (cv *)&v142;
    *((_QWORD *)&v141 + 1) = &v142;
    *(_QWORD *)&v141 = &v140[8];
    v148 = v97;
  }
  else
  {
    v96 = (cv *)*((_QWORD *)&v141 + 1);
    v149 = **((_QWORD **)&v141 + 1);
    v150 = *(_QWORD *)(*((_QWORD *)&v141 + 1) + 8LL);
  }
  *(_DWORD *)v140 = 1124007936;
  memset(&v140[4], 0, 60);
  if ( v96 != (cv *)&v142 )
    cv::fastFree(v96, v95);
  if ( *(_QWORD *)&v135[52] )
  {
    v98 = (unsigned int *)(*(_QWORD *)&v135[52] + 20LL);
    do
    {
      v99 = __ldaxr(v98);
      v100 = v99 - 1;
    }
    while ( __stlxr(v100, v98) );
    if ( !v100 )
      cv::Mat::deallocate((cv::Mat *)&v134);
  }
  *(_QWORD *)&v135[52] = 0LL;
  memset(&v135[12], 0, 32);
  if ( *(int *)v135 >= 1 )
  {
    v101 = v136;
    v102 = 0LL;
    do
      *(_DWORD *)&v101[4 * v102++] = 0;
    while ( v102 < *(int *)v135 );
  }
  if ( v137 != (cv *)&v138 )
    cv::fastFree(v137, v95);
  cv::operator*(&v134, &v144, &v151);
  cv::operator*(v140, &v134, &v158);
  v103 = *(_QWORD *)v140;
  *(_DWORD *)a2 = 1124007936;
  *(_OWORD *)(a2 + 4) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 36) = 0u;
  *(_OWORD *)(a2 + 20) = 0u;
  *(_QWORD *)(a2 + 80) = 0LL;
  *(_QWORD *)(a2 + 64) = a2 + 8;
  *(_QWORD *)(a2 + 72) = a2 + 80;
  *(_QWORD *)(a2 + 88) = 0LL;
  (*(void (__fastcall **)(__int64, _BYTE *, __int64, __int64))(*(_QWORD *)v103 + 24LL))(v103, v140, a2, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v140, v104);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v134, v105);
  if ( *((_QWORD *)&v147 + 1) )
  {
    v107 = (unsigned int *)(*((_QWORD *)&v147 + 1) + 20LL);
    do
    {
      v108 = __ldaxr(v107);
      v109 = v108 - 1;
    }
    while ( __stlxr(v109, v107) );
    if ( !v109 )
      cv::Mat::deallocate((cv::Mat *)&v144);
  }
  *((_QWORD *)&v147 + 1) = 0LL;
  v145 = 0u;
  v146 = 0u;
  if ( SDWORD1(v144) >= 1 )
  {
    v110 = v148;
    v111 = 0LL;
    do
      *(_DWORD *)(v110 + 4 * v111++) = 0;
    while ( v111 < SDWORD1(v144) );
  }
  if ( *((__int64 **)&v148 + 1) != &v149 )
    cv::fastFree(*((cv **)&v148 + 1), v106);
  if ( *((_QWORD *)&v154 + 1) )
  {
    v112 = (unsigned int *)(*((_QWORD *)&v154 + 1) + 20LL);
    do
    {
      v113 = __ldaxr(v112);
      v114 = v113 - 1;
    }
    while ( __stlxr(v114, v112) );
    if ( !v114 )
      cv::Mat::deallocate((cv::Mat *)&v151);
  }
  *((_QWORD *)&v154 + 1) = 0LL;
  v152 = 0u;
  v153 = 0u;
  if ( SDWORD1(v151) >= 1 )
  {
    v115 = v155;
    v116 = 0LL;
    do
      *(_DWORD *)(v115 + 4 * v116++) = 0;
    while ( v116 < SDWORD1(v151) );
  }
  if ( *((__int64 **)&v155 + 1) != &v156 )
    cv::fastFree(*((cv **)&v155 + 1), v106);
  if ( *((_QWORD *)&v161 + 1) )
  {
    v117 = (unsigned int *)(*((_QWORD *)&v161 + 1) + 20LL);
    do
    {
      v118 = __ldaxr(v117);
      v119 = v118 - 1;
    }
    while ( __stlxr(v119, v117) );
    if ( !v119 )
      cv::Mat::deallocate((cv::Mat *)&v158);
  }
  *((_QWORD *)&v161 + 1) = 0LL;
  v159 = 0u;
  v160 = 0u;
  if ( SDWORD1(v158) >= 1 )
  {
    v120 = v162;
    v121 = 0LL;
    do
      *(_DWORD *)(v120 + 4 * v121++) = 0;
    while ( v121 < SDWORD1(v158) );
  }
  result = *((_QWORD *)&v162 + 1);
  if ( *((__int64 **)&v162 + 1) != &v163 )
    return cv::fastFree(*((cv **)&v162 + 1), v106);
  return result;
}
// 15550: conditional instruction was optimized away because x20.8==0
// 1555C: conditional instruction was optimized away because x20.8==0
// 15AD0: conditional instruction was optimized away because x20.8==0
// 16008: conditional instruction was optimized away because x20.8==0
// 16014: conditional instruction was optimized away because x20.8==0
// 16020: conditional instruction was optimized away because x20.8==0
// 1602C: conditional instruction was optimized away because x20.8==0
// 1566C: variable 'v31' is possibly undefined
// 15BE4: variable 'v63' is possibly undefined
// 1614C: variable 'v95' is possibly undefined
// 16230: variable 'v104' is possibly undefined
// 16238: variable 'v105' is possibly undefined
// 162A4: variable 'v106' is possibly undefined
// 12C90: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);
// 136C0: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);

//----- (00000000000168E0) ----------------------------------------------------
__int64 __fastcall checktool::init(__int64 a1, __int64 a2, int a3, int a4)
{
  int v7; // w24
  int v8; // w25
  int v9; // w26
  double v10; // d8
  _BOOL4 v11; // w11
  _BOOL4 v12; // w12
  __int128 v13; // q0
  __int128 v14; // q1
  __int64 v15; // x8
  unsigned int *v16; // x8
  unsigned int v17; // w9
  _QWORD *v18; // x8
  cv *v19; // x10
  void *v20; // x1
  unsigned int *v21; // x8
  unsigned int v22; // w9
  unsigned int v23; // w9
  __int64 v24; // x8
  __int64 v25; // x9
  _DWORD *v26; // x22
  __int64 v27; // x8
  unsigned int *v28; // x8
  unsigned int v29; // w9
  __int64 v30; // x8
  unsigned int *v31; // x8
  unsigned int v32; // w9
  unsigned int v33; // w9
  int v34; // w8
  __int64 v35; // x8
  __int64 v36; // x9
  __int64 v37; // x10
  int v38; // w8
  _QWORD *v39; // x10
  _QWORD *v40; // x8
  int v42[4]; // [xsp+0h] [xbp-D0h] BYREF
  __int128 v43; // [xsp+10h] [xbp-C0h] BYREF
  __int128 v44; // [xsp+20h] [xbp-B0h]
  __int128 v45; // [xsp+30h] [xbp-A0h]
  __int64 v46; // [xsp+40h] [xbp-90h]
  __int64 v47; // [xsp+48h] [xbp-88h]
  __int64 v48; // [xsp+50h] [xbp-80h]
  cv *v49; // [xsp+58h] [xbp-78h]
  __int64 v50[4]; // [xsp+60h] [xbp-70h] BYREF

  v7 = -1083771680;
  v8 = -1092825974;
  v9 = -1138166870;
  v50[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_DWORD *)(a1 + 852) = 1065269330;
  if ( a3 != 3 || a4 )
  {
    if ( a3 != 4 || a4 )
    {
      if ( a3 == 6 && a4 == 1 )
      {
        v10 = 930.0;
        v7 = -1084941421;
        v8 = -1089611980;
        *(_QWORD *)(a1 + 852) = 0x402000003F266666LL;
        v9 = 1002839430;
      }
      else if ( a3 == 6 && a4 == 2 )
      {
        v10 = 930.0;
        v7 = -1084524272;
        v8 = -1090288353;
        v9 = 1023801555;
      }
      else
      {
        v11 = a3 == 6;
        v12 = a4 == 3;
        if ( v11 && v12 )
          v9 = 0x80000000;
        else
          v9 = 0;
        if ( v11 && v12 )
          v8 = -1088794493;
        else
          v8 = 0;
        if ( v11 && v12 )
          v7 = -1085521124;
        else
          v7 = 1065353216;
        if ( v11 && v12 )
          v10 = 930.0;
        else
          v10 = 1000.0;
      }
    }
    else
    {
      v10 = 1077.0;
    }
  }
  else
  {
    v10 = 1055.0;
  }
  v13 = *(_OWORD *)a2;
  v14 = *(_OWORD *)(a2 + 16);
  v43 = *(_OWORD *)a2;
  v44 = v14;
  v45 = *(_OWORD *)(a2 + 32);
  v46 = *(_QWORD *)(a2 + 48);
  v15 = *(_QWORD *)(a2 + 56);
  v49 = (cv *)v50;
  v50[0] = 0LL;
  v50[1] = 0LL;
  v47 = v15;
  v48 = (__int64)&v43 + 8;
  if ( v15 )
  {
    v16 = (unsigned int *)(v15 + 20);
    do
      v17 = __ldaxr(v16);
    while ( __stlxr(v17 + 1, v16) );
    if ( *(int *)(a2 + 4) <= 2 )
      goto LABEL_29;
LABEL_31:
    DWORD1(v43) = 0;
    cv::Mat::copySize((cv::Mat *)&v43, (const cv::Mat *)a2);
    goto LABEL_32;
  }
  if ( SDWORD1(v13) > 2 )
    goto LABEL_31;
LABEL_29:
  v18 = *(_QWORD **)(a2 + 72);
  v19 = v49;
  *(_QWORD *)v49 = *v18;
  *((_QWORD *)v19 + 1) = v18[1];
LABEL_32:
  v42[0] = v9;
  v42[1] = v8;
  v42[2] = v7;
  feasibal_region::feasibal_region::init(a1, &v43, (__int64)v42, a4, v10);
  if ( v47 )
  {
    v21 = (unsigned int *)(v47 + 20);
    do
    {
      v22 = __ldaxr(v21);
      v23 = v22 - 1;
    }
    while ( __stlxr(v23, v21) );
    if ( !v23 )
      cv::Mat::deallocate((cv::Mat *)&v43);
  }
  v47 = 0LL;
  v44 = 0u;
  v45 = 0u;
  if ( SDWORD1(v43) >= 1 )
  {
    v24 = v48;
    v25 = 0LL;
    do
      *(_DWORD *)(v24 + 4 * v25++) = 0;
    while ( v25 < SDWORD1(v43) );
  }
  if ( v49 != (cv *)v50 )
    cv::fastFree(v49, v20);
  v26 = (_DWORD *)(a1 + 640);
  if ( a1 + 640 != a2 )
  {
    v27 = *(_QWORD *)(a2 + 56);
    if ( v27 )
    {
      v28 = (unsigned int *)(v27 + 20);
      do
        v29 = __ldaxr(v28);
      while ( __stlxr(v29 + 1, v28) );
    }
    v30 = *(_QWORD *)(a1 + 696);
    if ( v30 )
    {
      v31 = (unsigned int *)(v30 + 20);
      do
      {
        v32 = __ldaxr(v31);
        v33 = v32 - 1;
      }
      while ( __stlxr(v33, v31) );
      if ( !v33 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 640));
    }
    v34 = *(_DWORD *)(a1 + 644);
    *(_QWORD *)(a1 + 696) = 0LL;
    *(_OWORD *)(a1 + 656) = 0u;
    *(_OWORD *)(a1 + 672) = 0u;
    if ( v34 <= 0 )
    {
      *v26 = *(_DWORD *)a2;
    }
    else
    {
      v35 = *(_QWORD *)(a1 + 704);
      v36 = 0LL;
      do
      {
        *(_DWORD *)(v35 + 4 * v36) = 0;
        v37 = *(int *)(a1 + 644);
        ++v36;
      }
      while ( v36 < v37 );
      *v26 = *(_DWORD *)a2;
      if ( (int)v37 > 2 )
        goto LABEL_59;
    }
    v38 = *(_DWORD *)(a2 + 4);
    if ( v38 <= 2 )
    {
      *(_DWORD *)(a1 + 644) = v38;
      v39 = *(_QWORD **)(a1 + 712);
      *(_QWORD *)(a1 + 648) = *(_QWORD *)(a2 + 8);
      v40 = *(_QWORD **)(a2 + 72);
      *v39 = *v40;
      v39[1] = v40[1];
LABEL_60:
      *(_OWORD *)(a1 + 656) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a1 + 672) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 688) = *(_OWORD *)(a2 + 48);
      goto LABEL_61;
    }
LABEL_59:
    cv::Mat::copySize((cv::Mat *)(a1 + 640), (const cv::Mat *)a2);
    goto LABEL_60;
  }
LABEL_61:
  *(double *)(a1 + 840) = v10;
  *(_DWORD *)(a1 + 848) = a4;
  return 0LL;
}
// 16B4C: variable 'v20' is possibly undefined

//----- (0000000000016D0C) ----------------------------------------------------
void __usercall checktool::runcheck(
        feasibal_region::feasibal_region *a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        _BYTE *a4@<X3>,
        __int64 a5@<X8>)
{
  long double v5; // q8
  __int64 v9; // x9
  bool v10; // zf
  __int64 v11; // x8
  int v12; // w16
  __int64 v13; // x0
  int v14; // w9
  int v15; // w9
  __int64 v16; // x20
  int v17; // w25
  int v18; // w13
  int v19; // w9
  int v20; // w26
  int v21; // w27
  int v22; // w19
  int v23; // w21
  void *v24; // x1
  __int64 v25; // x21
  unsigned __int64 v26; // x27
  int *v27; // x24
  __int64 v28; // x8
  unsigned int *v29; // x8
  unsigned int v30; // w9
  unsigned int *v31; // x8
  unsigned int v32; // w9
  unsigned int v33; // w9
  __int64 v34; // x8
  __int64 i; // x9
  __int64 v36; // x8
  _QWORD *v37; // x10
  _QWORD *v38; // x8
  _OWORD *v39; // x8
  void *v40; // x1
  unsigned int *v41; // x8
  unsigned int v42; // w9
  unsigned int v43; // w9
  __int64 v44; // x8
  __int64 v45; // x9
  cv *v46; // x0
  __int128 v47; // q0
  _DWORD *v48; // x8
  __int64 v49; // x0
  __int64 v50; // x8
  unsigned int *v51; // x8
  unsigned int v52; // w9
  __int64 v53; // x8
  __int64 *v54; // x10
  int v55; // w24
  unsigned int *v56; // x8
  unsigned int v57; // w9
  unsigned int *v58; // x8
  unsigned int v59; // w9
  unsigned int v60; // w9
  _BYTE *v61; // x8
  __int64 v62; // x9
  __int64 v63; // x10
  cv *v64; // x9
  unsigned __int64 j; // x26
  float32x2_t *v66; // x8
  __int64 v67; // x10
  __int64 v68; // x9
  double *v69; // x11
  double *v70; // x9
  __int64 v71; // x9
  const cv::Mat *v72; // x1
  __int64 v73; // x0
  __int64 v74; // x8
  unsigned int *v75; // x8
  unsigned int v76; // w9
  cv *v77; // x8
  _QWORD *v78; // x10
  _QWORD *v79; // x8
  __int64 v80; // x0
  char *v81; // x8
  char *v82; // x10
  int *v83; // x9
  __int64 v84; // x10
  unsigned int *v85; // x10
  unsigned int v86; // w11
  _QWORD *v87; // x8
  _QWORD *v88; // x10
  __int64 v89; // x8
  unsigned int *v90; // x8
  unsigned int v91; // w9
  unsigned int v92; // w9
  _BYTE *v93; // x8
  __int64 v94; // x9
  unsigned int *v95; // x8
  unsigned int v96; // w9
  unsigned int v97; // w9
  cv *v98; // x8
  __int64 v99; // x9
  void *v100; // x1
  unsigned int *v101; // x8
  unsigned int v102; // w9
  unsigned int v103; // w9
  cv *v104; // x8
  __int64 v105; // x9
  int v106; // w8
  __int128 v107; // q0
  cv *v108; // x0
  _DWORD *v109; // x23
  unsigned int *v110; // x8
  unsigned int v111; // w9
  __int64 v112; // x8
  unsigned int *v113; // x8
  unsigned int v114; // w9
  unsigned int v115; // w9
  int v116; // w8
  __int64 v117; // x8
  __int64 v118; // x9
  __int64 v119; // x10
  _QWORD *v120; // x10
  cv *v121; // x8
  double *v122; // x9
  double v123; // d8
  double v124; // d10
  double *v125; // x8
  double v126; // d9
  double v127; // d11
  double v128; // d0
  double v129; // d8
  double v130; // d9
  double v131; // d10
  double v132; // d11
  float v133; // s1
  int v134; // s2
  int v135; // s3
  int v136; // s1
  unsigned int *v137; // x8
  unsigned int v138; // w9
  cv *v139; // x8
  cv *v140; // x10
  void *v141; // x1
  unsigned int *v142; // x8
  unsigned int v143; // w9
  unsigned int v144; // w9
  __int64 v145; // x8
  __int64 v146; // x9
  __int64 v147; // x9
  double v148; // d13
  double v149; // d12
  __int64 v150; // x10
  __int64 v151; // x11
  double v152; // d3
  double v153; // d4
  double v154; // d5
  double v155; // d7
  float v156; // s3
  double v157; // d4
  char v158; // w12
  char v159; // w13
  char *v160; // x14
  __int64 v161; // x10
  _QWORD *v162; // x0
  _QWORD *v163; // x23
  __int64 v164; // x0
  unsigned __int8 v165; // w24
  __int64 v166; // x9
  __int64 v167; // x8
  double v168; // d10
  double v169; // d9
  _QWORD *v170; // x0
  _QWORD *v171; // x0
  _QWORD *v172; // x0
  _QWORD *v173; // x23
  __int64 v174; // x0
  unsigned __int8 v175; // w24
  int v176; // w8
  int v177; // w20
  int v178; // w1
  __int128 v179; // q0
  __int64 *v180; // x0
  __int128 v181; // q0
  __int64 *v182; // x0
  void *v183; // x21
  __int64 v184; // x9
  char v185; // w22
  size_t v186; // x23
  const void *v187; // x22
  char *v188; // x24
  __int64 v189; // x9
  __int64 v190; // x23
  __int64 v191; // x22
  int v192; // w1
  __int64 *v193; // x0
  __int128 v194; // q0
  __int64 *v195; // x0
  void *v196; // x21
  __int64 v197; // x9
  char v198; // w22
  __int64 v199; // x9
  unsigned int *v200; // x8
  unsigned int v201; // w9
  cv *v202; // x8
  cv *v203; // x10
  int v204; // w10
  int v205; // w24
  int v206; // w8
  int v207; // w9
  int v208; // w25
  void *v209; // x1
  void *v210; // x1
  void *v211; // x1
  void *v212; // x1
  unsigned int *v213; // x8
  unsigned int v214; // w9
  unsigned int v215; // w9
  _DWORD *v216; // x8
  __int64 v217; // x9
  unsigned int *v218; // x8
  unsigned int v219; // w9
  unsigned int v220; // w9
  __int64 v221; // x8
  __int64 k; // x9
  unsigned int *v223; // x8
  unsigned int v224; // w9
  unsigned int v225; // w9
  _BYTE *v226; // x8
  __int64 v227; // x9
  void *v228; // x1
  unsigned int *v229; // x8
  unsigned int v230; // w9
  unsigned int v231; // w9
  cv *v232; // x8
  __int64 v233; // x9
  void *v234; // x1
  void *v235; // x1
  unsigned int *v236; // x8
  unsigned int v237; // w9
  unsigned int v238; // w9
  _QWORD *v239; // x8
  __int64 v240; // x9
  unsigned int *v241; // x8
  unsigned int v242; // w9
  unsigned int v243; // w9
  _QWORD *v244; // x8
  __int64 v245; // x9
  unsigned int *v246; // x8
  unsigned int v247; // w9
  unsigned int v248; // w9
  _BYTE *v249; // x8
  __int64 v250; // x9
  void *v251; // x1
  void *v252; // x1
  int v253; // [xsp+14h] [xbp-21BCh]
  int v254; // [xsp+18h] [xbp-21B8h]
  int v255; // [xsp+1Ch] [xbp-21B4h]
  int v256; // [xsp+20h] [xbp-21B0h]
  int v257; // [xsp+24h] [xbp-21ACh]
  __int64 v258; // [xsp+28h] [xbp-21A8h]
  __int64 v259; // [xsp+30h] [xbp-21A0h]
  __int64 *v262; // [xsp+A0h] [xbp-2130h]
  feasibal_region::feasibal_region *v263; // [xsp+C0h] [xbp-2110h]
  int v264[2]; // [xsp+D0h] [xbp-2100h] BYREF
  int v265[2]; // [xsp+D8h] [xbp-20F8h] BYREF
  __int64 v266; // [xsp+E0h] [xbp-20F0h] BYREF
  char v267[4]; // [xsp+ECh] [xbp-20E4h] BYREF
  __int128 v268; // [xsp+F0h] [xbp-20E0h] BYREF
  void *v269; // [xsp+100h] [xbp-20D0h]
  __int128 v270; // [xsp+110h] [xbp-20C0h] BYREF
  void *v271; // [xsp+120h] [xbp-20B0h]
  int v272[4]; // [xsp+128h] [xbp-20A8h] BYREF
  void *v273; // [xsp+138h] [xbp-2098h] BYREF
  void *v274; // [xsp+140h] [xbp-2090h]
  __int64 v275; // [xsp+148h] [xbp-2088h]
  void *v276; // [xsp+150h] [xbp-2080h] BYREF
  char *v277; // [xsp+158h] [xbp-2078h]
  void *v278; // [xsp+168h] [xbp-2068h] BYREF
  _OWORD *v279; // [xsp+170h] [xbp-2060h]
  _OWORD *v280; // [xsp+178h] [xbp-2058h]
  void *v281; // [xsp+180h] [xbp-2050h] BYREF
  _OWORD *v282; // [xsp+188h] [xbp-2048h]
  _OWORD *v283; // [xsp+190h] [xbp-2040h]
  void *v284; // [xsp+198h] [xbp-2038h] BYREF
  _QWORD *v285; // [xsp+1A0h] [xbp-2030h]
  _QWORD *v286; // [xsp+1A8h] [xbp-2028h]
  int v287[4]; // [xsp+1B0h] [xbp-2020h] BYREF
  char *v288; // [xsp+1C0h] [xbp-2010h] BYREF
  _OWORD *v289; // [xsp+1C8h] [xbp-2008h]
  _OWORD *v290; // [xsp+1D0h] [xbp-2000h]
  void *v291; // [xsp+1D8h] [xbp-1FF8h] BYREF
  _DWORD *v292; // [xsp+1E0h] [xbp-1FF0h]
  _DWORD *v293; // [xsp+1E8h] [xbp-1FE8h]
  _BYTE v294[345]; // [xsp+1F0h] [xbp-1FE0h] BYREF
  int v295[2]; // [xsp+350h] [xbp-1E80h] BYREF
  __int128 *v296; // [xsp+358h] [xbp-1E78h]
  void *v297; // [xsp+360h] [xbp-1E70h]
  _BYTE v298[64]; // [xsp+4B0h] [xbp-1D20h] BYREF
  _BYTE *v299; // [xsp+4F0h] [xbp-1CE0h]
  cv *v300; // [xsp+4F8h] [xbp-1CD8h]
  _QWORD v301[34]; // [xsp+500h] [xbp-1CD0h] BYREF
  __int64 v302[4]; // [xsp+610h] [xbp-1BC0h] BYREF
  __int64 v303[4]; // [xsp+630h] [xbp-1BA0h] BYREF
  __int128 v304; // [xsp+650h] [xbp-1B80h] BYREF
  __int128 v305; // [xsp+660h] [xbp-1B70h]
  __int128 v306; // [xsp+670h] [xbp-1B60h]
  __int128 v307; // [xsp+680h] [xbp-1B50h]
  _DWORD *v308; // [xsp+690h] [xbp-1B40h]
  cv *v309; // [xsp+698h] [xbp-1B38h]
  __int64 v310[2]; // [xsp+6A0h] [xbp-1B30h] BYREF
  char v311[4]; // [xsp+6B0h] [xbp-1B20h] BYREF
  int v312; // [xsp+6B4h] [xbp-1B1Ch]
  __int128 v313; // [xsp+6C0h] [xbp-1B10h]
  __int128 v314; // [xsp+6D0h] [xbp-1B00h]
  __int64 v315; // [xsp+6E8h] [xbp-1AE8h]
  __int64 v316; // [xsp+6F0h] [xbp-1AE0h]
  cv *v317; // [xsp+6F8h] [xbp-1AD8h]
  __int64 v318; // [xsp+700h] [xbp-1AD0h] BYREF
  _BYTE v319[64]; // [xsp+710h] [xbp-1AC0h] BYREF
  _BYTE *v320; // [xsp+750h] [xbp-1A80h]
  cv *v321; // [xsp+758h] [xbp-1A78h]
  __int64 v322[2]; // [xsp+760h] [xbp-1A70h] BYREF
  float32x2_t v323; // [xsp+770h] [xbp-1A60h] BYREF
  float v324; // [xsp+778h] [xbp-1A58h]
  float v325; // [xsp+77Ch] [xbp-1A54h]
  __int128 v326; // [xsp+780h] [xbp-1A50h] BYREF
  __int128 v327; // [xsp+790h] [xbp-1A40h]
  __int128 v328; // [xsp+7A0h] [xbp-1A30h]
  __int128 v329; // [xsp+7B0h] [xbp-1A20h]
  __int64 v330; // [xsp+7C0h] [xbp-1A10h]
  cv *v331; // [xsp+7C8h] [xbp-1A08h]
  __int64 v332[2]; // [xsp+7D0h] [xbp-1A00h] BYREF
  int v333[4]; // [xsp+7E0h] [xbp-19F0h] BYREF
  _BYTE v334[64]; // [xsp+7F0h] [xbp-19E0h] BYREF
  cv *v335[2]; // [xsp+830h] [xbp-19A0h]
  __int64 v336; // [xsp+840h] [xbp-1990h] BYREF
  __int64 v337; // [xsp+848h] [xbp-1988h]
  _BYTE v338[64]; // [xsp+1CB0h] [xbp-520h] BYREF
  cv *v339[2]; // [xsp+1CF0h] [xbp-4E0h]
  __int64 v340; // [xsp+1D00h] [xbp-4D0h] BYREF
  __int64 v341; // [xsp+1D08h] [xbp-4C8h]
  _QWORD v342[8]; // [xsp+1D10h] [xbp-4C0h] BYREF
  _QWORD *v343; // [xsp+1D50h] [xbp-480h]
  cv *v344; // [xsp+1D58h] [xbp-478h]
  __int64 v345[2]; // [xsp+1D60h] [xbp-470h] BYREF
  _BYTE v346[64]; // [xsp+1D70h] [xbp-460h] BYREF
  _QWORD *v347; // [xsp+1DB0h] [xbp-420h]
  cv *v348; // [xsp+1DB8h] [xbp-418h]
  __int64 v349[3]; // [xsp+1DC0h] [xbp-410h] BYREF
  _BYTE v350[64]; // [xsp+1DD8h] [xbp-3F8h] BYREF
  _BYTE *v351; // [xsp+1E18h] [xbp-3B8h]
  cv *v352; // [xsp+1E20h] [xbp-3B0h]
  __int64 v353[2]; // [xsp+1E28h] [xbp-3A8h] BYREF
  __int128 v354; // [xsp+1E38h] [xbp-398h] BYREF
  int v355; // [xsp+1E48h] [xbp-388h]
  int v356; // [xsp+1E4Ch] [xbp-384h]
  int v357; // [xsp+1E50h] [xbp-380h]
  int v358; // [xsp+1E54h] [xbp-37Ch]
  int v359; // [xsp+1E58h] [xbp-378h]
  int v360; // [xsp+1E5Ch] [xbp-374h]
  int v361; // [xsp+1E60h] [xbp-370h]
  int v362; // [xsp+1E64h] [xbp-36Ch]
  int v363; // [xsp+1E68h] [xbp-368h]
  int v364; // [xsp+1E6Ch] [xbp-364h]
  int v365; // [xsp+1E70h] [xbp-360h]
  int v366; // [xsp+1E74h] [xbp-35Ch]
  __int128 v367; // [xsp+1E78h] [xbp-358h]
  __int128 v368; // [xsp+1E88h] [xbp-348h]
  __int128 v369; // [xsp+1E98h] [xbp-338h]
  __int128 v370; // [xsp+1EA8h] [xbp-328h]
  __int128 v371; // [xsp+1EB8h] [xbp-318h]
  __int128 v372; // [xsp+1EC8h] [xbp-308h]
  __int128 v373; // [xsp+1ED8h] [xbp-2F8h]
  __int128 v374; // [xsp+1EE8h] [xbp-2E8h]
  __int128 v375; // [xsp+1EF8h] [xbp-2D8h]
  __int128 v376; // [xsp+1F08h] [xbp-2C8h]
  __int64 v377; // [xsp+1F18h] [xbp-2B8h]
  _BYTE v378[64]; // [xsp+1F20h] [xbp-2B0h] BYREF
  _BYTE *v379; // [xsp+1F60h] [xbp-270h]
  __int64 *v380; // [xsp+1F68h] [xbp-268h]
  __int64 v381[2]; // [xsp+1F70h] [xbp-260h] BYREF
  _OWORD v382[4]; // [xsp+1F80h] [xbp-250h] BYREF
  __int64 v383; // [xsp+1FC0h] [xbp-210h]
  __int64 *v384; // [xsp+1FC8h] [xbp-208h]
  __int64 v385[2]; // [xsp+1FD0h] [xbp-200h] BYREF
  int v386; // [xsp+1FE0h] [xbp-1F0h]
  __int64 v387; // [xsp+1FE4h] [xbp-1ECh]
  __int64 v388; // [xsp+1FECh] [xbp-1E4h]
  char v389; // [xsp+1FF4h] [xbp-1DCh]
  __int64 v390; // [xsp+1FF8h] [xbp-1D8h]
  char v391; // [xsp+2000h] [xbp-1D0h]
  int v392; // [xsp+2008h] [xbp-1C8h] BYREF
  int v393; // [xsp+200Ch] [xbp-1C4h]
  __int64 v394; // [xsp+2010h] [xbp-1C0h]
  __int128 v395; // [xsp+2018h] [xbp-1B8h]
  __int128 v396; // [xsp+2028h] [xbp-1A8h]
  __int128 v397; // [xsp+2038h] [xbp-198h]
  __int64 v398; // [xsp+2048h] [xbp-188h]
  _QWORD *v399; // [xsp+2050h] [xbp-180h]
  __int128 v400; // [xsp+20C8h] [xbp-108h] BYREF
  __int128 v401; // [xsp+20D8h] [xbp-F8h]
  __int128 v402; // [xsp+20E8h] [xbp-E8h]
  __int128 v403; // [xsp+20F8h] [xbp-D8h]
  __int128 v404; // [xsp+2108h] [xbp-C8h]
  __int64 v405[7]; // [xsp+2118h] [xbp-B8h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  feasibal_region::RunInputParam::RunInputParam((feasibal_region::RunInputParam *)&v392, a2, a3, (int)a4);
  v259 = a3;
  v377 = 0LL;
  v375 = 0u;
  v376 = 0u;
  v373 = 0u;
  v374 = 0u;
  v371 = 0u;
  v372 = 0u;
  v369 = 0u;
  v370 = 0u;
  v367 = 0u;
  v368 = 0u;
  *(_DWORD *)v378 = 1124007936;
  memset(&v378[4], 0, 60);
  v379 = &v378[8];
  v380 = v381;
  v381[0] = 0LL;
  v381[1] = 0LL;
  LODWORD(v382[0]) = 1124007936;
  memset((char *)v382 + 4, 0, 60);
  v383 = (__int64)v382 + 8;
  v384 = v385;
  v385[0] = 0LL;
  v385[1] = 0LL;
  v387 = 0LL;
  *(_DWORD *)v350 = 1124007936;
  v388 = 0LL;
  memset(&v350[4], 0, 60);
  v291 = 0LL;
  v292 = 0LL;
  v293 = 0LL;
  v288 = 0LL;
  v289 = 0LL;
  v290 = 0LL;
  v390 = 0xFFFFFFFFLL;
  v391 = 0;
  v386 = 1;
  v351 = &v350[8];
  v352 = (cv *)v353;
  v353[1] = 0LL;
  v353[0] = 0LL;
  v9 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)v346 = 1124007936;
  memset(&v346[4], 0, 60);
  v347 = &v346[8];
  v262 = (__int64 *)a2;
  v348 = (cv *)v349;
  v349[1] = 0LL;
  v349[0] = 0LL;
  *(_QWORD *)&v334[16] = 0LL;
  *(_DWORD *)v334 = 33619968;
  *(_QWORD *)&v334[8] = v346;
  cv::Mat::copyTo(v9 - 96, v334);
  v10 = *((_DWORD *)a1 + 212) == 1;
  v11 = *v347;
  LODWORD(v342[0]) = 1124007936;
  memset((char *)v342 + 4, 0, 60);
  v343 = &v342[1];
  if ( v10 )
    v12 = 50;
  else
    v12 = 0;
  if ( v10 )
    v13 = 120LL;
  else
    v13 = 50LL;
  if ( v10 )
    v14 = 100;
  else
    v14 = 30;
  v15 = *(_DWORD *)&v346[8] - v14 + v12;
  if ( v10 )
    v16 = 150LL;
  else
    v16 = 30LL;
  if ( v15 > v12 + *(_DWORD *)&v346[8] )
    v15 = v12 + *(_DWORD *)&v346[8];
  if ( *(int *)&v346[12] <= *(_DWORD *)&v346[12] - (int)v13 )
    v17 = *(_DWORD *)&v346[12];
  else
    v17 = *(_DWORD *)&v346[12] - v13;
  v18 = v16 - 2;
  v257 = v15;
  v19 = v15 + 2;
  if ( v17 + 2 >= (int)v13 - 2 )
    v20 = v13 - 2;
  else
    v20 = v17 + 2;
  if ( v19 >= v18 )
    v21 = v16 - 2;
  else
    v21 = v19;
  if ( (int)v13 - 2 >= v17 + 2 )
    v22 = v13 - 2;
  else
    v22 = v17 + 2;
  if ( v18 >= v19 )
    v23 = v16 - 2;
  else
    v23 = v19;
  v258 = v13;
  memset(v334, 0, 32);
  v344 = (cv *)v345;
  v345[1] = 0LL;
  v345[0] = 0LL;
  *(_QWORD *)v295 = v11;
  cv::Mat::create((cv::Mat *)v342, 2, v295, 0);
  cv::Mat::operator=(v342, v334);
  *(_QWORD *)&v298[16] = 0LL;
  v287[0] = v20;
  v287[1] = v21;
  *(_DWORD *)v298 = 50397184;
  *(_QWORD *)&v298[8] = v342;
  v255 = v23 - v21;
  v256 = v22 - v20;
  v287[2] = v22 - v20;
  v287[3] = v23 - v21;
  *(_OWORD *)v334 = 0x406FE00000000000uLL;
  *(_OWORD *)&v334[16] = 0uLL;
  cv::rectangle(v298, v287, v334, 0xFFFFFFFFLL, 8LL, 0LL);
  *(_OWORD *)v298 = 0x406FE00000000000uLL;
  *(_QWORD *)&v298[24] = 0LL;
  *(_QWORD *)&v298[16] = 0LL;
  cv::operator-(v334, v298, v342);
  (*(void (__fastcall **)(_QWORD, _BYTE *, _QWORD *, __int64))(**(_QWORD **)v334 + 24LL))(
    *(_QWORD *)v334,
    v334,
    v342,
    0xFFFFFFFFLL);
  v253 = v21;
  v254 = v20;
  v263 = a1;
  cv::MatExpr::~MatExpr((cv::MatExpr *)v334, v24);
  if ( v262[1] != *v262 )
  {
    v25 = *v262;
    v26 = 0LL;
    while ( 1 )
    {
      v27 = (int *)(v25 + 96 * v26);
      if ( &v392 != v27 )
        break;
LABEL_51:
      *(_DWORD *)v334 = -1056833530;
      *(_QWORD *)&v334[8] = v295;
      *(_DWORD *)v298 = 16842752;
      *(_QWORD *)v295 = 0LL;
      *(_QWORD *)&v334[16] = 0x100000001LL;
      *(_QWORD *)&v298[16] = 0LL;
      *(_QWORD *)&v298[8] = v342;
      cv::Mat::setTo(&v392, v334, v298);
      *(_DWORD *)v334 = 1124007936;
      memset(&v334[4], 0, 60);
      v335[0] = (cv *)&v334[8];
      v335[1] = (cv *)&v336;
      v336 = 0LL;
      v337 = 0LL;
      if ( *((_QWORD *)&v403 + 1) )
      {
        v41 = (unsigned int *)(*((_QWORD *)&v403 + 1) + 20LL);
        do
        {
          v42 = __ldaxr(v41);
          v43 = v42 - 1;
        }
        while ( __stlxr(v43, v41) );
        if ( !v43 )
          cv::Mat::deallocate((cv::Mat *)&v400);
      }
      *((_QWORD *)&v403 + 1) = 0LL;
      v401 = 0u;
      v402 = 0u;
      if ( SDWORD1(v400) >= 1 )
      {
        v44 = v404;
        v45 = 0LL;
        do
          *(_DWORD *)(v44 + 4 * v45++) = 0;
        while ( v45 < SDWORD1(v400) );
      }
      v400 = *(_OWORD *)v334;
      v401 = *(_OWORD *)&v334[16];
      v402 = *(_OWORD *)&v334[32];
      v403 = *(_OWORD *)&v334[48];
      if ( *((__int64 **)&v404 + 1) == v405 )
      {
        if ( *(int *)&v334[4] <= 2 )
        {
LABEL_61:
          v46 = v335[1];
          v405[0] = *(_QWORD *)v335[1];
          v405[1] = *((_QWORD *)v335[1] + 1);
          goto LABEL_64;
        }
      }
      else
      {
        cv::fastFree(*((cv **)&v404 + 1), v40);
        *((_QWORD *)&v404 + 1) = v405;
        *(_QWORD *)&v404 = (char *)&v400 + 8;
        if ( *(int *)&v334[4] <= 2 )
          goto LABEL_61;
      }
      v47 = *(_OWORD *)v335;
      v46 = (cv *)&v336;
      v335[1] = (cv *)&v336;
      v404 = v47;
      v335[0] = (cv *)&v334[8];
LABEL_64:
      *(_DWORD *)v334 = 1124007936;
      memset(&v334[4], 0, 60);
      if ( v46 != (cv *)&v336 )
        cv::fastFree(v46, v40);
      feasibal_region::feasibal_region::run(
        v263,
        (const feasibal_region::RunInputParam *)&v392,
        (feasibal_region::RunOutputParam *)&v354);
      if ( v389 )
      {
        v48 = v292;
        if ( v292 == v293 )
        {
          std::vector<Eigen::Transform<float,3,1,0>>::__push_back_slow_path<Eigen::Transform<float,3,1,0> const&>(
            (__int64)&v291,
            &v354);
        }
        else
        {
          *v292 = v354;
          *(_QWORD *)(v48 + 1) = *(_QWORD *)((char *)&v354 + 4);
          v48[3] = HIDWORD(v354);
          v48[4] = v355;
          v48[5] = v356;
          v48[6] = v357;
          v48[7] = v358;
          v48[8] = v359;
          v48[9] = v360;
          v48[10] = v361;
          v48[11] = v362;
          v48[12] = v363;
          v48[13] = v364;
          v48[14] = v365;
          v48[15] = v366;
          v292 = v48 + 16;
        }
      }
      v49 = (__int64)v289;
      if ( v289 == v290 )
      {
        std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>((__int64 *)&v288, (cv::Mat *)v378);
      }
      else
      {
        *v289 = *(_OWORD *)v378;
        *(_OWORD *)(v49 + 16) = *(_OWORD *)&v378[16];
        *(_OWORD *)(v49 + 32) = *(_OWORD *)&v378[32];
        *(_QWORD *)(v49 + 48) = *(_QWORD *)&v378[48];
        v50 = *(_QWORD *)&v378[56];
        *(_QWORD *)(v49 + 80) = 0LL;
        *(_QWORD *)(v49 + 64) = v49 + 8;
        *(_QWORD *)(v49 + 72) = v49 + 80;
        *(_QWORD *)(v49 + 56) = v50;
        *(_QWORD *)(v49 + 88) = 0LL;
        if ( v50 )
        {
          v51 = (unsigned int *)(v50 + 20);
          do
            v52 = __ldaxr(v51);
          while ( __stlxr(v52 + 1, v51) );
        }
        if ( *(int *)&v378[4] > 2 )
        {
          *(_DWORD *)(v49 + 4) = 0;
          cv::Mat::copySize((cv::Mat *)v49, (const cv::Mat *)v378);
        }
        else
        {
          v53 = (__int64)v380;
          v54 = *(__int64 **)(v49 + 72);
          *v54 = *v380;
          v54[1] = *(_QWORD *)(v53 + 8);
        }
        v289 += 6;
      }
      v55 = v386;
      if ( *((_QWORD *)&v382[3] + 1) )
      {
        v56 = (unsigned int *)(*((_QWORD *)&v382[3] + 1) + 20LL);
        do
          v57 = __ldaxr(v56);
        while ( __stlxr(v57 + 1, v56) );
      }
      if ( *(_QWORD *)&v350[56] )
      {
        v58 = (unsigned int *)(*(_QWORD *)&v350[56] + 20LL);
        do
        {
          v59 = __ldaxr(v58);
          v60 = v59 - 1;
        }
        while ( __stlxr(v60, v58) );
        if ( !v60 )
          cv::Mat::deallocate((cv::Mat *)v350);
      }
      *(_QWORD *)&v350[56] = 0LL;
      memset(&v350[16], 0, 32);
      if ( *(__int64 *)v350 <= 0 )
      {
        *(_DWORD *)v350 = v382[0];
      }
      else
      {
        v61 = v351;
        v62 = 0LL;
        do
          *(_DWORD *)&v61[4 * v62++] = 0;
        while ( v62 < *(int *)&v350[4] );
        *(_DWORD *)v350 = v382[0];
        if ( *(int *)&v350[4] > 2 )
        {
LABEL_95:
          cv::Mat::copySize((cv::Mat *)v350, (const cv::Mat *)v382);
          goto LABEL_96;
        }
      }
      if ( SDWORD1(v382[0]) > 2 )
        goto LABEL_95;
      v63 = (__int64)v384;
      *(_DWORD *)&v350[4] = DWORD1(v382[0]);
      *(_QWORD *)&v350[8] = *((_QWORD *)&v382[0] + 1);
      v64 = v352;
      *(_QWORD *)v352 = *v384;
      *((_QWORD *)v64 + 1) = *(_QWORD *)(v63 + 8);
LABEL_96:
      *(_OWORD *)&v350[16] = v382[1];
      *(_OWORD *)&v350[32] = v382[2];
      *(_OWORD *)&v350[48] = v382[3];
      ++v26;
      v25 = *v262;
      if ( v26 >= 0xAAAAAAAAAAAAAAABLL * ((v262[1] - *v262) >> 5) )
      {
        LODWORD(v262) = v55;
        goto LABEL_98;
      }
    }
    v28 = *(_QWORD *)(v25 + 96 * v26 + 56);
    if ( v28 )
    {
      v29 = (unsigned int *)(v28 + 20);
      do
        v30 = __ldaxr(v29);
      while ( __stlxr(v30 + 1, v29) );
    }
    if ( *((_QWORD *)&v397 + 1) )
    {
      v31 = (unsigned int *)(*((_QWORD *)&v397 + 1) + 20LL);
      do
      {
        v32 = __ldaxr(v31);
        v33 = v32 - 1;
      }
      while ( __stlxr(v33, v31) );
      if ( !v33 )
        cv::Mat::deallocate((cv::Mat *)&v392);
    }
    *((_QWORD *)&v397 + 1) = 0LL;
    v395 = 0u;
    v396 = 0u;
    if ( v393 <= 0 )
    {
      v392 = *v27;
    }
    else
    {
      v34 = v398;
      for ( i = 0LL; i < v393; *(_DWORD *)(v34 + 4 * i++) = 0 )
        ;
      v392 = *v27;
      if ( v393 > 2 )
        goto LABEL_49;
    }
    if ( *(int *)(v25 + 96 * v26 + 4) <= 2 )
    {
      v393 = *(_DWORD *)(v25 + 96 * v26 + 4);
      v36 = v25 + 96 * v26;
      v37 = v399;
      v394 = *(_QWORD *)(v36 + 8);
      v38 = *(_QWORD **)(v36 + 72);
      *v399 = *v38;
      v37[1] = v38[1];
LABEL_50:
      v39 = (_OWORD *)(v25 + 96 * v26);
      v395 = v39[1];
      v396 = v39[2];
      v397 = v39[3];
      goto LABEL_51;
    }
LABEL_49:
    cv::Mat::copySize((cv::Mat *)&v392, (const cv::Mat *)(v25 + 96 * v26));
    goto LABEL_50;
  }
LABEL_98:
  v284 = 0LL;
  v285 = 0LL;
  v286 = 0LL;
  v281 = 0LL;
  v282 = 0LL;
  v283 = 0LL;
  v279 = 0LL;
  v280 = 0LL;
  v278 = 0LL;
  if ( (unsigned __int64)(((char *)v292 - (_BYTE *)v291) >> 6) >= 2 )
  {
    for ( j = 1LL; j < ((char *)v292 - (_BYTE *)v291) >> 6; ++j )
    {
      *(_DWORD *)v334 = 1124007936;
      memset(&v334[4], 0, 60);
      v335[0] = (cv *)&v334[8];
      v335[1] = (cv *)&v336;
      v336 = 0LL;
      v337 = 0LL;
      *(_QWORD *)v295 = 0x300000003LL;
      cv::Mat::create((cv::Mat *)v334, 2, v295, 6);
      *(_DWORD *)v298 = 1124007936;
      memset(&v298[4], 0, 60);
      v299 = &v298[8];
      v300 = (cv *)v301;
      v301[0] = 0LL;
      v301[1] = 0LL;
      *(_QWORD *)v295 = 0x300000001LL;
      cv::Mat::create((cv::Mat *)v298, 2, v295, 6);
      *(_DWORD *)&v294[8] = 0;
      *(_QWORD *)v294 = 0LL;
      v66 = (float32x2_t *)((char *)v291 + 64 * j);
      v67 = *(_QWORD *)&v334[16];
      v68 = *(_QWORD *)v335[1];
      **(double **)&v334[16] = v66->n64_f32[0];
      v69 = (double *)(v67 + v68);
      v70 = (double *)(v67 + 2 * v68);
      *(double *)(v67 + 8) = v66[2].n64_f32[0];
      *(double *)(v67 + 16) = v66[4].n64_f32[0];
      *v69 = v66->n64_f32[1];
      v69[1] = v66[2].n64_f32[1];
      v69[2] = v66[4].n64_f32[1];
      *v70 = v66[1].n64_f32[0];
      v70[1] = v66[3].n64_f32[0];
      v70[2] = v66[5].n64_f32[0];
      v71 = *(_QWORD *)&v298[16];
      **(_OWORD **)&v298[16] = vcvtq_f64_f32(v66[6]);
      *(double *)(v71 + 16) = v66[7].n64_f32[0];
      rotationMatrixToEulerAngles((cv::Mat *)v334, (__int64)v295);
      *(_DWORD *)&v294[8] = (_DWORD)v296;
      *(_QWORD *)v294 = *(_QWORD *)v295;
      if ( BYTE4(v296) )
      {
        v73 = (__int64)v282;
        if ( v282 == v283 )
        {
          std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>((__int64 *)&v281, (cv::Mat *)v298);
        }
        else
        {
          *v282 = *(_OWORD *)v298;
          *(_OWORD *)(v73 + 16) = *(_OWORD *)&v298[16];
          *(_OWORD *)(v73 + 32) = *(_OWORD *)&v298[32];
          *(_QWORD *)(v73 + 48) = *(_QWORD *)&v298[48];
          v74 = *(_QWORD *)&v298[56];
          *(_QWORD *)(v73 + 80) = 0LL;
          *(_QWORD *)(v73 + 64) = v73 + 8;
          *(_QWORD *)(v73 + 72) = v73 + 80;
          *(_QWORD *)(v73 + 56) = v74;
          *(_QWORD *)(v73 + 88) = 0LL;
          if ( v74 )
          {
            v75 = (unsigned int *)(v74 + 20);
            do
              v76 = __ldaxr(v75);
            while ( __stlxr(v76 + 1, v75) );
          }
          if ( *(int *)&v298[4] > 2 )
          {
            *(_DWORD *)(v73 + 4) = 0;
            cv::Mat::copySize((cv::Mat *)v73, (const cv::Mat *)v298);
          }
          else
          {
            v77 = v300;
            v78 = *(_QWORD **)(v73 + 72);
            *v78 = *(_QWORD *)v300;
            v78[1] = *((_QWORD *)v77 + 1);
          }
          v282 += 6;
        }
        v79 = v285;
        if ( v285 == v286 )
        {
          std::vector<cv::Vec<float,3>>::__push_back_slow_path<cv::Vec<float,3> const&>((__int64)&v284, (__int64)v294);
        }
        else
        {
          *v285 = *(_QWORD *)v294;
          *((_DWORD *)v79 + 2) = *(_DWORD *)&v294[8];
          v285 = (_QWORD *)((char *)v79 + 12);
        }
        v80 = (__int64)v279;
        v81 = v288;
        v72 = (const cv::Mat *)&v288[96 * j];
        if ( v279 != v280 )
        {
          v82 = &v288[96 * j];
          v83 = (int *)(v82 + 4);
          *v279 = *(_OWORD *)v72;
          *(_OWORD *)(v80 + 16) = *((_OWORD *)v82 + 1);
          *(_OWORD *)(v80 + 32) = *((_OWORD *)v82 + 2);
          *(_QWORD *)(v80 + 48) = *((_QWORD *)v82 + 6);
          v84 = *((_QWORD *)v82 + 7);
          *(_QWORD *)(v80 + 80) = 0LL;
          *(_QWORD *)(v80 + 64) = v80 + 8;
          *(_QWORD *)(v80 + 72) = v80 + 80;
          *(_QWORD *)(v80 + 56) = v84;
          *(_QWORD *)(v80 + 88) = 0LL;
          if ( v84 )
          {
            v85 = (unsigned int *)(v84 + 20);
            do
              v86 = __ldaxr(v85);
            while ( __stlxr(v86 + 1, v85) );
          }
          if ( *v83 > 2 )
          {
            *(_DWORD *)(v80 + 4) = 0;
            cv::Mat::copySize((cv::Mat *)v80, v72);
          }
          else
          {
            v87 = *(_QWORD **)&v81[96 * j + 72];
            v88 = *(_QWORD **)(v80 + 72);
            *v88 = *v87;
            v88[1] = v87[1];
          }
          v279 += 6;
          v89 = *(_QWORD *)&v298[56];
          if ( !*(_QWORD *)&v298[56] )
            goto LABEL_128;
LABEL_124:
          v90 = (unsigned int *)(v89 + 20);
          do
          {
            v91 = __ldaxr(v90);
            v92 = v91 - 1;
          }
          while ( __stlxr(v92, v90) );
          if ( !v92 )
            cv::Mat::deallocate((cv::Mat *)v298);
          goto LABEL_128;
        }
        std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>((__int64 *)&v278, v72);
      }
      v89 = *(_QWORD *)&v298[56];
      if ( *(_QWORD *)&v298[56] )
        goto LABEL_124;
LABEL_128:
      *(_QWORD *)&v298[56] = 0LL;
      memset(&v298[16], 0, 32);
      if ( *(int *)&v298[4] >= 1 )
      {
        v93 = v299;
        v94 = 0LL;
        do
          *(_DWORD *)&v93[4 * v94++] = 0;
        while ( v94 < *(int *)&v298[4] );
      }
      if ( v300 != (cv *)v301 )
        cv::fastFree(v300, v72);
      if ( *(_QWORD *)&v334[56] )
      {
        v95 = (unsigned int *)(*(_QWORD *)&v334[56] + 20LL);
        do
        {
          v96 = __ldaxr(v95);
          v97 = v96 - 1;
        }
        while ( __stlxr(v97, v95) );
        if ( !v97 )
          cv::Mat::deallocate((cv::Mat *)v334);
      }
      *(_QWORD *)&v334[56] = 0LL;
      memset(&v334[16], 0, 32);
      if ( *(int *)&v334[4] >= 1 )
      {
        v98 = v335[0];
        v99 = 0LL;
        do
          *((_DWORD *)v98 + v99++) = 0;
        while ( v99 < *(int *)&v334[4] );
      }
      if ( (__int64 *)v335[1] != &v336 )
        cv::fastFree(v335[1], v72);
    }
  }
  *(_DWORD *)v338 = 1124007936;
  memset(&v338[4], 0, 60);
  v339[0] = (cv *)&v338[8];
  v339[1] = (cv *)&v340;
  v341 = 0LL;
  v340 = 0LL;
  checktool::getExtrinsicParameters(&v284, &v281, (__int64)v334);
  if ( *(_QWORD *)&v338[56] )
  {
    v101 = (unsigned int *)(*(_QWORD *)&v338[56] + 20LL);
    do
    {
      v102 = __ldaxr(v101);
      v103 = v102 - 1;
    }
    while ( __stlxr(v103, v101) );
    if ( !v103 )
      cv::Mat::deallocate((cv::Mat *)v338);
  }
  *(_QWORD *)&v338[56] = 0LL;
  memset(&v338[16], 0, 32);
  if ( *(int *)&v338[4] >= 1 )
  {
    v104 = v339[0];
    v105 = 0LL;
    do
      *((_DWORD *)v104 + v105++) = 0;
    while ( v105 < *(int *)&v338[4] );
  }
  *(_OWORD *)v338 = *(_OWORD *)v334;
  *(_OWORD *)&v338[16] = *(_OWORD *)&v334[16];
  *(_OWORD *)&v338[32] = *(_OWORD *)&v334[32];
  *(_OWORD *)&v338[48] = *(_OWORD *)&v334[48];
  if ( (__int64 *)v339[1] == &v340 )
  {
    v106 = *(_DWORD *)&v334[4];
  }
  else
  {
    cv::fastFree(v339[1], v100);
    v106 = *(_DWORD *)&v334[4];
    v339[1] = (cv *)&v340;
    v339[0] = (cv *)&v338[8];
  }
  if ( v106 <= 2 )
  {
    v108 = v335[1];
    v340 = *(_QWORD *)v335[1];
    v341 = *((_QWORD *)v335[1] + 1);
  }
  else
  {
    v107 = *(_OWORD *)v335;
    v108 = (cv *)&v336;
    v335[1] = (cv *)&v336;
    *(_OWORD *)v339 = v107;
    v335[0] = (cv *)&v334[8];
  }
  *(_DWORD *)v334 = 1124007936;
  memset(&v334[4], 0, 60);
  if ( v108 != (cv *)&v336 )
    v108 = (cv *)cv::fastFree(v108, v100);
  v109 = (_DWORD *)((char *)v263 + 736);
  *((_DWORD *)v263 + 208) = checktool::getNearEdge((__int64)v108, (__int64 *)&v278, (int)v262);
  if ( (char *)v263 + 736 != v338 )
  {
    if ( *(_QWORD *)&v338[56] )
    {
      v110 = (unsigned int *)(*(_QWORD *)&v338[56] + 20LL);
      do
        v111 = __ldaxr(v110);
      while ( __stlxr(v111 + 1, v110) );
    }
    v112 = *((_QWORD *)v263 + 99);
    if ( v112 )
    {
      v113 = (unsigned int *)(v112 + 20);
      do
      {
        v114 = __ldaxr(v113);
        v115 = v114 - 1;
      }
      while ( __stlxr(v115, v113) );
      if ( !v115 )
        cv::Mat::deallocate((feasibal_region::feasibal_region *)((char *)v263 + 736));
    }
    v116 = *((_DWORD *)v263 + 185);
    *((_QWORD *)v263 + 99) = 0LL;
    *((_OWORD *)v263 + 47) = 0u;
    *((_OWORD *)v263 + 48) = 0u;
    if ( v116 <= 0 )
    {
      *v109 = *(_DWORD *)v338;
    }
    else
    {
      v117 = *((_QWORD *)v263 + 100);
      v118 = 0LL;
      do
      {
        *(_DWORD *)(v117 + 4 * v118) = 0;
        v119 = *((int *)v263 + 185);
        ++v118;
      }
      while ( v118 < v119 );
      *v109 = *(_DWORD *)v338;
      if ( (int)v119 > 2 )
        goto LABEL_177;
    }
    if ( *(int *)&v338[4] <= 2 )
    {
      *((_DWORD *)v263 + 185) = *(_DWORD *)&v338[4];
      v120 = (_QWORD *)*((_QWORD *)v263 + 101);
      *((_QWORD *)v263 + 93) = *(_QWORD *)&v338[8];
      v121 = v339[1];
      *v120 = *(_QWORD *)v339[1];
      v120[1] = *((_QWORD *)v121 + 1);
LABEL_178:
      *((_OWORD *)v263 + 47) = *(_OWORD *)&v338[16];
      *((_OWORD *)v263 + 48) = *(_OWORD *)&v338[32];
      *((_OWORD *)v263 + 49) = *(_OWORD *)&v338[48];
      goto LABEL_179;
    }
LABEL_177:
    cv::Mat::copySize((feasibal_region::feasibal_region *)((char *)v263 + 736), (const cv::Mat *)v338);
    goto LABEL_178;
  }
LABEL_179:
  v122 = (double *)*((_QWORD *)v263 + 82);
  v123 = *v122;
  v124 = v122[2];
  v125 = (double *)((char *)v122 + **((_QWORD **)v263 + 89));
  v126 = v125[1];
  v127 = v125[2];
  ground_filter::Plane_Seg::Plane_Seg((ground_filter::Plane_Seg *)v334, 0, 20.0);
  v128 = *(double *)v346;
  v129 = v123 * 0.5;
  v130 = v126 * 0.5;
  v131 = v124 * 0.5;
  v132 = v127 * 0.5;
  v133 = v129;
  v327 = *(_OWORD *)&v346[16];
  v328 = *(_OWORD *)&v346[32];
  v329 = *(_OWORD *)&v346[48];
  *(float *)&v134 = v130;
  *(float *)&v135 = v131;
  *(float *)v333 = v133;
  *(float *)&v136 = v132;
  v326 = *(_OWORD *)v346;
  v330 = (__int64)&v326 + 8;
  v333[1] = v134;
  v333[2] = v135;
  v333[3] = v136;
  v331 = (cv *)v332;
  v332[1] = 0LL;
  v332[0] = 0LL;
  if ( *(_QWORD *)&v346[56] )
  {
    v137 = (unsigned int *)(*(_QWORD *)&v346[56] + 20LL);
    do
      v138 = __ldaxr(v137);
    while ( __stlxr(v138 + 1, v137) );
    if ( *(int *)&v346[4] <= 2 )
      goto LABEL_183;
  }
  else if ( *(int *)&v346[4] <= 2 )
  {
LABEL_183:
    v139 = v348;
    v140 = v331;
    *(_QWORD *)v331 = *(_QWORD *)v348;
    *((_QWORD *)v140 + 1) = *((_QWORD *)v139 + 1);
    goto LABEL_186;
  }
  DWORD1(v326) = 0;
  cv::Mat::copySize((cv::Mat *)&v326, (const cv::Mat *)v346);
LABEL_186:
  checktool::getPointCloud((float *)v333, &v276, v128, (__int64)&v326, 5);
  if ( *((_QWORD *)&v329 + 1) )
  {
    v142 = (unsigned int *)(*((_QWORD *)&v329 + 1) + 20LL);
    do
    {
      v143 = __ldaxr(v142);
      v144 = v143 - 1;
    }
    while ( __stlxr(v144, v142) );
    if ( !v144 )
      cv::Mat::deallocate((cv::Mat *)&v326);
  }
  *((_QWORD *)&v329 + 1) = 0LL;
  v327 = 0u;
  v328 = 0u;
  if ( SDWORD1(v326) >= 1 )
  {
    v145 = v330;
    v146 = 0LL;
    do
      *(_DWORD *)(v145 + 4 * v146++) = 0;
    while ( v146 < SDWORD1(v326) );
  }
  if ( v331 != (cv *)v332 )
    cv::fastFree(v331, v141);
  std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
    (__int64)v334,
    (char *)v276,
    v277);
  v273 = 0LL;
  v274 = 0LL;
  v275 = 0LL;
  ground_filter::Plane_Seg::segPlane((char **)v334, &v323, (__int64 *)&v273, 20);
  v147 = *v347;
  memset(v298, 0, 32);
  *(_DWORD *)v319 = 1124007936;
  memset(&v319[4], 0, 60);
  v320 = &v319[8];
  v321 = (cv *)v322;
  v322[1] = 0LL;
  v322[0] = 0LL;
  *(_QWORD *)v295 = v147;
  cv::Mat::create((cv::Mat *)v319, 2, v295, 16);
  cv::Mat::operator=(v319, v298);
  *a4 = 1;
  v295[0] = 50397184;
  v297 = 0LL;
  v296 = (__int128 *)v319;
  v272[0] = v254;
  *(int64x2_t *)v298 = vdupq_n_s64(0x406FE00000000000uLL);
  *(_QWORD *)&v298[24] = 0LL;
  *(_QWORD *)&v298[16] = 0LL;
  v272[1] = v253;
  v272[2] = v256;
  v272[3] = v255;
  cv::rectangle(v295, v272, v298, 2LL, 8LL, 0LL);
  v148 = 0.0;
  v149 = 0.0;
  if ( (int)v16 >= v257 )
    goto LABEL_209;
  v149 = 0.0;
  v148 = 0.0;
  do
  {
    if ( (int)v258 >= v17 )
      goto LABEL_208;
    v150 = v258 + 2LL * (unsigned int)v258;
    v151 = v258;
    while ( 1 )
    {
      v149 = v149 + 1.0;
      if ( !*(_WORD *)(*(_QWORD *)&v346[16] + v16 * *(_QWORD *)v348 + 2 * v151) )
      {
        v158 = 0x80;
        v159 = 0x80;
        goto LABEL_205;
      }
      v152 = (double)*(unsigned __int16 *)(*(_QWORD *)&v346[16] + v16 * *(_QWORD *)v348 + 2 * v151) / 1000.0;
      v153 = ((double)(int)v151 - v131) * v152 / v129 * v323.n64_f32[0];
      v154 = ((double)(int)v16 - v132) * v152 / v130 * v323.n64_f32[1];
      v155 = v152 * v324;
      v156 = *((float *)v263 + 214);
      v157 = v155 + v153 + v154 + v325;
      v148 = v148 + 1.0;
      if ( v157 >= v156 || v157 <= (float)-v156 )
        break;
      v158 = 0;
      v159 = 100;
LABEL_205:
      ++v151;
      v160 = (char *)(*(_QWORD *)&v319[16] + v16 * *(_QWORD *)v321 + v150);
      v150 += 3LL;
      *v160 = v158;
      v160[1] = v159;
      v160[2] = v158;
      if ( v17 <= (int)v151 )
        goto LABEL_208;
    }
    v161 = *(_QWORD *)&v319[16] + *(_QWORD *)v321 * v16 + v150;
    *(_WORD *)v161 = 0;
    *(_BYTE *)(v161 + 2) = -6;
    *a4 = 0;
LABEL_208:
    ++v16;
  }
  while ( v257 > (int)v16 );
LABEL_209:
  v162 = std::__put_character_sequence<char,std::char_traits<char>>(&std::cout, (__int64)"fill_rate:", 10LL);
  *(double *)&v5 = v148 / v149;
  v163 = std::ostream::operator<<(v162, v5);
  std::ios_base::getloc(v298, (std::ios_base *)((char *)v163 + *(_QWORD *)(*v163 - 24LL)));
  v164 = std::locale::use_facet(v298, &std::ctype<char>::id);
  v165 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v164 + 56LL))(v164, 10LL);
  std::locale::~locale((std::locale *)v298);
  std::ostream::put(v163, v165);
  std::ostream::flush(v163);
  if ( v148 / v149 < *((float *)v263 + 213) )
    *a4 = 0;
  v166 = *((_QWORD *)v263 + 94);
  v167 = **((_QWORD **)v263 + 101);
  *(_QWORD *)&v5 = *(_QWORD *)(v166 + 24);
  v168 = *(double *)(v166 + v167 + 24);
  v169 = *(double *)(v166 + 2 * v167 + 24);
  v170 = std::__put_character_sequence<char,std::char_traits<char>>(&std::cout, (__int64)"height:", 7LL);
  *(double *)&v5 = sqrt(*(double *)&v5 * *(double *)&v5 + v168 * v168 + v169 * v169);
  v171 = std::ostream::operator<<(v170, v5);
  v172 = std::__put_character_sequence<char,std::char_traits<char>>(v171, (__int64)" legal:", 7LL);
  v173 = std::ostream::operator<<(v172);
  std::ios_base::getloc(v298, (std::ios_base *)((char *)v173 + *(_QWORD *)(*v173 - 24LL)));
  v174 = std::locale::use_facet(v298, &std::ctype<char>::id);
  v175 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v174 + 56LL))(v174, 10LL);
  std::locale::~locale((std::locale *)v298);
  std::ostream::put(v173, v175);
  std::ostream::flush(v173);
  if ( *((_DWORD *)v263 + 212) == 1 )
    v176 = 20;
  else
    v176 = 15;
  if ( vabdd_f64(*(double *)&v5, *((double *)v263 + 105)) >= (double)v176 )
  {
    v177 = 1;
    *a4 = 0;
  }
  else
  {
    v177 = 0;
  }
  getColorDepthImage((const cv::Mat *)v346, 100, 8000, (__int64)v311);
  v271 = 0LL;
  v270 = 0uLL;
  if ( *a4 )
  {
    v269 = 0LL;
    v268 = 0uLL;
    if ( (*(_BYTE *)v259 & 1) == 0 )
    {
      v179 = *(_OWORD *)v259;
      v269 = *(void **)(v259 + 16);
      v268 = v179;
      goto LABEL_236;
    }
    v186 = *(_QWORD *)(v259 + 8);
    if ( v186 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v187 = *(const void **)(v259 + 16);
    if ( v186 >= 0x17 )
    {
      v188 = (char *)operator new((v186 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v268 + 1) = v186;
      v269 = v188;
      *(_QWORD *)&v268 = (v186 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v188 = (char *)&v268 + 1;
      LOBYTE(v268) = 2 * v186;
      if ( !v186 )
        goto LABEL_235;
    }
    memcpy(v188, v187, v186);
LABEL_235:
    v188[v186] = 0;
LABEL_236:
    checktool::saveResults((__int64)v263, (unsigned __int8 *)&v268);
    if ( (v268 & 1) != 0 )
      operator delete(v269);
    std::to_string(v295, (std::__ndk1 *)(unsigned int)(int)*(double *)&v5, v192);
    v193 = std::string::insert((__int64 *)v295, 0LL, "OK-", 3uLL);
    v194 = *(_OWORD *)v193;
    *(_QWORD *)&v298[16] = v193[2];
    *(_OWORD *)v298 = v194;
    v193[1] = 0LL;
    v193[2] = 0LL;
    *v193 = 0LL;
    v195 = std::string::append((__int64 *)v298, " mm", 3uLL);
    v196 = (void *)v195[2];
    v197 = *(__int64 *)((char *)v195 + 1);
    v198 = *(_BYTE *)v195;
    *(_QWORD *)&v294[7] = v195[1];
    *(_QWORD *)v294 = v197;
    *v195 = 0LL;
    v195[1] = 0LL;
    v195[2] = 0LL;
    if ( (v270 & 1) != 0 )
    {
      *(_BYTE *)v271 = 0;
      *((_QWORD *)&v270 + 1) = 0LL;
      if ( (v270 & 1) != 0 )
      {
        operator delete(v271);
        *(_QWORD *)&v270 = 0LL;
      }
    }
    else
    {
      LOWORD(v270) = 0;
    }
    v199 = *(_QWORD *)v294;
    LOBYTE(v270) = v198;
    *((_QWORD *)&v270 + 1) = *(_QWORD *)&v294[7];
    *(_QWORD *)v294 = 0LL;
    *(_QWORD *)((char *)&v270 + 1) = v199;
    v271 = v196;
    *(_QWORD *)&v294[7] = 0LL;
    if ( (v298[0] & 1) != 0 )
      operator delete(*(void **)&v298[16]);
    if ( (v295[0] & 1) != 0 )
      operator delete(v297);
    v191 = 0LL;
    v190 = 0x406FE00000000000LL;
  }
  else
  {
    std::to_string(v295, (std::__ndk1 *)(unsigned int)(int)*(double *)&v5, v178);
    v180 = std::string::insert((__int64 *)v295, 0LL, "Failed-", 7uLL);
    v181 = *(_OWORD *)v180;
    *(_QWORD *)&v298[16] = v180[2];
    *(_OWORD *)v298 = v181;
    v180[1] = 0LL;
    v180[2] = 0LL;
    *v180 = 0LL;
    v182 = std::string::append((__int64 *)v298, " mm", 3uLL);
    v183 = (void *)v182[2];
    v184 = *(__int64 *)((char *)v182 + 1);
    v185 = *(_BYTE *)v182;
    *(_QWORD *)&v294[7] = v182[1];
    *(_QWORD *)v294 = v184;
    *v182 = 0LL;
    v182[1] = 0LL;
    v182[2] = 0LL;
    if ( (v270 & 1) != 0 )
    {
      *(_BYTE *)v271 = 0;
      *((_QWORD *)&v270 + 1) = 0LL;
      if ( (v270 & 1) != 0 )
      {
        operator delete(v271);
        *(_QWORD *)&v270 = 0LL;
      }
    }
    else
    {
      LOWORD(v270) = 0;
    }
    v189 = *(_QWORD *)v294;
    LOBYTE(v270) = v185;
    *((_QWORD *)&v270 + 1) = *(_QWORD *)&v294[7];
    *(_QWORD *)v294 = 0LL;
    *(_QWORD *)((char *)&v270 + 1) = v189;
    v271 = v183;
    *(_QWORD *)&v294[7] = 0LL;
    if ( (v298[0] & 1) != 0 )
      operator delete(*(void **)&v298[16]);
    if ( (v295[0] & 1) != 0 )
      operator delete(v297);
    v190 = 0LL;
    v191 = 0x406FE00000000000LL;
  }
  v305 = *(_OWORD *)&v319[16];
  v307 = *(_OWORD *)&v319[48];
  v304 = *(_OWORD *)v319;
  v306 = *(_OWORD *)&v319[32];
  v308 = (_DWORD *)&v304 + 2;
  v309 = (cv *)v310;
  v310[1] = 0LL;
  v310[0] = 0LL;
  if ( *(_QWORD *)&v319[56] )
  {
    v200 = (unsigned int *)(*(_QWORD *)&v319[56] + 20LL);
    do
      v201 = __ldaxr(v200);
    while ( __stlxr(v201 + 1, v200) );
    if ( *(int *)&v319[4] <= 2 )
    {
LABEL_251:
      v202 = v321;
      v203 = v309;
      *(_QWORD *)v309 = *(_QWORD *)v321;
      *((_QWORD *)v203 + 1) = *((_QWORD *)v202 + 1);
      goto LABEL_254;
    }
  }
  else if ( *(int *)&v319[4] <= 2 )
  {
    goto LABEL_251;
  }
  DWORD1(v304) = 0;
  cv::Mat::copySize((cv::Mat *)&v304, (const cv::Mat *)v319);
LABEL_254:
  if ( (v304 & 0xFF8) == 0 )
  {
    *(_DWORD *)v298 = 16842752;
    *(_QWORD *)&v298[16] = 0LL;
    v297 = 0LL;
    v295[0] = 33619968;
    *(_QWORD *)&v298[8] = &v304;
    v296 = &v304;
    cv::cvtColor(v298, v295, 8LL, 0LL);
  }
  cv::getTextSize(&v266, &v270, 3LL, 2LL, v267, 1.0);
  v204 = HIDWORD(v266);
  if ( SHIDWORD(v266) >= *v308 )
    v204 = *v308;
  HIDWORD(v266) = v204;
  v205 = SDWORD2(v304) / 3 + v204;
  v206 = v308[1];
  *(_QWORD *)&v298[8] = &v304;
  *(_QWORD *)&v298[16] = 0LL;
  if ( (int)v266 < v206 )
    v206 = v266;
  if ( v304 >= 0 )
    v207 = HIDWORD(v304);
  else
    v207 = HIDWORD(v304) + 1;
  v265[1] = SDWORD2(v304) / 3 + v204;
  LODWORD(v266) = v206;
  v208 = (v207 >> 1) - v206 / 2;
  *(_DWORD *)v298 = 50397184;
  v303[0] = 0LL;
  v303[1] = v190;
  v303[2] = v191;
  v265[0] = v208;
  v303[3] = 0LL;
  cv::putText(v298, &v270, v265, 3LL, v303, 2LL, 8LL, 0LL, 1.0);
  if ( !*a4 )
  {
    std::string::assign((__int64 *)&v270, "", 0LL);
    if ( v177 )
      std::string::append((__int64 *)&v270, "    distance error!", 0x13uLL);
    else
      std::string::append((__int64 *)&v270, " fill rate error!", 0x11uLL);
    *(_DWORD *)v298 = 50397184;
    *(_QWORD *)&v298[8] = &v304;
    *(_QWORD *)&v298[16] = 0LL;
    v302[0] = 0LL;
    v302[1] = v190;
    v302[2] = v191;
    v264[0] = v208;
    v264[1] = (int)((double)SHIDWORD(v266) * 1.5 + (double)v205);
    v302[3] = 0LL;
    cv::putText(v298, &v270, v264, 3LL, v302, 2LL, 8LL, 0LL, 1.0);
  }
  cv::operator*(v295, v311, 0.3);
  cv::operator*(v294, &v304, 0.7);
  cv::operator+(v298, v295, v294);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int128 *, __int64))(**(_QWORD **)v298 + 24LL))(
    *(_QWORD *)v298,
    v298,
    &v304,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v298, v209);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v294, v210);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v295, v211);
  *(_DWORD *)a5 = 1124007936;
  *(_DWORD *)v298 = 16842752;
  *(_OWORD *)(a5 + 4) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 36) = 0u;
  *(_OWORD *)(a5 + 20) = 0u;
  *(_QWORD *)(a5 + 80) = 0LL;
  *(_QWORD *)&v298[16] = 0LL;
  *(_QWORD *)&v298[8] = &v304;
  v297 = 0LL;
  v295[0] = 33619968;
  *(_QWORD *)(a5 + 88) = 0LL;
  *(_QWORD *)(a5 + 64) = a5 + 8;
  *(_QWORD *)(a5 + 72) = a5 + 80;
  v296 = (__int128 *)a5;
  cv::cvtColor(v298, v295, 0LL, 0LL);
  if ( *((_QWORD *)&v307 + 1) )
  {
    v213 = (unsigned int *)(*((_QWORD *)&v307 + 1) + 20LL);
    do
    {
      v214 = __ldaxr(v213);
      v215 = v214 - 1;
    }
    while ( __stlxr(v215, v213) );
    if ( !v215 )
      cv::Mat::deallocate((cv::Mat *)&v304);
  }
  *((_QWORD *)&v307 + 1) = 0LL;
  v305 = 0u;
  v306 = 0u;
  if ( SDWORD1(v304) >= 1 )
  {
    v216 = v308;
    v217 = 0LL;
    do
      v216[v217++] = 0;
    while ( v217 < SDWORD1(v304) );
  }
  if ( v309 != (cv *)v310 )
    cv::fastFree(v309, v212);
  if ( (v270 & 1) != 0 )
    operator delete(v271);
  if ( v315 )
  {
    v218 = (unsigned int *)(v315 + 20);
    do
    {
      v219 = __ldaxr(v218);
      v220 = v219 - 1;
    }
    while ( __stlxr(v220, v218) );
    if ( !v220 )
      cv::Mat::deallocate((cv::Mat *)v311);
  }
  v315 = 0LL;
  v314 = 0u;
  v313 = 0u;
  if ( v312 >= 1 )
  {
    v221 = v316;
    for ( k = 0LL; k < v312; *(_DWORD *)(v221 + 4 * k++) = 0 )
      ;
  }
  if ( v317 != (cv *)&v318 )
    cv::fastFree(v317, v212);
  if ( *(_QWORD *)&v319[56] )
  {
    v223 = (unsigned int *)(*(_QWORD *)&v319[56] + 20LL);
    do
    {
      v224 = __ldaxr(v223);
      v225 = v224 - 1;
    }
    while ( __stlxr(v225, v223) );
    if ( !v225 )
      cv::Mat::deallocate((cv::Mat *)v319);
  }
  *(_QWORD *)&v319[56] = 0LL;
  memset(&v319[16], 0, 32);
  if ( *(int *)&v319[4] >= 1 )
  {
    v226 = v320;
    v227 = 0LL;
    do
      *(_DWORD *)&v226[4 * v227++] = 0;
    while ( v227 < *(int *)&v319[4] );
  }
  if ( v321 != (cv *)v322 )
    cv::fastFree(v321, v212);
  if ( v273 )
  {
    v274 = v273;
    operator delete(v273);
  }
  if ( v276 )
  {
    v277 = (char *)v276;
    operator delete(v276);
  }
  ground_filter::Plane_Seg::~Plane_Seg((ground_filter::Plane_Seg *)v334, v212);
  if ( *(_QWORD *)&v338[56] )
  {
    v229 = (unsigned int *)(*(_QWORD *)&v338[56] + 20LL);
    do
    {
      v230 = __ldaxr(v229);
      v231 = v230 - 1;
    }
    while ( __stlxr(v231, v229) );
    if ( !v231 )
      cv::Mat::deallocate((cv::Mat *)v338);
  }
  *(_QWORD *)&v338[56] = 0LL;
  memset(&v338[16], 0, 32);
  if ( *(int *)&v338[4] >= 1 )
  {
    v232 = v339[0];
    v233 = 0LL;
    do
      *((_DWORD *)v232 + v233++) = 0;
    while ( v233 < *(int *)&v338[4] );
  }
  if ( (__int64 *)v339[1] != &v340 )
    cv::fastFree(v339[1], v228);
  sub_1FD5C(&v278, v228);
  sub_1FD5C(&v281, v234);
  if ( v284 )
  {
    v285 = v284;
    operator delete(v284);
  }
  if ( v342[7] )
  {
    v236 = (unsigned int *)(v342[7] + 20LL);
    do
    {
      v237 = __ldaxr(v236);
      v238 = v237 - 1;
    }
    while ( __stlxr(v238, v236) );
    if ( !v238 )
      cv::Mat::deallocate((cv::Mat *)v342);
  }
  v342[7] = 0LL;
  memset(&v342[2], 0, 32);
  if ( SHIDWORD(v342[0]) >= 1 )
  {
    v239 = v343;
    v240 = 0LL;
    do
      *((_DWORD *)v239 + v240++) = 0;
    while ( v240 < SHIDWORD(v342[0]) );
  }
  if ( v344 != (cv *)v345 )
    cv::fastFree(v344, v235);
  if ( *(_QWORD *)&v346[56] )
  {
    v241 = (unsigned int *)(*(_QWORD *)&v346[56] + 20LL);
    do
    {
      v242 = __ldaxr(v241);
      v243 = v242 - 1;
    }
    while ( __stlxr(v243, v241) );
    if ( !v243 )
      cv::Mat::deallocate((cv::Mat *)v346);
  }
  *(_QWORD *)&v346[56] = 0LL;
  memset(&v346[16], 0, 32);
  if ( *(int *)&v346[4] >= 1 )
  {
    v244 = v347;
    v245 = 0LL;
    do
      *((_DWORD *)v244 + v245++) = 0;
    while ( v245 < *(int *)&v346[4] );
  }
  if ( v348 != (cv *)v349 )
    cv::fastFree(v348, v235);
  if ( *(_QWORD *)&v350[56] )
  {
    v246 = (unsigned int *)(*(_QWORD *)&v350[56] + 20LL);
    do
    {
      v247 = __ldaxr(v246);
      v248 = v247 - 1;
    }
    while ( __stlxr(v248, v246) );
    if ( !v248 )
      cv::Mat::deallocate((cv::Mat *)v350);
  }
  *(_QWORD *)&v350[56] = 0LL;
  memset(&v350[16], 0, 32);
  if ( *(int *)&v350[4] >= 1 )
  {
    v249 = v351;
    v250 = 0LL;
    do
      *(_DWORD *)&v249[4 * v250++] = 0;
    while ( v250 < *(int *)&v350[4] );
  }
  if ( v352 != (cv *)v353 )
    cv::fastFree(v352, v235);
  sub_1FD5C((void **)&v288, v235);
  if ( v291 )
  {
    v292 = v291;
    operator delete(v291);
  }
  feasibal_region::RunOutputParam::~RunOutputParam((feasibal_region::RunOutputParam *)&v354, v251);
  feasibal_region::RunInputParam::~RunInputParam((feasibal_region::RunInputParam *)&v392, v252);
}
// 17094: variable 'v24' is possibly undefined
// 17368: variable 'v40' is possibly undefined
// 17A78: variable 'v72' is possibly undefined
// 17BF4: variable 'v100' is possibly undefined
// 17EB0: variable 'v128' is possibly undefined
// 17F1C: variable 'v141' is possibly undefined
// 181B8: variable 'v5' is possibly undefined
// 18398: variable 'v178' is possibly undefined
// 18518: variable 'v192' is possibly undefined
// 188E4: variable 'v209' is possibly undefined
// 188EC: variable 'v210' is possibly undefined
// 188F4: variable 'v211' is possibly undefined
// 189D0: variable 'v212' is possibly undefined
// 18B68: variable 'v228' is possibly undefined
// 18B78: variable 'v234' is possibly undefined
// 18C00: variable 'v235' is possibly undefined
// 18D1C: variable 'v251' is possibly undefined
// 18D28: variable 'v252' is possibly undefined
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 12C00: using guessed type __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD);
// 12D70: using guessed type __int64 __fastcall cv::rectangle(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 12FF0: using guessed type _QWORD *__fastcall cv::operator-(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13230: using guessed type __int64 __fastcall cv::cvtColor(_QWORD, _QWORD, _QWORD, _QWORD);
// 13330: using guessed type __int64 __fastcall cv::Mat::setTo(_QWORD, _QWORD, _QWORD);
// 133B0: using guessed type __int64 __fastcall cv::putText(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 133C0: using guessed type _QWORD *__fastcall cv::getTextSize(_QWORD *__return_ptr, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 134E0: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, double);
// 13690: using guessed type _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD);
// 70420: using guessed type _QWORD std::cout;
// 16D0C: using guessed type char var_20E4[4];

//----- (00000000000196A8) ----------------------------------------------------
void __fastcall feasibal_region::RunInputParam::RunInputParam(
        feasibal_region::RunInputParam *this,
        __int64 a2,
        __int64 a3,
        int a4)
{
  char *v4; // x22
  void *v5; // x1
  __int64 v6[46]; // [xsp+0h] [xbp-1C0h] BYREF

  v6[44] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_DWORD *)this = 1124007936;
  *(_OWORD *)((char *)this + 4) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 20) = 0u;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_DWORD *)this + 24) = 1124007936;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *(_OWORD *)((char *)this + 132) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *((_QWORD *)this + 22) = 0LL;
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 20) = (char *)this + 104;
  *((_QWORD *)this + 21) = (char *)this + 176;
  *((_DWORD *)this + 48) = 1124007936;
  v4 = (char *)this + 192;
  *(_OWORD *)((char *)this + 196) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 228) = 0u;
  *((_QWORD *)this + 32) = (char *)this + 200;
  *((_QWORD *)this + 34) = 0LL;
  *((_QWORD *)this + 36) = 0LL;
  *((_QWORD *)this + 35) = 0LL;
  *((_QWORD *)this + 33) = (char *)this + 272;
  *((_DWORD *)this + 74) = 1128792064;
  cv::Mat::eye(v6, (cv::Mat *)((unsigned int)&dword_0 + 3), 3, 6, a4);
  (*(void (__fastcall **)(__int64, __int64 *, char *, __int64))(*(_QWORD *)v6[0] + 24LL))(v6[0], v6, v4, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v6, v5);
}
// 197AC: variable 'v5' is possibly undefined
// 0: using guessed type int dword_0;

//----- (0000000000019958) ----------------------------------------------------
cv::Mat *__fastcall cv::Mat::operator=(cv::Mat *this, cv::Mat *a2)
{
  __int64 v3; // x8
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  _QWORD *v12; // x9

  if ( this != a2 )
  {
    v3 = *((_QWORD *)this + 7);
    if ( v3 )
    {
      v5 = (unsigned int *)(v3 + 20);
      do
      {
        v6 = __ldaxr(v5);
        v7 = v6 - 1;
      }
      while ( __stlxr(v7, v5) );
      if ( !v7 )
        cv::Mat::deallocate(this);
    }
    v8 = *((_DWORD *)this + 1);
    *((_QWORD *)this + 7) = 0LL;
    *((_OWORD *)this + 1) = 0u;
    *((_OWORD *)this + 2) = 0u;
    if ( v8 >= 1 )
    {
      v9 = *((_QWORD *)this + 8);
      v10 = 0LL;
      do
        *(_DWORD *)(v9 + 4 * v10++) = 0;
      while ( v10 < *((int *)this + 1) );
    }
    v11 = (cv *)*((_QWORD *)this + 9);
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
    *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
    *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
    if ( v11 != (cv::Mat *)((char *)this + 80) )
    {
      cv::fastFree(v11, a2);
      v11 = (cv::Mat *)((char *)this + 80);
      *((_QWORD *)this + 8) = (char *)this + 8;
      *((_QWORD *)this + 9) = (char *)this + 80;
    }
    if ( *((int *)a2 + 1) <= 2 )
    {
      v12 = (_QWORD *)*((_QWORD *)a2 + 9);
      *(_QWORD *)v11 = *v12;
      *((_QWORD *)v11 + 1) = v12[1];
    }
    else
    {
      *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
      *((_QWORD *)a2 + 8) = (char *)a2 + 8;
      *((_QWORD *)a2 + 9) = (char *)a2 + 80;
    }
    *(_DWORD *)a2 = 1124007936;
    *((_OWORD *)a2 + 3) = 0u;
    *(_OWORD *)((char *)a2 + 20) = 0u;
    *(_OWORD *)((char *)a2 + 36) = 0u;
    *(_OWORD *)((char *)a2 + 4) = 0u;
  }
  return this;
}
// 19A08: variable 'a2' is possibly undefined

//----- (0000000000019A7C) ----------------------------------------------------
cv *__usercall checktool::getExtrinsicParameters@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X2>, __int64 a3@<X8>)
{
  __int64 v4; // x8
  __int64 v5; // x11
  __int64 v6; // x8
  float32x2_t v7; // d2
  double v8; // d4
  float v9; // s3
  float64x2_t v10; // q0
  double v11; // d1
  unsigned __int64 v12; // x9
  float *v13; // x10
  unsigned __int64 v14; // x11
  float64x2_t **v15; // x12
  float32x2_t v16; // d4
  float v17; // t1
  float v18; // s5
  float64x2_t *v19; // t1
  unsigned __int64 v20; // x8
  double v21; // d8
  double v22; // d10
  double v23; // d9
  __int64 v24; // x9
  unsigned int *v25; // x8
  unsigned int v26; // w9
  int v27; // w8
  cv *v28; // x8
  cv *v29; // x10
  void *v30; // x1
  unsigned int *v31; // x8
  unsigned int v32; // w9
  unsigned int v33; // w9
  _QWORD *v34; // x8
  __int64 v35; // x9
  void *v36; // x1
  __int64 v37; // x8
  __int64 v38; // x10
  __int64 v39; // x9
  __int64 v40; // x11
  _QWORD *v41; // x14
  _QWORD *v42; // x12
  _QWORD *v43; // x8
  __int64 v44; // x12
  _QWORD *v45; // x14
  __int128 v46; // q0
  __int64 v47; // x8
  __int128 v48; // q1
  unsigned int *v49; // x8
  unsigned int v50; // w9
  int v51; // w8
  cv *v52; // x8
  _QWORD *v53; // x10
  __int64 v54; // x8
  unsigned int *v55; // x8
  unsigned int v56; // w9
  unsigned int v57; // w9
  _BYTE *v58; // x8
  __int64 v59; // x9
  unsigned int *v60; // x8
  unsigned int v61; // w9
  unsigned int v62; // w9
  __int64 v63; // x8
  __int64 i; // x9
  unsigned int *v65; // x8
  unsigned int v66; // w9
  unsigned int v67; // w9
  _BYTE *v68; // x8
  __int64 v69; // x9
  cv *result; // x0
  int v71[2]; // [xsp+8h] [xbp-228h] BYREF
  __int128 v72[2]; // [xsp+10h] [xbp-220h] BYREF
  _BYTE v73[64]; // [xsp+30h] [xbp-200h] BYREF
  _BYTE *v74; // [xsp+70h] [xbp-1C0h]
  cv *v75; // [xsp+78h] [xbp-1B8h]
  __int64 v76[2]; // [xsp+80h] [xbp-1B0h] BYREF
  _QWORD v77[7]; // [xsp+90h] [xbp-1A0h] BYREF
  __int64 v78; // [xsp+C8h] [xbp-168h]
  _QWORD *v79; // [xsp+D0h] [xbp-160h]
  cv *v80; // [xsp+D8h] [xbp-158h]
  __int64 v81[2]; // [xsp+E0h] [xbp-150h] BYREF
  char v82[4]; // [xsp+F0h] [xbp-140h] BYREF
  int v83; // [xsp+F4h] [xbp-13Ch]
  __int128 v84; // [xsp+100h] [xbp-130h]
  __int128 v85; // [xsp+110h] [xbp-120h]
  __int64 v86; // [xsp+128h] [xbp-108h]
  __int64 v87; // [xsp+130h] [xbp-100h]
  cv *v88; // [xsp+138h] [xbp-F8h]
  __int64 v89; // [xsp+140h] [xbp-F0h] BYREF
  _BYTE v90[64]; // [xsp+150h] [xbp-E0h] BYREF
  _BYTE *v91; // [xsp+190h] [xbp-A0h]
  cv *v92; // [xsp+198h] [xbp-98h]
  __int64 v93[3]; // [xsp+1A0h] [xbp-90h] BYREF
  __int64 v94; // [xsp+1B8h] [xbp-78h]
  float v95; // [xsp+1C0h] [xbp-70h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v94 = 0LL;
  v95 = 0.0;
  v4 = a1[1];
  v5 = v4 - *a1;
  if ( v4 == *a1 )
  {
    v6 = *a2;
    v7.n64_u64[0] = 0LL;
    v8 = 0.0;
    v9 = 0.0;
    v10.n128_u64[0] = 0LL;
    v11 = 0.0;
  }
  else
  {
    v6 = *a2;
    v12 = 0LL;
    v13 = (float *)(*a1 + 8LL);
    v10 = 0uLL;
    v7.n64_u64[0] = 0LL;
    v11 = 0.0;
    v14 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 2);
    v15 = (float64x2_t **)(*a2 + 16LL);
    v9 = 0.0;
    do
    {
      v16.n64_u64[0] = *(_QWORD *)(v13 - 2);
      v17 = *v13;
      v13 += 3;
      v18 = v17;
      v19 = *v15;
      v15 += 12;
      v10 = vaddq_f64(v10, vcvtq_f64_f32(v16));
      ++v12;
      v11 = v11 + v18;
      v7.n64_u64[0] = vcvt_f32_f64(vaddq_f64(*v19, vcvtq_f64_f32(v7))).n64_u64[0];
      v9 = v19[1].n128_f64[0] + v9;
    }
    while ( v12 < v14 );
    v8 = v10.n128_f64[1];
    v94 = v7.n64_u64[0];
    v95 = v9;
  }
  v20 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - v6) >> 5);
  *(_DWORD *)v90 = 1124007936;
  memset(&v90[4], 0, 60);
  v21 = v10.n128_f64[0] / (double)v20;
  v10.n128_f32[0] = (float)v20;
  v22 = v11 / (double)v20;
  v91 = &v90[8];
  v92 = (cv *)v93;
  v93[0] = 0LL;
  v93[1] = 0LL;
  v23 = v8 / (double)v20;
  v94 = vdiv_f32(v7, vdup_lane_s32((int32x2_t)v10.n128_u64[0], 0)).n64_i64[0];
  v95 = v9 / (float)v20;
  *(_QWORD *)v71 = 0x300000001LL;
  cv::Mat::create((cv::Mat *)v90, 2, v71, 6);
  v24 = *(_QWORD *)&v90[16];
  **(double **)&v90[16] = v21;
  *(double *)(v24 + 8) = v23;
  *(double *)(v24 + 16) = v22;
  *(_OWORD *)v77 = *(_OWORD *)v90;
  v77[2] = v24;
  *(_OWORD *)&v77[3] = *(_OWORD *)&v90[24];
  *(_OWORD *)&v77[5] = *(_OWORD *)&v90[40];
  v78 = *(_QWORD *)&v90[56];
  v79 = &v77[1];
  v80 = (cv *)v81;
  v81[0] = 0LL;
  v81[1] = 0LL;
  if ( *(_QWORD *)&v90[56] )
  {
    v25 = (unsigned int *)(*(_QWORD *)&v90[56] + 20LL);
    do
      v26 = __ldaxr(v25);
    while ( __stlxr(v26 + 1, v25) );
    v27 = *(_DWORD *)&v90[4];
  }
  else
  {
    v27 = *(_DWORD *)&v90[4];
  }
  if ( v27 > 2 )
  {
    HIDWORD(v77[0]) = 0;
    cv::Mat::copySize((cv::Mat *)v77, (const cv::Mat *)v90);
  }
  else
  {
    v28 = v92;
    v29 = v80;
    *(_QWORD *)v80 = *(_QWORD *)v92;
    *((_QWORD *)v29 + 1) = *((_QWORD *)v28 + 1);
  }
  eulerAnglestoRotationMtx((__int64)v77, (__int64)v82);
  if ( v78 )
  {
    v31 = (unsigned int *)(v78 + 20);
    do
    {
      v32 = __ldaxr(v31);
      v33 = v32 - 1;
    }
    while ( __stlxr(v33, v31) );
    if ( !v33 )
      cv::Mat::deallocate((cv::Mat *)v77);
  }
  v78 = 0LL;
  memset(&v77[2], 0, 32);
  if ( SHIDWORD(v77[0]) >= 1 )
  {
    v34 = v79;
    v35 = 0LL;
    do
      *((_DWORD *)v34 + v35++) = 0;
    while ( v35 < SHIDWORD(v77[0]) );
  }
  if ( v80 != (cv *)v81 )
    cv::fastFree(v80, v30);
  *(_DWORD *)v73 = 1124007936;
  memset(v72, 0, sizeof(v72));
  memset(&v73[4], 0, 60);
  v74 = &v73[8];
  v75 = (cv *)v76;
  v76[0] = 0LL;
  v76[1] = 0LL;
  *(_QWORD *)v71 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v73, 2, v71, 6);
  cv::Mat::operator=(v73, v72);
  v37 = v84;
  v38 = *(_QWORD *)&v73[16];
  v39 = *(_QWORD *)v88;
  v40 = *(_QWORD *)v75;
  **(_QWORD **)&v73[16] = *(_QWORD *)v84;
  v41 = (_QWORD *)(v38 + v40);
  *(_QWORD *)(v38 + 8) = *(_QWORD *)(v37 + 8);
  *(_QWORD *)(v38 + 16) = *(_QWORD *)(v37 + 16);
  v42 = (_QWORD *)(v37 + v39);
  v43 = (_QWORD *)(v37 + 2 * v39);
  *(double *)(v38 + 24) = *(float *)&v94;
  *v41 = *v42;
  v41[1] = v42[1];
  v41[2] = v42[2];
  v44 = v38 + 24;
  v45 = (_QWORD *)(v38 + 2 * v40);
  *(double *)(v44 + v40) = *((float *)&v94 + 1);
  *v45 = *v43;
  v45[1] = v43[1];
  v45[2] = v43[2];
  *(double *)(v44 + 2 * v40) = v95;
  *(_QWORD *)(v38 + 3 * v40 + 24) = 0x3FF0000000000000LL;
  v46 = *(_OWORD *)v73;
  v47 = *(_QWORD *)&v73[56];
  *(_OWORD *)(a3 + 24) = *(_OWORD *)&v73[24];
  v48 = *(_OWORD *)&v73[40];
  *(_QWORD *)(a3 + 16) = v38;
  *(_OWORD *)a3 = v46;
  *(_OWORD *)(a3 + 40) = v48;
  *(_QWORD *)(a3 + 80) = 0LL;
  *(_QWORD *)(a3 + 64) = a3 + 8;
  *(_QWORD *)(a3 + 72) = a3 + 80;
  *(_QWORD *)(a3 + 56) = v47;
  *(_QWORD *)(a3 + 88) = 0LL;
  if ( v47 )
  {
    v49 = (unsigned int *)(v47 + 20);
    do
      v50 = __ldaxr(v49);
    while ( __stlxr(v50 + 1, v49) );
    v51 = *(_DWORD *)&v73[4];
  }
  else
  {
    v51 = DWORD1(v46);
  }
  if ( v51 > 2 )
  {
    *(_DWORD *)(a3 + 4) = 0;
    cv::Mat::copySize((cv::Mat *)a3, (const cv::Mat *)v73);
  }
  else
  {
    v52 = v75;
    v53 = *(_QWORD **)(a3 + 72);
    *v53 = *(_QWORD *)v75;
    v53[1] = *((_QWORD *)v52 + 1);
  }
  v54 = *(_QWORD *)&v73[56];
  *(_DWORD *)(a3 + 96) = 0;
  if ( v54 )
  {
    v55 = (unsigned int *)(v54 + 20);
    do
    {
      v56 = __ldaxr(v55);
      v57 = v56 - 1;
    }
    while ( __stlxr(v57, v55) );
    if ( !v57 )
      cv::Mat::deallocate((cv::Mat *)v73);
  }
  *(_QWORD *)&v73[56] = 0LL;
  memset(&v73[16], 0, 32);
  if ( *(int *)&v73[4] >= 1 )
  {
    v58 = v74;
    v59 = 0LL;
    do
      *(_DWORD *)&v58[4 * v59++] = 0;
    while ( v59 < *(int *)&v73[4] );
  }
  if ( v75 != (cv *)v76 )
    cv::fastFree(v75, v36);
  if ( v86 )
  {
    v60 = (unsigned int *)(v86 + 20);
    do
    {
      v61 = __ldaxr(v60);
      v62 = v61 - 1;
    }
    while ( __stlxr(v62, v60) );
    if ( !v62 )
      cv::Mat::deallocate((cv::Mat *)v82);
  }
  v86 = 0LL;
  v84 = 0u;
  v85 = 0u;
  if ( v83 >= 1 )
  {
    v63 = v87;
    for ( i = 0LL; i < v83; *(_DWORD *)(v63 + 4 * i++) = 0 )
      ;
  }
  if ( v88 != (cv *)&v89 )
    cv::fastFree(v88, v36);
  if ( *(_QWORD *)&v90[56] )
  {
    v65 = (unsigned int *)(*(_QWORD *)&v90[56] + 20LL);
    do
    {
      v66 = __ldaxr(v65);
      v67 = v66 - 1;
    }
    while ( __stlxr(v67, v65) );
    if ( !v67 )
      cv::Mat::deallocate((cv::Mat *)v90);
  }
  *(_QWORD *)&v90[56] = 0LL;
  memset(&v90[16], 0, 32);
  if ( *(int *)&v90[4] >= 1 )
  {
    v68 = v91;
    v69 = 0LL;
    do
      *(_DWORD *)&v68[4 * v69++] = 0;
    while ( v69 < *(int *)&v90[4] );
  }
  result = v92;
  if ( v92 != (cv *)v93 )
    return (cv *)cv::fastFree(v92, v36);
  return result;
}
// 19D14: variable 'v30' is possibly undefined
// 19F20: variable 'v36' is possibly undefined
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);

//----- (000000000001A248) ----------------------------------------------------
__int64 __fastcall checktool::getNearEdge(__int64 a1, __int64 *a2, int a3)
{
  __int64 v4; // x8
  int *v5; // x0
  char *v6; // x8
  unsigned __int64 v8; // x25
  __int64 v9; // x1
  __int64 v10; // x10
  unsigned int *v11; // x10
  unsigned int v12; // w11
  _QWORD *v13; // x8
  cv *v14; // x10
  __int64 v15; // x9
  int v16; // w8
  __int64 v17; // x10
  unsigned __int64 v18; // x12
  __int64 v19; // x15
  unsigned __int64 v20; // x14
  unsigned __int64 v21; // x13
  unsigned __int64 v22; // x16
  bool v23; // w17
  unsigned __int64 v24; // x14
  bool v25; // w16
  __int64 v26; // x0
  unsigned __int64 v27; // x2
  int8x16_t v28; // q0
  unsigned __int64 v29; // x1
  __int64 v30; // x2
  int8x16_t v31; // q1
  int8x16_t v32; // q4
  int8x16_t *v33; // x3
  int8x16_t v34; // q0
  int8x16_t v35; // q0
  int8x16_t v36; // q0
  int8x16_t v37; // q0
  __int64 v38; // x3
  int v39; // w4
  int *v40; // x9
  __int64 v41; // x8
  unsigned int *v42; // x8
  unsigned int v43; // w9
  unsigned int v44; // w9
  __int64 v45; // x8
  __int64 v46; // x9
  int *v47; // x10
  int *v48; // x9
  int *v49; // x11
  int v50; // t1
  double v51; // d8
  int v53; // [xsp+14h] [xbp-ECh] BYREF
  void *v54; // [xsp+18h] [xbp-E8h] BYREF
  int *v55; // [xsp+20h] [xbp-E0h]
  int *v56; // [xsp+28h] [xbp-D8h]
  __int128 v57; // [xsp+30h] [xbp-D0h] BYREF
  __int128 v58; // [xsp+40h] [xbp-C0h]
  __int128 v59; // [xsp+50h] [xbp-B0h]
  __int64 v60; // [xsp+60h] [xbp-A0h]
  __int64 v61; // [xsp+68h] [xbp-98h]
  __int64 v62; // [xsp+70h] [xbp-90h]
  cv *v63; // [xsp+78h] [xbp-88h]
  _QWORD v64[4]; // [xsp+80h] [xbp-80h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v55 = 0LL;
  v56 = 0LL;
  v54 = 0LL;
  v4 = *a2;
  if ( a2[1] == *a2 )
  {
    v5 = 0LL;
    v6 = 0LL;
    goto LABEL_40;
  }
  v8 = 0LL;
  do
  {
    v9 = v4 + 96 * v8;
    v57 = *(_OWORD *)v9;
    v58 = *(_OWORD *)(v9 + 16);
    v59 = *(_OWORD *)(v9 + 32);
    v60 = *(_QWORD *)(v9 + 48);
    v10 = *(_QWORD *)(v9 + 56);
    v63 = (cv *)v64;
    v61 = v10;
    v62 = (__int64)&v57 + 8;
    v64[0] = 0LL;
    v64[1] = 0LL;
    if ( v10 )
    {
      v11 = (unsigned int *)(v10 + 20);
      do
        v12 = __ldaxr(v11);
      while ( __stlxr(v12 + 1, v11) );
    }
    if ( *(int *)(v9 + 4) > 2 )
    {
      DWORD1(v57) = 0;
      cv::Mat::copySize((cv::Mat *)&v57, (const cv::Mat *)v9);
    }
    else
    {
      v13 = *(_QWORD **)(v4 + 96 * v8 + 72);
      v14 = v63;
      *(_QWORD *)v63 = *v13;
      *((_QWORD *)v14 + 1) = v13[1];
    }
    v53 = 0;
    v15 = SDWORD2(v57) - 1LL;
    v16 = 0;
    if ( DWORD2(v57) != 1 )
    {
      v17 = (unsigned int)(int)((double)SHIDWORD(v57) * 0.2);
      v18 = HIDWORD(v57) - (int)v17;
      if ( (int)v17 + 1LL >= v18 )
        v19 = (int)v17 + 1LL;
      else
        v19 = HIDWORD(v57) - (int)v17;
      v20 = v19 + ~(__int64)(int)v17;
      v21 = v19 - (int)v17;
      v22 = HIDWORD(v20);
      v23 = (int)v17 + (int)v20 < (int)v17;
      v24 = v21 & 0xFFFFFFFFFFFFFFE0LL;
      v25 = v23 || v22 != 0;
      while ( (unsigned int)v18 > (unsigned int)v17 )
      {
        v26 = v58 + *(_QWORD *)v63 * (int)v15;
        if ( v21 < 0x20 || v25 )
        {
          LODWORD(v9) = 0;
          v27 = (int)v17;
        }
        else
        {
          v28 = 0uLL;
          v29 = v21 & 0xFFFFFFFFFFFFFFE0LL;
          v30 = v17 << 32;
          v31 = 0uLL;
          v32.n128_u64[0] = 0x101010101010101LL;
          v32.n128_u64[1] = 0x101010101010101LL;
          do
          {
            v33 = (int8x16_t *)(v26 + (v30 >> 32));
            v29 -= 32LL;
            v30 += 0x2000000000LL;
            v28 = vorrq_s8(v28, vmvnq_s8(vceqq_s8(*v33, v32)));
            v31 = vorrq_s8(v31, vmvnq_s8(vceqq_s8(v33[1], v32)));
          }
          while ( v29 );
          v34 = vorrq_s8(v31, v28);
          v35 = vorrq_s8(v34, vextq_s8(v34, v34, 8uLL));
          v36 = vorrq_s8(v35, vextq_s8(v35, v35, 4uLL));
          v37 = vorrq_s8(v36, vextq_s8(v36, v36, 2uLL));
          v9 = vorrq_s8(v37, vdupq_lane_s8((int8x8_t)v37.n128_u64[0], 1)).n128_u8[0];
          v27 = v24 + (int)v17;
          if ( v21 == v24 )
            goto LABEL_23;
        }
        v38 = v27 << 32;
        do
        {
          v39 = *(unsigned __int8 *)(v26 + (v38 >> 32));
          ++v27;
          v38 += 0x100000000LL;
          v9 = (unsigned int)v9 | (v39 != 1);
        }
        while ( v27 < v18 );
LABEL_23:
        if ( (v9 & 1) != 0 )
        {
          ++v16;
          --v15;
          v53 = v16;
          if ( v15 )
            continue;
        }
        break;
      }
    }
    v40 = v55;
    if ( v55 == v56 )
    {
      std::vector<int>::__push_back_slow_path<int const&>((__int64)&v54, &v53);
      v41 = v61;
      if ( !v61 )
        goto LABEL_33;
    }
    else
    {
      *v55 = v16;
      v55 = v40 + 1;
      v41 = v61;
      if ( !v61 )
        goto LABEL_33;
    }
    v42 = (unsigned int *)(v41 + 20);
    do
    {
      v43 = __ldaxr(v42);
      v44 = v43 - 1;
    }
    while ( __stlxr(v44, v42) );
    if ( !v44 )
      cv::Mat::deallocate((cv::Mat *)&v57);
LABEL_33:
    v61 = 0LL;
    v58 = 0u;
    v59 = 0u;
    if ( SDWORD1(v57) >= 1 )
    {
      v45 = v62;
      v46 = 0LL;
      do
        *(_DWORD *)(v45 + 4 * v46++) = 0;
      while ( v46 < SDWORD1(v57) );
    }
    if ( v63 != (cv *)v64 )
      cv::fastFree(v63, (void *)v9);
    v4 = *a2;
    ++v8;
  }
  while ( v8 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) );
  v5 = (int *)v54;
  v6 = (char *)v55;
LABEL_40:
  if ( (unsigned __int64)((v6 - (char *)v5) >> 2) <= 1 )
  {
    v51 = 0.5;
    if ( v5 )
      goto LABEL_52;
  }
  else
  {
    if ( v5 == (int *)v6 )
    {
      v48 = v5;
    }
    else
    {
      v47 = v5 + 1;
      v48 = v5;
      if ( v5 + 1 != (int *)v6 )
      {
        v49 = v5 + 1;
        do
        {
          v50 = *v49++;
          if ( *v48 < v50 )
            v48 = v47;
          v47 = v49;
        }
        while ( v6 != (char *)v49 );
      }
    }
    v51 = (float)*v48 + 0.5;
    if ( v5 )
    {
LABEL_52:
      v55 = v5;
      operator delete(v5);
    }
  }
  return (unsigned int)(int)(v51 * (double)a3);
}
// 1A54C: variable 'v9' is possibly undefined

//----- (000000000001A6D0) ----------------------------------------------------
void __usercall checktool::getPointCloud(float *a1@<X1>, __int64 a2@<X2>, int a3@<W3>, _QWORD *a4@<X8>, double a5@<D0>)
{
  float v8; // s11
  float v9; // s12
  float v10; // s8
  float v11; // s9
  int v12; // w23
  int v13; // w25
  int v14; // w8
  __int64 v15; // x24
  __int64 v16; // x0
  __int64 v17; // x24
  double v18; // d11
  double v19; // d12
  __int64 v20; // x25
  double v21; // d13
  float *v22; // x8
  float *v23; // x9
  double v24; // d0
  double v25; // d2
  float v26; // s3
  float v27; // s1
  int v28; // [xsp+8h] [xbp-88h] BYREF
  float v29; // [xsp+Ch] [xbp-84h]
  float v30; // [xsp+10h] [xbp-80h]
  __int64 v31; // [xsp+18h] [xbp-78h]

  v31 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *a1;
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  a4[1] = 0LL;
  a4[2] = 0LL;
  *a4 = 0LL;
  v13 = *(_DWORD *)(a2 + 8);
  v12 = *(_DWORD *)(a2 + 12);
  v14 = v12 * v13 / (a3 * a3);
  if ( v14 )
  {
    v15 = v14;
    if ( v14 < 0 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v16 = operator new(12LL * v14);
    *a4 = v16;
    a4[1] = v16;
    a4[2] = v16 + 12 * v15;
  }
  if ( v13 >= 1 )
  {
    v17 = 0LL;
    v18 = v8;
    v19 = v9;
    do
    {
      if ( v12 >= 1 )
      {
        *(float *)&a5 = (float)(int)v17 - v11;
        v20 = 0LL;
        v21 = *(float *)&a5;
        do
        {
          LOWORD(a5) = *(_WORD *)(*(_QWORD *)(a2 + 16) + v17 * **(_QWORD **)(a2 + 72) + 2 * v20);
          v22 = (float *)a4[1];
          v23 = (float *)a4[2];
          v24 = (double)*(unsigned __int64 *)&a5 * 0.001;
          v25 = v24 * v21;
          v26 = v24;
          a5 = v24 * (float)((float)(int)v20 - v10) / v18;
          *(float *)&a5 = a5;
          v27 = v25 / v19;
          v28 = LODWORD(a5);
          v29 = v27;
          v30 = v26;
          if ( v22 == v23 )
          {
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
              (__int64)a4,
              (__int64)&v28);
            v12 = *(_DWORD *)(a2 + 12);
          }
          else
          {
            *v22 = *(float *)&a5;
            v22[1] = v29;
            v22[2] = v30;
            a4[1] = v22 + 3;
          }
          v20 += a3;
        }
        while ( v20 < v12 );
        v13 = *(_DWORD *)(a2 + 8);
      }
      v17 += a3;
    }
    while ( v17 < v13 );
  }
}
// 1A7B4: variable 'a5' is possibly undefined

//----- (000000000001A89C) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, long double a2)
{
  _QWORD *v3; // x8
  char *v4; // x9
  _QWORD *v5; // x0
  __int64 v7; // x20
  char *v8; // x21
  __int64 v9; // x22
  __int64 v10; // x0
  unsigned __int8 v11; // w23
  char v13[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v14; // [xsp+8h] [xbp-58h]
  _QWORD v15[2]; // [xsp+10h] [xbp-50h] BYREF

  v15[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13[0] = 0;
  v14 = a1;
  v3 = (_QWORD *)(*a1 - 24LL);
  v4 = (char *)a1 + *v3;
  if ( !*((_DWORD *)v4 + 8) )
  {
    v5 = (_QWORD *)*((_QWORD *)v4 + 17);
    if ( v5 )
    {
      std::ostream::flush(v5);
      v3 = (_QWORD *)(*a1 - 24LL);
    }
    v13[0] = 1;
    std::ios_base::getloc(v15, (std::ios_base *)((char *)a1 + *v3));
    v7 = std::locale::use_facet(v15, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v15);
    v8 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v9 = *((_QWORD *)v8 + 5);
    if ( *((_DWORD *)v8 + 36) == -1 )
    {
      std::ios_base::getloc(v15, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v10 = std::locale::use_facet(v15, &std::ctype<char>::id);
      v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 56LL))(v10, 32LL);
      std::locale::~locale((std::locale *)v15);
      *((_DWORD *)v8 + 36) = v11;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *, long double))(*(_QWORD *)v7 + 64LL))(v7, v9, v8, a2) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v13);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 1A89C: using guessed type char var_60[8];

//----- (000000000001AA68) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 24LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 1AA68: using guessed type char var_60[8];

//----- (000000000001AC34) ----------------------------------------------------
void __usercall getColorDepthImage(const cv::Mat *a1@<X0>, int a2@<W1>, int a3@<W2>, __int64 a4@<X8>)
{
  __int64 v7; // x8
  int v9; // w26
  int v10; // w27
  int *v11; // x9
  int *v12; // x8
  int i; // w28
  int v14; // w11
  __int64 v15; // x13
  __int64 j; // x8
  __int64 v17; // x11
  __int64 v18; // x12
  unsigned __int64 v19; // x13
  _DWORD *v20; // x13
  int v21; // w13
  int v22[2]; // [xsp+8h] [xbp-88h] BYREF
  void *v23[2]; // [xsp+10h] [xbp-80h] BYREF
  __int128 v24; // [xsp+20h] [xbp-70h]
  __int64 v25; // [xsp+38h] [xbp-58h]

  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = **((_QWORD **)a1 + 8);
  *(_DWORD *)a4 = 1124007936;
  *(_OWORD *)(a4 + 4) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 36) = 0u;
  *(_OWORD *)(a4 + 20) = 0u;
  *(_QWORD *)(a4 + 80) = 0LL;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  *(_QWORD *)(a4 + 64) = a4 + 8;
  *(_QWORD *)(a4 + 72) = a4 + 80;
  *(_QWORD *)(a4 + 88) = 0LL;
  *(_QWORD *)v22 = v7;
  cv::Mat::create((cv::Mat *)a4, 2, v22, 16);
  cv::Mat::operator=(a4, v23);
  v9 = a3 - a2;
  v23[0] = 0LL;
  v23[1] = 0LL;
  *(_QWORD *)&v24 = 0LL;
  if ( a3 >= a2 )
  {
    v10 = 0;
    v11 = 0LL;
    v12 = 0LL;
    for ( i = a2; ; ++i )
    {
      v22[0] = v10 / v9;
      if ( v12 == v11 )
      {
        std::vector<int>::__push_back_slow_path<int const&>((__int64)v23, v22);
        if ( i >= a3 )
          break;
      }
      else
      {
        *v12 = v10 / v9;
        v23[1] = v12 + 1;
        if ( i >= a3 )
          break;
      }
      v12 = (int *)v23[1];
      v11 = (int *)v24;
      v10 += 255;
    }
  }
  v14 = *((_DWORD *)a1 + 2);
  if ( v14 > 0 )
  {
    LODWORD(v15) = *((_DWORD *)a1 + 3);
    for ( j = 0LL; j < v14; ++j )
    {
      if ( (int)v15 >= 1 )
      {
        v17 = 0LL;
        v18 = 0LL;
        do
        {
          v19 = *(__int16 *)(*((_QWORD *)a1 + 2) + j * **((_QWORD **)a1 + 9) + 2 * v18) - (__int64)a2;
          if ( (v19 & 0x80000000) != 0 || v19 >= ((char *)v23[1] - (char *)v23[0]) >> 2 )
          {
            LOBYTE(v21) = 0;
            *(_BYTE *)(*(_QWORD *)(a4 + 16) + j * **(_QWORD **)(a4 + 72) + v17) = 0;
            *(_BYTE *)(*(_QWORD *)(a4 + 16) + j * **(_QWORD **)(a4 + 72) + v17 + 1) = 0;
          }
          else
          {
            v20 = (_DWORD *)((char *)&colormap + 12 * *((int *)v23[0] + v19));
            *(_BYTE *)(*(_QWORD *)(a4 + 16) + j * **(_QWORD **)(a4 + 72) + v17) = *v20;
            *(_BYTE *)(*(_QWORD *)(a4 + 16) + j * **(_QWORD **)(a4 + 72) + v17 + 1) = v20[1];
            v21 = v20[2];
          }
          ++v18;
          *(_BYTE *)(*(_QWORD *)(a4 + 16) + j * **(_QWORD **)(a4 + 72) + v17 + 2) = v21;
          v15 = *((int *)a1 + 3);
          v17 += 3LL;
        }
        while ( v18 < v15 );
        v14 = *((_DWORD *)a1 + 2);
      }
    }
  }
  if ( v23[0] )
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
}
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);

//----- (000000000001AF38) ----------------------------------------------------
__int64 __fastcall checktool::saveResults(__int64 a1, unsigned __int8 *a2)
{
  __int64 v3; // x8
  __int64 v4; // x13
  __int64 v5; // x12
  int64x2_t v6; // q1
  _QWORD *v7; // x13
  __int64 v8; // x14
  int64x2_t v9; // q0
  __int64 v10; // d2
  __int64 v11; // x10
  int *v12; // x11
  __int64 v13; // t1
  _QWORD *v14; // x8
  cv::Mat *v15; // x1
  __int64 v16; // x9
  unsigned __int64 v17; // x10
  _QWORD *v18; // x9
  void *v19; // x1
  unsigned int *v20; // x8
  unsigned int v21; // w9
  unsigned int v22; // w9
  __int64 v23; // x8
  __int64 v24; // x9
  int v25; // w9
  __int128 v26; // q0
  cv *v27; // x0
  unsigned int *v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w9
  __int64 v31; // x8
  __int64 v32; // x9
  int v33; // w8
  __int64 v34; // x8
  __int64 v35; // x8
  __int64 v36; // x13
  __int64 v37; // x13
  __int64 v38; // x12
  __int64 v39; // x12
  int64x2_t v40; // q1
  _QWORD *v41; // x13
  __int64 v42; // x14
  int64x2_t v43; // q0
  __int64 v44; // d2
  __int64 v45; // x10
  int *v46; // x11
  __int64 v47; // t1
  _QWORD *v48; // x8
  cv::Mat *v49; // x1
  __int64 v50; // x9
  unsigned __int64 v51; // x10
  _QWORD *v52; // x9
  void *v53; // x1
  unsigned int *v54; // x8
  unsigned int v55; // w9
  unsigned int v56; // w9
  __int64 v57; // x8
  __int64 v58; // x9
  int v59; // w9
  __int128 v60; // q0
  cv *v61; // x0
  unsigned int *v62; // x8
  unsigned int v63; // w9
  unsigned int v64; // w9
  __int64 v65; // x8
  __int64 v66; // x9
  int64x2_t v67; // q1
  _QWORD *v68; // x13
  __int64 v69; // x14
  int64x2_t v70; // q0
  __int64 v71; // d2
  __int64 v72; // x10
  int *v73; // x11
  __int64 v74; // t1
  _QWORD *v75; // x8
  cv::Mat *v76; // x1
  __int64 v77; // x9
  unsigned __int64 v78; // x10
  _QWORD *v79; // x9
  void *v80; // x1
  unsigned int *v81; // x8
  unsigned int v82; // w9
  unsigned int v83; // w9
  __int64 v84; // x8
  __int64 v85; // x9
  int v86; // w9
  __int128 v87; // q0
  cv *v88; // x0
  unsigned int *v89; // x8
  unsigned int v90; // w9
  unsigned int v91; // w9
  __int64 v92; // x8
  __int64 v93; // x9
  __int64 v94; // x8
  __int64 v95; // x13
  __int64 v96; // x12
  int64x2_t v97; // q1
  _QWORD *v98; // x13
  __int64 v99; // x14
  int64x2_t v100; // q0
  __int64 v101; // d2
  __int64 v102; // x10
  int *v103; // x11
  __int64 v104; // t1
  _QWORD *v105; // x8
  cv::Mat *v106; // x1
  __int64 v107; // x9
  unsigned __int64 v108; // x10
  _QWORD *v109; // x9
  void *v110; // x1
  unsigned int *v111; // x8
  unsigned int v112; // w9
  unsigned int v113; // w9
  __int64 v114; // x8
  __int64 v115; // x9
  int v116; // w9
  __int128 v117; // q0
  cv *v118; // x0
  unsigned int *v119; // x8
  unsigned int v120; // w9
  unsigned int v121; // w9
  __int64 v122; // x8
  __int64 v123; // x9
  __int64 v124; // x8
  __int64 v125; // x13
  __int64 v126; // x12
  int64x2_t v127; // q1
  _QWORD *v128; // x13
  __int64 v129; // x14
  int64x2_t v130; // q0
  __int64 v131; // d2
  __int64 v132; // x10
  int *v133; // x11
  __int64 v134; // t1
  _QWORD *v135; // x8
  cv::Mat *v136; // x1
  __int64 v137; // x9
  unsigned __int64 v138; // x10
  _QWORD *v139; // x9
  _QWORD *v140; // x8
  _QWORD *v141; // x9
  _QWORD *v142; // x8
  _QWORD *v143; // x9
  _QWORD *v144; // x8
  _QWORD *v145; // x9
  void *v146; // x1
  cv *v147; // x0
  __int128 v148; // q0
  unsigned int *v149; // x8
  unsigned int v150; // w9
  unsigned int v151; // w9
  __int64 v152; // x8
  __int64 v153; // x9
  __int64 v154; // x8
  __int64 v155; // x13
  __int64 v156; // x12
  int64x2_t v157; // q1
  _QWORD *v158; // x13
  __int64 v159; // x14
  int64x2_t v160; // q0
  __int64 v161; // d2
  __int64 v162; // x10
  int *v163; // x11
  __int64 v164; // t1
  _QWORD *v165; // x8
  cv::Mat *v166; // x1
  __int64 v167; // x9
  unsigned __int64 v168; // x10
  _QWORD *v169; // x9
  _QWORD *v170; // x8
  _QWORD *v171; // x9
  _QWORD *v172; // x8
  _QWORD *v173; // x9
  _QWORD *v174; // x8
  _QWORD *v175; // x9
  void *v176; // x1
  cv *v177; // x0
  __int128 v178; // q0
  unsigned int *v179; // x8
  unsigned int v180; // w9
  unsigned int v181; // w9
  __int64 v182; // x8
  __int64 v183; // x9
  __int64 v184; // x8
  __int64 v185; // x13
  __int64 v186; // x12
  int64x2_t v187; // q1
  _QWORD *v188; // x13
  __int64 v189; // x14
  int64x2_t v190; // q0
  __int64 v191; // d2
  __int64 v192; // x10
  int *v193; // x11
  __int64 v194; // t1
  _QWORD *v195; // x8
  cv::Mat *v196; // x1
  __int64 v197; // x9
  unsigned __int64 v198; // x10
  _QWORD *v199; // x9
  void *v200; // x1
  cv *v201; // x0
  __int128 v202; // q0
  unsigned int *v203; // x8
  unsigned int v204; // w9
  unsigned int v205; // w9
  __int64 v206; // x8
  __int64 v207; // x9
  __int64 v208; // x8
  __int64 v209; // x13
  __int64 v210; // x12
  int64x2_t v211; // q1
  _QWORD *v212; // x13
  __int64 v213; // x14
  int64x2_t v214; // q0
  __int64 v215; // d2
  __int64 v216; // x10
  int *v217; // x11
  __int64 v218; // t1
  _QWORD *v219; // x8
  cv::Mat *v220; // x1
  __int64 v221; // x9
  unsigned __int64 v222; // x10
  _QWORD *v223; // x9
  _QWORD *v224; // x8
  _QWORD *v225; // x9
  _QWORD *v226; // x8
  _QWORD *v227; // x9
  _QWORD *v228; // x8
  _QWORD *v229; // x9
  _QWORD *v230; // x8
  _QWORD *v231; // x9
  _QWORD *v232; // x8
  _QWORD *v233; // x9
  _QWORD *v234; // x8
  _QWORD *v235; // x9
  _QWORD *v236; // x8
  void *v237; // x1
  cv *v238; // x0
  __int128 v239; // q0
  unsigned int *v240; // x8
  unsigned int v241; // w9
  unsigned int v242; // w9
  _BYTE *v243; // x8
  __int64 v244; // x9
  _DWORD *v245; // x20
  _DWORD *v246; // x20
  _DWORD *v247; // x20
  __int64 v248; // x0
  _DWORD *v249; // x20
  __int64 v250; // x0
  __int64 v251; // x9
  __int64 v252; // x20
  __int64 v253; // x8
  double v254; // d9
  double v255; // d10
  double v256; // d8
  _DWORD *v257; // x20
  _DWORD *v258; // x20
  _DWORD *v259; // x20
  _DWORD *v260; // x20
  _DWORD *v261; // x20
  int v262; // w8
  _DWORD *v263; // x20
  _DWORD *v264; // x20
  _DWORD *v265; // x20
  _DWORD *v266; // x20
  int v267; // w8
  _DWORD *v268; // x20
  _DWORD *v269; // x20
  _DWORD *v270; // x20
  _DWORD *v271; // x20
  _DWORD *v272; // x20
  _DWORD *v273; // x20
  _DWORD *v274; // x20
  _DWORD *v275; // x20
  _DWORD *v276; // x20
  _DWORD *v277; // x20
  _DWORD *v278; // x20
  _DWORD *v279; // x20
  _DWORD *v280; // x19
  void *v281; // x1
  unsigned int *v282; // x8
  unsigned int v283; // w9
  unsigned int v284; // w9
  __int64 v285; // x8
  __int64 v286; // x9
  unsigned int *v287; // x8
  unsigned int v288; // w9
  unsigned int v289; // w9
  __int64 v290; // x8
  __int64 v291; // x9
  unsigned int *v292; // x8
  unsigned int v293; // w9
  unsigned int v294; // w9
  __int64 v295; // x8
  __int64 v296; // x9
  unsigned int *v297; // x8
  unsigned int v298; // w9
  unsigned int v299; // w9
  __int64 v300; // x8
  __int64 v301; // x9
  unsigned int *v302; // x8
  unsigned int v303; // w9
  unsigned int v304; // w9
  __int64 v305; // x8
  __int64 v306; // x9
  unsigned int *v307; // x8
  unsigned int v308; // w9
  unsigned int v309; // w9
  __int64 v310; // x8
  __int64 v311; // x9
  void *v313; // x1
  struct _Unwind_Exception *v314; // x19
  __int64 v315; // x8
  unsigned int *v316; // x8
  unsigned int v317; // w9
  unsigned int v318; // w9
  __int64 v319; // x8
  __int64 v320; // x9
  unsigned int *v321; // x8
  unsigned int v322; // w9
  unsigned int v323; // w9
  __int64 v324; // x8
  __int64 v325; // x9
  unsigned int *v326; // x8
  unsigned int v327; // w9
  unsigned int v328; // w9
  __int64 v329; // x8
  __int64 v330; // x9
  unsigned int *v331; // x8
  unsigned int v332; // w9
  unsigned int v333; // w9
  __int64 v334; // x8
  __int64 v335; // x9
  unsigned int *v336; // x8
  unsigned int v337; // w9
  unsigned int v338; // w9
  __int64 v339; // x8
  __int64 v340; // x9
  unsigned int *v341; // x8
  unsigned int v342; // w9
  unsigned int v343; // w9
  __int64 v344; // x8
  __int64 v345; // x9
  cv::Mat *v346; // [xsp+58h] [xbp-438h] BYREF
  __int64 v347; // [xsp+60h] [xbp-430h]
  _QWORD *v348; // [xsp+68h] [xbp-428h]
  __int64 v349; // [xsp+70h] [xbp-420h]
  unsigned __int64 v350; // [xsp+78h] [xbp-418h]
  char v351[56]; // [xsp+80h] [xbp-410h] BYREF
  __int64 v352[2]; // [xsp+B8h] [xbp-3D8h] BYREF
  void *v353; // [xsp+C8h] [xbp-3C8h]
  int v354[2]; // [xsp+D0h] [xbp-3C0h] BYREF
  cv::Mat *v355; // [xsp+D8h] [xbp-3B8h] BYREF
  __int64 v356; // [xsp+E0h] [xbp-3B0h]
  _QWORD *v357; // [xsp+E8h] [xbp-3A8h]
  __int64 v358; // [xsp+F0h] [xbp-3A0h]
  unsigned __int64 v359; // [xsp+F8h] [xbp-398h]
  _BYTE v360[64]; // [xsp+100h] [xbp-390h] BYREF
  _BYTE *v361; // [xsp+140h] [xbp-350h]
  cv *v362; // [xsp+148h] [xbp-348h]
  __int64 v363[2]; // [xsp+150h] [xbp-340h] BYREF
  _BYTE v364[64]; // [xsp+160h] [xbp-330h] BYREF
  __int128 v365; // [xsp+1A0h] [xbp-2F0h]
  __int64 v366; // [xsp+1B0h] [xbp-2E0h] BYREF
  __int64 v367; // [xsp+1B8h] [xbp-2D8h]
  _BYTE v368[64]; // [xsp+1C0h] [xbp-2D0h] BYREF
  __int128 v369; // [xsp+200h] [xbp-290h]
  __int64 v370; // [xsp+210h] [xbp-280h] BYREF
  __int64 v371; // [xsp+218h] [xbp-278h]
  _BYTE v372[64]; // [xsp+220h] [xbp-270h] BYREF
  __int128 v373; // [xsp+260h] [xbp-230h]
  __int64 v374; // [xsp+270h] [xbp-220h] BYREF
  __int64 v375; // [xsp+278h] [xbp-218h]
  _BYTE v376[64]; // [xsp+280h] [xbp-210h] BYREF
  __int128 v377; // [xsp+2C0h] [xbp-1D0h]
  __int64 v378; // [xsp+2D0h] [xbp-1C0h] BYREF
  __int64 v379; // [xsp+2D8h] [xbp-1B8h]
  _BYTE v380[64]; // [xsp+2E0h] [xbp-1B0h] BYREF
  __int128 v381; // [xsp+320h] [xbp-170h]
  __int64 v382; // [xsp+330h] [xbp-160h] BYREF
  __int64 v383; // [xsp+338h] [xbp-158h]
  _BYTE v384[64]; // [xsp+340h] [xbp-150h] BYREF
  __int128 v385; // [xsp+380h] [xbp-110h]
  __int64 v386; // [xsp+390h] [xbp-100h] BYREF
  __int64 v387; // [xsp+398h] [xbp-F8h]
  _BYTE v388[64]; // [xsp+3A0h] [xbp-F0h] BYREF
  __int128 v389; // [xsp+3E0h] [xbp-B0h]
  __int64 v390; // [xsp+3F0h] [xbp-A0h] BYREF
  __int64 v391; // [xsp+3F8h] [xbp-98h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  sub_20140("PreParamInfo.json", a2, v352);
  memset(v388, 0, 24);
  cv::FileStorage::FileStorage(v351, v352, 1LL, v388);
  if ( (v388[0] & 1) != 0 )
    operator delete(*(void **)&v388[16]);
  *(_DWORD *)v388 = 1124007936;
  memset(&v388[4], 0, 60);
  *(_DWORD *)v380 = 1124007936;
  memset(&v380[4], 0, 60);
  *(_QWORD *)&v389 = &v388[8];
  *((_QWORD *)&v389 + 1) = &v390;
  v390 = 0LL;
  v391 = 0LL;
  *(_QWORD *)&v381 = &v380[8];
  *((_QWORD *)&v381 + 1) = &v382;
  v383 = 0LL;
  v382 = 0LL;
  *(_QWORD *)v354 = 0x300000001LL;
  cv::Mat::create((cv::Mat *)v380, 2, v354, 6);
  *(_QWORD *)v376 = v380;
  if ( *(int *)&v380[4] < 1 )
    v3 = 0LL;
  else
    v3 = *(_QWORD *)(*((_QWORD *)&v381 + 1) + 8LL * (*(_DWORD *)&v380[4] - 1));
  *(_QWORD *)&v376[8] = v3;
  memset(&v376[16], 0, 24);
  if ( (v380[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v376[24] = *(_QWORD *)&v380[16];
    if ( *(int *)&v380[4] >= 3 )
    {
      if ( *(_DWORD *)&v380[4] == 3 )
      {
        v5 = 0LL;
        v4 = 1LL;
      }
      else
      {
        v5 = *(_DWORD *)&v380[4] & 0xFFFFFFFC;
        v6 = vdupq_n_s64(1uLL);
        v7 = (_QWORD *)(v381 + 8);
        v8 = v5;
        v9 = v6;
        do
        {
          v10 = *(v7 - 1);
          v6.n128_u64[0] *= (int)v10;
          v9.n128_u64[0] *= (int)*v7;
          v8 -= 4LL;
          v6.n128_u64[1] *= SHIDWORD(v10);
          v9.n128_u64[1] *= (int)HIDWORD(*v7);
          v7 += 2;
        }
        while ( v8 );
        v4 = v9.n128_u64[0] * v6.n128_u64[0] * v9.n128_u64[1] * v6.n128_u64[1];
        if ( v5 == *(unsigned int *)&v380[4] )
          goto LABEL_16;
      }
      v11 = *(unsigned int *)&v380[4] - v5;
      v12 = (int *)(v381 + 4 * v5);
      do
      {
        v13 = *v12++;
        --v11;
        v4 *= v13;
      }
      while ( v11 );
    }
    else
    {
      v4 = *(int *)&v380[12] * (__int64)*(int *)&v380[8];
    }
LABEL_16:
    *(_QWORD *)&v376[32] = *(_QWORD *)&v380[16] + v4 * v3;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 0LL, 0);
  v14 = *(_QWORD **)&v376[16];
  **(_QWORD **)&v376[16] = 0x4049000000000000LL;
  v15 = *(cv::Mat **)v376;
  if ( *(_QWORD *)v376 )
  {
    *(_QWORD *)&v376[16] = (char *)v14 + *(_QWORD *)&v376[8];
    if ( (unsigned __int64)v14 + *(_QWORD *)&v376[8] >= *(_QWORD *)&v376[32] )
    {
      *(_QWORD *)&v376[16] = v14;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 1LL, 1);
      v15 = *(cv::Mat **)v376;
      v14 = *(_QWORD **)&v376[16];
    }
    else
    {
      v14 = (_QWORD *)((char *)v14 + *(_QWORD *)&v376[8]);
    }
  }
  v16 = *(_QWORD *)&v376[8];
  v17 = *(_QWORD *)&v376[32];
  *(_QWORD *)v372 = v15;
  *(_QWORD *)&v372[8] = *(_QWORD *)&v376[8];
  *(_QWORD *)&v372[16] = v14;
  *(_QWORD *)&v372[24] = *(_QWORD *)&v376[24];
  *(_QWORD *)&v372[32] = *(_QWORD *)&v376[32];
  *v14 = 0x4049000000000000LL;
  if ( v15 )
  {
    v18 = (_QWORD *)((char *)v14 + v16);
    *(_QWORD *)&v372[16] = v18;
    if ( (unsigned __int64)v18 >= v17 )
    {
      *(_QWORD *)&v372[16] = v14;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
      v18 = *(_QWORD **)&v372[16];
      v15 = *(cv::Mat **)v372;
    }
    *v18 = 0x4034000000000000LL;
    if ( v15 )
    {
      *(_QWORD *)&v372[16] = (char *)v18 + *(_QWORD *)&v372[8];
      if ( (unsigned __int64)v18 + *(_QWORD *)&v372[8] >= *(_QWORD *)&v372[32] )
      {
        *(_QWORD *)&v372[16] = v18;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
        v15 = *(cv::Mat **)v372;
      }
    }
  }
  else
  {
    *v14 = 0x4034000000000000LL;
  }
  memset(&v384[4], 0, 60);
  *(_QWORD *)&v385 = &v384[8];
  *((_QWORD *)&v385 + 1) = &v386;
  v387 = 0LL;
  v386 = 0LL;
  *(_DWORD *)v384 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v384, v15);
  if ( *(_QWORD *)&v388[56] )
  {
    v20 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while ( __stlxr(v22, v20) );
    if ( !v22 )
      cv::Mat::deallocate((cv::Mat *)v388);
  }
  *(_QWORD *)&v388[56] = 0LL;
  memset(&v388[16], 0, 32);
  if ( *(int *)&v388[4] >= 1 )
  {
    v23 = v389;
    v24 = 0LL;
    do
      *(_DWORD *)(v23 + 4 * v24++) = 0;
    while ( v24 < *(int *)&v388[4] );
  }
  *(_OWORD *)v388 = *(_OWORD *)v384;
  *(_OWORD *)&v388[16] = *(_OWORD *)&v384[16];
  *(_OWORD *)&v388[32] = *(_OWORD *)&v384[32];
  *(_OWORD *)&v388[48] = *(_OWORD *)&v384[48];
  if ( *((__int64 **)&v389 + 1) == &v390 )
  {
    v25 = *(_DWORD *)&v384[4];
  }
  else
  {
    cv::fastFree(*((cv **)&v389 + 1), v19);
    v25 = *(_DWORD *)&v384[4];
    *(_QWORD *)&v389 = &v388[8];
    *((_QWORD *)&v389 + 1) = &v390;
  }
  if ( v25 <= 2 )
  {
    v27 = (cv *)*((_QWORD *)&v385 + 1);
    v390 = **((_QWORD **)&v385 + 1);
    v391 = *(_QWORD *)(*((_QWORD *)&v385 + 1) + 8LL);
  }
  else
  {
    v26 = v385;
    v27 = (cv *)&v386;
    *((_QWORD *)&v385 + 1) = &v386;
    *(_QWORD *)&v385 = &v384[8];
    v389 = v26;
  }
  *(_DWORD *)v384 = 1124007936;
  memset(&v384[4], 0, 60);
  if ( v27 != (cv *)&v386 )
    cv::fastFree(v27, v19);
  if ( *(_QWORD *)&v380[56] )
  {
    v28 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while ( __stlxr(v30, v28) );
    if ( !v30 )
      cv::Mat::deallocate((cv::Mat *)v380);
  }
  *(_QWORD *)&v380[56] = 0LL;
  memset(&v380[16], 0, 32);
  if ( *(int *)&v380[4] >= 1 )
  {
    v31 = v381;
    v32 = 0LL;
    do
      *(_DWORD *)(v31 + 4 * v32++) = 0;
    while ( v32 < *(int *)&v380[4] );
  }
  if ( *((__int64 **)&v381 + 1) != &v382 )
    cv::fastFree(*((cv **)&v381 + 1), v19);
  v33 = *(_DWORD *)(a1 + 848);
  if ( v33 )
  {
    if ( v33 == 1 )
      goto LABEL_56;
LABEL_161:
    if ( v33 != 2 )
      goto LABEL_213;
LABEL_162:
    *(_DWORD *)v380 = 1124007936;
    memset(&v380[4], 0, 60);
    *(_QWORD *)&v381 = &v380[8];
    *((_QWORD *)&v381 + 1) = &v382;
    v383 = 0LL;
    v382 = 0LL;
    *(_QWORD *)v354 = 0x300000001LL;
    cv::Mat::create((cv::Mat *)v380, 2, v354, 6);
    *(_QWORD *)v376 = v380;
    if ( *(int *)&v380[4] < 1 )
      v94 = 0LL;
    else
      v94 = *(_QWORD *)(*((_QWORD *)&v381 + 1) + 8LL * (*(_DWORD *)&v380[4] - 1));
    *(_QWORD *)&v376[8] = v94;
    memset(&v376[16], 0, 24);
    if ( (v380[1] & 0x40) == 0 )
      goto LABEL_176;
    *(_QWORD *)&v376[24] = *(_QWORD *)&v380[16];
    if ( *(int *)&v380[4] >= 3 )
    {
      if ( *(_DWORD *)&v380[4] == 3 )
      {
        v96 = 0LL;
        v95 = 1LL;
      }
      else
      {
        v96 = *(_DWORD *)&v380[4] & 0xFFFFFFFC;
        v97 = vdupq_n_s64(1uLL);
        v98 = (_QWORD *)(v381 + 8);
        v99 = v96;
        v100 = v97;
        do
        {
          v101 = *(v98 - 1);
          v97.n128_u64[0] *= (int)v101;
          v100.n128_u64[0] *= (int)*v98;
          v99 -= 4LL;
          v97.n128_u64[1] *= SHIDWORD(v101);
          v100.n128_u64[1] *= (int)HIDWORD(*v98);
          v98 += 2;
        }
        while ( v99 );
        v95 = v100.n128_u64[0] * v97.n128_u64[0] * v100.n128_u64[1] * v97.n128_u64[1];
        if ( v96 == *(unsigned int *)&v380[4] )
          goto LABEL_175;
      }
      v102 = *(unsigned int *)&v380[4] - v96;
      v103 = (int *)(v381 + 4 * v96);
      do
      {
        v104 = *v103++;
        --v102;
        v95 *= v104;
      }
      while ( v102 );
    }
    else
    {
      v95 = *(int *)&v380[12] * (__int64)*(int *)&v380[8];
    }
LABEL_175:
    *(_QWORD *)&v376[32] = *(_QWORD *)&v380[16] + v95 * v94;
LABEL_176:
    cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 0LL, 0);
    v105 = *(_QWORD **)&v376[16];
    **(_QWORD **)&v376[16] = 0x4049000000000000LL;
    v106 = *(cv::Mat **)v376;
    if ( *(_QWORD *)v376 )
    {
      *(_QWORD *)&v376[16] = (char *)v105 + *(_QWORD *)&v376[8];
      if ( (unsigned __int64)v105 + *(_QWORD *)&v376[8] >= *(_QWORD *)&v376[32] )
      {
        *(_QWORD *)&v376[16] = v105;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 1LL, 1);
        v106 = *(cv::Mat **)v376;
        v105 = *(_QWORD **)&v376[16];
      }
      else
      {
        v105 = (_QWORD *)((char *)v105 + *(_QWORD *)&v376[8]);
      }
    }
    v107 = *(_QWORD *)&v376[8];
    v108 = *(_QWORD *)&v376[32];
    *(_QWORD *)v372 = v106;
    *(_QWORD *)&v372[8] = *(_QWORD *)&v376[8];
    *(_QWORD *)&v372[16] = v105;
    *(_QWORD *)&v372[24] = *(_QWORD *)&v376[24];
    *(_QWORD *)&v372[32] = *(_QWORD *)&v376[32];
    *v105 = 0x4049000000000000LL;
    if ( v106 )
    {
      v109 = (_QWORD *)((char *)v105 + v107);
      *(_QWORD *)&v372[16] = v109;
      if ( (unsigned __int64)v109 >= v108 )
      {
        *(_QWORD *)&v372[16] = v105;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
        v109 = *(_QWORD **)&v372[16];
        v106 = *(cv::Mat **)v372;
      }
      *v109 = 0x4034000000000000LL;
      if ( v106 )
      {
        *(_QWORD *)&v372[16] = (char *)v109 + *(_QWORD *)&v372[8];
        if ( (unsigned __int64)v109 + *(_QWORD *)&v372[8] >= *(_QWORD *)&v372[32] )
        {
          *(_QWORD *)&v372[16] = v109;
          cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
          v106 = *(cv::Mat **)v372;
        }
      }
    }
    else
    {
      *v105 = 0x4034000000000000LL;
    }
    memset(&v384[4], 0, 60);
    *(_QWORD *)&v385 = &v384[8];
    *((_QWORD *)&v385 + 1) = &v386;
    v387 = 0LL;
    v386 = 0LL;
    *(_DWORD *)v384 = 1124007942;
    cv::Mat_<double>::operator=((cv::Mat *)v384, v106);
    if ( *(_QWORD *)&v388[56] )
    {
      v111 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
      do
      {
        v112 = __ldaxr(v111);
        v113 = v112 - 1;
      }
      while ( __stlxr(v113, v111) );
      if ( !v113 )
        cv::Mat::deallocate((cv::Mat *)v388);
    }
    *(_QWORD *)&v388[56] = 0LL;
    memset(&v388[16], 0, 32);
    if ( *(int *)&v388[4] >= 1 )
    {
      v114 = v389;
      v115 = 0LL;
      do
        *(_DWORD *)(v114 + 4 * v115++) = 0;
      while ( v115 < *(int *)&v388[4] );
    }
    *(_OWORD *)v388 = *(_OWORD *)v384;
    *(_OWORD *)&v388[16] = *(_OWORD *)&v384[16];
    *(_OWORD *)&v388[32] = *(_OWORD *)&v384[32];
    *(_OWORD *)&v388[48] = *(_OWORD *)&v384[48];
    if ( *((__int64 **)&v389 + 1) == &v390 )
    {
      v116 = *(_DWORD *)&v384[4];
    }
    else
    {
      cv::fastFree(*((cv **)&v389 + 1), v110);
      v116 = *(_DWORD *)&v384[4];
      *(_QWORD *)&v389 = &v388[8];
      *((_QWORD *)&v389 + 1) = &v390;
    }
    if ( v116 <= 2 )
    {
      v118 = (cv *)*((_QWORD *)&v385 + 1);
      v390 = **((_QWORD **)&v385 + 1);
      v391 = *(_QWORD *)(*((_QWORD *)&v385 + 1) + 8LL);
    }
    else
    {
      v117 = v385;
      v118 = (cv *)&v386;
      *((_QWORD *)&v385 + 1) = &v386;
      *(_QWORD *)&v385 = &v384[8];
      v389 = v117;
    }
    *(_DWORD *)v384 = 1124007936;
    memset(&v384[4], 0, 60);
    if ( v118 != (cv *)&v386 )
      cv::fastFree(v118, v110);
    if ( *(_QWORD *)&v380[56] )
    {
      v119 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
      do
      {
        v120 = __ldaxr(v119);
        v121 = v120 - 1;
      }
      while ( __stlxr(v121, v119) );
      if ( !v121 )
        cv::Mat::deallocate((cv::Mat *)v380);
    }
    *(_QWORD *)&v380[56] = 0LL;
    memset(&v380[16], 0, 32);
    if ( *(int *)&v380[4] >= 1 )
    {
      v122 = v381;
      v123 = 0LL;
      do
        *(_DWORD *)(v122 + 4 * v123++) = 0;
      while ( v123 < *(int *)&v380[4] );
    }
    if ( *((__int64 **)&v381 + 1) != &v382 )
      cv::fastFree(*((cv **)&v381 + 1), v110);
    goto LABEL_213;
  }
  *(_DWORD *)v380 = 1124007936;
  memset(&v380[4], 0, 60);
  *(_QWORD *)&v381 = &v380[8];
  *((_QWORD *)&v381 + 1) = &v382;
  v383 = 0LL;
  v382 = 0LL;
  *(_QWORD *)v354 = 0x300000001LL;
  cv::Mat::create((cv::Mat *)v380, 2, v354, 6);
  *(_QWORD *)v376 = v380;
  if ( *(int *)&v380[4] < 1 )
    v35 = 0LL;
  else
    v35 = *(_QWORD *)(*((_QWORD *)&v381 + 1) + 8LL * (*(_DWORD *)&v380[4] - 1));
  *(_QWORD *)&v376[8] = v35;
  memset(&v376[16], 0, 24);
  if ( (v380[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v376[24] = *(_QWORD *)&v380[16];
    if ( *(int *)&v380[4] >= 3 )
    {
      if ( *(_DWORD *)&v380[4] == 3 )
      {
        v39 = 0LL;
        v37 = 1LL;
      }
      else
      {
        v39 = *(_DWORD *)&v380[4] & 0xFFFFFFFC;
        v67 = vdupq_n_s64(1uLL);
        v68 = (_QWORD *)(v381 + 8);
        v69 = v39;
        v70 = v67;
        do
        {
          v71 = *(v68 - 1);
          v67.n128_u64[0] *= (int)v71;
          v70.n128_u64[0] *= (int)*v68;
          v69 -= 4LL;
          v67.n128_u64[1] *= SHIDWORD(v71);
          v70.n128_u64[1] *= (int)HIDWORD(*v68);
          v68 += 2;
        }
        while ( v69 );
        v37 = v70.n128_u64[0] * v67.n128_u64[0] * v70.n128_u64[1] * v67.n128_u64[1];
        if ( v39 == *(unsigned int *)&v380[4] )
          goto LABEL_122;
      }
      v72 = *(unsigned int *)&v380[4] - v39;
      v73 = (int *)(v381 + 4 * v39);
      do
      {
        v74 = *v73++;
        --v72;
        v37 *= v74;
      }
      while ( v72 );
    }
    else
    {
      v37 = *(int *)&v380[12] * (__int64)*(int *)&v380[8];
    }
LABEL_122:
    *(_QWORD *)&v376[32] = *(_QWORD *)&v380[16] + v37 * v35;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 0LL, 0);
  v75 = *(_QWORD **)&v376[16];
  **(_QWORD **)&v376[16] = 0x4049000000000000LL;
  v76 = *(cv::Mat **)v376;
  if ( *(_QWORD *)v376 )
  {
    *(_QWORD *)&v376[16] = (char *)v75 + *(_QWORD *)&v376[8];
    if ( (unsigned __int64)v75 + *(_QWORD *)&v376[8] >= *(_QWORD *)&v376[32] )
    {
      *(_QWORD *)&v376[16] = v75;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 1LL, 1);
      v76 = *(cv::Mat **)v376;
      v75 = *(_QWORD **)&v376[16];
    }
    else
    {
      v75 = (_QWORD *)((char *)v75 + *(_QWORD *)&v376[8]);
    }
  }
  v77 = *(_QWORD *)&v376[8];
  v78 = *(_QWORD *)&v376[32];
  *(_QWORD *)v372 = v76;
  *(_QWORD *)&v372[8] = *(_QWORD *)&v376[8];
  *(_QWORD *)&v372[16] = v75;
  *(_QWORD *)&v372[24] = *(_QWORD *)&v376[24];
  *(_QWORD *)&v372[32] = *(_QWORD *)&v376[32];
  *v75 = 0x4049000000000000LL;
  if ( v76 )
  {
    v79 = (_QWORD *)((char *)v75 + v77);
    *(_QWORD *)&v372[16] = v79;
    if ( (unsigned __int64)v79 >= v78 )
    {
      *(_QWORD *)&v372[16] = v75;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
      v79 = *(_QWORD **)&v372[16];
      v76 = *(cv::Mat **)v372;
    }
    *v79 = 0x4034000000000000LL;
    if ( v76 )
    {
      *(_QWORD *)&v372[16] = (char *)v79 + *(_QWORD *)&v372[8];
      if ( (unsigned __int64)v79 + *(_QWORD *)&v372[8] >= *(_QWORD *)&v372[32] )
      {
        *(_QWORD *)&v372[16] = v79;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
        v76 = *(cv::Mat **)v372;
      }
    }
  }
  else
  {
    *v75 = 0x4034000000000000LL;
  }
  memset(&v384[4], 0, 60);
  *(_QWORD *)&v385 = &v384[8];
  *((_QWORD *)&v385 + 1) = &v386;
  v387 = 0LL;
  v386 = 0LL;
  *(_DWORD *)v384 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v384, v76);
  if ( *(_QWORD *)&v388[56] )
  {
    v81 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
    do
    {
      v82 = __ldaxr(v81);
      v83 = v82 - 1;
    }
    while ( __stlxr(v83, v81) );
    if ( !v83 )
      cv::Mat::deallocate((cv::Mat *)v388);
  }
  *(_QWORD *)&v388[56] = 0LL;
  memset(&v388[16], 0, 32);
  if ( *(int *)&v388[4] >= 1 )
  {
    v84 = v389;
    v85 = 0LL;
    do
      *(_DWORD *)(v84 + 4 * v85++) = 0;
    while ( v85 < *(int *)&v388[4] );
  }
  *(_OWORD *)v388 = *(_OWORD *)v384;
  *(_OWORD *)&v388[16] = *(_OWORD *)&v384[16];
  *(_OWORD *)&v388[32] = *(_OWORD *)&v384[32];
  *(_OWORD *)&v388[48] = *(_OWORD *)&v384[48];
  if ( *((__int64 **)&v389 + 1) == &v390 )
  {
    v86 = *(_DWORD *)&v384[4];
  }
  else
  {
    cv::fastFree(*((cv **)&v389 + 1), v80);
    v86 = *(_DWORD *)&v384[4];
    *(_QWORD *)&v389 = &v388[8];
    *((_QWORD *)&v389 + 1) = &v390;
  }
  if ( v86 <= 2 )
  {
    v88 = (cv *)*((_QWORD *)&v385 + 1);
    v390 = **((_QWORD **)&v385 + 1);
    v391 = *(_QWORD *)(*((_QWORD *)&v385 + 1) + 8LL);
  }
  else
  {
    v87 = v385;
    v88 = (cv *)&v386;
    *((_QWORD *)&v385 + 1) = &v386;
    *(_QWORD *)&v385 = &v384[8];
    v389 = v87;
  }
  *(_DWORD *)v384 = 1124007936;
  memset(&v384[4], 0, 60);
  if ( v88 != (cv *)&v386 )
    cv::fastFree(v88, v80);
  if ( *(_QWORD *)&v380[56] )
  {
    v89 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
    do
    {
      v90 = __ldaxr(v89);
      v91 = v90 - 1;
    }
    while ( __stlxr(v91, v89) );
    if ( !v91 )
      cv::Mat::deallocate((cv::Mat *)v380);
  }
  *(_QWORD *)&v380[56] = 0LL;
  memset(&v380[16], 0, 32);
  if ( *(int *)&v380[4] >= 1 )
  {
    v92 = v381;
    v93 = 0LL;
    do
      *(_DWORD *)(v92 + 4 * v93++) = 0;
    while ( v93 < *(int *)&v380[4] );
  }
  if ( *((__int64 **)&v381 + 1) != &v382 )
    cv::fastFree(*((cv **)&v381 + 1), v80);
  v33 = *(_DWORD *)(a1 + 848);
  if ( v33 != 1 )
    goto LABEL_161;
LABEL_56:
  *(_DWORD *)v380 = 1124007936;
  memset(&v380[4], 0, 60);
  *(_QWORD *)&v381 = &v380[8];
  *((_QWORD *)&v381 + 1) = &v382;
  v383 = 0LL;
  v382 = 0LL;
  *(_QWORD *)v354 = 0x300000001LL;
  cv::Mat::create((cv::Mat *)v380, 2, v354, 6);
  *(_QWORD *)v376 = v380;
  if ( *(int *)&v380[4] < 1 )
    v34 = 0LL;
  else
    v34 = *(_QWORD *)(*((_QWORD *)&v381 + 1) + 8LL * (*(_DWORD *)&v380[4] - 1));
  *(_QWORD *)&v376[8] = v34;
  memset(&v376[16], 0, 24);
  if ( (v380[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v376[24] = *(_QWORD *)&v380[16];
    if ( *(int *)&v380[4] >= 3 )
    {
      if ( *(_DWORD *)&v380[4] == 3 )
      {
        v38 = 0LL;
        v36 = 1LL;
      }
      else
      {
        v38 = *(_DWORD *)&v380[4] & 0xFFFFFFFC;
        v40 = vdupq_n_s64(1uLL);
        v41 = (_QWORD *)(v381 + 8);
        v42 = v38;
        v43 = v40;
        do
        {
          v44 = *(v41 - 1);
          v40.n128_u64[0] *= (int)v44;
          v43.n128_u64[0] *= (int)*v41;
          v42 -= 4LL;
          v40.n128_u64[1] *= SHIDWORD(v44);
          v43.n128_u64[1] *= (int)HIDWORD(*v41);
          v41 += 2;
        }
        while ( v42 );
        v36 = v43.n128_u64[0] * v40.n128_u64[0] * v43.n128_u64[1] * v40.n128_u64[1];
        if ( v38 == *(unsigned int *)&v380[4] )
          goto LABEL_77;
      }
      v45 = *(unsigned int *)&v380[4] - v38;
      v46 = (int *)(v381 + 4 * v38);
      do
      {
        v47 = *v46++;
        --v45;
        v36 *= v47;
      }
      while ( v45 );
    }
    else
    {
      v36 = *(int *)&v380[12] * (__int64)*(int *)&v380[8];
    }
LABEL_77:
    *(_QWORD *)&v376[32] = *(_QWORD *)&v380[16] + v36 * v34;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 0LL, 0);
  v48 = *(_QWORD **)&v376[16];
  **(_QWORD **)&v376[16] = 0x4049000000000000LL;
  v49 = *(cv::Mat **)v376;
  if ( *(_QWORD *)v376 )
  {
    *(_QWORD *)&v376[16] = (char *)v48 + *(_QWORD *)&v376[8];
    if ( (unsigned __int64)v48 + *(_QWORD *)&v376[8] >= *(_QWORD *)&v376[32] )
    {
      *(_QWORD *)&v376[16] = v48;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v376, 1LL, 1);
      v49 = *(cv::Mat **)v376;
      v48 = *(_QWORD **)&v376[16];
    }
    else
    {
      v48 = (_QWORD *)((char *)v48 + *(_QWORD *)&v376[8]);
    }
  }
  v50 = *(_QWORD *)&v376[8];
  v51 = *(_QWORD *)&v376[32];
  *(_QWORD *)v372 = v49;
  *(_QWORD *)&v372[8] = *(_QWORD *)&v376[8];
  *(_QWORD *)&v372[16] = v48;
  *(_QWORD *)&v372[24] = *(_QWORD *)&v376[24];
  *(_QWORD *)&v372[32] = *(_QWORD *)&v376[32];
  *v48 = 0x4049000000000000LL;
  if ( v49 )
  {
    v52 = (_QWORD *)((char *)v48 + v50);
    *(_QWORD *)&v372[16] = v52;
    if ( (unsigned __int64)v52 >= v51 )
    {
      *(_QWORD *)&v372[16] = v48;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
      v52 = *(_QWORD **)&v372[16];
      v49 = *(cv::Mat **)v372;
    }
    *v52 = 0x403E000000000000LL;
    if ( v49 )
    {
      *(_QWORD *)&v372[16] = (char *)v52 + *(_QWORD *)&v372[8];
      if ( (unsigned __int64)v52 + *(_QWORD *)&v372[8] >= *(_QWORD *)&v372[32] )
      {
        *(_QWORD *)&v372[16] = v52;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
        v49 = *(cv::Mat **)v372;
      }
    }
  }
  else
  {
    *v48 = 0x403E000000000000LL;
  }
  memset(&v384[4], 0, 60);
  *(_QWORD *)&v385 = &v384[8];
  *((_QWORD *)&v385 + 1) = &v386;
  v387 = 0LL;
  v386 = 0LL;
  *(_DWORD *)v384 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v384, v49);
  if ( *(_QWORD *)&v388[56] )
  {
    v54 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
    do
    {
      v55 = __ldaxr(v54);
      v56 = v55 - 1;
    }
    while ( __stlxr(v56, v54) );
    if ( !v56 )
      cv::Mat::deallocate((cv::Mat *)v388);
  }
  *(_QWORD *)&v388[56] = 0LL;
  memset(&v388[16], 0, 32);
  if ( *(int *)&v388[4] >= 1 )
  {
    v57 = v389;
    v58 = 0LL;
    do
      *(_DWORD *)(v57 + 4 * v58++) = 0;
    while ( v58 < *(int *)&v388[4] );
  }
  *(_OWORD *)v388 = *(_OWORD *)v384;
  *(_OWORD *)&v388[16] = *(_OWORD *)&v384[16];
  *(_OWORD *)&v388[32] = *(_OWORD *)&v384[32];
  *(_OWORD *)&v388[48] = *(_OWORD *)&v384[48];
  if ( *((__int64 **)&v389 + 1) == &v390 )
  {
    v59 = *(_DWORD *)&v384[4];
  }
  else
  {
    cv::fastFree(*((cv **)&v389 + 1), v53);
    v59 = *(_DWORD *)&v384[4];
    *(_QWORD *)&v389 = &v388[8];
    *((_QWORD *)&v389 + 1) = &v390;
  }
  if ( v59 <= 2 )
  {
    v61 = (cv *)*((_QWORD *)&v385 + 1);
    v390 = **((_QWORD **)&v385 + 1);
    v391 = *(_QWORD *)(*((_QWORD *)&v385 + 1) + 8LL);
  }
  else
  {
    v60 = v385;
    v61 = (cv *)&v386;
    *((_QWORD *)&v385 + 1) = &v386;
    *(_QWORD *)&v385 = &v384[8];
    v389 = v60;
  }
  *(_DWORD *)v384 = 1124007936;
  memset(&v384[4], 0, 60);
  if ( v61 != (cv *)&v386 )
    cv::fastFree(v61, v53);
  if ( *(_QWORD *)&v380[56] )
  {
    v62 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
    do
    {
      v63 = __ldaxr(v62);
      v64 = v63 - 1;
    }
    while ( __stlxr(v64, v62) );
    if ( !v64 )
      cv::Mat::deallocate((cv::Mat *)v380);
  }
  *(_QWORD *)&v380[56] = 0LL;
  memset(&v380[16], 0, 32);
  if ( *(int *)&v380[4] >= 1 )
  {
    v65 = v381;
    v66 = 0LL;
    do
      *(_DWORD *)(v65 + 4 * v66++) = 0;
    while ( v66 < *(int *)&v380[4] );
  }
  if ( *((__int64 **)&v381 + 1) != &v382 )
    cv::fastFree(*((cv **)&v381 + 1), v53);
  if ( *(_DWORD *)(a1 + 848) == 2 )
    goto LABEL_162;
LABEL_213:
  *(_DWORD *)v376 = 1124007936;
  memset(&v376[4], 0, 60);
  *(_QWORD *)&v377 = &v376[8];
  *((_QWORD *)&v377 + 1) = &v378;
  v379 = 0LL;
  v378 = 0LL;
  *(_QWORD *)v354 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v376, 2, v354, 6);
  *(_QWORD *)v372 = v376;
  if ( *(int *)&v376[4] < 1 )
    v124 = 0LL;
  else
    v124 = *(_QWORD *)(*((_QWORD *)&v377 + 1) + 8LL * (*(_DWORD *)&v376[4] - 1));
  *(_QWORD *)&v372[8] = v124;
  memset(&v372[16], 0, 24);
  if ( (v376[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v372[24] = *(_QWORD *)&v376[16];
    if ( *(int *)&v376[4] >= 3 )
    {
      if ( *(_DWORD *)&v376[4] == 3 )
      {
        v126 = 0LL;
        v125 = 1LL;
      }
      else
      {
        v126 = *(_DWORD *)&v376[4] & 0xFFFFFFFC;
        v127 = vdupq_n_s64(1uLL);
        v128 = (_QWORD *)(v377 + 8);
        v129 = v126;
        v130 = v127;
        do
        {
          v131 = *(v128 - 1);
          v127.n128_u64[0] *= (int)v131;
          v130.n128_u64[0] *= (int)*v128;
          v129 -= 4LL;
          v127.n128_u64[1] *= SHIDWORD(v131);
          v130.n128_u64[1] *= (int)HIDWORD(*v128);
          v128 += 2;
        }
        while ( v129 );
        v125 = v130.n128_u64[0] * v127.n128_u64[0] * v130.n128_u64[1] * v127.n128_u64[1];
        if ( v126 == *(unsigned int *)&v376[4] )
          goto LABEL_226;
      }
      v132 = *(unsigned int *)&v376[4] - v126;
      v133 = (int *)(v377 + 4 * v126);
      do
      {
        v134 = *v133++;
        --v132;
        v125 *= v134;
      }
      while ( v132 );
    }
    else
    {
      v125 = *(int *)&v376[12] * (__int64)*(int *)&v376[8];
    }
LABEL_226:
    *(_QWORD *)&v372[32] = *(_QWORD *)&v376[16] + v125 * v124;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 0LL, 0);
  v135 = *(_QWORD **)&v372[16];
  **(_QWORD **)&v372[16] = 0x40803149BA5E353FLL;
  v136 = *(cv::Mat **)v372;
  if ( *(_QWORD *)v372 )
  {
    *(_QWORD *)&v372[16] = (char *)v135 + *(_QWORD *)&v372[8];
    if ( (unsigned __int64)v135 + *(_QWORD *)&v372[8] >= *(_QWORD *)&v372[32] )
    {
      *(_QWORD *)&v372[16] = v135;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v372, 1LL, 1);
      v136 = *(cv::Mat **)v372;
      v135 = *(_QWORD **)&v372[16];
    }
    else
    {
      v135 = (_QWORD *)((char *)v135 + *(_QWORD *)&v372[8]);
    }
  }
  v137 = *(_QWORD *)&v372[8];
  v138 = *(_QWORD *)&v372[32];
  *(_QWORD *)v368 = v136;
  *(_QWORD *)&v368[8] = *(_QWORD *)&v372[8];
  *(_QWORD *)&v368[16] = v135;
  *(_QWORD *)&v368[24] = *(_QWORD *)&v372[24];
  *(_QWORD *)&v368[32] = *(_QWORD *)&v372[32];
  *v135 = 0LL;
  if ( !v136 )
  {
    *v135 = 0x3FF0000000000000LL;
    goto LABEL_262;
  }
  v139 = (_QWORD *)((char *)v135 + v137);
  *(_QWORD *)&v368[16] = v139;
  if ( (unsigned __int64)v139 >= v138 )
  {
    *(_QWORD *)&v368[16] = v135;
    cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
    v139 = *(_QWORD **)&v368[16];
    v136 = *(cv::Mat **)v368;
  }
  *v139 = 0x407499C6A7EF9DB2LL;
  if ( !v136 )
  {
    v140 = v139;
    *v139 = 0LL;
LABEL_242:
    v141 = v140;
    goto LABEL_243;
  }
  v140 = (_QWORD *)((char *)v139 + *(_QWORD *)&v368[8]);
  *(_QWORD *)&v368[16] = (char *)v139 + *(_QWORD *)&v368[8];
  if ( (unsigned __int64)v139 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
  {
    *(_QWORD *)&v368[16] = v139;
    cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
    v140 = *(_QWORD **)&v368[16];
    v136 = *(cv::Mat **)v368;
  }
  *v140 = 0LL;
  if ( !v136 )
    goto LABEL_242;
  v141 = (_QWORD *)((char *)v140 + *(_QWORD *)&v368[8]);
  *(_QWORD *)&v368[16] = (char *)v140 + *(_QWORD *)&v368[8];
  if ( (unsigned __int64)v140 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
  {
    *(_QWORD *)&v368[16] = v140;
    cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
    v141 = *(_QWORD **)&v368[16];
    v136 = *(cv::Mat **)v368;
  }
LABEL_243:
  *v141 = 0x40803149BA5E353FLL;
  if ( v136 )
  {
    v142 = (_QWORD *)((char *)v141 + *(_QWORD *)&v368[8]);
    *(_QWORD *)&v368[16] = (char *)v141 + *(_QWORD *)&v368[8];
    if ( (unsigned __int64)v141 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
    {
      *(_QWORD *)&v368[16] = v141;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
      v142 = *(_QWORD **)&v368[16];
      v136 = *(cv::Mat **)v368;
    }
  }
  else
  {
    v142 = v141;
  }
  *v142 = 0x406E065604189375LL;
  if ( !v136 )
  {
    v143 = v142;
    *v142 = 0LL;
LABEL_257:
    v144 = v143;
    *v143 = 0LL;
    goto LABEL_258;
  }
  v143 = (_QWORD *)((char *)v142 + *(_QWORD *)&v368[8]);
  *(_QWORD *)&v368[16] = (char *)v142 + *(_QWORD *)&v368[8];
  if ( (unsigned __int64)v142 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
  {
    *(_QWORD *)&v368[16] = v142;
    cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
    v143 = *(_QWORD **)&v368[16];
    v136 = *(cv::Mat **)v368;
  }
  *v143 = 0LL;
  if ( !v136 )
    goto LABEL_257;
  v144 = (_QWORD *)((char *)v143 + *(_QWORD *)&v368[8]);
  *(_QWORD *)&v368[16] = (char *)v143 + *(_QWORD *)&v368[8];
  if ( (unsigned __int64)v143 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
  {
    *(_QWORD *)&v368[16] = v143;
    cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
    v144 = *(_QWORD **)&v368[16];
    v136 = *(cv::Mat **)v368;
  }
  *v144 = 0LL;
  if ( v136 )
  {
    v145 = (_QWORD *)((char *)v144 + *(_QWORD *)&v368[8]);
    *(_QWORD *)&v368[16] = (char *)v144 + *(_QWORD *)&v368[8];
    if ( (unsigned __int64)v144 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
    {
      *(_QWORD *)&v368[16] = v144;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
      v145 = *(_QWORD **)&v368[16];
      v136 = *(cv::Mat **)v368;
    }
    goto LABEL_259;
  }
LABEL_258:
  v145 = v144;
LABEL_259:
  *v145 = 0x3FF0000000000000LL;
  if ( v136 )
  {
    *(_QWORD *)&v368[16] = (char *)v145 + *(_QWORD *)&v368[8];
    if ( (unsigned __int64)v145 + *(_QWORD *)&v368[8] >= *(_QWORD *)&v368[32] )
    {
      *(_QWORD *)&v368[16] = v145;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v368, 1LL, 1);
      v136 = *(cv::Mat **)v368;
    }
  }
LABEL_262:
  memset(&v380[4], 0, 60);
  *(_QWORD *)&v381 = &v380[8];
  *((_QWORD *)&v381 + 1) = &v382;
  v383 = 0LL;
  v382 = 0LL;
  *(_DWORD *)v380 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v380, v136);
  *(_OWORD *)&v384[16] = *(_OWORD *)&v380[16];
  *(_OWORD *)&v384[32] = *(_OWORD *)&v380[32];
  *(_OWORD *)v384 = *(_OWORD *)v380;
  *(_OWORD *)&v384[48] = *(_OWORD *)&v380[48];
  *(_QWORD *)&v385 = &v384[8];
  *((_QWORD *)&v385 + 1) = &v386;
  v387 = 0LL;
  v386 = 0LL;
  if ( *(int *)&v380[4] > 2 )
  {
    v148 = v381;
    v147 = (cv *)&v382;
    *((_QWORD *)&v381 + 1) = &v382;
    *(_QWORD *)&v381 = &v380[8];
    v385 = v148;
  }
  else
  {
    v147 = (cv *)*((_QWORD *)&v381 + 1);
    v386 = **((_QWORD **)&v381 + 1);
    v387 = *(_QWORD *)(*((_QWORD *)&v381 + 1) + 8LL);
  }
  *(_DWORD *)v380 = 1124007936;
  memset(&v380[4], 0, 60);
  if ( v147 != (cv *)&v382 )
    cv::fastFree(v147, v146);
  if ( *(_QWORD *)&v376[56] )
  {
    v149 = (unsigned int *)(*(_QWORD *)&v376[56] + 20LL);
    do
    {
      v150 = __ldaxr(v149);
      v151 = v150 - 1;
    }
    while ( __stlxr(v151, v149) );
    if ( !v151 )
      cv::Mat::deallocate((cv::Mat *)v376);
  }
  *(_QWORD *)&v376[56] = 0LL;
  memset(&v376[16], 0, 32);
  if ( *(int *)&v376[4] >= 1 )
  {
    v152 = v377;
    v153 = 0LL;
    do
      *(_DWORD *)(v152 + 4 * v153++) = 0;
    while ( v153 < *(int *)&v376[4] );
  }
  if ( *((__int64 **)&v377 + 1) != &v378 )
    cv::fastFree(*((cv **)&v377 + 1), v146);
  *(_DWORD *)v376 = 33619968;
  *(_DWORD *)v380 = 1124007936;
  *(_QWORD *)&v376[16] = 0LL;
  memset(&v380[4], 0, 60);
  *(_QWORD *)&v381 = &v380[8];
  *((_QWORD *)&v381 + 1) = &v382;
  v383 = 0LL;
  v382 = 0LL;
  *(_QWORD *)&v376[8] = v380;
  cv::Mat::copyTo(a1 + 640, v376);
  *(_DWORD *)v368 = 1124007936;
  memset(&v368[4], 0, 60);
  *(_QWORD *)&v369 = &v368[8];
  *((_QWORD *)&v369 + 1) = &v370;
  v371 = 0LL;
  v370 = 0LL;
  *(_QWORD *)v354 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v368, 2, v354, 6);
  *(_QWORD *)v364 = v368;
  if ( *(int *)&v368[4] < 1 )
    v154 = 0LL;
  else
    v154 = *(_QWORD *)(*((_QWORD *)&v369 + 1) + 8LL * (*(_DWORD *)&v368[4] - 1));
  *(_QWORD *)&v364[8] = v154;
  memset(&v364[16], 0, 24);
  if ( (v368[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v364[24] = *(_QWORD *)&v368[16];
    if ( *(int *)&v368[4] >= 3 )
    {
      if ( *(_DWORD *)&v368[4] == 3 )
      {
        v156 = 0LL;
        v155 = 1LL;
      }
      else
      {
        v156 = *(_DWORD *)&v368[4] & 0xFFFFFFFC;
        v157 = vdupq_n_s64(1uLL);
        v158 = (_QWORD *)(v369 + 8);
        v159 = v156;
        v160 = v157;
        do
        {
          v161 = *(v158 - 1);
          v157.n128_u64[0] *= (int)v161;
          v160.n128_u64[0] *= (int)*v158;
          v159 -= 4LL;
          v157.n128_u64[1] *= SHIDWORD(v161);
          v160.n128_u64[1] *= (int)HIDWORD(*v158);
          v158 += 2;
        }
        while ( v159 );
        v155 = v160.n128_u64[0] * v157.n128_u64[0] * v160.n128_u64[1] * v157.n128_u64[1];
        if ( v156 == *(unsigned int *)&v368[4] )
          goto LABEL_290;
      }
      v162 = *(unsigned int *)&v368[4] - v156;
      v163 = (int *)(v369 + 4 * v156);
      do
      {
        v164 = *v163++;
        --v162;
        v155 *= v164;
      }
      while ( v162 );
    }
    else
    {
      v155 = *(int *)&v368[12] * (__int64)*(int *)&v368[8];
    }
LABEL_290:
    *(_QWORD *)&v364[32] = *(_QWORD *)&v368[16] + v155 * v154;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v364, 0LL, 0);
  v165 = *(_QWORD **)&v364[16];
  **(_QWORD **)&v364[16] = 0x3FEFFFA3B9AE0C17LL;
  v166 = *(cv::Mat **)v364;
  if ( *(_QWORD *)v364 )
  {
    *(_QWORD *)&v364[16] = (char *)v165 + *(_QWORD *)&v364[8];
    if ( (unsigned __int64)v165 + *(_QWORD *)&v364[8] >= *(_QWORD *)&v364[32] )
    {
      *(_QWORD *)&v364[16] = v165;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v364, 1LL, 1);
      v166 = *(cv::Mat **)v364;
      v165 = *(_QWORD **)&v364[16];
    }
    else
    {
      v165 = (_QWORD *)((char *)v165 + *(_QWORD *)&v364[8]);
    }
  }
  v167 = *(_QWORD *)&v364[8];
  v168 = *(_QWORD *)&v364[32];
  *(_QWORD *)v360 = v166;
  *(_QWORD *)&v360[8] = *(_QWORD *)&v364[8];
  *(_QWORD *)&v360[16] = v165;
  *(_QWORD *)&v360[24] = *(_QWORD *)&v364[24];
  *(_QWORD *)&v360[32] = *(_QWORD *)&v364[32];
  *v165 = 0x3F831FDA90DAAE37LL;
  if ( v166 )
  {
    v169 = (_QWORD *)((char *)v165 + v167);
    *(_QWORD *)&v360[16] = v169;
    if ( (unsigned __int64)v169 >= v168 )
    {
      *(_QWORD *)&v360[16] = v165;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
      v169 = *(_QWORD **)&v360[16];
      v166 = *(cv::Mat **)v360;
    }
    *v169 = 0x3F4C317B9A77876DLL;
    if ( v166 )
    {
      v170 = (_QWORD *)((char *)v169 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v169 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v169 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v169;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v170 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v170 = v169;
    }
    *v170 = 0xBF831E06255E0874LL;
    if ( v166 )
    {
      v171 = (_QWORD *)((char *)v170 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v170 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v170 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v170;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v171 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v171 = v170;
    }
    *v171 = 0x3FEFFF950B955F78LL;
    if ( v166 )
    {
      v172 = (_QWORD *)((char *)v171 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v171 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v171 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v171;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v172 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v172 = v171;
    }
    *v172 = 0xBF70465EB41570D6LL;
    if ( v166 )
    {
      v173 = (_QWORD *)((char *)v172 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v172 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v172 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v172;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v173 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v173 = v172;
    }
    *v173 = 0xBF4D685D58EDFA3BLL;
    if ( v166 )
    {
      v174 = (_QWORD *)((char *)v173 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v173 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v173 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v173;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v174 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v174 = v173;
    }
    *v174 = 0x3F703DC2D92E041FLL;
    if ( v166 )
    {
      v175 = (_QWORD *)((char *)v174 + *(_QWORD *)&v360[8]);
      *(_QWORD *)&v360[16] = (char *)v174 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v174 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v174;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v175 = *(_QWORD **)&v360[16];
        v166 = *(cv::Mat **)v360;
      }
    }
    else
    {
      v175 = v174;
    }
    *v175 = 0x3FEFFFEF39085F4ALL;
    if ( v166 )
    {
      *(_QWORD *)&v360[16] = (char *)v175 + *(_QWORD *)&v360[8];
      if ( (unsigned __int64)v175 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
      {
        *(_QWORD *)&v360[16] = v175;
        cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
        v166 = *(cv::Mat **)v360;
      }
    }
  }
  else
  {
    *v165 = 0x3FEFFFEF39085F4ALL;
  }
  memset(&v372[4], 0, 60);
  *(_QWORD *)&v373 = &v372[8];
  *((_QWORD *)&v373 + 1) = &v374;
  v375 = 0LL;
  v374 = 0LL;
  *(_DWORD *)v372 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v372, v166);
  *(_OWORD *)&v376[16] = *(_OWORD *)&v372[16];
  *(_OWORD *)&v376[32] = *(_OWORD *)&v372[32];
  *(_OWORD *)v376 = *(_OWORD *)v372;
  *(_OWORD *)&v376[48] = *(_OWORD *)&v372[48];
  *(_QWORD *)&v377 = &v376[8];
  *((_QWORD *)&v377 + 1) = &v378;
  v379 = 0LL;
  v378 = 0LL;
  if ( *(int *)&v372[4] > 2 )
  {
    v178 = v373;
    v177 = (cv *)&v374;
    *((_QWORD *)&v373 + 1) = &v374;
    *(_QWORD *)&v373 = &v372[8];
    v377 = v178;
  }
  else
  {
    v177 = (cv *)*((_QWORD *)&v373 + 1);
    v378 = **((_QWORD **)&v373 + 1);
    v379 = *(_QWORD *)(*((_QWORD *)&v373 + 1) + 8LL);
  }
  *(_DWORD *)v372 = 1124007936;
  memset(&v372[4], 0, 60);
  if ( v177 != (cv *)&v374 )
    cv::fastFree(v177, v176);
  if ( *(_QWORD *)&v368[56] )
  {
    v179 = (unsigned int *)(*(_QWORD *)&v368[56] + 20LL);
    do
    {
      v180 = __ldaxr(v179);
      v181 = v180 - 1;
    }
    while ( __stlxr(v181, v179) );
    if ( !v181 )
      cv::Mat::deallocate((cv::Mat *)v368);
  }
  *(_QWORD *)&v368[56] = 0LL;
  memset(&v368[16], 0, 32);
  if ( *(int *)&v368[4] >= 1 )
  {
    v182 = v369;
    v183 = 0LL;
    do
      *(_DWORD *)(v182 + 4 * v183++) = 0;
    while ( v183 < *(int *)&v368[4] );
  }
  if ( *((__int64 **)&v369 + 1) != &v370 )
    cv::fastFree(*((cv **)&v369 + 1), v176);
  *(_DWORD *)v364 = 1124007936;
  memset(&v364[4], 0, 60);
  *(_QWORD *)&v365 = &v364[8];
  *((_QWORD *)&v365 + 1) = &v366;
  v366 = 0LL;
  v367 = 0LL;
  *(_QWORD *)v354 = 0x100000003LL;
  cv::Mat::create((cv::Mat *)v364, 2, v354, 6);
  *(_QWORD *)v360 = v364;
  if ( *(int *)&v364[4] < 1 )
    v184 = 0LL;
  else
    v184 = *(_QWORD *)(*((_QWORD *)&v365 + 1) + 8LL * (*(_DWORD *)&v364[4] - 1));
  *(_QWORD *)&v360[8] = v184;
  memset(&v360[16], 0, 24);
  if ( (v364[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v360[24] = *(_QWORD *)&v364[16];
    if ( *(int *)&v364[4] >= 3 )
    {
      if ( *(_DWORD *)&v364[4] == 3 )
      {
        v186 = 0LL;
        v185 = 1LL;
      }
      else
      {
        v186 = *(_DWORD *)&v364[4] & 0xFFFFFFFC;
        v187 = vdupq_n_s64(1uLL);
        v188 = (_QWORD *)(v365 + 8);
        v189 = v186;
        v190 = v187;
        do
        {
          v191 = *(v188 - 1);
          v187.n128_u64[0] *= (int)v191;
          v190.n128_u64[0] *= (int)*v188;
          v189 -= 4LL;
          v187.n128_u64[1] *= SHIDWORD(v191);
          v190.n128_u64[1] *= (int)HIDWORD(*v188);
          v188 += 2;
        }
        while ( v189 );
        v185 = v190.n128_u64[0] * v187.n128_u64[0] * v190.n128_u64[1] * v187.n128_u64[1];
        if ( v186 == *(unsigned int *)&v364[4] )
          goto LABEL_354;
      }
      v192 = *(unsigned int *)&v364[4] - v186;
      v193 = (int *)(v365 + 4 * v186);
      do
      {
        v194 = *v193++;
        --v192;
        v185 *= v194;
      }
      while ( v192 );
    }
    else
    {
      v185 = *(int *)&v364[12] * (__int64)*(int *)&v364[8];
    }
LABEL_354:
    *(_QWORD *)&v360[32] = *(_QWORD *)&v364[16] + v185 * v184;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 0LL, 0);
  v195 = *(_QWORD **)&v360[16];
  **(_QWORD **)&v360[16] = 0xC038E34D6A161E4FLL;
  v196 = *(cv::Mat **)v360;
  if ( *(_QWORD *)v360 )
  {
    *(_QWORD *)&v360[16] = (char *)v195 + *(_QWORD *)&v360[8];
    if ( (unsigned __int64)v195 + *(_QWORD *)&v360[8] >= *(_QWORD *)&v360[32] )
    {
      *(_QWORD *)&v360[16] = v195;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v360, 1LL, 1);
      v196 = *(cv::Mat **)v360;
      v195 = *(_QWORD **)&v360[16];
    }
    else
    {
      v195 = (_QWORD *)((char *)v195 + *(_QWORD *)&v360[8]);
    }
  }
  v197 = *(_QWORD *)&v360[8];
  v198 = *(_QWORD *)&v360[32];
  v355 = v196;
  v356 = *(_QWORD *)&v360[8];
  v357 = v195;
  v358 = *(_QWORD *)&v360[24];
  v359 = *(_QWORD *)&v360[32];
  *v195 = 0x3FC679CC74B838C1LL;
  if ( v196 )
  {
    v199 = (_QWORD *)((char *)v195 + v197);
    v357 = v199;
    if ( (unsigned __int64)v199 >= v198 )
    {
      v357 = v195;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v355, 1LL, 1);
      v199 = v357;
      v196 = v355;
    }
    *v199 = 0x3FE6FA3DB3BFB58DLL;
    if ( v196 )
    {
      v357 = (_QWORD *)((char *)v199 + v356);
      if ( (unsigned __int64)v199 + v356 >= v359 )
      {
        v357 = v199;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v355, 1LL, 1);
        v196 = v355;
      }
    }
  }
  else
  {
    *v195 = 0x3FE6FA3DB3BFB58DLL;
  }
  memset(&v368[4], 0, 60);
  *(_QWORD *)&v369 = &v368[8];
  *((_QWORD *)&v369 + 1) = &v370;
  v371 = 0LL;
  v370 = 0LL;
  *(_DWORD *)v368 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v368, v196);
  *(_OWORD *)&v372[16] = *(_OWORD *)&v368[16];
  *(_OWORD *)&v372[32] = *(_OWORD *)&v368[32];
  *(_OWORD *)v372 = *(_OWORD *)v368;
  *(_OWORD *)&v372[48] = *(_OWORD *)&v368[48];
  *(_QWORD *)&v373 = &v372[8];
  *((_QWORD *)&v373 + 1) = &v374;
  v375 = 0LL;
  v374 = 0LL;
  if ( *(int *)&v368[4] > 2 )
  {
    v202 = v369;
    v201 = (cv *)&v370;
    *((_QWORD *)&v369 + 1) = &v370;
    *(_QWORD *)&v369 = &v368[8];
    v373 = v202;
  }
  else
  {
    v201 = (cv *)*((_QWORD *)&v369 + 1);
    v374 = **((_QWORD **)&v369 + 1);
    v375 = *(_QWORD *)(*((_QWORD *)&v369 + 1) + 8LL);
  }
  *(_DWORD *)v368 = 1124007936;
  memset(&v368[4], 0, 60);
  if ( v201 != (cv *)&v370 )
    cv::fastFree(v201, v200);
  if ( *(_QWORD *)&v364[56] )
  {
    v203 = (unsigned int *)(*(_QWORD *)&v364[56] + 20LL);
    do
    {
      v204 = __ldaxr(v203);
      v205 = v204 - 1;
    }
    while ( __stlxr(v205, v203) );
    if ( !v205 )
      cv::Mat::deallocate((cv::Mat *)v364);
  }
  *(_QWORD *)&v364[56] = 0LL;
  memset(&v364[16], 0, 32);
  if ( *(int *)&v364[4] >= 1 )
  {
    v206 = v365;
    v207 = 0LL;
    do
      *(_DWORD *)(v206 + 4 * v207++) = 0;
    while ( v207 < *(int *)&v364[4] );
  }
  if ( *((__int64 **)&v365 + 1) != &v366 )
    cv::fastFree(*((cv **)&v365 + 1), v200);
  *(_DWORD *)v360 = 1124007936;
  memset(&v360[4], 0, 60);
  v361 = &v360[8];
  v362 = (cv *)v363;
  v363[0] = 0LL;
  v363[1] = 0LL;
  *(_QWORD *)v354 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v360, 2, v354, 6);
  v355 = (cv::Mat *)v360;
  if ( *(int *)&v360[4] < 1 )
    v208 = 0LL;
  else
    v208 = *((_QWORD *)v362 + *(_DWORD *)&v360[4] - 1);
  v356 = v208;
  v357 = 0LL;
  v358 = 0LL;
  v359 = 0LL;
  if ( (v360[1] & 0x40) != 0 )
  {
    v358 = *(_QWORD *)&v360[16];
    if ( *(int *)&v360[4] >= 3 )
    {
      if ( *(_DWORD *)&v360[4] == 3 )
      {
        v210 = 0LL;
        v209 = 1LL;
      }
      else
      {
        v210 = *(_DWORD *)&v360[4] & 0xFFFFFFFC;
        v211 = vdupq_n_s64(1uLL);
        v212 = v361 + 8;
        v213 = v210;
        v214 = v211;
        do
        {
          v215 = *(v212 - 1);
          v211.n128_u64[0] *= (int)v215;
          v214.n128_u64[0] *= (int)*v212;
          v213 -= 4LL;
          v211.n128_u64[1] *= SHIDWORD(v215);
          v214.n128_u64[1] *= (int)HIDWORD(*v212);
          v212 += 2;
        }
        while ( v213 );
        v209 = v214.n128_u64[0] * v211.n128_u64[0] * v214.n128_u64[1] * v211.n128_u64[1];
        if ( v210 == *(unsigned int *)&v360[4] )
          goto LABEL_394;
      }
      v216 = *(unsigned int *)&v360[4] - v210;
      v217 = (int *)&v361[4 * v210];
      do
      {
        v218 = *v217++;
        --v216;
        v209 *= v218;
      }
      while ( v216 );
    }
    else
    {
      v209 = *(int *)&v360[12] * (__int64)*(int *)&v360[8];
    }
LABEL_394:
    v359 = *(_QWORD *)&v360[16] + v209 * v208;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v355, 0LL, 0);
  v219 = v357;
  *v357 = 0x3FF0000000000000LL;
  v220 = v355;
  if ( v355 )
  {
    v357 = (_QWORD *)((char *)v219 + v356);
    if ( (unsigned __int64)v219 + v356 >= v359 )
    {
      v357 = v219;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v355, 1LL, 1);
      v220 = v355;
      v219 = v357;
    }
    else
    {
      v219 = (_QWORD *)((char *)v219 + v356);
    }
  }
  v221 = v356;
  v222 = v359;
  v346 = v220;
  v347 = v356;
  v348 = v219;
  v349 = v358;
  v350 = v359;
  *v219 = 0LL;
  if ( !v220 )
  {
    *v219 = 0x3FF0000000000000LL;
    goto LABEL_458;
  }
  v223 = (_QWORD *)((char *)v219 + v221);
  v348 = v223;
  if ( (unsigned __int64)v223 >= v222 )
  {
    v348 = v219;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v223 = v348;
    v220 = v346;
  }
  *v223 = 0LL;
  if ( !v220 )
  {
    v224 = v223;
    *v223 = 0LL;
LABEL_413:
    v225 = v224;
    *v224 = 0LL;
LABEL_414:
    v226 = v225;
    goto LABEL_415;
  }
  v224 = (_QWORD *)((char *)v223 + v347);
  v348 = (_QWORD *)((char *)v223 + v347);
  if ( (unsigned __int64)v223 + v347 >= v350 )
  {
    v348 = v223;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v224 = v348;
    v220 = v346;
  }
  *v224 = 0LL;
  if ( !v220 )
    goto LABEL_413;
  v225 = (_QWORD *)((char *)v224 + v347);
  v348 = (_QWORD *)((char *)v224 + v347);
  if ( (unsigned __int64)v224 + v347 >= v350 )
  {
    v348 = v224;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v225 = v348;
    v220 = v346;
  }
  *v225 = 0LL;
  if ( !v220 )
    goto LABEL_414;
  v226 = (_QWORD *)((char *)v225 + v347);
  v348 = (_QWORD *)((char *)v225 + v347);
  if ( (unsigned __int64)v225 + v347 >= v350 )
  {
    v348 = v225;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v226 = v348;
    v220 = v346;
  }
LABEL_415:
  *v226 = 0x3FF0000000000000LL;
  if ( !v220 )
  {
    v227 = v226;
    *v226 = 0LL;
LABEL_431:
    v228 = v227;
    *v227 = 0LL;
LABEL_432:
    v229 = v228;
    *v228 = 0LL;
LABEL_433:
    v230 = v229;
    *v229 = 0LL;
LABEL_434:
    v231 = v230;
    goto LABEL_435;
  }
  v227 = (_QWORD *)((char *)v226 + v347);
  v348 = (_QWORD *)((char *)v226 + v347);
  if ( (unsigned __int64)v226 + v347 >= v350 )
  {
    v348 = v226;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v227 = v348;
    v220 = v346;
  }
  *v227 = 0LL;
  if ( !v220 )
    goto LABEL_431;
  v228 = (_QWORD *)((char *)v227 + v347);
  v348 = (_QWORD *)((char *)v227 + v347);
  if ( (unsigned __int64)v227 + v347 >= v350 )
  {
    v348 = v227;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v228 = v348;
    v220 = v346;
  }
  *v228 = 0LL;
  if ( !v220 )
    goto LABEL_432;
  v229 = (_QWORD *)((char *)v228 + v347);
  v348 = (_QWORD *)((char *)v228 + v347);
  if ( (unsigned __int64)v228 + v347 >= v350 )
  {
    v348 = v228;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v229 = v348;
    v220 = v346;
  }
  *v229 = 0LL;
  if ( !v220 )
    goto LABEL_433;
  v230 = (_QWORD *)((char *)v229 + v347);
  v348 = (_QWORD *)((char *)v229 + v347);
  if ( (unsigned __int64)v229 + v347 >= v350 )
  {
    v348 = v229;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v230 = v348;
    v220 = v346;
  }
  *v230 = 0LL;
  if ( !v220 )
    goto LABEL_434;
  v231 = (_QWORD *)((char *)v230 + v347);
  v348 = (_QWORD *)((char *)v230 + v347);
  if ( (unsigned __int64)v230 + v347 >= v350 )
  {
    v348 = v230;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v231 = v348;
    v220 = v346;
  }
LABEL_435:
  *v231 = 0x3FF0000000000000LL;
  if ( !v220 )
  {
    v232 = v231;
    *v231 = 0LL;
LABEL_451:
    v233 = v232;
    *v232 = 0LL;
LABEL_452:
    v234 = v233;
    *v233 = 0LL;
LABEL_453:
    v235 = v234;
    *v234 = 0LL;
    goto LABEL_454;
  }
  v232 = (_QWORD *)((char *)v231 + v347);
  v348 = (_QWORD *)((char *)v231 + v347);
  if ( (unsigned __int64)v231 + v347 >= v350 )
  {
    v348 = v231;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v232 = v348;
    v220 = v346;
  }
  *v232 = 0LL;
  if ( !v220 )
    goto LABEL_451;
  v233 = (_QWORD *)((char *)v232 + v347);
  v348 = (_QWORD *)((char *)v232 + v347);
  if ( (unsigned __int64)v232 + v347 >= v350 )
  {
    v348 = v232;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v233 = v348;
    v220 = v346;
  }
  *v233 = 0LL;
  if ( !v220 )
    goto LABEL_452;
  v234 = (_QWORD *)((char *)v233 + v347);
  v348 = (_QWORD *)((char *)v233 + v347);
  if ( (unsigned __int64)v233 + v347 >= v350 )
  {
    v348 = v233;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v234 = v348;
    v220 = v346;
  }
  *v234 = 0LL;
  if ( !v220 )
    goto LABEL_453;
  v235 = (_QWORD *)((char *)v234 + v347);
  v348 = (_QWORD *)((char *)v234 + v347);
  if ( (unsigned __int64)v234 + v347 >= v350 )
  {
    v348 = v234;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
    v235 = v348;
    v220 = v346;
  }
  *v235 = 0LL;
  if ( v220 )
  {
    v236 = (_QWORD *)((char *)v235 + v347);
    v348 = (_QWORD *)((char *)v235 + v347);
    if ( (unsigned __int64)v235 + v347 >= v350 )
    {
      v348 = v235;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
      v236 = v348;
      v220 = v346;
    }
    goto LABEL_455;
  }
LABEL_454:
  v236 = v235;
LABEL_455:
  *v236 = 0x3FF0000000000000LL;
  if ( v220 )
  {
    v348 = (_QWORD *)((char *)v236 + v347);
    if ( (unsigned __int64)v236 + v347 >= v350 )
    {
      v348 = v236;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v346, 1LL, 1);
      v220 = v346;
    }
  }
LABEL_458:
  memset(&v364[4], 0, 60);
  *(_QWORD *)&v365 = &v364[8];
  *((_QWORD *)&v365 + 1) = &v366;
  v366 = 0LL;
  v367 = 0LL;
  *(_DWORD *)v364 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v364, v220);
  *(_OWORD *)&v368[16] = *(_OWORD *)&v364[16];
  *(_OWORD *)&v368[32] = *(_OWORD *)&v364[32];
  *(_OWORD *)v368 = *(_OWORD *)v364;
  *(_OWORD *)&v368[48] = *(_OWORD *)&v364[48];
  *(_QWORD *)&v369 = &v368[8];
  *((_QWORD *)&v369 + 1) = &v370;
  v371 = 0LL;
  v370 = 0LL;
  if ( *(int *)&v364[4] > 2 )
  {
    v239 = v365;
    v238 = (cv *)&v366;
    *(_QWORD *)&v365 = &v364[8];
    *((_QWORD *)&v365 + 1) = &v366;
    v369 = v239;
  }
  else
  {
    v238 = (cv *)*((_QWORD *)&v365 + 1);
    v370 = **((_QWORD **)&v365 + 1);
    v371 = *(_QWORD *)(*((_QWORD *)&v365 + 1) + 8LL);
  }
  *(_DWORD *)v364 = 1124007936;
  memset(&v364[4], 0, 60);
  if ( v238 != (cv *)&v366 )
    cv::fastFree(v238, v237);
  if ( *(_QWORD *)&v360[56] )
  {
    v240 = (unsigned int *)(*(_QWORD *)&v360[56] + 20LL);
    do
    {
      v241 = __ldaxr(v240);
      v242 = v241 - 1;
    }
    while ( __stlxr(v242, v240) );
    if ( !v242 )
      cv::Mat::deallocate((cv::Mat *)v360);
  }
  *(_QWORD *)&v360[56] = 0LL;
  memset(&v360[16], 0, 32);
  if ( *(int *)&v360[4] >= 1 )
  {
    v243 = v361;
    v244 = 0LL;
    do
      *(_DWORD *)&v243[4 * v244++] = 0;
    while ( v244 < *(int *)&v360[4] );
  }
  if ( v362 != (cv *)v363 )
    cv::fastFree(v362, v237);
  v245 = (_DWORD *)sub_2024C((__int64)v351, "use_static_extrinsic");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v245 + 24LL))(v245) & 1) != 0 )
  {
    if ( v245[2] == 6 )
    {
      memset(v364, 0, 24);
      *(_QWORD *)&v364[16] = operator new(0x20uLL);
      *(_OWORD *)v364 = xmmword_53EB0;
      strcpy(*(char **)&v364[16], "No element name has been given");
      cv::error(
        4294967294LL,
        v364,
        "operator<<",
        "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
        1207LL);
      goto LABEL_657;
    }
    cv::write(v245, v245 + 4, 1LL);
    if ( (v245[2] & 4) != 0 )
      v245[2] = 6;
  }
  v246 = (_DWORD *)sub_2024C((__int64)v351, "use_static_camera_matrix");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v246 + 24LL))(v246) & 1) == 0 )
    goto LABEL_481;
  if ( v246[2] == 6 )
  {
LABEL_657:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_658;
  }
  cv::write(v246, v246 + 4, 1LL);
  if ( (v246[2] & 4) != 0 )
    v246[2] = 6;
LABEL_481:
  v247 = (_DWORD *)sub_2024C((__int64)v351, "near_edge");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v247 + 24LL))(v247) & 1) == 0 )
    goto LABEL_485;
  if ( v247[2] == 6 )
  {
LABEL_658:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_659;
  }
  cv::write(v247, v247 + 4, 1LL);
  if ( (v247[2] & 4) != 0 )
    v247[2] = 6;
LABEL_485:
  v248 = sub_2024C((__int64)v351, "mask_file");
  sub_2024C(v248, "/sdcard/pudu/config/mask.png");
  v249 = (_DWORD *)sub_2024C((__int64)v351, "lamda");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v249 + 24LL))(v249) & 1) == 0 )
    goto LABEL_489;
  if ( v249[2] == 6 )
  {
LABEL_659:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_660;
  }
  cv::write(v249, v249 + 4, 0.8);
  if ( (v249[2] & 4) != 0 )
    v249[2] = 6;
LABEL_489:
  v250 = sub_2024C((__int64)v351, "dz");
  v251 = *(_QWORD *)(a1 + 752);
  v252 = v250;
  v253 = **(_QWORD **)(a1 + 808);
  v254 = *(double *)(v251 + 24);
  v255 = *(double *)(v251 + v253 + 24);
  v256 = *(double *)(v251 + 2 * v253 + 24);
  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v250 + 24LL))(v250) & 1) == 0 )
    goto LABEL_493;
  if ( *(_DWORD *)(v252 + 8) == 6 )
  {
LABEL_660:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_661;
  }
  cv::write(v252, v252 + 16, sqrt(v254 * v254 + v255 * v255 + v256 * v256));
  if ( (*(_BYTE *)(v252 + 8) & 4) != 0 )
    *(_DWORD *)(v252 + 8) = 6;
LABEL_493:
  v257 = (_DWORD *)sub_2024C((__int64)v351, "region_x");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v257 + 24LL))(v257) & 1) == 0 )
    goto LABEL_497;
  if ( v257[2] == 6 )
  {
LABEL_661:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_662;
  }
  cv::write(v257, v257 + 4, 1000LL);
  if ( (v257[2] & 4) != 0 )
    v257[2] = 6;
LABEL_497:
  v258 = (_DWORD *)sub_2024C((__int64)v351, "region_y");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v258 + 24LL))(v258) & 1) == 0 )
    goto LABEL_501;
  if ( v258[2] == 6 )
  {
LABEL_662:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_663;
  }
  cv::write(v258, v258 + 4, 1500LL);
  if ( (v258[2] & 4) != 0 )
    v258[2] = 6;
LABEL_501:
  if ( *(_DWORD *)(a1 + 848) == 1 )
  {
    v259 = (_DWORD *)sub_2024C((__int64)v351, "angular_resolution");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v259 + 24LL))(v259) & 1) != 0 )
    {
      if ( v259[2] == 6 )
      {
LABEL_672:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_673;
      }
      cv::write(v259, v259 + 4, 20LL);
      if ( (v259[2] & 4) != 0 )
        v259[2] = 6;
    }
    v260 = (_DWORD *)sub_2024C((__int64)v351, "patch_size");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v260 + 24LL))(v260) & 1) != 0 )
    {
      if ( v260[2] == 6 )
      {
LABEL_673:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_674;
      }
      cv::write(v260, v260 + 4, 10LL);
      goto LABEL_516;
    }
  }
  else
  {
    v261 = (_DWORD *)sub_2024C((__int64)v351, "angular_resolution");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v261 + 24LL))(v261) & 1) != 0 )
    {
      if ( v261[2] == 6 )
      {
LABEL_674:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_675;
      }
      cv::write(v261, v261 + 4, 15LL);
      if ( (v261[2] & 4) != 0 )
        v261[2] = 6;
    }
    v260 = (_DWORD *)sub_2024C((__int64)v351, "patch_size");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v260 + 24LL))(v260) & 1) != 0 )
    {
      if ( v260[2] == 6 )
      {
LABEL_675:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_676;
      }
      cv::write(v260, v260 + 4, 8LL);
LABEL_516:
      if ( (v260[2] & 4) != 0 )
        v260[2] = 6;
    }
  }
  v262 = *(_DWORD *)(a1 + 848);
  if ( v262 )
  {
    if ( v262 != 1 )
      goto LABEL_538;
  }
  else
  {
    v263 = (_DWORD *)sub_2024C((__int64)v351, "image_width");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v263 + 24LL))(v263) & 1) != 0 )
    {
      if ( v263[2] == 6 )
      {
LABEL_682:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
LABEL_683:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        v314 = (struct _Unwind_Exception *)cv::error(
                                             4294967294LL,
                                             v364,
                                             "operator<<",
                                             "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/"
                                             "core/persistence.hpp",
                                             1207LL);
        if ( (v364[0] & 1) != 0 )
        {
          operator delete(*(void **)&v364[16]);
          v315 = *(_QWORD *)&v368[56];
          if ( !*(_QWORD *)&v368[56] )
            goto LABEL_692;
        }
        else
        {
          v315 = *(_QWORD *)&v368[56];
          if ( !*(_QWORD *)&v368[56] )
            goto LABEL_692;
        }
        v316 = (unsigned int *)(v315 + 20);
        do
        {
          v317 = __ldaxr(v316);
          v318 = v317 - 1;
        }
        while ( __stlxr(v318, v316) );
        if ( !v318 )
          cv::Mat::deallocate((cv::Mat *)v368);
LABEL_692:
        *(_QWORD *)&v368[56] = 0LL;
        memset(&v368[16], 0, 32);
        if ( *(int *)&v368[4] >= 1 )
        {
          v319 = v369;
          v320 = 0LL;
          do
            *(_DWORD *)(v319 + 4 * v320++) = 0;
          while ( v320 < *(int *)&v368[4] );
        }
        if ( *((__int64 **)&v369 + 1) != &v370 )
          cv::fastFree(*((cv **)&v369 + 1), v313);
        if ( *(_QWORD *)&v372[56] )
        {
          v321 = (unsigned int *)(*(_QWORD *)&v372[56] + 20LL);
          do
          {
            v322 = __ldaxr(v321);
            v323 = v322 - 1;
          }
          while ( __stlxr(v323, v321) );
          if ( !v323 )
            cv::Mat::deallocate((cv::Mat *)v372);
        }
        *(_QWORD *)&v372[56] = 0LL;
        memset(&v372[16], 0, 32);
        if ( *(int *)&v372[4] >= 1 )
        {
          v324 = v373;
          v325 = 0LL;
          do
            *(_DWORD *)(v324 + 4 * v325++) = 0;
          while ( v325 < *(int *)&v372[4] );
        }
        if ( *((__int64 **)&v373 + 1) != &v374 )
          cv::fastFree(*((cv **)&v373 + 1), v313);
        if ( *(_QWORD *)&v376[56] )
        {
          v326 = (unsigned int *)(*(_QWORD *)&v376[56] + 20LL);
          do
          {
            v327 = __ldaxr(v326);
            v328 = v327 - 1;
          }
          while ( __stlxr(v328, v326) );
          if ( !v328 )
            cv::Mat::deallocate((cv::Mat *)v376);
        }
        *(_QWORD *)&v376[56] = 0LL;
        memset(&v376[16], 0, 32);
        if ( *(int *)&v376[4] >= 1 )
        {
          v329 = v377;
          v330 = 0LL;
          do
            *(_DWORD *)(v329 + 4 * v330++) = 0;
          while ( v330 < *(int *)&v376[4] );
        }
        if ( *((__int64 **)&v377 + 1) != &v378 )
          cv::fastFree(*((cv **)&v377 + 1), v313);
        if ( *(_QWORD *)&v380[56] )
        {
          v331 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
          do
          {
            v332 = __ldaxr(v331);
            v333 = v332 - 1;
          }
          while ( __stlxr(v333, v331) );
          if ( !v333 )
            cv::Mat::deallocate((cv::Mat *)v380);
        }
        *(_QWORD *)&v380[56] = 0LL;
        memset(&v380[16], 0, 32);
        if ( *(int *)&v380[4] >= 1 )
        {
          v334 = v381;
          v335 = 0LL;
          do
            *(_DWORD *)(v334 + 4 * v335++) = 0;
          while ( v335 < *(int *)&v380[4] );
        }
        if ( *((__int64 **)&v381 + 1) != &v382 )
          cv::fastFree(*((cv **)&v381 + 1), v313);
        if ( *(_QWORD *)&v384[56] )
        {
          v336 = (unsigned int *)(*(_QWORD *)&v384[56] + 20LL);
          do
          {
            v337 = __ldaxr(v336);
            v338 = v337 - 1;
          }
          while ( __stlxr(v338, v336) );
          if ( !v338 )
            cv::Mat::deallocate((cv::Mat *)v384);
        }
        *(_QWORD *)&v384[56] = 0LL;
        memset(&v384[16], 0, 32);
        if ( *(int *)&v384[4] >= 1 )
        {
          v339 = v385;
          v340 = 0LL;
          do
            *(_DWORD *)(v339 + 4 * v340++) = 0;
          while ( v340 < *(int *)&v384[4] );
        }
        if ( *((__int64 **)&v385 + 1) != &v386 )
          cv::fastFree(*((cv **)&v385 + 1), v313);
        if ( *(_QWORD *)&v388[56] )
        {
          v341 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
          do
          {
            v342 = __ldaxr(v341);
            v343 = v342 - 1;
          }
          while ( __stlxr(v343, v341) );
          if ( !v343 )
            cv::Mat::deallocate((cv::Mat *)v388);
        }
        *(_QWORD *)&v388[56] = 0LL;
        memset(&v388[16], 0, 32);
        if ( *(int *)&v388[4] >= 1 )
        {
          v344 = v389;
          v345 = 0LL;
          do
            *(_DWORD *)(v344 + 4 * v345++) = 0;
          while ( v345 < *(int *)&v388[4] );
        }
        if ( *((__int64 **)&v389 + 1) != &v390 )
          cv::fastFree(*((cv **)&v389 + 1), v313);
        cv::FileStorage::~FileStorage((cv::FileStorage *)v351);
        if ( (v352[0] & 1) != 0 )
        {
          operator delete(v353);
          _Unwind_Resume(v314);
        }
        _Unwind_Resume(v314);
      }
      cv::write(v263, v263 + 4, 320LL);
      if ( (v263[2] & 4) != 0 )
        v263[2] = 6;
    }
    v264 = (_DWORD *)sub_2024C((__int64)v351, "image_hight");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v264 + 24LL))(v264) & 1) != 0 )
    {
      if ( v264[2] == 6 )
        goto LABEL_683;
      cv::write(v264, v264 + 4, 240LL);
      if ( (v264[2] & 4) != 0 )
        v264[2] = 6;
    }
    if ( *(_DWORD *)(a1 + 848) != 1 )
      goto LABEL_538;
  }
  v265 = (_DWORD *)sub_2024C((__int64)v351, "image_width");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v265 + 24LL))(v265) & 1) != 0 )
  {
    if ( v265[2] == 6 )
    {
LABEL_676:
      memset(v364, 0, 24);
      *(_QWORD *)&v364[16] = operator new(0x20uLL);
      *(_OWORD *)v364 = xmmword_53EB0;
      strcpy(*(char **)&v364[16], "No element name has been given");
      cv::error(
        4294967294LL,
        v364,
        "operator<<",
        "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
        1207LL);
      goto LABEL_677;
    }
    cv::write(v265, v265 + 4, 424LL);
    if ( (v265[2] & 4) != 0 )
      v265[2] = 6;
  }
  v266 = (_DWORD *)sub_2024C((__int64)v351, "image_hight");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v266 + 24LL))(v266) & 1) != 0 )
  {
    if ( v266[2] == 6 )
    {
LABEL_677:
      memset(v364, 0, 24);
      *(_QWORD *)&v364[16] = operator new(0x20uLL);
      *(_OWORD *)v364 = xmmword_53EB0;
      strcpy(*(char **)&v364[16], "No element name has been given");
      cv::error(
        4294967294LL,
        v364,
        "operator<<",
        "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
        1207LL);
      goto LABEL_678;
    }
    cv::write(v266, v266 + 4, 240LL);
    if ( (v266[2] & 4) != 0 )
      v266[2] = 6;
  }
LABEL_538:
  v267 = *(_DWORD *)(a1 + 848);
  if ( v267 == 2 )
  {
    v268 = (_DWORD *)sub_2024C((__int64)v351, "image_width");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v268 + 24LL))(v268) & 1) != 0 )
    {
      if ( v268[2] == 6 )
      {
LABEL_678:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_679;
      }
      cv::write(v268, v268 + 4, 200LL);
      if ( (v268[2] & 4) != 0 )
        v268[2] = 6;
    }
    v269 = (_DWORD *)sub_2024C((__int64)v351, "image_hight");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v269 + 24LL))(v269) & 1) != 0 )
    {
      if ( v269[2] == 6 )
      {
LABEL_679:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_680;
      }
      cv::write(v269, v269 + 4, 320LL);
      if ( (v269[2] & 4) != 0 )
        v269[2] = 6;
    }
    v267 = *(_DWORD *)(a1 + 848);
  }
  if ( v267 == 3 )
  {
    v270 = (_DWORD *)sub_2024C((__int64)v351, "image_width");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v270 + 24LL))(v270) & 1) != 0 )
    {
      if ( v270[2] == 6 )
      {
LABEL_680:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_681;
      }
      cv::write(v270, v270 + 4, 200LL);
      if ( (v270[2] & 4) != 0 )
        v270[2] = 6;
    }
    v271 = (_DWORD *)sub_2024C((__int64)v351, "image_hight");
    if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v271 + 24LL))(v271) & 1) != 0 )
    {
      if ( v271[2] == 6 )
      {
LABEL_681:
        memset(v364, 0, 24);
        *(_QWORD *)&v364[16] = operator new(0x20uLL);
        *(_OWORD *)v364 = xmmword_53EB0;
        strcpy(*(char **)&v364[16], "No element name has been given");
        cv::error(
          4294967294LL,
          v364,
          "operator<<",
          "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
          1207LL);
        goto LABEL_682;
      }
      cv::write(v271, v271 + 4, 320LL);
      if ( (v271[2] & 4) != 0 )
        v271[2] = 6;
    }
  }
  v272 = (_DWORD *)sub_2024C((__int64)v351, "hand_hold");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v272 + 24LL))(v272) & 1) != 0 )
  {
    if ( v272[2] != 6 )
    {
      cv::write(v272, v272 + 4, 0LL);
      if ( (v272[2] & 4) != 0 )
        v272[2] = 6;
      goto LABEL_561;
    }
LABEL_663:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_664;
  }
LABEL_561:
  v273 = (_DWORD *)sub_2024C((__int64)v351, "camera_type");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v273 + 24LL))(v273) & 1) == 0 )
    goto LABEL_565;
  if ( v273[2] == 6 )
  {
LABEL_664:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_665;
  }
  cv::write(v273, v273 + 4, *(unsigned int *)(a1 + 848));
  if ( (v273[2] & 4) != 0 )
    v273[2] = 6;
LABEL_565:
  v274 = (_DWORD *)sub_2024C((__int64)v351, "obstacle_size");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v274 + 24LL))(v274) & 1) == 0 )
    goto LABEL_569;
  if ( v274[2] == 6 )
  {
LABEL_665:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_666;
  }
  cv::write(v274, v274 + 4, v388);
  if ( (v274[2] & 4) != 0 )
    v274[2] = 6;
LABEL_569:
  v275 = (_DWORD *)sub_2024C((__int64)v351, "camera_matrix_rgb");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v275 + 24LL))(v275) & 1) == 0 )
    goto LABEL_573;
  if ( v275[2] == 6 )
  {
LABEL_666:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_667;
  }
  cv::write(v275, v275 + 4, v384);
  if ( (v275[2] & 4) != 0 )
    v275[2] = 6;
LABEL_573:
  v276 = (_DWORD *)sub_2024C((__int64)v351, "camera_matrix");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v276 + 24LL))(v276) & 1) == 0 )
    goto LABEL_577;
  if ( v276[2] == 6 )
  {
LABEL_667:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_668;
  }
  cv::write(v276, v276 + 4, v380);
  if ( (v276[2] & 4) != 0 )
    v276[2] = 6;
LABEL_577:
  v277 = (_DWORD *)sub_2024C((__int64)v351, "R");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v277 + 24LL))(v277) & 1) == 0 )
    goto LABEL_581;
  if ( v277[2] == 6 )
  {
LABEL_668:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_669;
  }
  cv::write(v277, v277 + 4, v376);
  if ( (v277[2] & 4) != 0 )
    v277[2] = 6;
LABEL_581:
  v278 = (_DWORD *)sub_2024C((__int64)v351, "T");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v278 + 24LL))(v278) & 1) == 0 )
    goto LABEL_585;
  if ( v278[2] == 6 )
  {
LABEL_669:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_670;
  }
  cv::write(v278, v278 + 4, v372);
  if ( (v278[2] & 4) != 0 )
    v278[2] = 6;
LABEL_585:
  v279 = (_DWORD *)sub_2024C((__int64)v351, "Trc");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v279 + 24LL))(v279) & 1) == 0 )
    goto LABEL_589;
  if ( v279[2] == 6 )
  {
LABEL_670:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
LABEL_671:
    memset(v364, 0, 24);
    *(_QWORD *)&v364[16] = operator new(0x20uLL);
    *(_OWORD *)v364 = xmmword_53EB0;
    strcpy(*(char **)&v364[16], "No element name has been given");
    cv::error(
      4294967294LL,
      v364,
      "operator<<",
      "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
      1207LL);
    goto LABEL_672;
  }
  cv::write(v279, v279 + 4, a1 + 736);
  if ( (v279[2] & 4) != 0 )
    v279[2] = 6;
LABEL_589:
  v280 = (_DWORD *)sub_2024C((__int64)v351, "Trg");
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v280 + 24LL))(v280) & 1) == 0 )
    goto LABEL_593;
  if ( v280[2] == 6 )
    goto LABEL_671;
  cv::write(v280, v280 + 4, v368);
  if ( (v280[2] & 4) != 0 )
    v280[2] = 6;
LABEL_593:
  cv::FileStorage::release((cv::FileStorage *)v351);
  if ( *(_QWORD *)&v368[56] )
  {
    v282 = (unsigned int *)(*(_QWORD *)&v368[56] + 20LL);
    do
    {
      v283 = __ldaxr(v282);
      v284 = v283 - 1;
    }
    while ( __stlxr(v284, v282) );
    if ( !v284 )
      cv::Mat::deallocate((cv::Mat *)v368);
  }
  *(_QWORD *)&v368[56] = 0LL;
  memset(&v368[16], 0, 32);
  if ( *(int *)&v368[4] >= 1 )
  {
    v285 = v369;
    v286 = 0LL;
    do
      *(_DWORD *)(v285 + 4 * v286++) = 0;
    while ( v286 < *(int *)&v368[4] );
  }
  if ( *((__int64 **)&v369 + 1) != &v370 )
    cv::fastFree(*((cv **)&v369 + 1), v281);
  if ( *(_QWORD *)&v372[56] )
  {
    v287 = (unsigned int *)(*(_QWORD *)&v372[56] + 20LL);
    do
    {
      v288 = __ldaxr(v287);
      v289 = v288 - 1;
    }
    while ( __stlxr(v289, v287) );
    if ( !v289 )
      cv::Mat::deallocate((cv::Mat *)v372);
  }
  *(_QWORD *)&v372[56] = 0LL;
  memset(&v372[16], 0, 32);
  if ( *(int *)&v372[4] >= 1 )
  {
    v290 = v373;
    v291 = 0LL;
    do
      *(_DWORD *)(v290 + 4 * v291++) = 0;
    while ( v291 < *(int *)&v372[4] );
  }
  if ( *((__int64 **)&v373 + 1) != &v374 )
    cv::fastFree(*((cv **)&v373 + 1), v281);
  if ( *(_QWORD *)&v376[56] )
  {
    v292 = (unsigned int *)(*(_QWORD *)&v376[56] + 20LL);
    do
    {
      v293 = __ldaxr(v292);
      v294 = v293 - 1;
    }
    while ( __stlxr(v294, v292) );
    if ( !v294 )
      cv::Mat::deallocate((cv::Mat *)v376);
  }
  *(_QWORD *)&v376[56] = 0LL;
  memset(&v376[16], 0, 32);
  if ( *(int *)&v376[4] >= 1 )
  {
    v295 = v377;
    v296 = 0LL;
    do
      *(_DWORD *)(v295 + 4 * v296++) = 0;
    while ( v296 < *(int *)&v376[4] );
  }
  if ( *((__int64 **)&v377 + 1) != &v378 )
    cv::fastFree(*((cv **)&v377 + 1), v281);
  if ( *(_QWORD *)&v380[56] )
  {
    v297 = (unsigned int *)(*(_QWORD *)&v380[56] + 20LL);
    do
    {
      v298 = __ldaxr(v297);
      v299 = v298 - 1;
    }
    while ( __stlxr(v299, v297) );
    if ( !v299 )
      cv::Mat::deallocate((cv::Mat *)v380);
  }
  *(_QWORD *)&v380[56] = 0LL;
  memset(&v380[16], 0, 32);
  if ( *(int *)&v380[4] >= 1 )
  {
    v300 = v381;
    v301 = 0LL;
    do
      *(_DWORD *)(v300 + 4 * v301++) = 0;
    while ( v301 < *(int *)&v380[4] );
  }
  if ( *((__int64 **)&v381 + 1) != &v382 )
    cv::fastFree(*((cv **)&v381 + 1), v281);
  if ( *(_QWORD *)&v384[56] )
  {
    v302 = (unsigned int *)(*(_QWORD *)&v384[56] + 20LL);
    do
    {
      v303 = __ldaxr(v302);
      v304 = v303 - 1;
    }
    while ( __stlxr(v304, v302) );
    if ( !v304 )
      cv::Mat::deallocate((cv::Mat *)v384);
  }
  *(_QWORD *)&v384[56] = 0LL;
  memset(&v384[16], 0, 32);
  if ( *(int *)&v384[4] >= 1 )
  {
    v305 = v385;
    v306 = 0LL;
    do
      *(_DWORD *)(v305 + 4 * v306++) = 0;
    while ( v306 < *(int *)&v384[4] );
  }
  if ( *((__int64 **)&v385 + 1) != &v386 )
    cv::fastFree(*((cv **)&v385 + 1), v281);
  if ( *(_QWORD *)&v388[56] )
  {
    v307 = (unsigned int *)(*(_QWORD *)&v388[56] + 20LL);
    do
    {
      v308 = __ldaxr(v307);
      v309 = v308 - 1;
    }
    while ( __stlxr(v309, v307) );
    if ( !v309 )
      cv::Mat::deallocate((cv::Mat *)v388);
  }
  *(_QWORD *)&v388[56] = 0LL;
  memset(&v388[16], 0, 32);
  if ( *(int *)&v388[4] >= 1 )
  {
    v310 = v389;
    v311 = 0LL;
    do
      *(_DWORD *)(v310 + 4 * v311++) = 0;
    while ( v311 < *(int *)&v388[4] );
  }
  if ( *((__int64 **)&v389 + 1) != &v390 )
    cv::fastFree(*((cv **)&v389 + 1), v281);
  cv::FileStorage::~FileStorage((cv::FileStorage *)v351);
  if ( (v352[0] & 1) != 0 )
    operator delete(v353);
  return 0LL;
}
// 1C48C: conditional instruction was optimized away because x1.8==0
// 1D324: conditional instruction was optimized away because x1.8==0
// 1D474: conditional instruction was optimized away because x1.8==0
// 1D480: conditional instruction was optimized away because x1.8==0
// 1D48C: conditional instruction was optimized away because x1.8==0
// 1D5DC: conditional instruction was optimized away because x1.8==0
// 1D5E8: conditional instruction was optimized away because x1.8==0
// 1D5F4: conditional instruction was optimized away because x1.8==0
// 1B320: variable 'v19' is possibly undefined
// 1B810: variable 'v53' is possibly undefined
// 1BB74: variable 'v80' is possibly undefined
// 1BF9C: variable 'v110' is possibly undefined
// 1C5AC: variable 'v146' is possibly undefined
// 1CBE0: variable 'v176' is possibly undefined
// 1CFC4: variable 'v200' is possibly undefined
// 1D708: variable 'v237' is possibly undefined
// 1E138: variable 'v281' is possibly undefined
// 1F9E0: variable 'v313' is possibly undefined
// 12630: using guessed type __int64 __fastcall cv::FileStorage::FileStorage(_QWORD, _QWORD, _QWORD, _QWORD);
// 127A0: using guessed type __int64 __fastcall cv::write(_QWORD, _QWORD, _QWORD);
// 127B0: using guessed type __int64 __fastcall cv::write(_QWORD, _QWORD, _QWORD);
// 12C00: using guessed type __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD);
// 13350: using guessed type __int64 __fastcall cv::error(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 13630: using guessed type __int64 __fastcall cv::write(_QWORD, _QWORD, double);
// 53EB0: using guessed type __int128 xmmword_53EB0;

//----- (000000000001FC58) ----------------------------------------------------
void __fastcall ground_filter::Plane_Seg::~Plane_Seg(ground_filter::Plane_Seg *this, void *a2)
{
  __int64 v2; // x20
  __int64 v4; // x21
  __int64 v5; // x8
  unsigned int *v6; // x8
  unsigned int v7; // w9
  unsigned int v8; // w9
  int v9; // w8
  __int64 v10; // x8
  __int64 v11; // x9
  cv *v12; // x0
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0

  v2 = *((_QWORD *)this + 661);
  if ( v2 )
  {
    v4 = *((_QWORD *)this + 662);
    if ( v4 == v2 )
    {
      v13 = (void *)*((_QWORD *)this + 661);
    }
    else
    {
      do
      {
        v5 = *(_QWORD *)(v4 - 80);
        if ( v5 )
        {
          v6 = (unsigned int *)(v5 + 20);
          do
          {
            v7 = __ldaxr(v6);
            v8 = v7 - 1;
          }
          while ( __stlxr(v8, v6) );
          if ( !v8 )
            cv::Mat::deallocate((cv::Mat *)(v4 - 136));
        }
        v9 = *(_DWORD *)(v4 - 132);
        *(_QWORD *)(v4 - 80) = 0LL;
        *(_OWORD *)(v4 - 104) = 0u;
        *(_OWORD *)(v4 - 120) = 0u;
        if ( v9 >= 1 )
        {
          v10 = *(_QWORD *)(v4 - 72);
          v11 = 0LL;
          do
            *(_DWORD *)(v10 + 4 * v11++) = 0;
          while ( v11 < *(int *)(v4 - 132) );
        }
        v12 = *(cv **)(v4 - 64);
        if ( v12 != (cv *)(v4 - 56) )
          cv::fastFree(v12, a2);
        v4 -= 176LL;
      }
      while ( v4 != v2 );
      v13 = (void *)*((_QWORD *)this + 661);
    }
    *((_QWORD *)this + 662) = v2;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 657);
  if ( v14 )
  {
    *((_QWORD *)this + 658) = v14;
    operator delete(v14);
  }
  std::random_device::~random_device((ground_filter::Plane_Seg *)((char *)this + 24));
  v15 = *(void **)this;
  if ( *(_QWORD *)this )
  {
    *((_QWORD *)this + 1) = v15;
    operator delete(v15);
  }
}
// 1FCF0: variable 'a2' is possibly undefined

//----- (000000000001FD5C) ----------------------------------------------------
void __fastcall sub_1FD5C(void **a1, void *a2)
{
  char *v2; // x21
  char *v3; // x22
  __int64 v5; // x8
  char *v6; // x20
  unsigned int *v7; // x8
  unsigned int v8; // w9
  unsigned int v9; // w9
  int v10; // w8
  __int64 v11; // x8
  __int64 v12; // x9
  cv *v13; // x0
  void *v14; // x0

  v2 = (char *)*a1;
  if ( *a1 )
  {
    v3 = (char *)a1[1];
    if ( v3 == v2 )
    {
      v14 = *a1;
    }
    else
    {
      do
      {
        v5 = *((_QWORD *)v3 - 5);
        v6 = v3 - 96;
        if ( v5 )
        {
          v7 = (unsigned int *)(v5 + 20);
          do
          {
            v8 = __ldaxr(v7);
            v9 = v8 - 1;
          }
          while ( __stlxr(v9, v7) );
          if ( !v9 )
            cv::Mat::deallocate((cv::Mat *)(v3 - 96));
        }
        v10 = *((_DWORD *)v3 - 23);
        *((_QWORD *)v3 - 5) = 0LL;
        *((_OWORD *)v3 - 5) = 0u;
        *((_OWORD *)v3 - 4) = 0u;
        if ( v10 >= 1 )
        {
          v11 = *((_QWORD *)v3 - 4);
          v12 = 0LL;
          do
            *(_DWORD *)(v11 + 4 * v12++) = 0;
          while ( v12 < *((int *)v3 - 23) );
        }
        v13 = (cv *)*((_QWORD *)v3 - 3);
        if ( v13 != (cv *)(v3 - 16) )
          cv::fastFree(v13, a2);
        v3 -= 96;
      }
      while ( v6 != v2 );
      v14 = *a1;
    }
    a1[1] = v2;
    operator delete(v14);
  }
}
// 1FDF4: variable 'a2' is possibly undefined

//----- (000000000001FE38) ----------------------------------------------------
void __fastcall feasibal_region::RunOutputParam::~RunOutputParam(feasibal_region::RunOutputParam *this, void *a2)
{
  __int64 v2; // x8
  cv::Mat *v4; // x0
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  __int64 v8; // x8
  __int64 v9; // x9
  cv *v10; // x0
  __int64 v11; // x8
  unsigned int *v12; // x8
  unsigned int v13; // w9
  unsigned int v14; // w9
  int v15; // w8
  __int64 v16; // x8
  __int64 v17; // x9
  cv *v18; // x0
  void *v19; // x0
  void *v20; // x0
  void *v21; // x0
  void *v22; // x0
  void *v23; // x0
  void *v24; // x0
  void *v25; // x0

  v2 = *((_QWORD *)this + 48);
  if ( v2 )
  {
    v4 = (feasibal_region::RunOutputParam *)((char *)this + 328);
    v5 = (unsigned int *)(v2 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate(v4);
  }
  *((_QWORD *)this + 48) = 0LL;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  if ( *((int *)this + 83) >= 1 )
  {
    v8 = *((_QWORD *)this + 49);
    v9 = 0LL;
    do
      *(_DWORD *)(v8 + 4 * v9++) = 0;
    while ( v9 < *((int *)this + 83) );
  }
  v10 = (cv *)*((_QWORD *)this + 50);
  if ( v10 != (feasibal_region::RunOutputParam *)((char *)this + 408) )
    cv::fastFree(v10, a2);
  v11 = *((_QWORD *)this + 36);
  if ( v11 )
  {
    v12 = (unsigned int *)(v11 + 20);
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while ( __stlxr(v14, v12) );
    if ( !v14 )
      cv::Mat::deallocate((feasibal_region::RunOutputParam *)((char *)this + 232));
  }
  *((_QWORD *)this + 36) = 0LL;
  *(_OWORD *)((char *)this + 264) = 0u;
  v15 = *((_DWORD *)this + 59);
  *(_OWORD *)((char *)this + 248) = 0u;
  if ( v15 >= 1 )
  {
    v16 = *((_QWORD *)this + 37);
    v17 = 0LL;
    do
      *(_DWORD *)(v16 + 4 * v17++) = 0;
    while ( v17 < *((int *)this + 59) );
  }
  v18 = (cv *)*((_QWORD *)this + 38);
  if ( v18 != (feasibal_region::RunOutputParam *)((char *)this + 312) )
    cv::fastFree(v18, a2);
  v19 = (void *)*((_QWORD *)this + 26);
  if ( v19 )
  {
    *((_QWORD *)this + 27) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 23);
  if ( v20 )
  {
    *((_QWORD *)this + 24) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 20);
  if ( v21 )
  {
    *((_QWORD *)this + 21) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 17);
  if ( v22 )
  {
    *((_QWORD *)this + 18) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 14);
  if ( v23 )
  {
    *((_QWORD *)this + 15) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 11);
  if ( v24 )
  {
    *((_QWORD *)this + 12) = v24;
    operator delete(v24);
  }
  v25 = (void *)*((_QWORD *)this + 8);
  if ( v25 )
  {
    *((_QWORD *)this + 9) = v25;
    operator delete(v25);
  }
}
// 1FEC0: variable 'a2' is possibly undefined

//----- (000000000001FFC8) ----------------------------------------------------
void __fastcall feasibal_region::RunInputParam::~RunInputParam(feasibal_region::RunInputParam *this, void *a2)
{
  __int64 v2; // x8
  cv::Mat *v4; // x0
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  __int64 v12; // x8
  unsigned int *v13; // x8
  unsigned int v14; // w9
  unsigned int v15; // w9
  int v16; // w8
  __int64 v17; // x8
  __int64 v18; // x9
  cv *v19; // x0
  __int64 v20; // x8
  unsigned int *v21; // x8
  unsigned int v22; // w9
  unsigned int v23; // w9
  int v24; // w8
  __int64 v25; // x8
  __int64 v26; // x9
  cv *v27; // x0

  v2 = *((_QWORD *)this + 31);
  if ( v2 )
  {
    v4 = (feasibal_region::RunInputParam *)((char *)this + 192);
    v5 = (unsigned int *)(v2 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate(v4);
  }
  v8 = *((_DWORD *)this + 49);
  *((_QWORD *)this + 31) = 0LL;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  if ( v8 >= 1 )
  {
    v9 = *((_QWORD *)this + 32);
    v10 = 0LL;
    do
      *(_DWORD *)(v9 + 4 * v10++) = 0;
    while ( v10 < *((int *)this + 49) );
  }
  v11 = (cv *)*((_QWORD *)this + 33);
  if ( v11 != (feasibal_region::RunInputParam *)((char *)this + 272) )
    cv::fastFree(v11, a2);
  v12 = *((_QWORD *)this + 19);
  if ( v12 )
  {
    v13 = (unsigned int *)(v12 + 20);
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while ( __stlxr(v15, v13) );
    if ( !v15 )
      cv::Mat::deallocate((feasibal_region::RunInputParam *)((char *)this + 96));
  }
  v16 = *((_DWORD *)this + 25);
  *((_QWORD *)this + 19) = 0LL;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  if ( v16 >= 1 )
  {
    v17 = *((_QWORD *)this + 20);
    v18 = 0LL;
    do
      *(_DWORD *)(v17 + 4 * v18++) = 0;
    while ( v18 < *((int *)this + 25) );
  }
  v19 = (cv *)*((_QWORD *)this + 21);
  if ( v19 != (feasibal_region::RunInputParam *)((char *)this + 176) )
    cv::fastFree(v19, a2);
  v20 = *((_QWORD *)this + 7);
  if ( v20 )
  {
    v21 = (unsigned int *)(v20 + 20);
    do
    {
      v22 = __ldaxr(v21);
      v23 = v22 - 1;
    }
    while ( __stlxr(v23, v21) );
    if ( !v23 )
      cv::Mat::deallocate(this);
  }
  v24 = *((_DWORD *)this + 1);
  *((_QWORD *)this + 7) = 0LL;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  if ( v24 >= 1 )
  {
    v25 = *((_QWORD *)this + 8);
    v26 = 0LL;
    do
      *(_DWORD *)(v25 + 4 * v26++) = 0;
    while ( v26 < *((int *)this + 1) );
  }
  v27 = (cv *)*((_QWORD *)this + 9);
  if ( v27 != (feasibal_region::RunInputParam *)((char *)this + 80) )
    cv::fastFree(v27, a2);
}
// 20044: variable 'a2' is possibly undefined

//----- (0000000000020140) ----------------------------------------------------
__int64 *__usercall sub_20140@<X0>(char *s@<X1>, unsigned __int8 *a2@<X0>, __int64 *a3@<X8>)
{
  unsigned __int64 v4; // x8
  size_t v7; // x21
  size_t v8; // x22
  const void *v9; // x23
  size_t v10; // x0
  unsigned __int64 v11; // x8
  void *v12; // x24
  unsigned __int64 v14; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v4 = *a2;
  if ( (v4 & 1) != 0 )
  {
    v7 = *((_QWORD *)a2 + 1);
    v10 = strlen(s);
    v9 = (const void *)*((_QWORD *)a2 + 2);
    v8 = v10;
  }
  else
  {
    v7 = v4 >> 1;
    v8 = strlen(s);
    v9 = a2 + 1;
  }
  v11 = v7 + v8;
  if ( v7 + v8 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  if ( v11 > 0x16 )
  {
    v14 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (void *)operator new(v14);
    a3[1] = v7;
    a3[2] = (__int64)v12;
    *a3 = v14 | 1;
    if ( !v7 )
      goto LABEL_8;
    goto LABEL_7;
  }
  *(_BYTE *)a3 = 2 * v7;
  v12 = (char *)a3 + 1;
  if ( v7 )
LABEL_7:
    memcpy(v12, v9, v7);
LABEL_8:
  *((_BYTE *)v12 + v7) = 0;
  return std::string::append(a3, s, v8);
}

//----- (000000000002024C) ----------------------------------------------------
__int64 __fastcall sub_2024C(__int64 a1, char *s)
{
  size_t v4; // x0
  size_t v5; // x21
  char *v6; // x22
  unsigned __int64 v7; // x23
  __int64 v8; // x19
  unsigned __int64 v10; // [xsp+0h] [xbp-50h] BYREF
  size_t v11; // [xsp+8h] [xbp-48h]
  void *v12; // [xsp+10h] [xbp-40h]
  __int64 v13; // [xsp+18h] [xbp-38h]

  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v4 = strlen(s);
  if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v5 = v4;
  if ( v4 >= 0x17 )
  {
    v7 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v6 = (char *)operator new(v7);
    v11 = v5;
    v12 = v6;
    v10 = v7 | 1;
    goto LABEL_6;
  }
  v6 = (char *)&v10 + 1;
  LOBYTE(v10) = 2 * v4;
  if ( v4 )
LABEL_6:
    memcpy(v6, s, v5);
  v6[v5] = 0;
  v8 = cv::operator<<(a1, &v10);
  if ( (v10 & 1) != 0 )
    operator delete(v12);
  return v8;
}
// 12FD0: using guessed type __int64 __fastcall cv::operator<<(_QWORD, _QWORD);

//----- (0000000000020360) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::static_delete(__int64 a1, void **a2)
{
  if ( *a2 )
    operator delete(*a2);
  *a2 = 0LL;
}

//----- (000000000002038C) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::copy_from_value(
        __int64 a1,
        __int64 a2,
        _QWORD *a3)
{
  __int64 result; // x0

  result = operator new(1uLL);
  *a3 = result;
  return result;
}

//----- (00000000000203B4) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::clone(
        __int64 a1,
        __int64 a2,
        _QWORD *a3)
{
  __int64 result; // x0

  result = operator new(1uLL);
  *a3 = result;
  return result;
}

//----- (00000000000203E0) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (00000000000203E8) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (00000000000203F0) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::get_size()
{
  return 1LL;
}

//----- (00000000000203F8) ----------------------------------------------------
void **cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::type()
{
  return &`typeinfo for'cvflann::anyimpl::empty_any;
}
// 6DEB8: using guessed type void *`typeinfo for'cvflann::anyimpl::empty_any;

//----- (0000000000020404) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::print(int a1, _QWORD *a2)
{
  return std::__put_character_sequence<char,std::char_traits<char>>(a2, (__int64)"[empty_any]", 11LL);
}

//----- (0000000000020424) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::copy_from_value(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (0000000000020430) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::clone(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (000000000002043C) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<char const*>::move(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (0000000000020448) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<char const*>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000020450) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<char const*>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000020458) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<char const*>::get_size()
{
  return 8LL;
}

//----- (0000000000020460) ----------------------------------------------------
void *cvflann::anyimpl::typed_base_any_policy<char const*>::type()
{
  return &`typeinfo for'char const*;
}

//----- (000000000002046C) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<char const*>::print(__int64 a1, _QWORD *a2, const char **a3)
{
  const char *v3; // x19
  __int64 v5; // x2

  v3 = *a3;
  v5 = strlen(*a3);
  return std::__put_character_sequence<char,std::char_traits<char>>(a2, (__int64)v3, v5);
}

//----- (00000000000204A8) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<int>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000204B4) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<int>::clone(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000204C0) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<int>::move(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000204CC) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<int>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (00000000000204D4) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<int>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (00000000000204DC) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<int>::get_size()
{
  return 4LL;
}

//----- (00000000000204E4) ----------------------------------------------------
void *cvflann::anyimpl::typed_base_any_policy<int>::type()
{
  return &`typeinfo for'int;
}

//----- (00000000000204F0) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<int>::print(__int64 a1, _QWORD *a2)
{
  return std::ostream::operator<<(a2);
}

//----- (0000000000020508) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<float>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = *a2;
}

//----- (0000000000020514) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<float>::clone(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (0000000000020520) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<float>::move(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (000000000002052C) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<float>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000020534) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<float>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (000000000002053C) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<float>::get_size()
{
  return 4LL;
}

//----- (0000000000020544) ----------------------------------------------------
void *cvflann::anyimpl::typed_base_any_policy<float>::type()
{
  return &`typeinfo for'float;
}

//----- (0000000000020550) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<float>::print(__int64 a1, _QWORD *a2, float *a3)
{
  return std::ostream::operator<<(a2, *a3);
}

//----- (0000000000020564) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<bool>::copy_from_value(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  *a3 = *a2;
}

//----- (0000000000020570) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<bool>::clone(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (000000000002057C) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<bool>::move(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (0000000000020588) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<bool>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000020590) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<bool>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000020598) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<bool>::get_size()
{
  return 1LL;
}

//----- (00000000000205A0) ----------------------------------------------------
void *cvflann::anyimpl::typed_base_any_policy<bool>::type()
{
  return &`typeinfo for'bool;
}

//----- (00000000000205AC) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<bool>::print(__int64 a1, _QWORD *a2)
{
  return std::ostream::operator<<(a2);
}

//----- (00000000000205C0) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::static_delete(__int64 a1, void **a2)
{
  if ( *a2 )
    operator delete(*a2);
  *a2 = 0LL;
}

//----- (00000000000205EC) ----------------------------------------------------
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::copy_from_value(
        __int64 a1,
        _DWORD *a2,
        _QWORD *a3)
{
  _DWORD *result; // x0

  result = (_DWORD *)operator new(4uLL);
  *result = *a2;
  *a3 = result;
  return result;
}

//----- (0000000000020620) ----------------------------------------------------
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::clone(
        __int64 a1,
        _DWORD **a2,
        _QWORD *a3)
{
  _DWORD *result; // x0

  result = (_DWORD *)operator new(4uLL);
  *result = **a2;
  *a3 = result;
  return result;
}

//----- (0000000000020658) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::move(
        __int64 a1,
        _DWORD **a2,
        _DWORD **a3)
{
  **a3 = **a2;
}

//----- (000000000002066C) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (0000000000020674) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (000000000002067C) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::flann_algorithm_t>::get_size()
{
  return 4LL;
}

//----- (0000000000020684) ----------------------------------------------------
void **cvflann::anyimpl::typed_base_any_policy<cvflann::flann_algorithm_t>::type()
{
  return &`typeinfo for'cvflann::flann_algorithm_t;
}
// 6DEC8: using guessed type void *`typeinfo for'cvflann::flann_algorithm_t;

//----- (0000000000020690) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_algorithm_t>::print(__int64 a1, _QWORD *a2)
{
  return std::ostream::operator<<(a2);
}

//----- (00000000000206A8) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::static_delete(__int64 a1, void **a2)
{
  if ( *a2 )
    operator delete(*a2);
  *a2 = 0LL;
}

//----- (00000000000206D4) ----------------------------------------------------
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::copy_from_value(
        __int64 a1,
        _DWORD *a2,
        _QWORD *a3)
{
  _DWORD *result; // x0

  result = (_DWORD *)operator new(4uLL);
  *result = *a2;
  *a3 = result;
  return result;
}

//----- (0000000000020708) ----------------------------------------------------
_DWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::clone(
        __int64 a1,
        _DWORD **a2,
        _QWORD *a3)
{
  _DWORD *result; // x0

  result = (_DWORD *)operator new(4uLL);
  *result = **a2;
  *a3 = result;
  return result;
}

//----- (0000000000020740) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::move(
        __int64 a1,
        _DWORD **a2,
        _DWORD **a3)
{
  **a3 = **a2;
}

//----- (0000000000020754) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (000000000002075C) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (0000000000020764) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<cvflann::flann_centers_init_t>::get_size()
{
  return 4LL;
}

//----- (000000000002076C) ----------------------------------------------------
void **cvflann::anyimpl::typed_base_any_policy<cvflann::flann_centers_init_t>::type()
{
  return &`typeinfo for'cvflann::flann_centers_init_t;
}
// 6DED8: using guessed type void *`typeinfo for'cvflann::flann_centers_init_t;

//----- (0000000000020778) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<cvflann::flann_centers_init_t>::print(__int64 a1, _QWORD *a2)
{
  return std::ostream::operator<<(a2);
}

//----- (0000000000020794) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::copy_from_value(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000207A0) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::clone(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000207AC) ----------------------------------------------------
void __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::move(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  *a3 = *a2;
}

//----- (00000000000207B8) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (00000000000207C0) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::small_any_policy<unsigned int>::get_value(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (00000000000207C8) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<unsigned int>::get_size()
{
  return 4LL;
}

//----- (00000000000207D0) ----------------------------------------------------
void *cvflann::anyimpl::typed_base_any_policy<unsigned int>::type()
{
  return &`typeinfo for'unsigned int;
}

//----- (00000000000207DC) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::small_any_policy<unsigned int>::print(__int64 a1, _QWORD *a2)
{
  return std::ostream::operator<<(a2);
}

//----- (00000000000207F0) ----------------------------------------------------
void __fastcall cvflann::anyimpl::big_any_policy<std::string>::static_delete(__int64 a1, void **a2)
{
  void **v2; // x20

  v2 = (void **)*a2;
  if ( *a2 )
  {
    if ( (*(_BYTE *)v2 & 1) != 0 )
      operator delete(v2[2]);
    operator delete(v2);
  }
  *a2 = 0LL;
}

//----- (0000000000020830) ----------------------------------------------------
size_t *__fastcall cvflann::anyimpl::big_any_policy<std::string>::copy_from_value(
        __int64 a1,
        __int128 *a2,
        size_t **a3)
{
  size_t *result; // x0
  size_t *v6; // x19
  __int128 v7; // q0
  size_t v8; // x21
  const void *v9; // x22
  void *v10; // x23

  result = (size_t *)operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *result = 0LL;
  v6 = result;
  if ( (*(_BYTE *)a2 & 1) != 0 )
  {
    v8 = *((_QWORD *)a2 + 1);
    if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v9 = (const void *)*((_QWORD *)a2 + 2);
    if ( v8 >= 0x17 )
    {
      v10 = (void *)operator new((v8 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      v6[1] = v8;
      v6[2] = (size_t)v10;
      *v6 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      *(_BYTE *)result = 2 * v8;
      v10 = (char *)result + 1;
      if ( !v8 )
        goto LABEL_9;
    }
    result = (size_t *)memcpy(v10, v9, v8);
LABEL_9:
    *((_BYTE *)v10 + v8) = 0;
    goto LABEL_10;
  }
  v7 = *a2;
  result[2] = *((_QWORD *)a2 + 2);
  *(_OWORD *)result = v7;
LABEL_10:
  *a3 = v6;
  return result;
}

//----- (0000000000020910) ----------------------------------------------------
size_t *__fastcall cvflann::anyimpl::big_any_policy<std::string>::clone(__int64 a1, __int128 **a2, size_t **a3)
{
  size_t *result; // x0
  __int128 *v6; // x8
  size_t *v7; // x19
  __int128 v8; // q0
  size_t v9; // x21
  const void *v10; // x22
  void *v11; // x23

  result = (size_t *)operator new(0x18uLL);
  v6 = *a2;
  result[1] = 0LL;
  result[2] = 0LL;
  *result = 0LL;
  v7 = result;
  if ( (*(_BYTE *)v6 & 1) != 0 )
  {
    v9 = *((_QWORD *)v6 + 1);
    if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v10 = (const void *)*((_QWORD *)v6 + 2);
    if ( v9 >= 0x17 )
    {
      v11 = (void *)operator new((v9 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      v7[1] = v9;
      v7[2] = (size_t)v11;
      *v7 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      *(_BYTE *)result = 2 * v9;
      v11 = (char *)result + 1;
      if ( !v9 )
        goto LABEL_9;
    }
    result = (size_t *)memcpy(v11, v10, v9);
LABEL_9:
    *((_BYTE *)v11 + v9) = 0;
    goto LABEL_10;
  }
  v8 = *v6;
  result[2] = *((_QWORD *)v6 + 2);
  *(_OWORD *)result = v8;
LABEL_10:
  *a3 = v7;
  return result;
}

//----- (00000000000209F4) ----------------------------------------------------
__int64 *__fastcall cvflann::anyimpl::big_any_policy<std::string>::move(__int64 a1, __int64 **a2, __int64 **a3)
{
  __int64 *result; // x0
  __int64 *v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x1
  size_t v9; // x2

  result = *a3;
  if ( (*(_BYTE *)*a3 & 1) != 0 )
  {
    operator delete((void *)result[2]);
    result = *a3;
  }
  v6 = *a2;
  if ( result != *a2 )
  {
    v7 = *(unsigned __int8 *)v6;
    if ( (v7 & 1) != 0 )
      v8 = (void *)v6[2];
    else
      v8 = (char *)v6 + 1;
    if ( (v7 & 1) != 0 )
      v9 = v6[1];
    else
      v9 = v7 >> 1;
    return std::string::assign(result, v8, v9);
  }
  return result;
}

//----- (0000000000020A54) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<std::string>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (0000000000020A5C) ----------------------------------------------------
__int64 __fastcall cvflann::anyimpl::big_any_policy<std::string>::get_value(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a2;
}

//----- (0000000000020A64) ----------------------------------------------------
__int64 cvflann::anyimpl::typed_base_any_policy<std::string>::get_size()
{
  return 24LL;
}

//----- (0000000000020A6C) ----------------------------------------------------
void **cvflann::anyimpl::typed_base_any_policy<std::string>::type()
{
  return &`typeinfo for'std::string;
}
// 6DEF8: using guessed type void *`typeinfo for'std::string;

//----- (0000000000020A78) ----------------------------------------------------
_QWORD *__fastcall cvflann::anyimpl::big_any_policy<std::string>::print(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _BYTE *v3; // x8
  const char *v5; // x20
  __int64 v6; // x2

  v3 = (_BYTE *)*a3;
  if ( (*(_BYTE *)*a3 & 1) != 0 )
    v5 = (const char *)*((_QWORD *)v3 + 2);
  else
    v5 = v3 + 1;
  v6 = strlen(v5);
  return std::__put_character_sequence<char,std::char_traits<char>>(a2, (__int64)v5, v6);
}

//----- (0000000000020AC4) ----------------------------------------------------
void __fastcall __noreturn sub_20AC4(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (0000000000020AD0) ----------------------------------------------------
char *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
        __int64 a1,
        char *a2,
        char *a3)
{
  __int64 v4; // x8
  char *result; // x0
  unsigned __int64 v6; // x22
  char *v8; // x21
  __int64 v9; // x9
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x8
  __int64 v12; // x22
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x10
  __int64 v15; // x8
  char *v16; // x8
  char *v17; // x9
  int v18; // w10
  unsigned __int64 v19; // x10
  char *v20; // x9
  char *v21; // x11
  unsigned __int64 v22; // x14
  unsigned __int64 v23; // x13
  char *v24; // x12
  __int64 v25; // x12
  bool v26; // cc
  __int64 v27; // x12
  char *v28; // x15
  __int64 v29; // x16
  char *v30; // x17
  __int128 v31; // q1
  __int128 v32; // q2
  __int128 v33; // q3
  __int128 v34; // q4
  __int128 v35; // q5
  int v36; // w13
  unsigned __int64 v37; // x11
  unsigned __int64 v38; // x12
  __int64 v39; // x14
  char *v40; // x13
  char *v41; // x10
  __int64 v42; // x14
  __int128 v43; // q1
  __int128 v44; // q2
  __int128 v45; // q3
  __int128 v46; // q4
  __int128 v47; // q5
  int v48; // w10
  __int64 v49; // x9
  __int64 v50; // x12
  __int128 v51; // q1
  __int128 v52; // q2
  __int128 v53; // q3
  __int128 v54; // q4
  __int128 v55; // q5

  v4 = *(_QWORD *)(a1 + 16);
  result = *(char **)a1;
  v6 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2);
  v8 = a2;
  if ( v6 <= 0xAAAAAAAAAAAAAAABLL * ((v4 - (__int64)result) >> 2) )
  {
    v16 = *(char **)(a1 + 8);
    v19 = 0xAAAAAAAAAAAAAAABLL * ((v16 - result) >> 2);
    v20 = &a2[v16 - result];
    if ( v6 <= v19 )
      v21 = a3;
    else
      v21 = &a2[v16 - result];
    if ( v21 != a2 )
    {
      v22 = (v21 - 12 - a2) / 0xCuLL;
      v23 = v22 + 1;
      v24 = a2;
      if ( v22 + 1 < 8 )
        goto LABEL_46;
      v25 = 12 * v22 + 12;
      if ( result < &a2[v25] )
      {
        v26 = &result[v25] > a2;
        v24 = a2;
        if ( v26 )
          goto LABEL_46;
      }
      v27 = 12 * (v23 & 0x3FFFFFFFFFFFFFF8LL);
      v28 = result;
      result += v27;
      v24 = &a2[v27];
      v29 = v23 & 0x3FFFFFFFFFFFFFF8LL;
      v30 = a2;
      do
      {
        v31 = *((_OWORD *)v30 + 1);
        v32 = *((_OWORD *)v30 + 2);
        v33 = *((_OWORD *)v30 + 3);
        v34 = *((_OWORD *)v30 + 4);
        v35 = *((_OWORD *)v30 + 5);
        v29 -= 8LL;
        *(_OWORD *)v28 = *(_OWORD *)v30;
        *((_OWORD *)v28 + 1) = v31;
        *((_OWORD *)v28 + 2) = v32;
        *((_OWORD *)v28 + 3) = v33;
        *((_OWORD *)v28 + 4) = v34;
        *((_OWORD *)v28 + 5) = v35;
        v28 += 96;
        v30 += 96;
      }
      while ( v29 );
      if ( v23 != (v23 & 0x3FFFFFFFFFFFFFF8LL) )
      {
LABEL_46:
        do
        {
          *(_DWORD *)result = *(_DWORD *)v24;
          *((_DWORD *)result + 1) = *((_DWORD *)v24 + 1);
          v36 = *((_DWORD *)v24 + 2);
          v24 += 12;
          *((_DWORD *)result + 2) = v36;
          result += 12;
        }
        while ( v24 != v21 );
      }
    }
    if ( v6 <= v19 )
    {
      *(_QWORD *)(a1 + 8) = result;
      return result;
    }
    if ( v21 != a3 )
    {
      v37 = (&a3[12 * ~v19] - a2) / 0xCuLL + 1;
      if ( v37 < 8 )
        goto LABEL_47;
      v38 = (&a3[12 * ~v19] - a2) / 0xCuLL;
      if ( v16 < &a2[12 * v19 + 12 + 12 * v38] && v20 < &v16[12 * v38 + 12] )
        goto LABEL_47;
      v39 = 12 * (v37 & 0x3FFFFFFFFFFFFFF8LL);
      v40 = v16;
      v16 += v39;
      v20 += v39;
      v41 = &a2[12 * v19 + 48];
      v42 = v37 & 0x3FFFFFFFFFFFFFF8LL;
      do
      {
        v43 = *((_OWORD *)v41 - 2);
        v44 = *((_OWORD *)v41 - 1);
        v45 = *(_OWORD *)v41;
        v46 = *((_OWORD *)v41 + 1);
        v47 = *((_OWORD *)v41 + 2);
        v42 -= 8LL;
        *(_OWORD *)v40 = *((_OWORD *)v41 - 3);
        *((_OWORD *)v40 + 1) = v43;
        *((_OWORD *)v40 + 2) = v44;
        *((_OWORD *)v40 + 3) = v45;
        *((_OWORD *)v40 + 4) = v46;
        *((_OWORD *)v40 + 5) = v47;
        v40 += 96;
        v41 += 96;
      }
      while ( v42 );
      if ( v37 != (v37 & 0x3FFFFFFFFFFFFFF8LL) )
      {
LABEL_47:
        do
        {
          *(_DWORD *)v16 = *(_DWORD *)v20;
          *((_DWORD *)v16 + 1) = *((_DWORD *)v20 + 1);
          v48 = *((_DWORD *)v20 + 2);
          v20 += 12;
          *((_DWORD *)v16 + 2) = v48;
          v16 += 12;
        }
        while ( v20 != a3 );
      }
      goto LABEL_41;
    }
  }
  else
  {
    if ( result )
    {
      *(_QWORD *)(a1 + 8) = result;
      operator delete(result);
      v4 = 0LL;
      *(_QWORD *)a1 = 0LL;
      *(_QWORD *)(a1 + 8) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
    }
    v9 = 0x1555555555555555LL;
    if ( v6 > 0x1555555555555555LL )
      std::__vector_base_common<true>::__throw_length_error();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 2);
    if ( v10 <= 0xAAAAAAAAAAAAAA9LL )
    {
      v11 = 2 * v10;
      if ( v11 >= v6 )
        v9 = v11;
      else
        v9 = v6;
    }
    v12 = 12 * v9;
    result = (char *)operator new(12 * v9);
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 16) = &result[v12];
    if ( v8 != a3 )
    {
      v13 = (a3 - 12 - v8) / 0xCuLL;
      v14 = v13 + 1;
      if ( v13 + 1 >= 8 && ((v15 = 12 * v13 + 12, result >= &v8[v15]) || &result[v15] <= v8) )
      {
        v49 = 12 * (v14 & 0x3FFFFFFFFFFFFFF8LL);
        v16 = &result[v49];
        v17 = &v8[v49];
        v50 = v14 & 0x3FFFFFFFFFFFFFF8LL;
        do
        {
          v51 = *((_OWORD *)v8 + 1);
          v52 = *((_OWORD *)v8 + 2);
          v53 = *((_OWORD *)v8 + 3);
          v54 = *((_OWORD *)v8 + 4);
          v55 = *((_OWORD *)v8 + 5);
          v50 -= 8LL;
          *(_OWORD *)result = *(_OWORD *)v8;
          *((_OWORD *)result + 1) = v51;
          *((_OWORD *)result + 2) = v52;
          *((_OWORD *)result + 3) = v53;
          *((_OWORD *)result + 4) = v54;
          *((_OWORD *)result + 5) = v55;
          result += 96;
          v8 += 96;
        }
        while ( v50 );
        if ( v14 == (v14 & 0x3FFFFFFFFFFFFFF8LL) )
          goto LABEL_41;
      }
      else
      {
        v16 = result;
        v17 = v8;
      }
      do
      {
        *(_QWORD *)v16 = *(_QWORD *)v17;
        v18 = *((_DWORD *)v17 + 2);
        v17 += 12;
        *((_DWORD *)v16 + 2) = v18;
        v16 += 12;
      }
      while ( v17 != a3 );
LABEL_41:
      *(_QWORD *)(a1 + 8) = v16;
    }
  }
  return result;
}

//----- (0000000000020E5C) ----------------------------------------------------
void __noreturn std::__vector_base_common<true>::__throw_length_error()
{
  sub_20E70("vector");
}

//----- (0000000000020E70) ----------------------------------------------------
void __fastcall __noreturn sub_20E70(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_20EC0(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::length_error,
    (void (__fastcall *)(void *))&std::length_error::~length_error);
}

//----- (0000000000020EC0) ----------------------------------------------------
__int64 __fastcall sub_20EC0(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::length_error + 16;
  return result;
}

//----- (0000000000020EF0) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_length_error()
{
  sub_20E70("basic_string");
}

//----- (0000000000020F04) ----------------------------------------------------
_QWORD *__fastcall std::__put_character_sequence<char,std::char_traits<char>>(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x8
  char *v5; // x9
  _QWORD *v6; // x0
  __int64 v9; // x22
  int v10; // w5
  __int64 v11; // x23
  int v12; // w26
  __int64 v13; // x0
  unsigned __int8 v14; // w24
  __int64 v15; // x2
  char v17[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v18; // [xsp+8h] [xbp-58h]
  _QWORD v19[2]; // [xsp+10h] [xbp-50h] BYREF

  v19[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17[0] = 0;
  v18 = a1;
  v4 = (_QWORD *)(*a1 - 24LL);
  v5 = (char *)a1 + *v4;
  if ( !*((_DWORD *)v5 + 8) )
  {
    v6 = (_QWORD *)*((_QWORD *)v5 + 17);
    if ( v6 )
    {
      std::ostream::flush(v6);
      v4 = (_QWORD *)(*a1 - 24LL);
    }
    v17[0] = 1;
    v9 = (__int64)a1 + *v4;
    v10 = *(_DWORD *)(v9 + 144);
    v11 = *(_QWORD *)(v9 + 40);
    v12 = *(_DWORD *)(v9 + 8);
    if ( v10 == -1 )
    {
      std::ios_base::getloc(v19, (std::ios_base *)v9);
      v13 = std::locale::use_facet(v19, &std::ctype<char>::id);
      v14 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 56LL))(v13, 32LL);
      std::locale::~locale((std::locale *)v19);
      v10 = v14;
      *(_DWORD *)(v9 + 144) = v14;
    }
    if ( (v12 & 0xB0) == 32 )
      v15 = a2 + a3;
    else
      v15 = a2;
    if ( !sub_210A8(v11, a2, v15, a2 + a3, v9, v10) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v17);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 20F04: using guessed type char var_60[8];

//----- (00000000000210A8) ----------------------------------------------------
__int64 __fastcall sub_210A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c)
{
  __int64 v6; // x19
  __int64 v7; // x8
  __int64 v8; // x25
  bool v10; // cc
  signed __int64 v11; // x8
  signed __int64 v15; // x23
  char *v16; // x25
  void *v17; // x1
  __int64 v18; // x24
  __int64 v19; // x22
  unsigned __int64 v21; // [xsp+0h] [xbp-70h] BYREF
  __int64 v22; // [xsp+8h] [xbp-68h]
  void *v23; // [xsp+10h] [xbp-60h]
  __int64 v24; // [xsp+18h] [xbp-58h]

  v6 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v7 = *(_QWORD *)(a5 + 24);
    v8 = a3 - a2;
    v10 = v7 <= a4 - a2;
    v11 = v7 - (a4 - a2);
    if ( v10 )
      v15 = 0LL;
    else
      v15 = v11;
    if ( v8 >= 1 && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96LL))(a1) != v8 )
      return 0LL;
    if ( v15 >= 1 )
    {
      v21 = 0LL;
      v22 = 0LL;
      v23 = 0LL;
      if ( (unsigned __int64)v15 >= 0x17 )
      {
        v16 = (char *)operator new((v15 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v22 = v15;
        v23 = v16;
        v21 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)&v21 + 1;
        LOBYTE(v21) = 2 * v15;
      }
      memset(v16, c, v15);
      v16[v15] = 0;
      v17 = (v21 & 1) != 0 ? v23 : (char *)&v21 + 1;
      v18 = (*(__int64 (__fastcall **)(__int64, void *, signed __int64))(*(_QWORD *)v6 + 96LL))(v6, v17, v15);
      if ( (v21 & 1) != 0 )
        operator delete(v23);
      if ( v18 != v15 )
        return 0LL;
    }
    v19 = a4 - a3;
    if ( v19 < 1 || (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 96LL))(v6, a3, v19) == v19 )
      *(_QWORD *)(a5 + 24) = 0LL;
    else
      return 0LL;
  }
  return v6;
}

//----- (000000000002125C) ----------------------------------------------------
__int64 __fastcall std::ostream::sentry::~sentry(__int64 result)
{
  __int64 v1; // x8
  __int64 v2; // x19
  __int64 v3; // x0
  std::ios_base *v4; // x0

  v1 = *(_QWORD *)(result + 8) + *(_QWORD *)(**(_QWORD **)(result + 8) - 24LL);
  if ( *(_QWORD *)(v1 + 40) )
  {
    if ( !*(_DWORD *)(v1 + 32) && (*(_BYTE *)(v1 + 9) & 0x20) != 0 )
    {
      v2 = result;
      result = std::uncaught_exception();
      if ( (result & 1) == 0 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL) + 40LL);
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
        if ( (_DWORD)result == -1 )
        {
          v4 = (std::ios_base *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL));
          return std::ios_base::clear(v4, *((_DWORD *)v4 + 8) | 1u);
        }
      }
    }
  }
  return result;
}

//----- (00000000000212FC) ----------------------------------------------------
_QWORD *__fastcall std::ostream::flush(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  char v6[8]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD *v7; // [xsp+10h] [xbp-30h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (_QWORD *)(*a1 - 24LL);
  if ( *(_QWORD *)((char *)a1 + *v2 + 40) )
  {
    v6[0] = 0;
    v7 = a1;
    v3 = (char *)a1 + *v2;
    if ( !*((_DWORD *)v3 + 8) )
    {
      v4 = (_QWORD *)*((_QWORD *)v3 + 17);
      if ( v4 )
      {
        std::ostream::flush(v4);
        v2 = (_QWORD *)(*a1 - 24LL);
      }
      v6[0] = 1;
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)((char *)a1 + *v2 + 40) + 48LL))(*(_QWORD *)((char *)a1 + *v2 + 40)) == -1 )
        std::ios_base::clear(
          (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
          *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 1);
    }
    std::ostream::sentry::~sentry((__int64)v6);
  }
  return a1;
}
// 212FC: using guessed type char var_38[8];

//----- (000000000002141C) ----------------------------------------------------
__int64 *__fastcall std::string::assign(__int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x25
  _BYTE *v7; // x22
  void *v8; // x22
  unsigned __int64 v9; // x8
  __int64 v10; // x23
  void *v11; // x24

  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 >= n )
    {
LABEL_3:
      if ( (*(_BYTE *)a1 & 1) != 0 )
      {
        v7 = (_BYTE *)a1[2];
        if ( !n )
          goto LABEL_12;
      }
      else
      {
        v7 = (char *)a1 + 1;
        if ( !n )
        {
LABEL_12:
          v7[n] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = n;
          else
            *(_BYTE *)a1 = 2 * n;
          return a1;
        }
      }
      memmove(v7, src, n);
      goto LABEL_12;
    }
  }
  else
  {
    v6 = 22LL;
    if ( n <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v6 < n - v6 )
    std::__basic_string_common<true>::__throw_length_error();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v8 = (void *)a1[2];
  else
    v8 = (char *)a1 + 1;
  if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v10 = -17LL;
  }
  else
  {
    v9 = 2 * v6;
    if ( 2 * v6 <= n )
      v9 = n;
    if ( v9 >= 0x17 )
      v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v10 = 23LL;
  }
  v11 = (void *)operator new(v10);
  memcpy(v11, src, n);
  if ( v6 != 22 )
    operator delete(v8);
  a1[1] = n;
  a1[2] = (__int64)v11;
  *a1 = v10 | 1;
  *((_BYTE *)v11 + n) = 0;
  return a1;
}

//----- (000000000002156C) ----------------------------------------------------
__int64 *__fastcall std::string::append(__int64 *a1, void *src, size_t n)
{
  unsigned __int64 v3; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  void *v10; // x23
  char *v11; // x23
  unsigned __int64 v12; // x8
  __int64 v13; // x24
  __int64 v14; // x8
  char *v15; // x8
  char *v16; // x0
  char *v17; // x25

  v3 = *(unsigned __int8 *)a1;
  if ( (v3 & 1) != 0 )
  {
    v7 = a1[1];
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v7 = v3 >> 1;
    v8 = 22LL;
  }
  if ( v8 - v7 < n )
  {
    v9 = v7 + n;
    if ( -18LL - v8 < v7 + n - v8 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v3 & 1) != 0 )
      v10 = (void *)a1[2];
    else
      v10 = (char *)a1 + 1;
    if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v13 = -17LL;
    }
    else
    {
      v12 = 2 * v8;
      if ( v9 >= 2 * v8 )
        v12 = v7 + n;
      if ( v12 >= 0x17 )
        v13 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v13 = 23LL;
    }
    v16 = (char *)operator new(v13);
    v17 = v16;
    if ( v7 )
      memcpy(v16, v10, v7);
    memcpy(&v17[v7], src, n);
    if ( v8 != 22 )
      operator delete(v10);
    *a1 = v13 | 1;
    v15 = &v17[v9];
    a1[1] = v9;
    a1[2] = (__int64)v17;
    goto LABEL_29;
  }
  if ( n )
  {
    if ( (v3 & 1) != 0 )
      v11 = (char *)a1[2];
    else
      v11 = (char *)a1 + 1;
    memcpy(&v11[v7], src, n);
    v14 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v14;
    else
      *(_BYTE *)a1 = 2 * v14;
    v15 = &v11[v14];
LABEL_29:
    *v15 = 0;
  }
  return a1;
}

//----- (00000000000216EC) ----------------------------------------------------
_QWORD *__fastcall std::ostream::put(_QWORD *a1, unsigned __int8 a2)
{
  _QWORD *v3; // x8
  char *v4; // x9
  _QWORD *v5; // x0
  _QWORD *v7; // x0
  unsigned __int8 *v8; // x8
  char v10[8]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD *v11; // [xsp+10h] [xbp-30h]
  __int64 v12; // [xsp+18h] [xbp-28h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[0] = 0;
  v11 = a1;
  v3 = (_QWORD *)(*a1 - 24LL);
  v4 = (char *)a1 + *v3;
  if ( !*((_DWORD *)v4 + 8) )
  {
    v5 = (_QWORD *)*((_QWORD *)v4 + 17);
    if ( v5 )
    {
      std::ostream::flush(v5);
      v3 = (_QWORD *)(*a1 - 24LL);
    }
    v10[0] = 1;
    v7 = *(_QWORD **)((char *)a1 + *v3 + 40);
    if ( v7 )
    {
      v8 = (unsigned __int8 *)v7[6];
      if ( v8 != (unsigned __int8 *)v7[7] )
      {
        v7[6] = v8 + 1;
        *v8 = a2;
        goto LABEL_10;
      }
      if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(*v7 + 104LL))(v7, a2) != -1 )
        goto LABEL_10;
      v3 = (_QWORD *)(*a1 - 24LL);
    }
    std::ios_base::clear((std::ios_base *)((char *)a1 + *v3), *(_DWORD *)((char *)a1 + *v3 + 32) | 1);
  }
LABEL_10:
  std::ostream::sentry::~sentry((__int64)v10);
  return a1;
}
// 216EC: using guessed type char var_38[8];

//----- (0000000000021828) ----------------------------------------------------
void __fastcall std::vector<int>::__push_back_slow_path<int const&>(__int64 a1, _DWORD *a2)
{
  void *v2; // x20
  signed __int64 v4; // x21
  unsigned __int64 v5; // x8
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x25
  char *v10; // x23
  char *v11; // x24
  _DWORD *v12; // x24

  v2 = *(void **)a1;
  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v5 = (v4 >> 2) + 1;
  if ( v5 >> 62 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 2) > 0x1FFFFFFFFFFFFFFELL )
  {
    v9 = 0x3FFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = (char *)operator new(4 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 1;
  if ( v8 >= v5 )
    v9 = v8;
  else
    v9 = (v4 >> 2) + 1;
  if ( v9 )
  {
    if ( v9 >> 62 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = &v10[4 * (v4 >> 2)];
  *(_DWORD *)v11 = *a2;
  v12 = v11 + 4;
  if ( v4 >= 1 )
    memcpy(v10, v2, v4);
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = &v10[4 * v9];
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000021920) ----------------------------------------------------
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2)
{
  cv::Mat *v3; // x19
  __int64 v4; // x8
  unsigned int *v5; // x8
  unsigned int v6; // w9
  __int64 v7; // x8
  unsigned int *v8; // x8
  unsigned int v9; // w9
  unsigned int v10; // w9
  int v11; // w8
  __int64 v12; // x8
  __int64 v13; // x9
  __int64 v14; // x10
  void *v15; // x1
  unsigned int *v16; // x8
  unsigned int v17; // w9
  unsigned int v18; // w9
  __int64 v19; // x8
  __int64 v20; // x9
  __int64 v21; // x8
  __int64 v22; // x11
  int v23; // w8
  _QWORD *v24; // x10
  _QWORD *v25; // x8
  __int64 v26; // x9
  __int64 v27; // x10
  int64x2_t v28; // q1
  _QWORD *v29; // x11
  __int64 v30; // x12
  int64x2_t v31; // q0
  __int64 v32; // d2
  __int64 v33; // x12
  int *v34; // x9
  __int64 v35; // t1
  struct _Unwind_Exception *v37; // x0
  struct _Unwind_Exception *v38; // x19
  __int128 v39; // [xsp+0h] [xbp-90h] BYREF
  void *v40[2]; // [xsp+10h] [xbp-80h]
  __int128 v41; // [xsp+20h] [xbp-70h]
  __int64 v42; // [xsp+38h] [xbp-58h]
  __int64 v43; // [xsp+40h] [xbp-50h]
  cv *v44; // [xsp+48h] [xbp-48h]
  _QWORD v45[4]; // [xsp+50h] [xbp-40h] BYREF

  v3 = this;
  v45[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_DWORD *)a2 & 0xFFF) != 6 )
  {
    if ( (*(_DWORD *)a2 & 7) == 6 )
    {
      cv::Mat::reshape(&v39, a2, 1, *((_DWORD *)a2 + 1), 0LL);
      v3 = cv::Mat_<double>::operator=(v3, (cv::Mat *)&v39);
      if ( v42 )
      {
        v16 = (unsigned int *)(v42 + 20);
        do
        {
          v17 = __ldaxr(v16);
          v18 = v17 - 1;
        }
        while ( __stlxr(v18, v16) );
        if ( !v18 )
          cv::Mat::deallocate((cv::Mat *)&v39);
      }
      v42 = 0LL;
      *(_OWORD *)v40 = 0u;
      v41 = 0u;
      if ( SDWORD1(v39) >= 1 )
      {
        v19 = v43;
        v20 = 0LL;
        do
          *(_DWORD *)(v19 + 4 * v20++) = 0;
        while ( v20 < SDWORD1(v39) );
      }
      if ( v44 != (cv *)v45 )
        cv::fastFree(v44, v15);
      return v3;
    }
    if ( (*(_DWORD *)a2 & 0xFF8) == 0 || !*((_QWORD *)a2 + 2) )
    {
LABEL_45:
      *((_QWORD *)&v39 + 1) = this;
      v40[0] = 0LL;
      LODWORD(v39) = -2113863674;
      cv::Mat::convertTo(a2, &v39, 6LL, 1.0, 0.0);
      return v3;
    }
    v21 = *((unsigned int *)a2 + 1);
    if ( (int)v21 < 3 )
    {
      v22 = *((int *)a2 + 3) * (__int64)*((int *)a2 + 2);
      if ( !(_DWORD)v21 )
        goto LABEL_45;
LABEL_44:
      if ( v22 )
      {
        v39 = xmmword_53EC0;
        v40[0] = (void *)operator new(0x40uLL);
        strcpy((char *)v40[0], "DataType<_Tp>::channels == m.channels() || m.empty()");
        v37 = (struct _Unwind_Exception *)cv::error(
                                            4294967081LL,
                                            &v39,
                                            "operator=",
                                            "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/mat.inl.hpp",
                                            1711LL);
        v38 = v37;
        if ( (v39 & 1) != 0 )
        {
          operator delete(v40[0]);
          _Unwind_Resume(v38);
        }
        _Unwind_Resume(v37);
      }
      goto LABEL_45;
    }
    v26 = *((_QWORD *)a2 + 8);
    if ( (_DWORD)v21 == 3 )
    {
      v27 = 0LL;
      v22 = 1LL;
    }
    else
    {
      v27 = v21 & 0x7FFFFFFC;
      v28 = vdupq_n_s64(1uLL);
      v29 = (_QWORD *)(v26 + 8);
      v30 = (unsigned int)v21 & 0xFFFFFFFC;
      v31 = v28;
      do
      {
        v32 = *(v29 - 1);
        v28.n128_u64[0] *= (int)v32;
        v31.n128_u64[0] *= (int)*v29;
        v30 -= 4LL;
        v28.n128_u64[1] *= SHIDWORD(v32);
        v31.n128_u64[1] *= (int)HIDWORD(*v29);
        v29 += 2;
      }
      while ( v30 );
      v22 = v31.n128_u64[0] * v28.n128_u64[0] * v31.n128_u64[1] * v28.n128_u64[1];
      if ( v27 == v21 )
        goto LABEL_44;
    }
    v33 = v21 - v27;
    v34 = (int *)(v26 + 4 * v27);
    do
    {
      v35 = *v34++;
      --v33;
      v22 *= v35;
    }
    while ( v33 );
    goto LABEL_44;
  }
  if ( this != a2 )
  {
    v4 = *((_QWORD *)a2 + 7);
    if ( v4 )
    {
      v5 = (unsigned int *)(v4 + 20);
      do
        v6 = __ldaxr(v5);
      while ( __stlxr(v6 + 1, v5) );
    }
    v7 = *((_QWORD *)this + 7);
    if ( v7 )
    {
      v8 = (unsigned int *)(v7 + 20);
      do
      {
        v9 = __ldaxr(v8);
        v10 = v9 - 1;
      }
      while ( __stlxr(v10, v8) );
      if ( !v10 )
        cv::Mat::deallocate(this);
    }
    v11 = *((_DWORD *)v3 + 1);
    *((_QWORD *)v3 + 7) = 0LL;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    if ( v11 <= 0 )
    {
      *(_DWORD *)v3 = *(_DWORD *)a2;
    }
    else
    {
      v12 = *((_QWORD *)v3 + 8);
      v13 = 0LL;
      do
      {
        *(_DWORD *)(v12 + 4 * v13) = 0;
        v14 = *((int *)v3 + 1);
        ++v13;
      }
      while ( v13 < v14 );
      *(_DWORD *)v3 = *(_DWORD *)a2;
      if ( (int)v14 > 2 )
        goto LABEL_35;
    }
    v23 = *((_DWORD *)a2 + 1);
    if ( v23 <= 2 )
    {
      *((_DWORD *)v3 + 1) = v23;
      v24 = (_QWORD *)*((_QWORD *)v3 + 9);
      *((_QWORD *)v3 + 1) = *((_QWORD *)a2 + 1);
      v25 = (_QWORD *)*((_QWORD *)a2 + 9);
      *v24 = *v25;
      v24[1] = v25[1];
LABEL_36:
      *((_OWORD *)v3 + 1) = *((_OWORD *)a2 + 1);
      *((_OWORD *)v3 + 2) = *((_OWORD *)a2 + 2);
      *((_OWORD *)v3 + 3) = *((_OWORD *)a2 + 3);
      return v3;
    }
LABEL_35:
    cv::Mat::copySize(v3, a2);
    goto LABEL_36;
  }
  return v3;
}
// 21BEC: conditional instruction was optimized away because w8.4>=3
// 21B44: mask 0xFFFFFFFC is shortened because x8.8 <= 0x7FFFFFFF
// 21A90: variable 'v15' is possibly undefined
// 13040: using guessed type __int64 __fastcall cv::Mat::convertTo(_QWORD, _QWORD, _QWORD, double, double);
// 13350: using guessed type __int64 __fastcall cv::error(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 53EC0: using guessed type __int128 xmmword_53EC0;

//----- (0000000000021D58) ----------------------------------------------------
cv::Mat *__fastcall cv::Mat_<double>::operator=(cv::Mat *this, cv::Mat *a2)
{
  void *v3; // x1
  __int64 v4; // x8
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  int v11; // v0.s[1]
  __int128 v12; // q1
  cv *v13; // x0
  int v14; // w8
  unsigned int *v15; // x8
  unsigned int v16; // w9
  unsigned int v17; // w9
  cv *v18; // x9
  cv *v19; // x8
  __int64 v20; // x9
  _BYTE v22[64]; // [xsp+0h] [xbp-90h] BYREF
  cv *v23[2]; // [xsp+40h] [xbp-50h]
  _QWORD v24[4]; // [xsp+50h] [xbp-40h] BYREF

  v24[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_DWORD *)a2 & 0xFFF) == 6 )
  {
    cv::Mat::operator=(this, a2);
  }
  else if ( (*(_DWORD *)a2 & 7) == 6 )
  {
    cv::Mat::reshape(v22, a2, 1, *((_DWORD *)a2 + 1), 0LL);
    if ( this == (cv::Mat *)v22 )
    {
      if ( *(_QWORD *)&v22[56] )
      {
        v15 = (unsigned int *)(*(_QWORD *)&v22[56] + 20LL);
        do
        {
          v16 = __ldaxr(v15);
          v17 = v16 - 1;
        }
        while ( __stlxr(v17, v15) );
        if ( !v17 )
          cv::Mat::deallocate((cv::Mat *)v22);
      }
    }
    else
    {
      v4 = *((_QWORD *)this + 7);
      if ( v4 )
      {
        v5 = (unsigned int *)(v4 + 20);
        do
        {
          v6 = __ldaxr(v5);
          v7 = v6 - 1;
        }
        while ( __stlxr(v7, v5) );
        if ( !v7 )
          cv::Mat::deallocate(this);
      }
      v8 = *((_DWORD *)this + 1);
      *((_QWORD *)this + 7) = 0LL;
      *((_OWORD *)this + 1) = 0u;
      *((_OWORD *)this + 2) = 0u;
      if ( v8 >= 1 )
      {
        v9 = *((_QWORD *)this + 8);
        v10 = 0LL;
        do
          *(_DWORD *)(v9 + 4 * v10++) = 0;
        while ( v10 < *((int *)this + 1) );
      }
      v11 = *(_DWORD *)&v22[4];
      v12 = *(_OWORD *)&v22[16];
      v13 = (cv *)*((_QWORD *)this + 9);
      *(_OWORD *)this = *(_OWORD *)v22;
      *((_OWORD *)this + 1) = v12;
      *((_OWORD *)this + 2) = *(_OWORD *)&v22[32];
      *((_OWORD *)this + 3) = *(_OWORD *)&v22[48];
      if ( v13 == (cv::Mat *)((char *)this + 80) )
      {
        v14 = v11;
      }
      else
      {
        cv::fastFree(v13, v3);
        *((_QWORD *)this + 8) = (char *)this + 8;
        *((_QWORD *)this + 9) = (char *)this + 80;
        v14 = *(_DWORD *)&v22[4];
        v13 = (cv::Mat *)((char *)this + 80);
      }
      if ( v14 <= 2 )
      {
        v18 = v23[1];
        *(_QWORD *)v13 = *(_QWORD *)v23[1];
        *((_QWORD *)v13 + 1) = *((_QWORD *)v18 + 1);
      }
      else
      {
        *((_OWORD *)this + 4) = *(_OWORD *)v23;
        v23[0] = (cv *)&v22[8];
        v23[1] = (cv *)v24;
      }
      *(_DWORD *)v22 = 1124007936;
      memset(&v22[4], 0, 60);
    }
    *(_QWORD *)&v22[56] = 0LL;
    memset(&v22[16], 0, 32);
    if ( *(int *)&v22[4] >= 1 )
    {
      v19 = v23[0];
      v20 = 0LL;
      do
        *((_DWORD *)v19 + v20++) = 0;
      while ( v20 < *(int *)&v22[4] );
    }
    if ( (_QWORD *)v23[1] != v24 )
      cv::fastFree(v23[1], v3);
  }
  else
  {
    *(_QWORD *)&v22[8] = this;
    *(_QWORD *)&v22[16] = 0LL;
    *(_DWORD *)v22 = -2113863674;
    cv::Mat::convertTo(a2, v22, 6LL, 1.0, 0.0);
  }
  return this;
}
// 21E54: variable 'v3' is possibly undefined
// 13040: using guessed type __int64 __fastcall cv::Mat::convertTo(_QWORD, _QWORD, _QWORD, double, double);

//----- (0000000000022028) ----------------------------------------------------
void __fastcall std::vector<Eigen::Transform<float,3,1,0>>::__push_back_slow_path<Eigen::Transform<float,3,1,0> const&>(
        __int64 a1,
        _OWORD *a2)
{
  char *v2; // x20
  __int64 v4; // x22
  __int64 v6; // x9
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x23
  __int64 v9; // x0
  _OWORD *v10; // x8
  _OWORD *v11; // x10
  char *v12; // x11
  char *v13; // x12
  signed __int64 v14; // x13
  _DWORD *v15; // x14
  int v16; // t1

  v2 = *(char **)a1;
  v4 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 6;
  if ( (unsigned __int64)(v4 + 1) >> 58 )
    std::__vector_base_common<true>::__throw_length_error();
  v6 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v6 >> 6) > 0x1FFFFFFFFFFFFFELL )
  {
    v8 = 0x3FFFFFFFFFFFFFFLL;
LABEL_10:
    v9 = operator new(v8 << 6);
    goto LABEL_11;
  }
  v7 = v6 >> 5;
  if ( v7 >= v4 + 1 )
    v8 = v7;
  else
    v8 = v4 + 1;
  if ( v8 )
  {
    if ( v8 >> 58 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v9 = 0LL;
LABEL_11:
  v10 = (_OWORD *)(v9 + (v4 << 6));
  v11 = v10 + 4;
  *v10 = *a2;
  v10[1] = a2[1];
  v10[2] = a2[2];
  v10[3] = a2[3];
  v12 = *(char **)a1;
  v13 = *(char **)(a1 + 8);
  if ( v13 == *(char **)a1 )
  {
    v2 = *(char **)a1;
  }
  else
  {
    v14 = v13 - 64 - v12;
    v15 = v10 - 2;
    do
    {
      v16 = *((_DWORD *)v13 - 16);
      v13 -= 64;
      *(v15 - 8) = v16;
      *(v15 - 7) = *((_DWORD *)v13 + 1);
      *(v15 - 6) = *((_DWORD *)v13 + 2);
      *(v15 - 5) = *((_DWORD *)v13 + 3);
      *(v15 - 4) = *((_DWORD *)v13 + 4);
      *(v15 - 3) = *((_DWORD *)v13 + 5);
      *(v15 - 2) = *((_DWORD *)v13 + 6);
      *(v15 - 1) = *((_DWORD *)v13 + 7);
      *v15 = *((_DWORD *)v13 + 8);
      v15[1] = *((_DWORD *)v13 + 9);
      v15[2] = *((_DWORD *)v13 + 10);
      v15[3] = *((_DWORD *)v13 + 11);
      v15[4] = *((_DWORD *)v13 + 12);
      v15[5] = *((_DWORD *)v13 + 13);
      v15[6] = *((_DWORD *)v13 + 14);
      v15[7] = *((_DWORD *)v13 + 15);
      v15 -= 16;
    }
    while ( v12 != v13 );
    v10 = (_OWORD *)((char *)v10 + (~v14 & 0xFFFFFFFFFFFFFFC0LL));
  }
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = v11;
  *(_QWORD *)(a1 + 16) = v9 + (v8 << 6);
  if ( v2 )
    operator delete(v2);
}

//----- (00000000000221CC) ----------------------------------------------------
void __fastcall std::vector<cv::Mat>::__push_back_slow_path<cv::Mat const&>(__int64 *a1, cv::Mat *a2)
{
  __int64 v2; // x22
  unsigned __int64 v4; // x23
  __int64 v6; // x8
  __int64 v7; // x0
  __int128 v8; // q0
  __int128 v9; // q1
  __int64 v10; // x8
  unsigned int *v11; // x8
  unsigned int v12; // w9
  _QWORD *v13; // x8
  _QWORD *v14; // x9
  void *v15; // x1
  __int64 v16[2]; // [xsp+0h] [xbp-60h] BYREF
  __int64 v17; // [xsp+10h] [xbp-50h]
  __int64 v18; // [xsp+18h] [xbp-48h]
  __int64 *v19; // [xsp+20h] [xbp-40h]
  __int64 v20; // [xsp+28h] [xbp-38h]

  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = 0x2AAAAAAAAAAAAAALL;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  if ( v4 + 1 > 0x2AAAAAAAAAAAAAALL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555LL )
  {
    v18 = 0LL;
    v19 = a1 + 2;
  }
  else
  {
    if ( 0x5555555555555556LL * ((a1[2] - *a1) >> 5) >= v4 + 1 )
      v2 = 0x5555555555555556LL * ((a1[2] - *a1) >> 5);
    else
      v2 = v4 + 1;
    v18 = 0LL;
    v19 = a1 + 2;
    if ( !v2 )
    {
      v6 = 0LL;
      goto LABEL_10;
    }
  }
  v6 = operator new(96 * v2);
LABEL_10:
  v16[0] = v6;
  v7 = v6 + 96 * v4;
  v16[1] = v7;
  v17 = v7;
  v18 = v6 + 96 * v2;
  v8 = *(_OWORD *)a2;
  v9 = *((_OWORD *)a2 + 1);
  *(_OWORD *)v7 = *(_OWORD *)a2;
  *(_OWORD *)(v7 + 16) = v9;
  *(_OWORD *)(v7 + 32) = *((_OWORD *)a2 + 2);
  *(_QWORD *)(v7 + 48) = *((_QWORD *)a2 + 6);
  v10 = *((_QWORD *)a2 + 7);
  *(_QWORD *)(v7 + 88) = 0LL;
  *(_QWORD *)(v7 + 56) = v10;
  *(_QWORD *)(v7 + 64) = v7 + 8;
  *(_QWORD *)(v7 + 80) = 0LL;
  *(_QWORD *)(v7 + 72) = v7 + 80;
  if ( v10 )
  {
    v11 = (unsigned int *)(v10 + 20);
    do
      v12 = __ldaxr(v11);
    while ( __stlxr(v12 + 1, v11) );
    if ( *((int *)a2 + 1) <= 2 )
      goto LABEL_14;
LABEL_16:
    *(_DWORD *)(v7 + 4) = 0;
    cv::Mat::copySize((cv::Mat *)v7, a2);
    goto LABEL_17;
  }
  if ( SDWORD1(v8) > 2 )
    goto LABEL_16;
LABEL_14:
  v13 = (_QWORD *)*((_QWORD *)a2 + 9);
  v14 = *(_QWORD **)(v7 + 72);
  *v14 = *v13;
  v14[1] = v13[1];
LABEL_17:
  v17 += 96LL;
  std::vector<cv::Mat>::__swap_out_circular_buffer(a1, v16);
  std::__split_buffer<cv::Mat>::~__split_buffer((__int64)v16, v15);
}
// 22344: variable 'v15' is possibly undefined

//----- (0000000000022390) ----------------------------------------------------
__int64 *__fastcall std::vector<cv::Mat>::__swap_out_circular_buffer(__int64 *result, _QWORD *a2)
{
  __int64 v2; // x9
  __int64 v3; // x22
  __int64 *v4; // x19
  __int64 v6; // x8
  __int64 v7; // x21
  __int128 v8; // t1
  __int64 v9; // x10
  unsigned int *v10; // x10
  unsigned int v11; // w11
  _QWORD *v12; // x9
  _QWORD *v13; // x8
  __int64 v14; // x8
  __int64 v15; // x9
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x8

  v3 = *result;
  v2 = result[1];
  v4 = result;
  if ( v2 == *result )
  {
    v6 = a2[1];
  }
  else
  {
    v6 = a2[1];
    v7 = result[1];
    do
    {
      v8 = *(_OWORD *)(v7 - 96);
      v7 -= 96LL;
      *(_OWORD *)(v6 - 96) = v8;
      result = (__int64 *)(v6 - 96);
      *(_OWORD *)(v6 - 80) = *(_OWORD *)(v7 + 16);
      *(_OWORD *)(v6 - 64) = *(_OWORD *)(v7 + 32);
      *(_QWORD *)(v6 - 48) = *(_QWORD *)(v7 + 48);
      v9 = *(_QWORD *)(v7 + 56);
      *(_QWORD *)(v6 - 16) = 0LL;
      *(_QWORD *)(v6 - 32) = v6 - 88;
      *(_QWORD *)(v6 - 24) = v6 - 16;
      *(_QWORD *)(v6 - 40) = v9;
      *(_QWORD *)(v6 - 8) = 0LL;
      if ( v9 )
      {
        v10 = (unsigned int *)(v9 + 20);
        do
          v11 = __ldaxr(v10);
        while ( __stlxr(v11 + 1, v10) );
      }
      if ( *(int *)(v2 - 92) > 2 )
      {
        *(_DWORD *)(v6 - 92) = 0;
        result = (__int64 *)cv::Mat::copySize((cv::Mat *)result, (const cv::Mat *)v7);
      }
      else
      {
        v12 = *(_QWORD **)(v2 - 24);
        v13 = *(_QWORD **)(v6 - 24);
        *v13 = *v12;
        v13[1] = v12[1];
      }
      v2 = v7;
      v6 = a2[1] - 96LL;
      a2[1] = v6;
    }
    while ( v7 != v3 );
    v3 = *v4;
  }
  *v4 = v6;
  v14 = a2[2];
  a2[1] = v3;
  v15 = v4[1];
  v4[1] = v14;
  v16 = a2[3];
  a2[2] = v15;
  v17 = v4[2];
  v4[2] = v16;
  v18 = a2[1];
  a2[3] = v17;
  *a2 = v18;
  return result;
}

//----- (00000000000224AC) ----------------------------------------------------
void __fastcall std::__split_buffer<cv::Mat>::~__split_buffer(__int64 a1, void *a2)
{
  __int64 v2; // x20
  __int64 i; // x21
  __int64 v5; // x8
  unsigned int *v6; // x8
  unsigned int v7; // w9
  unsigned int v8; // w9
  int v9; // w8
  __int64 v10; // x8
  __int64 v11; // x9
  cv *v12; // x0

  v2 = *(_QWORD *)(a1 + 8);
  for ( i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16) )
  {
    *(_QWORD *)(a1 + 16) = i - 96;
    v5 = *(_QWORD *)(i - 40);
    if ( v5 )
    {
      v6 = (unsigned int *)(v5 + 20);
      do
      {
        v7 = __ldaxr(v6);
        v8 = v7 - 1;
      }
      while ( __stlxr(v8, v6) );
      if ( !v8 )
        cv::Mat::deallocate((cv::Mat *)(i - 96));
    }
    v9 = *(_DWORD *)(i - 92);
    *(_QWORD *)(i - 40) = 0LL;
    *(_OWORD *)(i - 80) = 0u;
    *(_OWORD *)(i - 64) = 0u;
    if ( v9 >= 1 )
    {
      v10 = *(_QWORD *)(i - 32);
      v11 = 0LL;
      do
        *(_DWORD *)(v10 + 4 * v11++) = 0;
      while ( v11 < *(int *)(i - 92) );
    }
    v12 = *(cv **)(i - 24);
    if ( v12 != (cv *)(i - 16) )
      cv::fastFree(v12, a2);
  }
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
}
// 22560: variable 'a2' is possibly undefined

//----- (000000000002257C) ----------------------------------------------------
void __fastcall std::vector<cv::Vec<float,3>>::__push_back_slow_path<cv::Vec<float,3> const&>(__int64 a1, __int64 a2)
{
  _DWORD *v2; // x20
  _DWORD *v3; // x22
  unsigned __int64 v4; // x24
  __int64 v5; // x23
  __int64 v8; // x0
  __int64 v9; // x8
  __int64 v10; // x10
  int v11; // t1

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD **)(a1 + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v3 - *(_QWORD *)a1) >> 2);
  v5 = 0x1555555555555555LL;
  if ( v4 + 1 > 0x1555555555555555LL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) > 0xAAAAAAAAAAAAAA9LL
    || (0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) >= v4 + 1
      ? (v5 = 0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2))
      : (v5 = v4 + 1),
        v5) )
  {
    v8 = operator new(12 * v5);
  }
  else
  {
    v8 = 0LL;
  }
  v9 = v8 + 12 * v4;
  *(_QWORD *)v9 = *(_QWORD *)a2;
  v10 = v9 + 12;
  for ( *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8); v2 != v3; *(_DWORD *)(v9 + 8) = v3[2] )
  {
    v11 = *(v3 - 3);
    v3 -= 3;
    *(_DWORD *)(v9 - 12) = v11;
    v9 -= 12LL;
    *(_DWORD *)(v9 + 4) = v3[1];
  }
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v8 + 12 * v5;
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000022698) ----------------------------------------------------
__int64 *__fastcall std::string::insert(__int64 *a1, size_t a2, char *src, size_t n)
{
  unsigned __int64 v4; // x8
  char *v6; // x21
  size_t v9; // x27
  unsigned __int64 v10; // x28
  unsigned __int64 v11; // x23
  char *v12; // x8
  char *v13; // x23
  unsigned __int64 v14; // x8
  __int64 v15; // x24
  char *v16; // x22
  __int64 v18; // x8
  char *v19; // x8
  char *v20; // x0
  char *v21; // x25
  char *srca; // [xsp+8h] [xbp-58h]

  v4 = *(unsigned __int8 *)a1;
  v6 = src;
  if ( (v4 & 1) != 0 )
  {
    v9 = a1[1];
    if ( v9 < a2 )
      goto LABEL_44;
  }
  else
  {
    v9 = v4 >> 1;
    if ( v4 >> 1 < a2 )
LABEL_44:
      std::__basic_string_common<true>::__throw_out_of_range();
  }
  if ( (v4 & 1) != 0 )
    v10 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v10 = 22LL;
  if ( v10 - v9 < n )
  {
    v11 = v9 + n;
    if ( -18LL - v10 < v9 + n - v10 )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v4 & 1) != 0 )
      v12 = (char *)a1[2];
    else
      v12 = (char *)a1 + 1;
    srca = v12;
    if ( v10 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v15 = -17LL;
    }
    else
    {
      v14 = 2 * v10;
      if ( v11 >= 2 * v10 )
        v14 = v9 + n;
      if ( v14 >= 0x17 )
        v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v15 = 23LL;
    }
    v20 = (char *)operator new(v15);
    v21 = v20;
    if ( a2 )
      memcpy(v20, srca, a2);
    memcpy(&v21[a2], v6, n);
    if ( v9 != a2 )
      memcpy(&v21[a2 + n], &srca[a2], v9 - a2);
    if ( v10 != 22 )
      operator delete(srca);
    *a1 = v15 | 1;
    v19 = &v21[v11];
    a1[1] = v11;
    a1[2] = (__int64)v21;
LABEL_42:
    *v19 = 0;
    return a1;
  }
  if ( n )
  {
    if ( (v4 & 1) != 0 )
      v13 = (char *)a1[2];
    else
      v13 = (char *)a1 + 1;
    v16 = &v13[a2];
    if ( v9 != a2 )
    {
      if ( &v13[v9] > src && v16 <= src )
        v6 = &src[n];
      memmove(&v16[n], v16, v9 - a2);
    }
    memmove(v16, v6, n);
    v18 = v9 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v18;
    else
      *(_BYTE *)a1 = 2 * v18;
    v19 = &v13[v18];
    goto LABEL_42;
  }
  return a1;
}

//----- (0000000000022894) ----------------------------------------------------
void __noreturn std::__basic_string_common<true>::__throw_out_of_range()
{
  sub_228A8("basic_string");
}

//----- (00000000000228A8) ----------------------------------------------------
void __fastcall __noreturn sub_228A8(const char *a1)
{
  std::logic_error *exception; // x19

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_228F8(exception, a1);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::out_of_range,
    (void (__fastcall *)(void *))&std::out_of_range::~out_of_range);
}

//----- (00000000000228F8) ----------------------------------------------------
__int64 __fastcall sub_228F8(std::logic_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::logic_error::logic_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::out_of_range + 16;
  return result;
}

//----- (0000000000022928) ----------------------------------------------------
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
        __int64 a1,
        __int64 a2)
{
  _DWORD *v2; // x20
  _DWORD *v3; // x22
  unsigned __int64 v4; // x24
  __int64 v5; // x23
  __int64 v8; // x0
  __int64 v9; // x8
  __int64 v10; // x10
  int v11; // t1

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD **)(a1 + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v3 - *(_QWORD *)a1) >> 2);
  v5 = 0x1555555555555555LL;
  if ( v4 + 1 > 0x1555555555555555LL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) > 0xAAAAAAAAAAAAAA9LL
    || (0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) >= v4 + 1
      ? (v5 = 0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2))
      : (v5 = v4 + 1),
        v5) )
  {
    v8 = operator new(12 * v5);
  }
  else
  {
    v8 = 0LL;
  }
  v9 = v8 + 12 * v4;
  *(_QWORD *)v9 = *(_QWORD *)a2;
  v10 = v9 + 12;
  for ( *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8); v2 != v3; *(_DWORD *)(v9 + 8) = v3[2] )
  {
    v11 = *(v3 - 3);
    v3 -= 3;
    *(_DWORD *)(v9 - 12) = v11;
    v9 -= 12LL;
    *(_DWORD *)(v9 + 4) = v3[1];
  }
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v8 + 12 * v5;
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000022A44) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 22A44: using guessed type char var_60[8];

//----- (0000000000022C30) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1, float a2)
{
  _QWORD *v3; // x8
  char *v4; // x9
  _QWORD *v5; // x0
  __int64 v7; // x20
  char *v8; // x21
  __int64 v9; // x22
  __int64 v10; // x0
  unsigned __int8 v11; // w23
  char v13[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v14; // [xsp+8h] [xbp-58h]
  _QWORD v15[2]; // [xsp+10h] [xbp-50h] BYREF

  v15[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13[0] = 0;
  v14 = a1;
  v3 = (_QWORD *)(*a1 - 24LL);
  v4 = (char *)a1 + *v3;
  if ( !*((_DWORD *)v4 + 8) )
  {
    v5 = (_QWORD *)*((_QWORD *)v4 + 17);
    if ( v5 )
    {
      std::ostream::flush(v5);
      v3 = (_QWORD *)(*a1 - 24LL);
    }
    v13[0] = 1;
    std::ios_base::getloc(v15, (std::ios_base *)((char *)a1 + *v3));
    v7 = std::locale::use_facet(v15, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v15);
    v8 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v9 = *((_QWORD *)v8 + 5);
    if ( *((_DWORD *)v8 + 36) == -1 )
    {
      std::ios_base::getloc(v15, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v10 = std::locale::use_facet(v15, &std::ctype<char>::id);
      v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 56LL))(v10, 32LL);
      std::locale::~locale((std::locale *)v15);
      *((_DWORD *)v8 + 36) = v11;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *, double))(*(_QWORD *)v7 + 64LL))(v7, v9, v8, a2) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v13);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 22C30: using guessed type char var_60[8];

//----- (0000000000022DFC) ----------------------------------------------------
_QWORD *__fastcall std::ostream::operator<<(_QWORD *a1)
{
  _QWORD *v2; // x8
  char *v3; // x9
  _QWORD *v4; // x0
  __int64 v5; // x21
  char *v6; // x22
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w24
  char v11[8]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD *v12; // [xsp+8h] [xbp-58h]
  _QWORD v13[2]; // [xsp+10h] [xbp-50h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11[0] = 0;
  v12 = a1;
  v2 = (_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + *v2;
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( v4 )
    {
      std::ostream::flush(v4);
      v2 = (_QWORD *)(*a1 - 24LL);
    }
    v11[0] = 1;
    std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *v2));
    v5 = std::locale::use_facet(v13, &std::num_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale((std::locale *)v13);
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_QWORD *)v6 + 5);
    if ( *((_DWORD *)v6 + 36) == -1 )
    {
      std::ios_base::getloc(v13, (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)));
      v8 = std::locale::use_facet(v13, &std::ctype<char>::id);
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 56LL))(v8, 32LL);
      std::locale::~locale((std::locale *)v13);
      *((_DWORD *)v6 + 36) = v9;
    }
    if ( !(*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 48LL))(v5, v7, v6) )
      std::ios_base::clear(
        (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL)),
        *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5);
  }
  std::ostream::sentry::~sentry((__int64)v11);
  return a1;
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 22DFC: using guessed type char var_60[8];

//----- (0000000000022FC8) ----------------------------------------------------
void *__fastcall ground_filter::Plane_Seg::Plane_Seg(ground_filter::Plane_Seg *this, char a2, float a3)
{
  int *v6; // x20
  unsigned __int64 v7; // x8
  __int64 i; // x9
  unsigned __int64 v9; // x8
  __int64 v10; // x9
  void *result; // x0
  __int128 v12; // [xsp+0h] [xbp-13E0h] BYREF
  void *v13; // [xsp+10h] [xbp-13D0h]
  __int64 v14; // [xsp+1380h] [xbp-60h]
  __int64 v15; // [xsp+1388h] [xbp-58h]

  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)this = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)&v12 + 1) = 0x6D6F646E00LL;
  LOBYTE(v12) = 24;
  v6 = (int *)((char *)this + 24);
  v13 = 0LL;
  *(_QWORD *)((char *)&v12 + 1) = *(_QWORD *)"/dev/urandom";
  std::random_device::random_device((_DWORD *)this + 6, (__int64)&v12);
  if ( (v12 & 1) != 0 )
    operator delete(v13);
  v7 = 5489LL;
  *((_QWORD *)this + 4) = 5489LL;
  for ( i = 5LL; i != 628; ++i )
  {
    v7 = (unsigned int)i + 1812433253 * ((unsigned int)(v7 >> 30) ^ (unsigned int)v7) - 4;
    *((_QWORD *)this + i) = v7;
  }
  *((_QWORD *)this + 628) = 0LL;
  *((_DWORD *)this + 1298) = 0;
  *((_QWORD *)this + 659) = 0LL;
  *((_QWORD *)this + 658) = 0LL;
  *((_QWORD *)this + 657) = 0LL;
  *((_QWORD *)this + 663) = 0LL;
  *((_QWORD *)this + 662) = 0LL;
  *((_QWORD *)this + 661) = 0LL;
  v9 = (unsigned int)std::random_device::operator()(v6);
  v10 = 1LL;
  *(_QWORD *)&v12 = v9;
  do
  {
    v9 = (unsigned int)v10 + 1812433253 * ((unsigned int)(v9 >> 30) ^ (unsigned int)v9);
    *((_QWORD *)&v12 + v10++) = v9;
  }
  while ( v10 != 624 );
  v14 = 0LL;
  result = memcpy((char *)this + 32, &v12, 0x1388uLL);
  *((float *)this + 1321) = a3;
  *((_BYTE *)this + 5280) = a2 & 1;
  return result;
}

//----- (000000000002326C) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::judgPointsValid(float *a1, float **a2)
{
  float *v2; // x9
  float *v3; // x10
  unsigned int v4; // w8
  float v5; // s3
  float v6; // s4
  float v7; // s4
  float v8; // s5
  float v9; // s6
  float v10; // s6

  v2 = *a2;
  v3 = a2[1];
  if ( *a2 == v3 )
    return 1LL;
  v4 = 255;
  while ( 1 )
  {
    v5 = v2[2];
    v6 = fabsf(v5);
    if ( v6 > 5000.0 || v6 < 0.0001 )
      break;
    v8 = *v2;
    v7 = v2[1];
    v9 = a1[1274] + (float)((float)((float)(*v2 * a1[1262]) + (float)(v7 * a1[1266])) + (float)(v5 * a1[1270]));
    if ( v9 < a1[1294] )
      return 0LL;
    if ( v9 > a1[1295] )
      return 0LL;
    v10 = a1[1275] + (float)((float)((float)(v8 * a1[1263]) + (float)(v7 * a1[1267])) + (float)(v5 * a1[1271]));
    if ( v10 < a1[1296] )
      return 0LL;
    if ( v10 > a1[1297] )
      return 0LL;
    if ( vabds_f32(
           a1[1276] + (float)((float)((float)(v8 * a1[1264]) + (float)(v7 * a1[1268])) + (float)(v5 * a1[1272])),
           a1[1298]) > (float)(a1[1321] * 5.0) )
      return 2;
    v2 += 3;
    if ( v3 == v2 )
      return 1LL;
  }
  return v4;
}

//----- (00000000000233C0) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::judgPlaneValid(__int64 a1, float *a2, float *a3, float a4)
{
  float v4; // s9
  float v5; // s10
  float v7; // s1
  float v8; // s11
  float v9; // s2
  float v10; // s4
  float v11; // s5
  float v12; // s0
  bool v15; // w8
  float v16; // s0
  float v17; // s1

  v4 = *a2;
  v5 = a2[1];
  v7 = a3[1];
  v8 = a2[2];
  v9 = a3[2];
  v10 = sqrtf((float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v8 * v8));
  v11 = sqrtf((float)((float)(*a3 * *a3) + (float)(v7 * v7)) + (float)(v9 * v9));
  v12 = (float)((float)(v8 / v10) * (float)(v9 / v11))
      + (float)((float)((float)(*a2 / v10) * (float)(*a3 / v11)) + (float)((float)(v5 / v10) * (float)(v7 / v11)));
  if ( fabsf(fabsf(v12) + -1.0) >= 0.0001 )
  {
    v16 = acosf(v12);
    if ( v16 > 1.57079633 )
    {
      v17 = 3.14159265 - v16;
      v16 = v17;
    }
    v15 = fabsf(v16) <= 0.523598776;
  }
  else
  {
    v15 = 1;
  }
  return v15 & (unsigned __int8)(vabds_f32(
                                   fabsf((float)((float)(v4 * 0.0) + (float)(v5 * 0.0)) + (float)((float)(v8 * 0.0)
                                                                                                + a2[3])),
                                   a4) <= *(float *)(a1 + 5284));
}

//----- (0000000000023504) ----------------------------------------------------
float __fastcall ground_filter::Plane_Seg::getVectorAngle(__int64 a1, float *a2, float *a3)
{
  float v3; // s1
  float v4; // s4
  float v5; // s2
  float v6; // s5
  float v7; // s6
  float v8; // s7
  float v9; // s0
  float v11; // s0
  float v12; // s1

  v3 = a2[1];
  v4 = a3[1];
  v5 = a2[2];
  v6 = a3[2];
  v7 = sqrtf((float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v5 * v5));
  v8 = sqrtf((float)((float)(*a3 * *a3) + (float)(v4 * v4)) + (float)(v6 * v6));
  v9 = (float)((float)((float)(*a2 / v7) * (float)(*a3 / v8)) + (float)((float)(v3 / v7) * (float)(v4 / v8)))
     + (float)((float)(v5 / v7) * (float)(v6 / v8));
  if ( fabsf(fabsf(v9) + -1.0) < 0.0001 )
    return 0.0;
  v11 = acosf(v9);
  if ( v11 > 1.57079633 )
  {
    v12 = 3.14159265 - v11;
    v11 = v12;
  }
  return fabsf(v11);
}

//----- (00000000000235D8) ----------------------------------------------------
void __usercall ground_filter::Plane_Seg::run(
        float32x2_t *a1@<X0>,
        _QWORD *a2@<X1>,
        int a3@<W2>,
        int a4@<W3>,
        int a5@<W4>,
        __int64 a6@<X5>,
        unsigned __int32 *a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        float a10@<S0>,
        char **a11)
{
  __int64 *v12; // x0

  v12 = (__int64 *)&a1[661];
  if ( v12 != (__int64 *)a11 )
    std::vector<ground_filter::plane_base>::assign<ground_filter::plane_base*>(v12, *a11, a11[1]);
  ground_filter::Plane_Seg::run(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0000000000023684) ----------------------------------------------------
void __usercall ground_filter::Plane_Seg::run(
        float32x2_t *a1@<X0>,
        _QWORD *a2@<X1>,
        int a3@<W2>,
        int a4@<W3>,
        int a5@<W4>,
        __int64 a6@<X5>,
        unsigned __int32 *a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        float a10@<S0>)
{
  __int64 v15; // x26
  char *v16; // x8
  __int64 v17; // x9
  float32x2_t v18; // d5
  float32x2_t v19; // d6
  float32x2_t v20; // d7
  float32x2_t v21; // d4
  float v22; // s0
  float v23; // s1
  float v24; // s2
  float v25; // s3
  unsigned __int32 v26; // w10
  unsigned __int32 v27; // w12
  unsigned __int32 v28; // w13
  unsigned __int32 v29; // w8
  unsigned __int32 v30; // w9
  unsigned __int32 v31; // w11
  float v32; // w14
  float v33; // w15
  float v34; // w16
  float v35; // w17
  float v36; // w0
  float v37; // w1
  float v38; // s17
  float v39; // s3
  unsigned __int32 v40; // w0
  unsigned __int64 v41; // x0
  int v42; // w27
  int v43; // w9
  int v44; // w23
  unsigned int v45; // w19
  __int64 v46; // x28
  __int64 v47; // x9
  char *v48; // x8
  int v49; // w24
  int v50; // w22
  int v51; // w21
  int *v52; // x26
  int v53; // w8
  _DWORD *v54; // x8
  _DWORD *v55; // x8
  char *v56; // x19
  _BYTE *v57; // x22
  signed __int64 v58; // x0
  int v59; // w8
  float32x2_t *v60; // x25
  __int64 v61; // x20
  char *v62; // x0
  char *v63; // x23
  __int64 v64; // x8
  __int64 v65; // x1
  __int64 v66; // x2
  __int64 v67; // x3
  __int64 v68; // x4
  char v69; // w22
  __int64 v70; // x1
  __int64 v71; // x2
  __int64 v72; // x3
  __int64 v73; // x4
  int v77; // [xsp+3Ch] [xbp-164h]
  void *v80; // [xsp+48h] [xbp-158h] BYREF
  char *v81; // [xsp+50h] [xbp-150h]
  __int64 v82; // [xsp+58h] [xbp-148h]
  int v83; // [xsp+64h] [xbp-13Ch] BYREF
  void *v84; // [xsp+68h] [xbp-138h] BYREF
  void *v85; // [xsp+70h] [xbp-130h]
  _DWORD *v86; // [xsp+78h] [xbp-128h]
  void *v87[2]; // [xsp+80h] [xbp-120h] BYREF
  void *v88; // [xsp+90h] [xbp-110h]
  void *v89; // [xsp+A0h] [xbp-100h] BYREF
  _DWORD *v90; // [xsp+A8h] [xbp-F8h]
  unsigned __int64 v91; // [xsp+B0h] [xbp-F0h]
  void *v92; // [xsp+B8h] [xbp-E8h] BYREF
  _DWORD *v93; // [xsp+C0h] [xbp-E0h]
  _DWORD *v94; // [xsp+C8h] [xbp-D8h]
  void *v95; // [xsp+D0h] [xbp-D0h] BYREF
  char *v96; // [xsp+D8h] [xbp-C8h]
  char *v97; // [xsp+E0h] [xbp-C0h]
  void *v98; // [xsp+E8h] [xbp-B8h] BYREF
  void *v99; // [xsp+F0h] [xbp-B0h]
  __int64 v100; // [xsp+F8h] [xbp-A8h]
  __int64 v101; // [xsp+100h] [xbp-A0h] BYREF
  int v102; // [xsp+108h] [xbp-98h]
  int v103; // [xsp+110h] [xbp-90h] BYREF
  int v104; // [xsp+114h] [xbp-8Ch]
  int v105; // [xsp+118h] [xbp-88h]
  float32x2_t v106; // [xsp+120h] [xbp-80h] BYREF
  float v107; // [xsp+128h] [xbp-78h]
  float v108; // [xsp+12Ch] [xbp-74h]
  __int64 v109; // [xsp+130h] [xbp-70h]

  v15 = a4 * a3;
  v109 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v98 = 0LL;
  v99 = 0LL;
  v100 = 0LL;
  v95 = 0LL;
  v96 = 0LL;
  v97 = 0LL;
  if ( a4 * a3 )
  {
    if ( (v15 & 0x80000000) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v16 = (char *)operator new(a4 * a3);
    v97 = &v16[v15];
    v17 = -v15;
    v95 = v16;
    v96 = v16;
    do
    {
      *v16 = 0;
      ++v17;
      v16 = ++v96;
    }
    while ( v17 );
  }
  if ( a1[660].n64_u8[0] )
  {
    v18.n64_u64[0] = a1[639].n64_u64[0];
    v19.n64_u64[0] = a1[641].n64_u64[0];
    v20.n64_u64[0] = a1[643].n64_u64[0];
    v21.n64_u64[0] = a1[645].n64_u64[0];
    v22 = a1[640].n64_f32[0];
    v23 = a1[642].n64_f32[0];
    v24 = a1[644].n64_f32[0];
    v25 = a1[646].n64_f32[0];
LABEL_8:
    a1[649].n64_f32[0] = a10;
    goto LABEL_9;
  }
  v26 = *(_DWORD *)a6;
  a1[631].n64_u32[0] = *(_DWORD *)a6;
  v27 = *(_DWORD *)(a6 + 4);
  v18.n64_u32[0] = v26;
  a1[631].n64_u32[1] = v27;
  v28 = *(_DWORD *)(a6 + 8);
  v19.n64_u32[0] = v27;
  a1[632].n64_u32[0] = v28;
  v20.n64_u32[0] = v28;
  a1[632].n64_u32[1] = *(_DWORD *)(a6 + 12);
  v29 = *(_DWORD *)(a6 + 16);
  a1[633].n64_u32[0] = v29;
  v30 = *(_DWORD *)(a6 + 20);
  v18.n64_u32[1] = v29;
  a1[633].n64_u32[1] = v30;
  v31 = *(_DWORD *)(a6 + 24);
  v19.n64_u32[1] = v30;
  a1[634].n64_u32[0] = v31;
  v20.n64_u32[1] = v31;
  a1[634].n64_u32[1] = *(_DWORD *)(a6 + 28);
  v32 = *(float *)(a6 + 32);
  a1[635].n64_f32[0] = v32;
  v33 = *(float *)(a6 + 36);
  v22 = v32;
  a1[635].n64_f32[1] = v33;
  v34 = *(float *)(a6 + 40);
  v23 = v33;
  a1[636].n64_f32[0] = v34;
  v24 = v34;
  a1[636].n64_u32[1] = *(_DWORD *)(a6 + 44);
  v35 = *(float *)(a6 + 48);
  a1[637].n64_f32[0] = v35;
  v36 = *(float *)(a6 + 52);
  a1[637].n64_f32[1] = v36;
  v37 = *(float *)(a6 + 56);
  v38 = v36;
  v39 = (float)-(float)(v36 * v33) - (float)(v35 * v32);
  a1[638].n64_f32[0] = v37;
  v40 = *(_DWORD *)(a6 + 60);
  v25 = v39 - (float)(v37 * v34);
  v21.n64_u64[0] = vsub_f32(vsub_f32(vneg_f32(vmul_n_f32(v19, v38)), vmul_n_f32(v18, v35)), vmul_n_f32(v20, v37)).n64_u64[0];
  a1[639].n64_u32[0] = v26;
  a1[641].n64_u32[0] = v27;
  a1[643].n64_u32[0] = v28;
  a1[640].n64_f32[0] = v32;
  a1[642].n64_f32[0] = v33;
  a1[644].n64_f32[0] = v34;
  a1[639].n64_u32[1] = v29;
  a1[640].n64_u32[1] = 0;
  a1[641].n64_u32[1] = v30;
  a1[642].n64_u32[1] = 0;
  a1[643].n64_u32[1] = v31;
  a1[644].n64_u32[1] = 0;
  a1[646].n64_u32[1] = 1065353216;
  a1[646].n64_f32[0] = v25;
  a1[638].n64_u32[1] = v40;
  a1[645].n64_u64[0] = v21.n64_u64[0];
  a1[647].n64_u32[0] = *a7;
  a1[647].n64_u32[1] = a7[1];
  a1[648].n64_u32[0] = a7[2];
  a1[648].n64_u32[1] = a7[3];
  if ( sqrtf((float)((float)(v35 * v35) + (float)(v38 * v38)) + (float)(v37 * v37)) < 100.0 )
    goto LABEL_8;
  a1[649].n64_u32[0] = 0;
LABEL_9:
  a1[649].n64_f32[1] = a10;
  a1[630].n64_u32[1] = 1065353216;
  a1[629].n64_u64[0] = vadd_f32(v21, vadd_f32(vadd_f32(vmul_f32(v18, 0LL), vmul_f32(v19, 0LL)), vmul_f32(v20, 0LL))).n64_u64[0];
  a1[630].n64_f32[0] = v25 + (float)((float)((float)(v22 * 0.0) + (float)(v23 * 0.0)) + (float)(v24 * 0.0));
  v92 = 0LL;
  v93 = 0LL;
  v94 = 0LL;
  v89 = 0LL;
  v90 = 0LL;
  v91 = 0LL;
  v87[0] = 0LL;
  v87[1] = 0LL;
  v88 = 0LL;
  if ( (_DWORD)v15 )
  {
    if ( (v15 & 0x80000000) != 0 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v41 = operator new(4 * v15);
    *(int64x2_t *)v87 = vdupq_n_s64(v41);
    v88 = (void *)(v41 + 4 * v15);
  }
  if ( a4 <= 0 )
  {
    v57 = 0LL;
    v56 = 0LL;
  }
  else
  {
    v42 = 0;
    v43 = 0;
    do
    {
      if ( a3 >= 1 )
      {
        v77 = v43;
        v44 = 0;
        v45 = (a5 >> 1) + a5 * v42;
        do
        {
          v46 = (unsigned int)(v42 + v44);
          *((_BYTE *)v95 + v46) = 1;
          v47 = a2[1];
          v48 = (char *)v87[1];
          v49 = *(_DWORD *)(*a2 + 4 * (v47 + v45));
          v50 = *(_DWORD *)(*a2 + 4 * (v45 + 2 * v47));
          v51 = *(_DWORD *)(*a2 + 4LL * v45);
          LODWORD(v84) = v45;
          if ( v87[1] >= v88 )
          {
            std::vector<int>::__push_back_slow_path<int>((__int64)v87, &v84);
          }
          else
          {
            *(_DWORD *)v87[1] = v45;
            v87[1] = v48 + 4;
          }
          v84 = 0LL;
          v85 = 0LL;
          v86 = 0LL;
          v52 = (int *)operator new(0xCuLL);
          *v52 = v51;
          v52[1] = v49;
          v84 = v52;
          v85 = v52 + 3;
          v52[2] = v50;
          v86 = v52 + 3;
          v53 = (unsigned __int8)ground_filter::Plane_Seg::judgPointsValid((float *)a1, (float **)&v84);
          if ( v53 != 2 )
          {
            if ( v53 )
            {
              v54 = v93;
              v103 = v51;
              v104 = v49;
              v105 = v50;
              if ( v93 == v94 )
              {
                std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
                  (__int64)&v92,
                  (__int64)&v103);
              }
              else
              {
                *v93 = v51;
                v54[1] = v104;
                v54[2] = v105;
                v93 = v54 + 3;
              }
              v55 = v90;
              v83 = v42 + v44;
              if ( (unsigned __int64)v90 >= v91 )
              {
                std::vector<int>::__push_back_slow_path<int>((__int64)&v89, &v83);
              }
              else
              {
                *v90 = v46;
                v90 = v55 + 1;
              }
            }
            else
            {
              *((_BYTE *)v95 + v46) = 0;
            }
          }
          operator delete(v52);
          ++v44;
          v45 += a5;
        }
        while ( v44 < a3 );
        v43 = v77;
        v42 += v44;
      }
      ++v43;
    }
    while ( v43 < a4 );
    v57 = v89;
    v56 = (char *)v90;
  }
  v85 = 0LL;
  v86 = 0LL;
  v84 = 0LL;
  v58 = v56 - v57;
  v101 = *(_QWORD *)a8;
  v59 = *(_DWORD *)(a8 + 8);
  v81 = 0LL;
  v82 = 0LL;
  v80 = 0LL;
  v102 = v59;
  if ( v56 != v57 )
  {
    v60 = a1;
    v61 = v58 >> 2;
    if ( (unsigned __int64)(v58 >> 2) >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v62 = (char *)operator new(v58);
    v63 = v62;
    v64 = (__int64)&v62[4 * v61];
    a1 = v60;
    v80 = v62;
    v81 = v62;
    v82 = v64;
    if ( v56 - v57 >= 1 )
    {
      memcpy(v62, v57, v56 - v57);
      v81 = &v63[v56 - v57];
    }
  }
  v69 = ground_filter::Plane_Seg::segPlane(
          a1,
          (float **)&v92,
          &v95,
          &v106,
          &v98,
          (__int64)&v84,
          (__int64)&v101,
          &v80,
          50);
  if ( v80 )
  {
    v81 = (char *)v80;
    operator delete(v80);
  }
  if ( (v69 & 1) != 0 )
  {
    LOBYTE(v103) = ground_filter::Plane_Seg::judgPlaneValid((__int64)a1, (float *)&v106, (float *)a8, a10) & 1;
    if ( v108 < 0.0 )
    {
      v106.n64_u64[0] = vneg_f32(v106).n64_u64[0];
      v107 = -v107;
      v108 = -v108;
    }
    _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(
      a9,
      v70,
      v71,
      v72,
      v73,
      &v106,
      (const void **)&v98,
      (char **)&v84,
      (__int64)&v95,
      &v103);
  }
  else
  {
    LOBYTE(v103) = 0;
    _ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(
      a9,
      v65,
      v66,
      v67,
      v68,
      &v106,
      (const void **)&v98,
      (char **)&v84,
      (__int64)&v95,
      &v103);
  }
  if ( v84 )
  {
    v85 = v84;
    operator delete(v84);
  }
  if ( v87[0] )
  {
    v87[1] = v87[0];
    operator delete(v87[0]);
  }
  if ( v89 )
  {
    v90 = v89;
    operator delete(v89);
  }
  if ( v92 )
  {
    v93 = v92;
    operator delete(v92);
  }
  if ( v95 )
  {
    v96 = (char *)v95;
    operator delete(v95);
  }
  if ( v98 )
  {
    v99 = v98;
    operator delete(v98);
  }
}
// 23BFC: variable 'v70' is possibly undefined
// 23BFC: variable 'v71' is possibly undefined
// 23BFC: variable 'v72' is possibly undefined
// 23BFC: variable 'v73' is possibly undefined
// 23C24: variable 'v65' is possibly undefined
// 23C24: variable 'v66' is possibly undefined
// 23C24: variable 'v67' is possibly undefined
// 23C24: variable 'v68' is possibly undefined

//----- (0000000000023DF0) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::segPlane(
        float32x2_t *a1,
        float **a2,
        _QWORD *a3,
        float32x2_t *a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8,
        int a9)
{
  unsigned __int64 v9; // x20
  float v11; // s8
  int32x4_t *v17; // x0
  __int64 v18; // x21
  int32x4_t *v19; // x19
  int32x4_t v20; // q0
  double v21; // d4
  double v22; // d5
  double v23; // d6
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x9
  int32x4_t *v27; // x11
  int32x4_t v28; // q1
  int32x4_t v29; // q2
  unsigned __int64 v30; // x12
  double v31; // d1
  double v32; // d3
  float **v33; // x24
  float v34; // s9
  double v35; // d2
  int v36; // w21
  __int64 v37; // x28
  __int64 v38; // x27
  int *v39; // x0
  _BYTE *v40; // x9
  _DWORD *v41; // x23
  int *v42; // x26
  char *v43; // x25
  __int64 v44; // x24
  unsigned __int64 v45; // x0
  int v46; // w10
  void *v47; // x0
  float *v48; // x8
  float *v49; // x9
  float *v50; // x10
  __int64 v51; // x10
  float *v52; // x8
  float *v53; // x23
  float *v54; // x25
  signed __int64 v55; // x0
  unsigned __int64 v56; // x24
  char *v57; // x0
  char *v58; // x9
  char *v59; // x8
  int v60; // w19
  char *v61; // x2
  __int128 v62; // kr00_16
  float v63; // w8
  double v64; // d0
  _DWORD *v65; // x9
  int v66; // w23
  double v67; // d0
  double *v68; // x8
  double v69; // x8
  double v70; // d0
  double v71; // d0
  float *v72; // x19
  float *v73; // x20
  __int64 v74; // x21
  float v75; // w24
  float v76; // w25
  float v77; // w26
  int v78; // w8
  _DWORD *v79; // x9
  unsigned __int64 v80; // x8
  int v81; // w10
  _QWORD *v82; // [xsp+10h] [xbp-1E0h]
  float32x2_t *v83; // [xsp+18h] [xbp-1D8h]
  __int64 v84; // [xsp+20h] [xbp-1D0h]
  _QWORD *v86; // [xsp+58h] [xbp-198h]
  int v88; // [xsp+6Ch] [xbp-184h]
  __int64 v90; // [xsp+78h] [xbp-178h] BYREF
  void *v91[2]; // [xsp+80h] [xbp-170h] BYREF
  char *v92; // [xsp+90h] [xbp-160h]
  void *v93; // [xsp+A0h] [xbp-150h] BYREF
  void *v94; // [xsp+A8h] [xbp-148h]
  __int64 v95; // [xsp+B0h] [xbp-140h]
  void *v96; // [xsp+B8h] [xbp-138h] BYREF
  void *v97; // [xsp+C0h] [xbp-130h]
  __int64 v98; // [xsp+C8h] [xbp-128h]
  __int128 v99; // [xsp+D0h] [xbp-120h] BYREF
  void *v100; // [xsp+E8h] [xbp-108h]
  _BYTE *v101; // [xsp+F0h] [xbp-100h]
  __int64 v102; // [xsp+F8h] [xbp-F8h]
  __int128 v103; // [xsp+100h] [xbp-F0h] BYREF
  double v104; // [xsp+118h] [xbp-D8h] BYREF
  int v105; // [xsp+120h] [xbp-D0h]
  __int64 v106; // [xsp+128h] [xbp-C8h] BYREF
  int v107; // [xsp+130h] [xbp-C0h]
  unsigned __int64 v108; // [xsp+138h] [xbp-B8h] BYREF
  __int64 v109; // [xsp+140h] [xbp-B0h]
  __int64 v110; // [xsp+148h] [xbp-A8h]
  __int64 v111; // [xsp+150h] [xbp-A0h]

  v111 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2);
  if ( v9 < 0xA )
    return 0LL;
  v11 = a1[660].n64_f32[1];
  v100 = 0LL;
  v101 = 0LL;
  v102 = 0LL;
  if ( v9 >> 62 )
    std::__vector_base_common<true>::__throw_length_error();
  v17 = (int32x4_t *)operator new(4 * v9);
  v18 = (__int64)v17 + 4 * v9;
  v19 = v17;
  v100 = v17;
  v102 = v18;
  memset(v17, 0, 4 * v9);
  v101 = (_BYTE *)v18;
  if ( 4 * v9 )
  {
    v24 = (v18 - (__int64)v19) >> 2;
    if ( v24 <= 1 )
      v25 = 1LL;
    else
      v25 = (v18 - (__int64)v19) >> 2;
    if ( v25 < 8 )
    {
      v26 = 0LL;
      do
      {
LABEL_13:
        v19->n128_u32[v26] = v26;
        ++v26;
      }
      while ( v24 > v26 );
      goto LABEL_14;
    }
    v20 = (int32x4_t)xmmword_54730;
    v26 = v25 & 0xFFFFFFFFFFFFFFF8LL;
    v27 = v19 + 1;
    v28.n128_u64[0] = 0x400000004LL;
    v28.n128_u64[1] = 0x400000004LL;
    v29.n128_u64[0] = 0x800000008LL;
    v29.n128_u64[1] = 0x800000008LL;
    v30 = v25 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v27[-1] = v20;
      *v27 = vaddq_s32(v20, v28);
      v20 = vaddq_s32(v20, v29);
      v30 -= 8LL;
      v27 += 2;
    }
    while ( v30 );
    if ( v25 != v26 )
      goto LABEL_13;
  }
LABEL_14:
  v88 = -2147483647;
  HIDWORD(v31) = 1070176665;
  v82 = a8;
  v32 = -4.60517025;
  v33 = a2;
  v34 = 1.0;
  v35 = v11;
  v36 = 0;
  v83 = a1;
  v37 = (__int64)&a1[4];
  v86 = a5;
  v84 = a6;
  v99 = 0uLL;
  v96 = 0LL;
  v97 = 0LL;
  v98 = 0LL;
  v93 = 0LL;
  v94 = 0LL;
  v95 = 0LL;
  do
  {
    v20.n128_f32[0] = (float)v36;
    *(float *)&v31 = ceilf(v34);
    if ( *(float *)&v31 <= (float)v36 )
      break;
    v108 = 0LL;
    v109 = 0LL;
    v110 = 0LL;
    v38 = operator new(0x24uLL);
    v110 = v38 + 36;
    v108 = v38;
    v109 = v38 + 36;
    v39 = (int *)operator new(0xCuLL);
    v41 = v100;
    v40 = v101;
    v42 = v39;
    v39[2] = 0;
    *(_QWORD *)v39 = 0LL;
    if ( v40 - (_BYTE *)v41 >= 5 )
    {
      v43 = v40 - 4;
      *(_OWORD *)v91 = xmmword_54740;
      if ( v40 - 4 > (_BYTE *)v41 )
      {
        v44 = ((unsigned __int64)(v40 - (_BYTE *)v41) >> 2) - 1;
        do
        {
          *(_QWORD *)&v103 = 0LL;
          *((_QWORD *)&v103 + 1) = v44;
          v45 = std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(
                  (__int64)v91,
                  v37,
                  (unsigned __int64 *)&v103);
          if ( v45 )
          {
            v46 = *v41;
            *v41 = v41[v45];
            v41[v45] = v46;
          }
          ++v41;
          --v44;
        }
        while ( v43 > (char *)v41 );
        v41 = v100;
        v33 = a2;
      }
    }
    v47 = memmove(v42, v41, 0xCuLL);
    v48 = *v33;
    v49 = &(*v33)[3 * *v42];
    v50 = &(*v33)[3 * v42[1]];
    *(float *)v38 = *v49;
    *(float *)(v38 + 4) = v49[1];
    *(float *)(v38 + 8) = v49[2];
    *(float *)(v38 + 12) = *v50;
    *(float *)(v38 + 16) = v50[1];
    *(float *)&v49 = v50[2];
    v51 = v42[2];
    *(_DWORD *)(v38 + 20) = (_DWORD)v49;
    v52 = &v48[3 * v51];
    *(float *)(v38 + 24) = *v52;
    *(float *)(v38 + 28) = v52[1];
    *(float *)(v38 + 32) = v52[2];
    v106 = *(_QWORD *)a7;
    v107 = *(_DWORD *)(a7 + 8);
    if ( (ground_filter::Plane_Seg::getPlaneFrom3Points((__int64)v47, (__int64)&v108, (float *)&v106, (__int64)&v103) & 1) != 0 )
    {
      v91[1] = 0LL;
      v92 = 0LL;
      v91[0] = 0LL;
      v53 = *v33;
      v54 = v33[1];
      v55 = (char *)v54 - (char *)*v33;
      if ( v54 == *v33 )
      {
        v59 = 0LL;
      }
      else
      {
        v56 = 0xAAAAAAAAAAAAAAABLL * (v55 >> 2);
        if ( v56 >= 0x1555555555555556LL )
          sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v57 = (char *)operator new(v55);
        v58 = &v57[12 * v56];
        v33 = a2;
        v59 = v57;
        v91[0] = v57;
        v91[1] = v57;
        v92 = v58;
      }
      v61 = v59;
      if ( v53 != v54 )
      {
        v62 = v103;
        do
        {
          v63 = *v53;
          *(float *)&v104 = v63;
          *((float *)&v104 + 1) = v53[1];
          v64 = fabsf(
                  (float)((float)(*(float *)&v62 * v63) + (float)(*((float *)&v62 + 1) * *((float *)&v104 + 1)))
                + (float)((float)(*((float *)&v62 + 2) * v53[2]) + *((float *)&v62 + 3)));
          v105 = *((_DWORD *)v53 + 2);
          if ( v11 * 0.2 > v64 )
          {
            v65 = v91[1];
            if ( v91[1] == v92 )
            {
              std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
                (__int64)v91,
                (__int64)&v104);
            }
            else
            {
              *(float *)v91[1] = v63;
              v65[1] = HIDWORD(v104);
              v65[2] = v105;
              v91[1] = v65 + 3;
            }
          }
          v53 += 3;
        }
        while ( v53 != v54 );
        v59 = (char *)v91[0];
        v61 = (char *)v91[1];
      }
      v66 = -1431655765 * ((unsigned __int64)(v61 - v59) >> 2);
      if ( v88 < v66 )
      {
        v99 = v103;
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>((__int64)&v96, v59, v61);
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
          (__int64)&v93,
          (char *)v38,
          (char *)(v38 + 36));
        v67 = pow((float)(1.0 / (float)v9) * (double)v66, 3.0);
        v90 = 0x3CB0000000000000LL;
        v68 = (double *)&v90;
        v104 = 1.0 - v67;
        if ( 1.0 - v67 > 2.22044605e-16 )
          v68 = &v104;
        v69 = *v68;
        v70 = v69;
        if ( v69 >= 1.0 )
          v70 = 1.0;
        v104 = v69;
        v71 = log(v70);
        v59 = (char *)v91[0];
        v88 = v66;
        v34 = -4.60517025 / v71;
      }
      if ( v36 >= a9 )
        v60 = 6;
      else
        v60 = 0;
      if ( v59 )
      {
        v91[1] = v59;
        operator delete(v59);
      }
      ++v36;
    }
    else
    {
      v60 = 5;
    }
    operator delete(v42);
    operator delete((void *)v38);
  }
  while ( v60 != 6 );
  ground_filter::Plane_Seg::optimizePlaneCoef(
    v83,
    (__int64 *)&v96,
    (unsigned __int32 *)&v99,
    a4,
    v20.n128_f64[0],
    v31,
    v35,
    v32,
    v21,
    v22,
    v23);
  v86[1] = *v86;
  v72 = *v33;
  v73 = v33[1];
  if ( *v33 != v73 )
  {
    v74 = 0LL;
    do
    {
      v75 = *v72;
      v76 = v72[1];
      v77 = v72[2];
      if ( v11 * 0.5 > fabsf(
                         (float)((float)(a4->n64_f32[0] * *v72) + (float)(a4->n64_f32[1] * v76))
                       + (float)((float)(a4[1].n64_f32[0] * v77) + a4[1].n64_f32[1])) )
      {
        v78 = *(_DWORD *)(*v82 + v74);
        LODWORD(v91[0]) = v78;
        v79 = (_DWORD *)v86[1];
        if ( v79 == (_DWORD *)v86[2] )
        {
          std::vector<int>::__push_back_slow_path<int const&>((__int64)v86, v91);
        }
        else
        {
          *v79 = v78;
          v86[1] = v79 + 1;
        }
        *(_BYTE *)(*a3 + SLODWORD(v91[0])) = 2;
        v108 = __PAIR64__(LODWORD(v76), LODWORD(v75));
        *(float *)&v109 = v77;
        v80 = *(_QWORD *)(v84 + 8);
        if ( v80 >= *(_QWORD *)(v84 + 16) )
        {
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(
            v84,
            (__int64 *)&v108);
        }
        else
        {
          v81 = v109;
          *(_QWORD *)v80 = v108;
          *(_DWORD *)(v80 + 8) = v81;
          *(float *)v80 = v75;
          *(_DWORD *)(v80 + 4) = HIDWORD(v108);
          *(_DWORD *)(v80 + 8) = v109;
          *(_QWORD *)(v84 + 8) += 12LL;
        }
      }
      v72 += 3;
      v74 += 4LL;
    }
    while ( v72 != v73 );
  }
  if ( v93 )
  {
    v94 = v93;
    operator delete(v93);
  }
  if ( v96 )
  {
    v97 = v96;
    operator delete(v96);
  }
  if ( v100 )
  {
    v101 = v100;
    operator delete(v100);
  }
  return 1LL;
}
// 24310: variable 'v20' is possibly undefined
// 24310: variable 'v31' is possibly undefined
// 24310: variable 'v35' is possibly undefined
// 24310: variable 'v32' is possibly undefined
// 24310: variable 'v21' is possibly undefined
// 24310: variable 'v22' is possibly undefined
// 24310: variable 'v23' is possibly undefined
// 54730: using guessed type __int128 xmmword_54730;
// 54740: using guessed type __int128 xmmword_54740;
// 23DF0: using guessed type __int128 var_120;

//----- (000000000002457C) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::getIndication(__int64 this, float *a2, float *a3)
{
  *a2 = *(float *)(this + 5200);
  *a3 = *(float *)(this + 5204);
  return this;
}

//----- (0000000000024590) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::getPointInfo(__int64 result, _DWORD *a2, _QWORD *a3)
{
  *a2 = *(_DWORD *)(result + 5208);
  a2[1] = *(_DWORD *)(result + 5212);
  a2[2] = *(_DWORD *)(result + 5216);
  a2[3] = *(_DWORD *)(result + 5220);
  a2[4] = *(_DWORD *)(result + 5224);
  a2[5] = *(_DWORD *)(result + 5228);
  a2[6] = *(_DWORD *)(result + 5232);
  a2[7] = *(_DWORD *)(result + 5236);
  a2[8] = *(_DWORD *)(result + 5240);
  *a3 = *(_QWORD *)(result + 5248);
  return result;
}

//----- (00000000000245E4) ----------------------------------------------------
float64x2_t __usercall ground_filter::Plane_Seg::getTFMatrix@<Q0>(
        double *a1@<X1>,
        float64x2_t *a2@<X2>,
        float64x2_t *a3@<X8>)
{
  double v3; // d9
  double v4; // d13
  double v7; // d10
  double v8; // d11
  double v9; // d12
  double v10; // d7
  double v11; // d16
  double v12; // d2
  double v13; // d1
  double v14; // d3
  double v15; // d5
  double v16; // d11
  double v17; // d2
  double v18; // d12
  double v19; // d9
  double v20; // d10
  double v21; // d7
  double v22; // d17
  double v23; // d18
  double v24; // d3
  double v25; // d0
  double v26; // d6
  double v27; // d3
  double v28; // d0
  double v29; // d4
  double v30; // d16
  double v31; // d1
  double v32; // d17
  double v33; // d4
  double v34; // d18
  double v35; // d6
  double v36; // d5
  double v37; // d3
  double v38; // d0
  double v39; // d7
  double v40; // d19
  double v41; // d20
  double v42; // d4
  double v43; // d18
  double v44; // d6
  double v45; // d3
  double v46; // d0
  double v47; // d1
  double v48; // d5
  float64x2_t result; // q0
  double v50; // d1
  double v51; // [xsp+8h] [xbp-78h] BYREF
  double v52; // [xsp+10h] [xbp-70h] BYREF
  double cosx; // [xsp+18h] [xbp-68h] BYREF
  double sinx; // [xsp+20h] [xbp-60h] BYREF
  double v55; // [xsp+28h] [xbp-58h] BYREF
  double v56; // [xsp+38h] [xbp-48h] BYREF

  v3 = a1[1];
  v4 = *a1;
  sincos(a1[2] * 0.5, &sinx, &cosx);
  v8 = cosx;
  v7 = sinx;
  v9 = sinx * 0.0;
  sincos(v3 * 0.5, &v52, &v51);
  v10 = v52 * 0.0 * v9;
  v11 = v7 * (v52 * 0.0);
  v12 = v8 * (v52 * 0.0);
  v13 = v51 * v7 + v12;
  v14 = v51 * v8 - v10;
  v15 = v12 + v51 * v9;
  v16 = v11 + v52 * v8 + v51 * v9 - v10;
  v17 = v14 - v52 * v9;
  v18 = v52 * v9 + v13 - v10;
  v19 = v17 - v11;
  v20 = v10 + v15 - v52 * v7;
  sincos(v4 * 0.5, &v56, &v55);
  v21 = v56 * 0.0 * v19;
  v22 = v56 * 0.0 * v16;
  v23 = v56 * 0.0 * v18;
  v24 = v56 * 0.0 * v20;
  v25 = v24 + v55 * v18 + v21;
  v26 = v22 + v56 * v19 + v55 * v20 - v23;
  v27 = v56 * v18 + v21 + v55 * v16 - v24;
  v28 = v25 - v56 * v16;
  v29 = v55 * v19 - v56 * v20 - v22 - v23;
  v30 = v29 * (v26 + v26);
  v31 = v26 * (v26 + v26);
  v32 = v29 * (v27 + v27);
  v33 = v29 * (v28 + v28);
  v34 = v26 * (v27 + v27);
  v35 = v26 * (v28 + v28);
  v36 = v27 * (v27 + v27);
  v37 = v27 * (v28 + v28);
  v38 = v28 * (v28 + v28);
  v39 = v36 + v38;
  v40 = v34 - v33;
  v41 = v35 + v32;
  v42 = v34 + v33;
  v43 = v37 - v30;
  v44 = v35 - v32;
  v45 = v37 + v30;
  v46 = 1.0 - (v31 + v38);
  v47 = 1.0 - (v31 + v36);
  v48 = (1.0 - v39) * 0.0;
  a3[1].n128_u64[1] = 0LL;
  a3[3].n128_u64[1] = 0LL;
  a3[5].n128_u64[1] = 0LL;
  a3[7].n128_u64[1] = 0x3FF0000000000000LL;
  a3[4].n128_f64[0] = v41 + v43 * 0.0 + v47 * 0.0;
  a3[4].n128_f64[1] = v43 + v41 * 0.0 + v47 * 0.0;
  a3[5].n128_f64[0] = v47 + v41 * 0.0 + v43 * 0.0;
  a3->n128_f64[0] = v44 * 0.0 + 1.0 - v39 + v42 * 0.0;
  a3->n128_f64[1] = v44 * 0.0 + v42 + v48;
  a3[1].n128_f64[0] = v44 + v42 * 0.0 + v48;
  a3[2].n128_f64[0] = v45 * 0.0 + v40 + v46 * 0.0;
  a3[2].n128_f64[1] = v45 * 0.0 + v40 * 0.0 + v46;
  a3[3].n128_f64[0] = v45 + v40 * 0.0 + v46 * 0.0;
  result = vaddq_f64(*a2, (float64x2_t)0);
  v50 = a2[1].n128_f64[0] + 0.0;
  a3[6] = result;
  a3[7].n128_f64[0] = v50;
  return result;
}

//----- (0000000000024854) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(__int64 a1, __int64 a2, float *a3, __int64 a4)
{
  float *v4; // x20
  float v5; // s4
  float v6; // s3
  float v7; // s2
  float v8; // s0
  float v9; // s1
  float v10; // s3
  float v12; // s5
  float v13; // s4
  __int64 result; // x0
  float v15; // s10
  float v16; // s9
  float v17; // s8
  float v18; // s2
  float v19; // s3
  float v20; // s11
  float v21; // s4
  float v22; // s5
  float v23; // s0
  float v24; // s0
  float v25; // s1
  float v26; // s1

  v4 = *(float **)a2;
  if ( *(_QWORD *)(a2 + 8) - *(_QWORD *)a2 != 36LL )
    return 0LL;
  v5 = v4[2];
  v6 = v4[1];
  v7 = v4[3] - *v4;
  v8 = v4[4] - v6;
  v9 = v4[6] - *v4;
  v10 = v4[7] - v6;
  v12 = v4[5] - v5;
  v13 = v4[8] - v5;
  if ( (float)(v7 / v9) == (float)(v8 / v10) && (float)(v12 / v13) == (float)(v8 / v10) )
    return 0LL;
  v15 = (float)(v8 * v13) - (float)(v12 * v10);
  v16 = (float)(v12 * v9) - (float)(v7 * v13);
  v17 = (float)(v7 * v10) - (float)(v8 * v9);
  *(_DWORD *)(a4 + 12) = 0;
  *(float *)a4 = v15;
  *(float *)(a4 + 4) = v16;
  *(float *)(a4 + 8) = v17;
  v18 = a3[1];
  v19 = a3[2];
  v20 = (float)(v15 * v15) + (float)(v16 * v16);
  v21 = sqrtf((float)(v17 * v17) + v20);
  v22 = sqrtf((float)((float)(*a3 * *a3) + (float)(v18 * v18)) + (float)(v19 * v19));
  v23 = (float)((float)(v17 / v21) * (float)(v19 / v22))
      + (float)((float)((float)(v15 / v21) * (float)(*a3 / v22)) + (float)((float)(v16 / v21) * (float)(v18 / v22)));
  if ( fabsf(fabsf(v23) + -1.0) >= 0.0001 )
  {
    v24 = acosf(v23);
    if ( v24 > 1.57079633 )
    {
      v25 = 3.14159265 - v24;
      v24 = v25;
    }
    if ( fabsf(v24) > 0.785398163 )
      return 0LL;
  }
  v26 = sqrtf(v20 + (float)((float)(v17 * v17) + 0.0));
  *(float *)a4 = v15 / v26;
  *(float *)(a4 + 4) = v16 / v26;
  *(float *)(a4 + 8) = v17 / v26;
  *(float *)(a4 + 12) = 0.0 / v26;
  result = 1LL;
  *(float *)(a4 + 12) = -(float)((float)((float)((float)(v15 / v26) * *v4) + (float)((float)(v16 / v26) * v4[1]))
                               + (float)((float)(v17 / v26) * v4[2]));
  return result;
}

//----- (0000000000024A30) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::optimizePlaneCoef(
        float32x2_t *a1,
        __int64 *a2,
        unsigned __int32 *a3,
        float32x2_t *a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 result; // x0
  __int64 v15; // x21
  __int64 v16; // x23
  int32x2_t v17; // d1
  float *v18; // x0
  float v19; // w8
  float v20; // w9
  float v21; // w10
  float v22; // s0
  float v23; // s2
  float v24; // s0
  float v25; // s2
  std::bad_alloc *exception; // x19
  void *memptr; // [xsp+8h] [xbp-D8h] BYREF
  int v28; // [xsp+10h] [xbp-D0h]
  __int64 v29; // [xsp+14h] [xbp-CCh]
  int v30; // [xsp+1Ch] [xbp-C4h]
  int v31; // [xsp+20h] [xbp-C0h]
  __int64 v32; // [xsp+24h] [xbp-BCh]
  float v33; // [xsp+30h] [xbp-B0h] BYREF
  float v34; // [xsp+34h] [xbp-ACh]
  float v35; // [xsp+38h] [xbp-A8h]
  int32x2_t v36; // [xsp+54h] [xbp-8Ch]
  char v37; // [xsp+6Ch] [xbp-74h]
  int v38[4]; // [xsp+70h] [xbp-70h] BYREF
  unsigned int v39[3]; // [xsp+80h] [xbp-60h] BYREF
  __int64 v40; // [xsp+8Ch] [xbp-54h]
  int v41; // [xsp+98h] [xbp-48h]
  __int64 v42; // [xsp+9Ch] [xbp-44h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( (int)(-1431655765 * ((unsigned __int64)(a2[1] - *a2) >> 2)) <= 3 )
  {
    result = 0LL;
    a4->n64_u32[0] = *a3;
    a4->n64_u32[1] = a3[1];
    a4[1].n64_u32[0] = a3[2];
    a4[1].n64_u32[1] = a3[3];
    return result;
  }
  ground_filter::Plane_Seg::computeMeanAndCovarianceMatrix(
    (__int64)a1,
    a2,
    (__int64)v39,
    (__int64)v38,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11);
  v16 = *a2;
  v15 = a2[1];
  memptr = (void *)__PAIR64__(v40, v39[0]);
  v28 = v41;
  v29 = v40;
  v30 = v42;
  v31 = v41;
  v32 = v42;
  v37 = 0;
  Eigen::SelfAdjointEigenSolver<Eigen::Matrix<float,3,3,0,3,3>>::compute((__int64)&v33, (float *)&memptr, 128);
  if ( posix_memalign(&memptr, 0x10uLL, 0xCuLL) )
  {
    memptr = 0LL;
LABEL_9:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  v18 = (float *)memptr;
  if ( !memptr )
    goto LABEL_9;
  v19 = v33;
  *(float *)memptr = v33;
  v20 = v34;
  v18[1] = v34;
  v21 = v35;
  v18[2] = v35;
  v22 = *(float *)v38;
  v17.n64_u32[0] = v38[1];
  v23 = *(float *)&v38[2];
  a4->n64_f32[0] = v19;
  a4->n64_f32[1] = v18[1];
  a4[1].n64_f32[0] = v18[2];
  a4[1].n64_f32[1] = -(float)((float)((float)(v22 * v19) + (float)(v17.n64_f32[0] * v20)) + (float)(v23 * v21));
  v17.n64_f32[0] = (float)(0xAAAAAAAAAAAAAAABLL * ((v15 - v16) >> 2));
  a1[650].n64_u64[0] = vdiv_f32(v36, vzip1_s32(v17, v36)).n64_u64[0];
  v24 = a4[1].n64_f32[1];
  if ( v24 < 0.0 )
  {
    v25 = -a4[1].n64_f32[0];
    a4->n64_u64[0] = vneg_f32((float32x2_t)a4->n64_u64[0]).n64_u64[0];
    a4[1].n64_f32[0] = v25;
    a4[1].n64_f32[1] = -v24;
  }
  free(v18);
  return 1LL;
}
// 24B90: variable 'v17' is possibly undefined
// 24A30: using guessed type unsigned int var_60[3];

//----- (0000000000024C24) ----------------------------------------------------
__int64 __fastcall ground_filter::Plane_Seg::detectPlane(
        float32x2_t *a1,
        __int64 *a2,
        float32x2_t *a3,
        _QWORD *a4,
        __int64 a5,
        int a6)
{
  float *v10; // x0
  unsigned __int64 v11; // x19
  unsigned int v12; // w19
  float v14; // s8
  int32x4_t *v15; // x0
  __int64 v16; // x21
  int32x4_t *v17; // x25
  int32x4_t v18; // q0
  double v19; // d4
  double v20; // d5
  double v21; // d6
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x10
  unsigned __int64 v24; // x9
  int32x4_t *v25; // x11
  int32x4_t v26; // q1
  int32x4_t v27; // q2
  unsigned __int64 v28; // x12
  double v29; // d2
  double v30; // d9
  double v31; // d3
  double v32; // d1
  float v33; // s15
  int v34; // w23
  __int64 v35; // x26
  double v36; // d14
  __int64 v37; // x25
  int *v38; // x0
  _BYTE *v39; // x9
  _DWORD *v40; // x22
  int *v41; // x27
  char *v42; // x19
  __int64 v43; // x24
  unsigned __int64 v44; // x0
  int v45; // w10
  void *v46; // x0
  char *v47; // x8
  _DWORD *v48; // x9
  _DWORD *v49; // x10
  __int64 v50; // x10
  char *v51; // x8
  float *v52; // x19
  float *v53; // x22
  signed __int64 v54; // x0
  unsigned __int64 v55; // x24
  char *v56; // x8
  int v57; // w19
  char *v58; // x2
  __int128 v59; // kr00_16
  float v60; // w8
  double v61; // d0
  _DWORD *v62; // x9
  int v63; // w19
  double v64; // d0
  double *v65; // x8
  double v66; // x8
  double v67; // d0
  double v68; // d0
  _DWORD *v69; // x19
  _DWORD *v70; // x21
  _DWORD *v71; // x9
  __int64 *v72; // [xsp+8h] [xbp-1C8h]
  _QWORD *v73; // [xsp+10h] [xbp-1C0h]
  float32x2_t *v74; // [xsp+18h] [xbp-1B8h]
  int v76; // [xsp+4Ch] [xbp-184h]
  __int64 v78; // [xsp+58h] [xbp-178h] BYREF
  void *v79[2]; // [xsp+60h] [xbp-170h] BYREF
  char *v80; // [xsp+70h] [xbp-160h]
  __int64 v81; // [xsp+78h] [xbp-158h] BYREF
  __int64 v82; // [xsp+80h] [xbp-150h]
  __int64 v83; // [xsp+88h] [xbp-148h]
  void *v84; // [xsp+90h] [xbp-140h] BYREF
  void *v85; // [xsp+98h] [xbp-138h]
  __int64 v86; // [xsp+A0h] [xbp-130h]
  void *v87; // [xsp+A8h] [xbp-128h] BYREF
  void *v88; // [xsp+B0h] [xbp-120h]
  __int64 v89; // [xsp+B8h] [xbp-118h]
  __int128 v90; // [xsp+C0h] [xbp-110h] BYREF
  void *v91; // [xsp+D0h] [xbp-100h]
  _BYTE *v92; // [xsp+D8h] [xbp-F8h]
  __int64 v93; // [xsp+E0h] [xbp-F0h]
  void *v94; // [xsp+E8h] [xbp-E8h] BYREF
  float *v95; // [xsp+F0h] [xbp-E0h]
  __int128 v96; // [xsp+100h] [xbp-D0h] BYREF
  double v97; // [xsp+110h] [xbp-C0h] BYREF
  int v98; // [xsp+118h] [xbp-B8h]
  __int64 v99; // [xsp+120h] [xbp-B0h] BYREF
  int v100; // [xsp+128h] [xbp-A8h]
  __int64 v101; // [xsp+130h] [xbp-A0h]

  v101 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  ground_filter::Plane_Seg::getPointCloudOnIndexes(a1, a2, &v94);
  v10 = (float *)v94;
  v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v95 - (_BYTE *)v94) >> 2);
  if ( v11 > 9 )
  {
    v14 = a1[660].n64_f32[1];
    v91 = 0LL;
    v92 = 0LL;
    v93 = 0LL;
    if ( v11 >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v15 = (int32x4_t *)operator new(0xAAAAAAAAAAAAAAACLL * (((char *)v95 - (_BYTE *)v94) >> 2));
    v16 = (__int64)v15 + 4 * v11;
    v17 = v15;
    v72 = a2;
    v73 = a4;
    v91 = v15;
    v93 = v16;
    memset(v15, 0, 4 * v11);
    v92 = (_BYTE *)v16;
    if ( 4 * v11 )
    {
      v22 = (v16 - (__int64)v17) >> 2;
      if ( v22 <= 1 )
        v23 = 1LL;
      else
        v23 = (v16 - (__int64)v17) >> 2;
      if ( v23 > 7 )
      {
        v18 = (int32x4_t)xmmword_54730;
        v24 = v23 & 0xFFFFFFFFFFFFFFF8LL;
        v25 = v17 + 1;
        v26.n128_u64[0] = 0x400000004LL;
        v26.n128_u64[1] = 0x400000004LL;
        v27.n128_u64[0] = 0x800000008LL;
        v27.n128_u64[1] = 0x800000008LL;
        v28 = v23 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v25[-1] = v18;
          *v25 = vaddq_s32(v18, v26);
          v18 = vaddq_s32(v18, v27);
          v28 -= 8LL;
          v25 += 2;
        }
        while ( v28 );
        if ( v23 == v24 )
          goto LABEL_16;
      }
      else
      {
        v24 = 0LL;
      }
      do
      {
        v17->n128_u32[v24] = v24;
        ++v24;
      }
      while ( v22 > v24 );
    }
LABEL_16:
    v29 = 0.5;
    v30 = v14 * 0.5;
    v76 = -2147483647;
    v31 = 0.0;
    HIDWORD(v32) = -1072534607;
    v33 = 1.0;
    v34 = 0;
    v35 = (__int64)&a1[4];
    v36 = (float)(1.0 / (float)v11);
    v90 = 0uLL;
    v87 = 0LL;
    v88 = 0LL;
    v89 = 0LL;
    v84 = 0LL;
    v85 = 0LL;
    v86 = 0LL;
    v74 = a1;
    do
    {
      v18.n128_f32[0] = (float)v34;
      *(float *)&v32 = ceilf(v33);
      if ( *(float *)&v32 <= (float)v34 )
        break;
      v81 = 0LL;
      v82 = 0LL;
      v83 = 0LL;
      v37 = operator new(0x24uLL);
      v83 = v37 + 36;
      v81 = v37;
      v82 = v37 + 36;
      v38 = (int *)operator new(0xCuLL);
      v40 = v91;
      v39 = v92;
      v41 = v38;
      v38[2] = 0;
      *(_QWORD *)v38 = 0LL;
      if ( v39 - (_BYTE *)v40 >= 5 )
      {
        v42 = v39 - 4;
        *(_OWORD *)v79 = xmmword_54740;
        if ( v39 - 4 > (_BYTE *)v40 )
        {
          v43 = ((unsigned __int64)(v39 - (_BYTE *)v40) >> 2) - 1;
          do
          {
            *(_QWORD *)&v96 = 0LL;
            *((_QWORD *)&v96 + 1) = v43;
            v44 = std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(
                    (__int64)v79,
                    v35,
                    (unsigned __int64 *)&v96);
            if ( v44 )
            {
              v45 = *v40;
              *v40 = v40[v44];
              v40[v44] = v45;
            }
            ++v40;
            --v43;
          }
          while ( v42 > (char *)v40 );
          v40 = v91;
        }
      }
      v46 = memmove(v41, v40, 0xCuLL);
      v47 = (char *)v94;
      v48 = (char *)v94 + 12 * *v41;
      v49 = (char *)v94 + 12 * v41[1];
      *(_DWORD *)v37 = *v48;
      *(_DWORD *)(v37 + 4) = v48[1];
      *(_DWORD *)(v37 + 8) = v48[2];
      *(_DWORD *)(v37 + 12) = *v49;
      *(_DWORD *)(v37 + 16) = v49[1];
      LODWORD(v48) = v49[2];
      v50 = v41[2];
      *(_DWORD *)(v37 + 20) = (_DWORD)v48;
      v51 = &v47[12 * v50];
      *(_DWORD *)(v37 + 24) = *(_DWORD *)v51;
      *(_DWORD *)(v37 + 28) = *((_DWORD *)v51 + 1);
      *(_DWORD *)(v37 + 32) = *((_DWORD *)v51 + 2);
      v99 = *(_QWORD *)a5;
      v100 = *(_DWORD *)(a5 + 8);
      if ( (ground_filter::Plane_Seg::getPlaneFrom3Points((__int64)v46, (__int64)&v81, (float *)&v99, (__int64)&v96) & 1) != 0 )
      {
        v52 = (float *)v94;
        v53 = v95;
        v79[0] = 0LL;
        v79[1] = 0LL;
        v80 = 0LL;
        v54 = (char *)v95 - (_BYTE *)v94;
        if ( v95 == v94 )
        {
          v56 = 0LL;
        }
        else
        {
          v55 = 0xAAAAAAAAAAAAAAABLL * (v54 >> 2);
          if ( v55 >= 0x1555555555555556LL )
            sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
          v56 = (char *)operator new(v54);
          v79[0] = v56;
          v79[1] = v56;
          v80 = &v56[12 * v55];
        }
        v58 = v56;
        if ( v52 != v53 )
        {
          v59 = v96;
          do
          {
            v60 = *v52;
            *(float *)&v97 = v60;
            *((float *)&v97 + 1) = v52[1];
            v61 = fabsf(
                    (float)((float)(*(float *)&v59 * v60) + (float)(*((float *)&v59 + 1) * *((float *)&v97 + 1)))
                  + (float)((float)(*((float *)&v59 + 2) * v52[2]) + *((float *)&v59 + 3)));
            v98 = *((_DWORD *)v52 + 2);
            if ( v30 > v61 )
            {
              v62 = v79[1];
              if ( v79[1] == v80 )
              {
                std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
                  (__int64)v79,
                  (__int64)&v97);
              }
              else
              {
                *(float *)v79[1] = v60;
                v62[1] = HIDWORD(v97);
                v62[2] = v98;
                v79[1] = v62 + 3;
              }
            }
            v52 += 3;
          }
          while ( v52 != v53 );
          v56 = (char *)v79[0];
          v58 = (char *)v79[1];
        }
        v63 = -1431655765 * ((unsigned __int64)(v58 - v56) >> 2);
        if ( v76 < v63 )
        {
          v90 = v96;
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>((__int64)&v87, v56, v58);
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
            (__int64)&v84,
            (char *)v37,
            (char *)(v37 + 36));
          v64 = pow(v36 * (double)v63, 3.0);
          v78 = 0x3CB0000000000000LL;
          v65 = (double *)&v78;
          v97 = 1.0 - v64;
          if ( 1.0 - v64 > 2.22044605e-16 )
            v65 = &v97;
          v66 = *v65;
          v67 = v66;
          if ( v66 >= 1.0 )
            v67 = 1.0;
          v97 = v66;
          v68 = log(v67);
          v56 = (char *)v79[0];
          v76 = v63;
          v33 = -4.60517025 / v68;
        }
        if ( v34 >= a6 )
          v57 = 6;
        else
          v57 = 0;
        if ( v56 )
        {
          v79[1] = v56;
          operator delete(v56);
        }
        ++v34;
      }
      else
      {
        v57 = 5;
      }
      operator delete(v41);
      operator delete((void *)v37);
    }
    while ( v57 != 6 );
    ground_filter::Plane_Seg::optimizePlaneCoef(
      v74,
      (__int64 *)&v87,
      (unsigned __int32 *)&v90,
      a3,
      v18.n128_f64[0],
      v32,
      v29,
      v31,
      v19,
      v20,
      v21);
    v73[1] = *v73;
    v69 = (_DWORD *)*v72;
    v70 = (_DWORD *)v72[1];
    if ( (_DWORD *)*v72 != v70 )
    {
      do
      {
        LODWORD(v81) = *v69;
        if ( v30 > fabsf(
                     vaddv_f32(vmul_f32(*(float32x2_t *)(v74->n64_u64[0] + 12LL * (int)v81), (float32x2_t)a3->n64_u64[0]))
                   + (float)((float)(*(float *)(v74->n64_u64[0] + 12LL * (int)v81 + 8) * a3[1].n64_f32[0])
                           + a3[1].n64_f32[1])) )
        {
          v71 = (_DWORD *)v73[1];
          if ( v71 == (_DWORD *)v73[2] )
          {
            std::vector<int>::__push_back_slow_path<int const&>((__int64)v73, &v81);
          }
          else
          {
            *v71 = v81;
            v73[1] = v71 + 1;
          }
        }
        ++v69;
      }
      while ( v70 != v69 );
    }
    if ( v84 )
    {
      v85 = v84;
      operator delete(v84);
    }
    if ( v87 )
    {
      v88 = v87;
      operator delete(v87);
    }
    if ( v91 )
    {
      v92 = v91;
      operator delete(v91);
    }
    v10 = (float *)v94;
    v12 = 1;
    if ( v94 )
      goto LABEL_3;
    return v12;
  }
  v12 = 0;
  if ( v94 )
  {
LABEL_3:
    v95 = v10;
    operator delete(v10);
  }
  return v12;
}
// 25174: variable 'v18' is possibly undefined
// 25174: variable 'v32' is possibly undefined
// 25174: variable 'v29' is possibly undefined
// 25174: variable 'v31' is possibly undefined
// 25174: variable 'v19' is possibly undefined
// 25174: variable 'v20' is possibly undefined
// 25174: variable 'v21' is possibly undefined
// 54730: using guessed type __int128 xmmword_54730;
// 54740: using guessed type __int128 xmmword_54740;

//----- (0000000000025334) ----------------------------------------------------
void __usercall ground_filter::Plane_Seg::getPointCloudOnIndexes(_QWORD *a1@<X0>, __int64 *a2@<X1>, _QWORD *a3@<X8>)
{
  __int64 v3; // x21
  __int64 v4; // x22
  unsigned __int64 v7; // x23
  _DWORD *v8; // x0
  _DWORD *v9; // x8
  __int64 i; // x22
  __int64 v11; // x9
  _DWORD *v12; // x1
  __int64 v13; // x9

  a3[1] = 0LL;
  a3[2] = 0LL;
  *a3 = 0LL;
  v4 = *a2;
  v3 = a2[1];
  if ( v3 != *a2 )
  {
    v7 = (v3 - *a2) >> 2;
    if ( v7 >= 0x1555555555555556LL )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v8 = (_DWORD *)operator new(12 * v7);
    v9 = &v8[3 * v7];
    *a3 = v8;
    a3[1] = v8;
    a3[2] = v9;
    if ( v4 != v3 )
    {
      for ( i = v4 + 4; ; i += 4LL )
      {
        v11 = *(int *)(i - 4);
        v12 = (_DWORD *)(*a1 + 12 * v11);
        if ( v8 == v9 )
        {
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
            (__int64)a3,
            (__int64)v12);
          if ( v3 == i )
            return;
        }
        else
        {
          v13 = *a1 + 12 * v11;
          *v8 = *v12;
          v8[1] = *(_DWORD *)(v13 + 4);
          v8[2] = *(_DWORD *)(v13 + 8);
          a3[1] = v8 + 3;
          if ( v3 == i )
            return;
        }
        v8 = (_DWORD *)a3[1];
        v9 = (_DWORD *)a3[2];
      }
    }
  }
}

//----- (000000000002545C) ----------------------------------------------------
bool __fastcall ground_filter::Plane_Seg::segPlane(char **a1, float32x2_t *a2, __int64 *a3, int a4)
{
  float v4; // s8
  float v5; // s10
  float v6; // s11
  float v7; // s15
  float *v10; // x0
  unsigned __int64 v11; // x21
  _BOOL4 v12; // w19
  int32x4_t *v14; // x0
  __int64 v15; // x19
  int32x4_t *v16; // x23
  int32x4_t v17; // q2
  int32x4_t v18; // q3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x10
  unsigned __int64 v24; // x9
  int32x4_t v25; // q0
  int32x4_t *v26; // x11
  int32x4_t v27; // q1
  unsigned __int64 v28; // x12
  double v29; // d0
  __int64 *v30; // x21
  double v31; // d13
  int v32; // w28
  __int64 v33; // x23
  int v34; // w22
  double v35; // d0
  double v36; // d1
  __int64 v37; // x24
  int *v38; // x0
  _BYTE *v39; // x9
  _DWORD *v40; // x26
  int *v41; // x25
  char *v42; // x21
  __int64 v43; // x19
  unsigned __int64 v44; // x0
  int v45; // w10
  float *v46; // x9
  float v47; // w11
  float *v48; // x10
  char *v49; // x8
  float v50; // w12
  float v51; // w13
  float v52; // s2
  float v53; // w14
  float v54; // s3
  float v55; // s4
  float v56; // w15
  float v57; // s6
  float v58; // s5
  float v59; // s7
  float v60; // s17
  float v61; // s16
  float v62; // s17
  float v63; // s18
  float v64; // s6
  float v65; // s3
  float v66; // s4
  float *v67; // x21
  float *v68; // x26
  signed __int64 v69; // x0
  unsigned __int64 v70; // x19
  char *v71; // x8
  char *v72; // x2
  float v73; // w8
  float v74; // s0
  _DWORD *v75; // x9
  int v76; // w21
  double v77; // d0
  double *v78; // x8
  double v79; // x8
  double v80; // d0
  double v81; // d0
  __int64 v83; // x8
  _BYTE *v84; // x0
  _BYTE *v85; // x9
  __int64 v86; // x10
  unsigned __int64 v87; // x10
  int v88; // w8
  float32x2_t v89; // x9
  _DWORD *v90; // x10
  char *v91; // x9
  float32x2_t *v92; // [xsp+8h] [xbp-188h]
  double v93; // [xsp+10h] [xbp-180h]
  __int64 v96; // [xsp+48h] [xbp-148h] BYREF
  void *v97[2]; // [xsp+50h] [xbp-140h] BYREF
  char *v98; // [xsp+60h] [xbp-130h]
  void *v99; // [xsp+70h] [xbp-120h] BYREF
  void *v100; // [xsp+78h] [xbp-118h]
  __int64 v101; // [xsp+80h] [xbp-110h]
  void *v102; // [xsp+88h] [xbp-108h] BYREF
  void *v103; // [xsp+90h] [xbp-100h]
  __int64 v104; // [xsp+98h] [xbp-F8h]
  void *v105; // [xsp+A0h] [xbp-F0h]
  _BYTE *v106; // [xsp+A8h] [xbp-E8h]
  __int64 v107; // [xsp+B0h] [xbp-E0h]
  void *v108; // [xsp+B8h] [xbp-D8h] BYREF
  float *v109; // [xsp+C0h] [xbp-D0h]
  unsigned __int64 v110; // [xsp+D0h] [xbp-C0h] BYREF
  unsigned __int64 v111; // [xsp+D8h] [xbp-B8h]
  double v112; // [xsp+E0h] [xbp-B0h] BYREF
  __int64 v113; // [xsp+E8h] [xbp-A8h]
  __int64 v114; // [xsp+F0h] [xbp-A0h]

  v114 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector((signed __int64 *)&v108, a1);
  v10 = (float *)v108;
  v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v109 - (_BYTE *)v108) >> 2);
  if ( v11 > 9 )
  {
    v105 = 0LL;
    v106 = 0LL;
    v107 = 0LL;
    if ( v11 >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v14 = (int32x4_t *)operator new(0xAAAAAAAAAAAAAAACLL * (((char *)v109 - (_BYTE *)v108) >> 2));
    v15 = (__int64)v14 + 4 * v11;
    v16 = v14;
    v105 = v14;
    v107 = v15;
    memset(v14, 0, 4 * v11);
    v106 = (_BYTE *)v15;
    if ( 4 * v11 )
    {
      v22 = (v15 - (__int64)v16) >> 2;
      if ( v22 <= 1 )
        v23 = 1LL;
      else
        v23 = (v15 - (__int64)v16) >> 2;
      if ( v23 > 7 )
      {
        v25 = (int32x4_t)xmmword_54730;
        v24 = v23 & 0xFFFFFFFFFFFFFFF8LL;
        v26 = v16 + 1;
        v27.n128_u64[0] = 0x400000004LL;
        v27.n128_u64[1] = 0x400000004LL;
        v17.n128_u64[0] = 0x800000008LL;
        v17.n128_u64[1] = 0x800000008LL;
        v28 = v23 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v18 = vaddq_s32(v25, v27);
          v26[-1] = v25;
          *v26 = v18;
          v25 = vaddq_s32(v25, v17);
          v28 -= 8LL;
          v26 += 2;
        }
        while ( v28 );
        if ( v23 == v24 )
          goto LABEL_16;
      }
      else
      {
        v24 = 0LL;
      }
      do
      {
        v16->n128_u32[v24] = v24;
        ++v24;
      }
      while ( v22 > v24 );
    }
LABEL_16:
    v29 = (double)v11;
    v30 = a3;
    v31 = 1.0;
    v92 = (float32x2_t *)a1;
    v32 = 0;
    v33 = (__int64)(a1 + 4);
    v34 = -2147483647;
    v110 = 0LL;
    v111 = 0LL;
    v102 = 0LL;
    v103 = 0LL;
    v104 = 0LL;
    v99 = 0LL;
    v100 = 0LL;
    v101 = 0LL;
    v93 = 1.0 / v29;
    do
    {
      v35 = (double)v32;
      v36 = ceil(v31);
      if ( v36 <= (double)v32 )
        break;
      v37 = operator new(0x24uLL);
      v38 = (int *)operator new(0xCuLL);
      v40 = v105;
      v39 = v106;
      v41 = v38;
      v38[2] = 0;
      *(_QWORD *)v38 = 0LL;
      if ( v39 - (_BYTE *)v40 >= 5 )
      {
        v42 = v39 - 4;
        *(_OWORD *)v97 = xmmword_54740;
        if ( v39 - 4 > (_BYTE *)v40 )
        {
          v43 = ((unsigned __int64)(v39 - (_BYTE *)v40) >> 2) - 1;
          do
          {
            v112 = 0.0;
            v113 = v43;
            v44 = std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(
                    (__int64)v97,
                    v33,
                    (unsigned __int64 *)&v112);
            if ( v44 )
            {
              v45 = *v40;
              *v40 = v40[v44];
              v40[v44] = v45;
            }
            ++v40;
            --v43;
          }
          while ( v42 > (char *)v40 );
          v40 = v105;
        }
      }
      memmove(v41, v40, 0xCuLL);
      v46 = (float *)((char *)v108 + 12 * *v41);
      v47 = *v46;
      v48 = (float *)((char *)v108 + 12 * v41[1]);
      v49 = (char *)v108 + 12 * v41[2];
      *(float *)v37 = *v46;
      v50 = v46[1];
      *(float *)(v37 + 4) = v50;
      *(float *)&v46 = v46[2];
      *(_DWORD *)(v37 + 8) = (_DWORD)v46;
      v51 = *v48;
      v52 = *(float *)&v46;
      *(float *)(v37 + 12) = *v48;
      v53 = v48[1];
      v54 = v51 - v47;
      *(float *)(v37 + 16) = v53;
      *(float *)&v48 = v48[2];
      v55 = v53 - v50;
      *(_DWORD *)(v37 + 20) = (_DWORD)v48;
      v56 = *(float *)v49;
      v57 = *(float *)&v48 - *(float *)&v46;
      *(_DWORD *)(v37 + 24) = *(_DWORD *)v49;
      LODWORD(v46) = *((_DWORD *)v49 + 1);
      v58 = v56 - v47;
      *(_DWORD *)(v37 + 28) = (_DWORD)v46;
      LODWORD(v49) = *((_DWORD *)v49 + 2);
      v59 = *(float *)&v46 - v50;
      v60 = (float)(v53 - v50) / (float)(*(float *)&v46 - v50);
      v61 = *(float *)&v49 - v52;
      *(_DWORD *)(v37 + 32) = (_DWORD)v49;
      if ( (float)((float)(v51 - v47) / (float)(v56 - v47)) != v60 || (float)(v57 / v61) != v60 )
      {
        v62 = v55 * v61;
        v63 = v57 * v59;
        v64 = (float)(v57 * v58) - (float)(v54 * v61);
        v65 = (float)(v54 * v59) - (float)(v55 * v58);
        v66 = sqrtf(
                (float)((float)(v65 * v65) + 0.0)
              + (float)((float)((float)(v62 - v63) * (float)(v62 - v63)) + (float)(v64 * v64)));
        v4 = (float)(v62 - v63) / v66;
        v7 = v64 / v66;
        v5 = v65 / v66;
        v6 = -(float)((float)((float)(v65 / v66) * v52) + (float)((float)(v4 * v47) + (float)((float)(v64 / v66) * v50)));
      }
      v67 = (float *)v108;
      v68 = v109;
      v97[0] = 0LL;
      v97[1] = 0LL;
      v98 = 0LL;
      v69 = (char *)v109 - (_BYTE *)v108;
      if ( v109 == v108 )
      {
        v71 = 0LL;
      }
      else
      {
        v70 = 0xAAAAAAAAAAAAAAABLL * (v69 >> 2);
        if ( v70 >= 0x1555555555555556LL )
          sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v71 = (char *)operator new(v69);
        v97[0] = v71;
        v97[1] = v71;
        v98 = &v71[12 * v70];
      }
      v72 = v71;
      if ( v67 != v68 )
      {
        do
        {
          v73 = *v67;
          *(float *)&v112 = v73;
          *((float *)&v112 + 1) = v67[1];
          v74 = fabsf((float)(v6 + (float)(v5 * v67[2])) + (float)((float)(v4 * v73)
                                                                 + (float)(v7 * *((float *)&v112 + 1))));
          *(float *)&v113 = v67[2];
          if ( v74 < 0.05 )
          {
            v75 = v97[1];
            if ( v97[1] == v98 )
            {
              std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
                (__int64)v97,
                (__int64)&v112);
            }
            else
            {
              *(float *)v97[1] = v73;
              v75[1] = HIDWORD(v112);
              v75[2] = v113;
              v97[1] = v75 + 3;
            }
          }
          v67 += 3;
        }
        while ( v67 != v68 );
        v71 = (char *)v97[0];
        v72 = (char *)v97[1];
      }
      v76 = -1431655765 * ((unsigned __int64)(v72 - v71) >> 2);
      if ( v34 < v76 )
      {
        v110 = __PAIR64__(LODWORD(v7), LODWORD(v4));
        v111 = __PAIR64__(LODWORD(v6), LODWORD(v5));
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>((__int64)&v102, v71, v72);
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
          (__int64)&v99,
          (char *)v37,
          (char *)(v37 + 36));
        v77 = pow(v93 * (double)v76, 3.0);
        v96 = 0x3CB0000000000000LL;
        v78 = &v112;
        v112 = 1.0 - v77;
        if ( 1.0 - v77 <= 2.22044605e-16 )
          v78 = (double *)&v96;
        v79 = *v78;
        v80 = v79;
        if ( v79 >= 1.0 )
          v80 = 1.0;
        v112 = v79;
        v81 = log(v80);
        v71 = (char *)v97[0];
        v31 = -4.60517019 / v81;
        v34 = v76;
      }
      v30 = a3;
      if ( v71 )
      {
        v97[1] = v71;
        operator delete(v71);
      }
      operator delete(v41);
      operator delete((void *)v37);
    }
    while ( v32++ < a4 );
    ground_filter::Plane_Seg::optimizePlaneCoef(
      v92,
      (__int64 *)&v102,
      (unsigned __int32 *)&v110,
      a2,
      v35,
      v36,
      v17.n128_f64[0],
      v18.n128_f64[0],
      v19,
      v20,
      v21);
    v83 = *v30;
    v30[1] = *v30;
    v97[0] = 0LL;
    v97[1] = 0LL;
    v98 = 0LL;
    LODWORD(v112) = 0;
    if ( v109 == v108 )
    {
      v84 = 0LL;
      v85 = 0LL;
      v86 = v83;
    }
    else
    {
      v87 = 0LL;
      v88 = 0;
      do
      {
        v89.n64_u64[0] = v92->n64_u64[0];
        if ( fabsf(
               vaddv_f32(vmul_f32(*(float32x2_t *)(v92->n64_u64[0] + 12 * v87), (float32x2_t)a2->n64_u64[0]))
             + (float)((float)(*(float *)(v92->n64_u64[0] + 12 * v87 + 8) * a2[1].n64_f32[0]) + a2[1].n64_f32[1])) < 0.05 )
        {
          v90 = (_DWORD *)v30[1];
          if ( v90 == (_DWORD *)v30[2] )
          {
            std::vector<int>::__push_back_slow_path<int const&>((__int64)v30, &v112);
            v89.n64_u64[0] = v92->n64_u64[0];
          }
          else
          {
            *v90 = v88;
            v30[1] = (__int64)(v90 + 1);
          }
        }
        if ( *(float *)(v89.n64_u64[0] + 12LL * SLODWORD(v112) + 8) > 0.0 )
        {
          v91 = (char *)v97[1];
          if ( v97[1] == v98 )
          {
            std::vector<int>::__push_back_slow_path<int const&>((__int64)v97, &v112);
          }
          else
          {
            *(_DWORD *)v97[1] = LODWORD(v112);
            v97[1] = v91 + 4;
          }
        }
        v87 = SLODWORD(v112) + 1LL;
        v88 = ++LODWORD(v112);
      }
      while ( 0xAAAAAAAAAAAAAAABLL * (((char *)v109 - (_BYTE *)v108) >> 2) > v87 );
      v83 = *v30;
      v86 = v30[1];
      v84 = v97[0];
      v85 = v97[1];
    }
    v12 = (float)((float)(unsigned __int64)((v86 - v83) >> 2) / (float)(unsigned __int64)((v85 - v84) >> 2)) >= 0.8;
    if ( v84 )
    {
      v97[1] = v84;
      operator delete(v84);
    }
    if ( v99 )
    {
      v100 = v99;
      operator delete(v99);
    }
    if ( v102 )
    {
      v103 = v102;
      operator delete(v102);
    }
    if ( v105 )
    {
      v106 = v105;
      operator delete(v105);
    }
    v10 = (float *)v108;
    if ( v108 )
      goto LABEL_3;
    return v12;
  }
  v12 = 0;
  if ( v108 )
  {
LABEL_3:
    v109 = v10;
    operator delete(v10);
  }
  return v12;
}
// 258A8: variable 'v6' is possibly undefined
// 258A4: variable 'v5' is possibly undefined
// 25888: variable 'v4' is possibly undefined
// 25898: variable 'v7' is possibly undefined
// 259F4: variable 'v35' is possibly undefined
// 259F4: variable 'v36' is possibly undefined
// 259F4: variable 'v17' is possibly undefined
// 259F4: variable 'v18' is possibly undefined
// 259F4: variable 'v19' is possibly undefined
// 259F4: variable 'v20' is possibly undefined
// 259F4: variable 'v21' is possibly undefined
// 54730: using guessed type __int128 xmmword_54730;
// 54740: using guessed type __int128 xmmword_54740;

//----- (0000000000025C84) ----------------------------------------------------
signed __int64 __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector(signed __int64 *a1, char **a2)
{
  char *v2; // x9
  signed __int64 result; // x0
  unsigned __int64 v5; // x21
  char *v7; // x8
  char *v8; // x10
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x12
  __int64 v11; // x9
  _DWORD *v12; // x9
  char *v13; // x11
  int v14; // w10
  __int64 v15; // x11
  __int64 v16; // x14
  __int128 v17; // q1
  __int128 v18; // q2
  __int128 v19; // q3
  __int128 v20; // q4
  __int128 v21; // q5

  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = 0LL;
  v2 = a2[1];
  result = v2 - *a2;
  if ( v2 != *a2 )
  {
    v5 = 0xAAAAAAAAAAAAAAABLL * (result >> 2);
    if ( v5 >= 0x1555555555555556LL )
      std::__vector_base_common<true>::__throw_length_error();
    result = operator new(result);
    *a1 = result;
    a1[1] = result;
    a1[2] = result + 12 * v5;
    v8 = *a2;
    v7 = a2[1];
    if ( *a2 != v7 )
    {
      v9 = (v7 - 12 - v8) / 0xCuLL;
      v10 = v9 + 1;
      if ( v9 + 1 >= 8
        && ((v11 = 12 * v9 + 12, result >= (unsigned __int64)&v8[v11]) || result + v11 <= (unsigned __int64)v8) )
      {
        v15 = 12 * (v10 & 0x3FFFFFFFFFFFFFF8LL);
        v12 = (_DWORD *)(result + v15);
        v13 = &v8[v15];
        v16 = v10 & 0x3FFFFFFFFFFFFFF8LL;
        do
        {
          v17 = *((_OWORD *)v8 + 1);
          v18 = *((_OWORD *)v8 + 2);
          v19 = *((_OWORD *)v8 + 3);
          v20 = *((_OWORD *)v8 + 4);
          v21 = *((_OWORD *)v8 + 5);
          v16 -= 8LL;
          *(_OWORD *)result = *(_OWORD *)v8;
          *(_OWORD *)(result + 16) = v17;
          *(_OWORD *)(result + 32) = v18;
          *(_OWORD *)(result + 48) = v19;
          *(_OWORD *)(result + 64) = v20;
          *(_OWORD *)(result + 80) = v21;
          result += 96LL;
          v8 += 96;
        }
        while ( v16 );
        if ( v10 == (v10 & 0x3FFFFFFFFFFFFFF8LL) )
          goto LABEL_9;
      }
      else
      {
        v12 = (_DWORD *)result;
        v13 = *a2;
      }
      do
      {
        *v12 = *(_DWORD *)v13;
        v12[1] = *((_DWORD *)v13 + 1);
        v14 = *((_DWORD *)v13 + 2);
        v13 += 12;
        v12[2] = v14;
        v12 += 3;
      }
      while ( v13 != v7 );
LABEL_9:
      a1[1] = (signed __int64)v12;
    }
  }
  return result;
}

//----- (0000000000025DF4) ----------------------------------------------------
float __fastcall ground_filter::Plane_Seg::getPlaneFrom3Points(float result, __int64 a2, __int64 a3, float *a4)
{
  float *v4; // x8
  float v5; // s4
  float v6; // s3
  float v7; // s2
  float v8; // s1
  float v9; // s3
  float v10; // s5
  float v11; // s4
  float v12; // s6
  float v13; // s4
  float v14; // s2
  float v15; // s3
  float v16; // s4
  float v17; // s0
  float v18; // s2
  float v19; // s3
  float v20; // s4
  float v21; // s0

  v4 = *(float **)a3;
  if ( *(_QWORD *)(a3 + 8) - *(_QWORD *)a3 == 36LL )
  {
    v5 = v4[2];
    v6 = v4[1];
    v7 = v4[3] - *v4;
    result = v4[4] - v6;
    v8 = v4[6] - *v4;
    v9 = v4[7] - v6;
    v10 = v4[5] - v5;
    v11 = v4[8] - v5;
    if ( (float)(v7 / v8) != (float)(result / v9) || (float)(v10 / v11) != (float)(result / v9) )
    {
      v12 = result * v11;
      v13 = v7 * v11;
      v14 = v7 * v9;
      v15 = v12 - (float)(v10 * v9);
      v16 = (float)(v10 * v8) - v13;
      v17 = v14 - (float)(result * v8);
      v18 = sqrtf((float)((float)(v15 * v15) + (float)(v16 * v16)) + (float)((float)(v17 * v17) + 0.0));
      v19 = v15 / v18;
      v20 = v16 / v18;
      v21 = v17 / v18;
      *a4 = v19;
      a4[1] = v20;
      a4[2] = v21;
      a4[3] = 0.0 / v18;
      result = -(float)((float)((float)(v19 * *v4) + (float)(v20 * v4[1])) + (float)(v21 * v4[2]));
      a4[3] = result;
    }
  }
  return result;
}

//----- (0000000000025EE4) ----------------------------------------------------
bool __fastcall ground_filter::Plane_Seg::validSeedPlaneFrom3Points(__int64 a1, float *a2)
{
  float *v2; // x20
  float v3; // s1
  float v4; // s3
  float v5; // s4
  float v6; // s2
  float v7; // s5
  float v8; // s6
  float v9; // s7
  float v10; // s0
  float v12; // s0
  float v13; // s1

  v2 = *(float **)(a1 + 5288);
  if ( *(_QWORD *)(a1 + 5296) - (_QWORD)v2 != 176LL )
    return 1LL;
  v3 = a2[1];
  v4 = v2[35];
  v5 = v2[36];
  v6 = a2[2];
  v7 = v2[37];
  v8 = sqrtf((float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v6 * v6));
  v9 = sqrtf((float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v7 * v7));
  v10 = (float)((float)(v6 / v8) * (float)(v7 / v9))
      + (float)((float)((float)(*a2 / v8) * (float)(v4 / v9)) + (float)((float)(v3 / v8) * (float)(v5 / v9)));
  if ( fabsf(fabsf(v10) + -1.0) < 0.0001 )
    return vabds_f32(a2[3], v2[41]) <= 10.0;
  v12 = acosf(v10);
  if ( v12 > 1.57079633 )
  {
    v13 = 3.14159265 - v12;
    v12 = v13;
  }
  return fabsf(v12) <= 0.157079633 && vabds_f32(a2[3], v2[41]) <= 10.0;
}

//----- (000000000002600C) ----------------------------------------------------
float __fastcall ground_filter::Plane_Seg::computeMeanAndCovarianceMatrix(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v11; // x9
  __int64 v12; // x10
  float32x2_t v13; // d2
  unsigned __int64 v14; // x8
  float result; // s0
  float v16; // s5
  float v17; // s1
  int32x2_t v18; // d3
  float32x2_t v19; // d4
  int32x2_t v20; // d6
  float v21; // s7
  float v22; // s16
  float32x2_t v23; // d17
  float32x2_t v24; // d7
  int8x16_t v25; // q17
  unsigned __int64 v26; // d2
  int8x16_t v27; // q16
  unsigned __int64 v28; // d4

  v11 = *a2;
  v12 = a2[1];
  v13.n64_u64[0] = 0LL;
  v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *a2) >> 2);
  if ( *a2 == v12 )
  {
    v17 = 0.0;
    v16 = 0.0;
    result = 0.0;
    v18.n64_u64[0] = 0LL;
    v19.n64_u64[0] = 0LL;
  }
  else
  {
    result = 0.0;
    v16 = 0.0;
    v17 = 0.0;
    v18.n64_u64[0] = 0LL;
    v19.n64_u64[0] = 0LL;
    do
    {
      v20.n64_u64[0] = *(unsigned __int64 *)v11;
      v21 = *(float *)(v11 + 8);
      v11 += 12LL;
      v22 = vmuls_n_f32(v20.n64_f32[0], v20.n64_f32[0]);
      v23.n64_u64[0] = vmul_lane_f32(v20, v20, 1).n64_u64[0];
      v18.n64_u64[0] = vadd_f32(v18, v20).n64_u64[0];
      a11 = vmul_n_f32(vrev64_s32(v20), v21).n64_f64[0];
      v16 = v16 + v22;
      v13.n64_u64[0] = vadd_f32(v13, v23).n64_u64[0];
      v17 = v17 + (float)(v21 * v21);
      v19.n64_u64[0] = vadd_f32(v19, *(float32x2_t *)&a11).n64_u64[0];
      result = result + v21;
    }
    while ( v11 != v12 );
  }
  *(float *)&a11 = (float)v14;
  *(float *)(a1 + 5208) = v16;
  v24.n64_u64[0] = vdup_lane_s32(*(int32x2_t *)&a11, 0).n64_u64[0];
  v25.n128_u64[0] = v13.n64_u64[0];
  *(float32x2_t *)&v25.n128_i8[8] = v19;
  v26 = vsub_f32(v13, vdiv_f32(vmul_lane_f32(v18, v18, 1), v24)).n64_u64[0];
  v27 = vextq_s8(v25, v25, 4uLL);
  v28 = vsub_f32(v19, vdiv_f32(vmul_n_f32(vrev64_s32(v18), result), v24)).n64_u64[0];
  *(int8x16_t *)(a1 + 5212) = vextq_s8(v27, vextq_s8(v25, v27, 0xCuLL), 0xCuLL);
  *(float *)(a1 + 5228) = v17;
  *(int32x2_t *)(a1 + 5232) = v18;
  *(float *)(a1 + 5240) = result;
  *(_QWORD *)(a1 + 5248) = v14;
  *(float *)a4 = v18.n64_f32[0] / (float)v14;
  *(float *)(a4 + 4) = v18.n64_f32[1] / (float)v14;
  *(float *)(a4 + 8) = result / (float)v14;
  *(_DWORD *)(a4 + 12) = 1065353216;
  *(_QWORD *)(a3 + 12) = v26;
  HIDWORD(v26) = HIDWORD(v28);
  *(float *)a3 = v16 - (float)(vmuls_n_f32(v18.n64_f32[0], v18.n64_f32[0]) / (float)v14);
  *(_DWORD *)(a3 + 28) = v28;
  *(float *)(a3 + 32) = v17 - (float)((float)(result * result) / (float)v14);
  *(_QWORD *)(a3 + 4) = v26;
  *(_QWORD *)(a3 + 20) = v28;
  return result;
}

//----- (0000000000026144) ----------------------------------------------------
void __usercall ground_filter::Plane_Seg::eigen33(
        __int64 a1@<X0>,
        float *a2@<X1>,
        float *a3@<X2>,
        __int64 a4@<X3>,
        unsigned __int32 *a5@<X8>)
{
  float v7; // s2
  float v8; // s3
  float v9; // s4
  float v10; // s5
  float v11; // s6
  float v12; // s7
  float v13; // s16
  float v14; // s18
  float v15; // s19
  float v16; // s20
  float v17; // s21
  float v18; // s17
  float v19; // s19
  float v20; // s21
  float v21; // s20
  float v22; // s21
  float v23; // s21
  float v24; // s8
  int32x2_t v26; // d0
  int32x2_t v27; // d2
  int32x2_t v28; // d1
  float32x2_t v29; // d4
  float v30; // s3
  float32x2_t v31; // d18
  float32x2_t v32; // d19
  float32x2_t v33; // d5
  float32x2_t v34; // d2
  float32x2_t v35; // d1
  int32x2_t v36; // d0
  float32x2_t v37; // d4
  float v38; // s3
  unsigned __int64 v39; // d17
  float v40; // s7
  unsigned __int64 v41; // d5
  float v42; // s3
  float v43; // s3
  float v44; // [xsp+0h] [xbp-60h] BYREF
  float v45; // [xsp+4h] [xbp-5Ch]
  float v46; // [xsp+8h] [xbp-58h]
  float v47; // [xsp+Ch] [xbp-54h]
  float v48; // [xsp+10h] [xbp-50h]
  float v49; // [xsp+14h] [xbp-4Ch]
  int32x2_t v50; // [xsp+18h] [xbp-48h]
  float v51; // [xsp+20h] [xbp-40h]
  __int64 v52; // [xsp+28h] [xbp-38h]

  v52 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2[1];
  v8 = a2[2];
  v9 = a2[3];
  v10 = a2[4];
  v11 = a2[5];
  v12 = a2[6];
  v13 = a2[7];
  v14 = fabsf(*a2);
  v15 = fabsf(v7);
  v16 = fabsf(v8);
  v17 = fabsf(v9);
  v18 = a2[8];
  if ( v14 < v15 )
    v14 = v15;
  if ( v16 < v17 )
    v16 = v17;
  v19 = fabsf(v10);
  v20 = fabsf(v11);
  if ( v14 < v16 )
    v14 = v16;
  v21 = fabsf(v13);
  if ( v19 < v20 )
    v19 = v20;
  v22 = fabsf(v18);
  if ( v21 < v22 )
    v21 = v22;
  v23 = fabsf(v12);
  if ( v23 >= v21 )
    v21 = v23;
  if ( v19 < v21 )
    v19 = v21;
  if ( v14 < v19 )
    v14 = v19;
  if ( v14 <= 1.1755e-38 )
    v24 = 1.0;
  else
    v24 = v14;
  v44 = *a2 / v24;
  v45 = v7 / v24;
  v46 = v8 / v24;
  v47 = v9 / v24;
  v48 = v10 / v24;
  v49 = v11 / v24;
  v50.n64_f32[0] = v12 / v24;
  v50.n64_f32[1] = v13 / v24;
  v51 = v18 / v24;
  ground_filter::Plane_Seg::computeRoots(a1, &v44, (__int64)a5);
  v26.n64_u32[0] = *a5;
  *a3 = v24 * *(float *)a5;
  v27.n64_u64[0] = vdup_lane_s32(v26, 0).n64_u64[0];
  v28.n64_u64[0] = vsub_f32((float32x2_t)__PAIR64__(LODWORD(v44), LODWORD(v48)), v27).n64_u64[0];
  v44 = v28.n64_f32[1];
  v29.n64_u32[0] = vdupq_lane_s32(v28, 1).n128_u32[0];
  v27.n64_f32[0] = v47;
  v29.n64_f32[1] = v45;
  v48 = v28.n64_f32[0];
  v30 = vmuls_lane_f32(v28.n64_f32[0], v28, 1);
  v31.n64_u64[0] = vzip1_s32(v27, v28).n64_u64[0];
  v27.n64_f32[1] = v45;
  v51 = v51 - v26.n64_f32[0];
  v32.n64_u64[0] = vmul_f32(v50, v28).n64_u64[0];
  v33.n64_u64[0] = vmul_f32(v27, vrev64_s32(v50)).n64_u64[0];
  v34.n64_u64[0] = vsub_f32(vmul_n_f32(v31, v51), vmul_n_f32(v50, v49)).n64_u64[0];
  v35.n64_u64[0] = vsub_f32(vmul_n_f32(v50, v46), vmul_n_f32(v29, v51)).n64_u64[0];
  v36.n64_u64[0] = vsub_f32(vmul_n_f32(v29, v49), vmul_n_f32(v31, v46)).n64_u64[0];
  v37.n64_u64[0] = vsub_f32(v33, v32).n64_u64[0];
  v38 = v30 - (float)(v47 * v45);
  v39 = vmul_f32(v37, v37).n64_u64[0];
  v40 = *(float *)&v39 + (float)(*((float *)&v39 + 1) + (float)(v38 * v38));
  v41 = vadd_f32(vmul_f32(v34, v34), vadd_f32(vmul_f32(v35, v35), vmul_f32(v36, v36))).n64_u64[0];
  if ( v40 < *(float *)&v41 || v40 < *((float *)&v41 + 1) )
  {
    if ( *(float *)&v41 < v40 || *(float *)&v41 < *((float *)&v41 + 1) )
    {
      v43 = sqrtf(*((float *)&v41 + 1));
      v36.n64_f32[0] = v36.n64_f32[1] / v43;
      *(float *)a4 = v34.n64_f32[1] / v43;
      *(float *)(a4 + 4) = v35.n64_f32[1] / v43;
    }
    else
    {
      v42 = sqrtf(*(float *)&v41);
      *(float *)a4 = v34.n64_f32[0] / v42;
      *(float *)(a4 + 4) = v35.n64_f32[0] / v42;
      v36.n64_f32[0] = v36.n64_f32[0] / v42;
    }
  }
  else
  {
    v36.n64_f32[0] = sqrtf(v40);
    *(float32x2_t *)a4 = vdiv_f32(v37, vdup_lane_s32(v36, 0));
    v36.n64_f32[0] = v38 / v36.n64_f32[0];
  }
  *(_DWORD *)(a4 + 8) = v36.n64_u32[0];
}
// 2625C: variable 'v26' is possibly undefined

//----- (00000000000263A8) ----------------------------------------------------
void __fastcall ground_filter::Plane_Seg::computeRoots(__int64 a1, float *a2, __int64 a3)
{
  float v3; // s1
  float v4; // s3
  float v5; // s4
  float v6; // s6
  float v7; // s5
  float v8; // s7
  float v9; // s16
  float v10; // s0
  float v11; // s1
  float v13; // s9
  float v14; // s8
  float v15; // s0
  float v16; // s0
  float v17; // s4
  float v18; // s1
  float v19; // s13
  float v20; // s0
  float v21; // s1
  float v22; // s3
  float v23; // s0
  float v24; // w8
  float v25; // s2
  float v26; // w9
  float v27; // s0
  float v28; // s0
  float cosx; // [xsp+38h] [xbp-8h] BYREF
  float sinx; // [xsp+3Ch] [xbp-4h] BYREF

  v3 = a2[3];
  v4 = a2[4];
  v6 = a2[7];
  v5 = a2[8];
  v7 = a2[6];
  v8 = *a2 * v4;
  v9 = (float)(*a2 * v5) + (float)(v8 - (float)(v3 * v3));
  v10 = v3 * (float)(v5 * v3);
  v11 = (float)((float)((float)(v8 * v5) + (float)((float)((float)(v3 + v3) * v7) * v6))
              - (float)(v6 * (float)(*a2 * v6)))
      - (float)(v7 * (float)(v4 * v7));
  v13 = (float)((float)(v4 * v5) + (float)(v9 - (float)(v7 * v7))) - (float)(v6 * v6);
  v14 = (float)(*a2 + v4) + v5;
  if ( vabds_f32(v11, v10) < 0.00000011921 )
  {
    v15 = (float)(v14 * v14) + v13 * -4.0;
    v16 = sqrtf(fmaxf(v15, 0.0));
    *(_DWORD *)a3 = 0;
    *(float *)(a3 + 4) = (float)(v14 - v16) * 0.5;
    *(float *)(a3 + 8) = (float)(v14 + v16) * 0.5;
    return;
  }
  v17 = fminf((float)(v13 - (float)(v14 * (float)(v14 * 0.33333))) * 0.33333, 0.0);
  v18 = (float)((float)(v11 - v10)
              + (float)((float)(v14 * 0.33333)
                      * (float)((float)((float)(v14 * 0.33333) * (float)((float)(v14 * 0.33333) + (float)(v14 * 0.33333)))
                              - v13)))
      * 0.5;
  v19 = sqrtf(-v17);
  v20 = atan2f(sqrtf(-fminf((float)(v18 * v18) + (float)(v17 * (float)(v17 * v17)), 0.0)), v18);
  sincosf(v20 * 0.33333, &sinx, &cosx);
  v21 = (float)(v14 * 0.33333) + (float)((float)(v19 + v19) * cosx);
  v22 = (float)(v14 * 0.33333) - (float)(v19 * (float)(cosx + (float)(sinx * 1.7321)));
  v23 = (float)(v14 * 0.33333) - (float)(v19 * (float)(cosx - (float)(sinx * 1.7321)));
  v24 = v21;
  *(float *)a3 = v21;
  *(float *)(a3 + 4) = v22;
  *(float *)(a3 + 8) = v23;
  if ( v21 >= v22 )
  {
    v25 = v22;
    v26 = v22;
    *(float *)a3 = v22;
    *(float *)(a3 + 4) = v21;
    if ( v21 < v23 )
      goto LABEL_9;
LABEL_7:
    *(float *)(a3 + 4) = v23;
    *(float *)(a3 + 8) = v24;
    if ( v25 >= v23 )
    {
      v25 = v23;
      *(float *)a3 = v23;
      *(float *)(a3 + 4) = v26;
    }
    goto LABEL_9;
  }
  v25 = v21;
  v26 = v21;
  v24 = v22;
  if ( v22 >= v23 )
    goto LABEL_7;
LABEL_9:
  if ( v25 <= 0.0 )
  {
    v27 = (float)(v14 * v14) + v13 * -4.0;
    v28 = sqrtf(fmaxf(v27, 0.0));
    *(_DWORD *)a3 = 0;
    *(float *)(a3 + 4) = (float)(v14 - v28) * 0.5;
    *(float *)(a3 + 8) = (float)(v14 + v28) * 0.5;
  }
}

//----- (0000000000026608) ----------------------------------------------------
float __fastcall ground_filter::Plane_Seg::computeRoots2(__int64 a1, float *a2, float *a3, __int64 a4)
{
  float v4; // s0
  float v5; // s0
  float result; // s0

  *(_DWORD *)a4 = 0;
  v4 = (float)(*a2 * *a2) + *a3 * -4.0;
  v5 = sqrtf(fmaxf(v4, 0.0));
  *(float *)(a4 + 8) = (float)(*a2 + v5) * 0.5;
  result = (float)(*a2 - v5) * 0.5;
  *(float *)(a4 + 4) = result;
  return result;
}

//----- (0000000000026660) ----------------------------------------------------
char *__fastcall ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSM_IJDpT2_EEEDpOT3_(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6,
        const void **a7,
        char **a8,
        __int64 a9,
        _BYTE *a10)
{
  int v12; // w8
  _BYTE *v13; // x9
  signed __int64 v14; // x0
  __int64 v15; // x24
  char *v17; // x0
  const void *v18; // x1
  char *v19; // x23
  signed __int64 v20; // x21
  char *result; // x0
  __int64 v22; // x9
  __int64 v23; // x24
  __int64 v24; // x8
  char *v25; // x23
  __int64 v26; // x20

  *(_DWORD *)a1 = *a6;
  *(_DWORD *)(a1 + 4) = a6[1];
  *(_DWORD *)(a1 + 8) = a6[2];
  v12 = a6[3];
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_DWORD *)(a1 + 12) = v12;
  v13 = a7[1];
  v14 = v13 - (_BYTE *)*a7;
  if ( v13 != *a7 )
  {
    v15 = v14 >> 2;
    if ( (unsigned __int64)(v14 >> 2) >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v17 = (char *)operator new(v14);
    *(_QWORD *)(a1 + 16) = v17;
    *(_QWORD *)(a1 + 24) = v17;
    *(_QWORD *)(a1 + 32) = &v17[4 * v15];
    v18 = *a7;
    v19 = v17;
    v20 = (_BYTE *)a7[1] - (_BYTE *)*a7;
    if ( v20 >= 1 )
    {
      memcpy(v17, v18, v20);
      *(_QWORD *)(a1 + 24) = &v19[v20];
    }
  }
  result = (char *)std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector((signed __int64 *)(a1 + 40), a8);
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  v22 = *(_QWORD *)(a9 + 8);
  v23 = v22 - *(_QWORD *)a9;
  if ( v22 != *(_QWORD *)a9 )
  {
    if ( v23 < 0 )
      std::__vector_base_common<true>::__throw_length_error();
    result = (char *)operator new(v22 - *(_QWORD *)a9);
    *(_QWORD *)(a1 + 64) = result;
    *(_QWORD *)(a1 + 72) = result;
    *(_QWORD *)(a1 + 80) = &result[v23];
    v24 = *(_QWORD *)(a9 + 8);
    v25 = result;
    v26 = v24 - *(_QWORD *)a9;
    if ( v26 >= 1 )
    {
      result = (char *)memcpy(result, *(const void **)a9, v24 - *(_QWORD *)a9);
      *(_QWORD *)(a1 + 72) = &v25[v26];
    }
  }
  *(_BYTE *)(a1 + 88) = *a10;
  return result;
}

//----- (000000000002681C) ----------------------------------------------------
char *__fastcall ZNSt6__ndk112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN5Eigen6MatrixIfLi4ELi1ELi0ELi4ELi1EEENS_6vectorIiNS_9allocatorIiEEEENS6_INS4_IfLi3ELi1ELi0ELi3ELi1EEENS7_ISA_EEEENS6_IcNS7_IcEEEEbEEC2IJLm0ELm1ELm2ELm3ELm4EEJS5_S9_SC_SE_bEJEJEJRS5_RS9_RSC_RSE_RbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSN_IJDpT2_EEEDpOT3_(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6,
        const void **a7,
        char **a8,
        __int64 a9,
        _BYTE *a10)
{
  int v12; // w8
  _BYTE *v13; // x9
  signed __int64 v14; // x0
  __int64 v15; // x24
  char *v17; // x0
  const void *v18; // x1
  char *v19; // x23
  signed __int64 v20; // x21
  char *result; // x0
  __int64 v22; // x9
  __int64 v23; // x24
  __int64 v24; // x8
  char *v25; // x23
  __int64 v26; // x20

  *(_DWORD *)a1 = *a6;
  *(_DWORD *)(a1 + 4) = a6[1];
  *(_DWORD *)(a1 + 8) = a6[2];
  v12 = a6[3];
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_DWORD *)(a1 + 12) = v12;
  v13 = a7[1];
  v14 = v13 - (_BYTE *)*a7;
  if ( v13 != *a7 )
  {
    v15 = v14 >> 2;
    if ( (unsigned __int64)(v14 >> 2) >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v17 = (char *)operator new(v14);
    *(_QWORD *)(a1 + 16) = v17;
    *(_QWORD *)(a1 + 24) = v17;
    *(_QWORD *)(a1 + 32) = &v17[4 * v15];
    v18 = *a7;
    v19 = v17;
    v20 = (_BYTE *)a7[1] - (_BYTE *)*a7;
    if ( v20 >= 1 )
    {
      memcpy(v17, v18, v20);
      *(_QWORD *)(a1 + 24) = &v19[v20];
    }
  }
  result = (char *)std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector((signed __int64 *)(a1 + 40), a8);
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  v22 = *(_QWORD *)(a9 + 8);
  v23 = v22 - *(_QWORD *)a9;
  if ( v22 != *(_QWORD *)a9 )
  {
    if ( v23 < 0 )
      std::__vector_base_common<true>::__throw_length_error();
    result = (char *)operator new(v22 - *(_QWORD *)a9);
    *(_QWORD *)(a1 + 64) = result;
    *(_QWORD *)(a1 + 72) = result;
    *(_QWORD *)(a1 + 80) = &result[v23];
    v24 = *(_QWORD *)(a9 + 8);
    v25 = result;
    v26 = v24 - *(_QWORD *)a9;
    if ( v26 >= 1 )
    {
      result = (char *)memcpy(result, *(const void **)a9, v24 - *(_QWORD *)a9);
      *(_QWORD *)(a1 + 72) = &v25[v26];
    }
  }
  *(_BYTE *)(a1 + 88) = *a10;
  return result;
}

//----- (00000000000269D8) ----------------------------------------------------
__int64 *__fastcall std::vector<ground_filter::plane_base>::assign<ground_filter::plane_base*>(
        __int64 *result,
        char *a2,
        char *a3)
{
  __int64 v3; // x8
  __int64 v4; // x21
  unsigned __int64 v5; // x24
  __int64 v7; // x22
  __int64 *v8; // x19
  __int64 v9; // x23
  __int64 v10; // x8
  unsigned int *v11; // x8
  unsigned int v12; // w9
  unsigned int v13; // w9
  int v14; // w8
  __int64 v15; // x8
  __int64 v16; // x9
  cv *v17; // x0
  void *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x26
  __int64 v21; // x23
  char *v22; // x25
  __int64 i; // x20
  __int64 v24; // x8
  unsigned int *v25; // x8
  unsigned int v26; // w9
  unsigned int v27; // w9
  int v28; // w8
  __int64 v29; // x8
  __int64 v30; // x9
  __int64 v31; // x9
  unsigned __int64 v32; // x8
  unsigned __int64 v33; // x8
  __int64 v34; // x21

  v3 = result[2];
  v4 = *result;
  v5 = 0x2E8BA2E8BA2E8BA3LL * ((a3 - a2) >> 4);
  v7 = (__int64)a2;
  v8 = result;
  if ( v5 <= 0x2E8BA2E8BA2E8BA3LL * ((v3 - *result) >> 4) )
  {
    v19 = result[1] - v4;
    v20 = 0x2E8BA2E8BA2E8BA3LL * (v19 >> 4);
    v21 = (__int64)&a2[v19];
    if ( v5 <= v20 )
      v22 = a3;
    else
      v22 = &a2[v19];
    if ( v22 != a2 )
    {
      do
      {
        result = (__int64 *)ground_filter::plane_base::operator=(v4, v7);
        v7 += 176LL;
        v4 += 176LL;
      }
      while ( v22 != (char *)v7 );
    }
    if ( v5 <= v20 )
    {
      for ( i = v8[1]; i != v4; i -= 176LL )
      {
        v24 = *(_QWORD *)(i - 80);
        if ( v24 )
        {
          v25 = (unsigned int *)(v24 + 20);
          do
          {
            v26 = __ldaxr(v25);
            v27 = v26 - 1;
          }
          while ( __stlxr(v27, v25) );
          if ( !v27 )
            cv::Mat::deallocate((cv::Mat *)(i - 136));
        }
        v28 = *(_DWORD *)(i - 132);
        *(_QWORD *)(i - 80) = 0LL;
        *(_OWORD *)(i - 104) = 0u;
        *(_OWORD *)(i - 120) = 0u;
        if ( v28 >= 1 )
        {
          v29 = *(_QWORD *)(i - 72);
          v30 = 0LL;
          do
            *(_DWORD *)(v29 + 4 * v30++) = 0;
          while ( v30 < *(int *)(i - 132) );
        }
        result = *(__int64 **)(i - 64);
        if ( result != (__int64 *)(i - 56) )
          result = (__int64 *)cv::fastFree((cv *)result, a2);
      }
      v8[1] = v4;
    }
    else if ( v22 != a3 )
    {
      result = (__int64 *)v8[1];
      do
      {
        ground_filter::plane_base::plane_base((__int64)result, v21);
        v21 += 176LL;
        result = (__int64 *)(v8[1] + 176);
        v8[1] = (__int64)result;
      }
      while ( a3 != (char *)v21 );
    }
  }
  else
  {
    if ( v4 )
    {
      v9 = result[1];
      if ( v9 == v4 )
      {
        v18 = (void *)*result;
      }
      else
      {
        do
        {
          v10 = *(_QWORD *)(v9 - 80);
          if ( v10 )
          {
            v11 = (unsigned int *)(v10 + 20);
            do
            {
              v12 = __ldaxr(v11);
              v13 = v12 - 1;
            }
            while ( __stlxr(v13, v11) );
            if ( !v13 )
              cv::Mat::deallocate((cv::Mat *)(v9 - 136));
          }
          v14 = *(_DWORD *)(v9 - 132);
          *(_QWORD *)(v9 - 80) = 0LL;
          *(_OWORD *)(v9 - 104) = 0u;
          *(_OWORD *)(v9 - 120) = 0u;
          if ( v14 >= 1 )
          {
            v15 = *(_QWORD *)(v9 - 72);
            v16 = 0LL;
            do
              *(_DWORD *)(v15 + 4 * v16++) = 0;
            while ( v16 < *(int *)(v9 - 132) );
          }
          v17 = *(cv **)(v9 - 64);
          if ( v17 != (cv *)(v9 - 56) )
            cv::fastFree(v17, a2);
          v9 -= 176LL;
        }
        while ( v9 != v4 );
        v18 = (void *)*v8;
      }
      v8[1] = v4;
      operator delete(v18);
      v3 = 0LL;
      *v8 = 0LL;
      v8[1] = 0LL;
      v8[2] = 0LL;
    }
    v31 = 0x1745D1745D1745DLL;
    if ( v5 > 0x1745D1745D1745DLL )
      std::__vector_base_common<true>::__throw_length_error();
    v32 = 0x2E8BA2E8BA2E8BA3LL * (v3 >> 4);
    if ( v32 <= 0xBA2E8BA2E8BA2DLL )
    {
      v33 = 2 * v32;
      if ( v33 >= v5 )
        v31 = v33;
      else
        v31 = v5;
    }
    v34 = 22 * v31;
    result = (__int64 *)operator new(176 * v31);
    *v8 = (__int64)result;
    v8[1] = (__int64)result;
    v8[2] = (__int64)&result[v34];
    if ( (char *)v7 != a3 )
    {
      do
      {
        ground_filter::plane_base::plane_base((__int64)result, v7);
        v7 += 176LL;
        result = (__int64 *)(v8[1] + 176);
        v8[1] = (__int64)result;
      }
      while ( a3 != (char *)v7 );
    }
  }
  return result;
}
// 26AB4: variable 'a2' is possibly undefined

//----- (0000000000026CB8) ----------------------------------------------------
__int64 __fastcall ground_filter::plane_base::operator=(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  unsigned int *v5; // x8
  unsigned int v6; // w9
  __int64 v7; // x8
  _DWORD *v8; // x21
  unsigned int *v9; // x8
  unsigned int v10; // w9
  unsigned int v11; // w9
  int v12; // w8
  const cv::Mat *v13; // x1
  __int64 v14; // x8
  __int64 v15; // x9
  __int64 v16; // x10
  int v17; // w8
  _QWORD *v18; // x10
  _QWORD *v19; // x8
  __int64 result; // x0

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)(a2 + 20);
  if ( a1 != a2 )
  {
    v4 = *(_QWORD *)(a2 + 96);
    if ( v4 )
    {
      v5 = (unsigned int *)(v4 + 20);
      do
        v6 = __ldaxr(v5);
      while ( __stlxr(v6 + 1, v5) );
    }
    v7 = *(_QWORD *)(a1 + 96);
    v8 = (_DWORD *)(a1 + 40);
    if ( v7 )
    {
      v9 = (unsigned int *)(v7 + 20);
      do
      {
        v10 = __ldaxr(v9);
        v11 = v10 - 1;
      }
      while ( __stlxr(v11, v9) );
      if ( !v11 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 40));
    }
    v12 = *(_DWORD *)(a1 + 44);
    v13 = (const cv::Mat *)(a2 + 40);
    *(_QWORD *)(a1 + 96) = 0LL;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    if ( v12 <= 0 )
    {
      *v8 = *(_DWORD *)v13;
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 104);
      v15 = 0LL;
      do
      {
        *(_DWORD *)(v14 + 4 * v15) = 0;
        v16 = *(int *)(a1 + 44);
        ++v15;
      }
      while ( v15 < v16 );
      *v8 = *(_DWORD *)v13;
      if ( (int)v16 > 2 )
        goto LABEL_18;
    }
    v17 = *(_DWORD *)(a2 + 44);
    if ( v17 <= 2 )
    {
      *(_DWORD *)(a1 + 44) = v17;
      v18 = *(_QWORD **)(a1 + 112);
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      v19 = *(_QWORD **)(a2 + 112);
      *v18 = *v19;
      v18[1] = v19[1];
LABEL_19:
      *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      goto LABEL_20;
    }
LABEL_18:
    cv::Mat::copySize((cv::Mat *)(a1 + 40), v13);
    goto LABEL_19;
  }
LABEL_20:
  result = a1;
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  *(_DWORD *)(a1 + 156) = *(_DWORD *)(a2 + 156);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 164) = *(_QWORD *)(a2 + 164);
  return result;
}

//----- (0000000000026E48) ----------------------------------------------------
__int64 __fastcall ground_filter::plane_base::plane_base(__int64 result, __int64 a2)
{
  __int64 v3; // x19
  __int64 v4; // x1
  __int128 v5; // t1
  __int64 v6; // x8
  unsigned int *v7; // x8
  unsigned int v8; // w9
  _QWORD *v9; // x8
  _QWORD *v10; // x10

  v3 = result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(result + 20) = *(_OWORD *)(a2 + 20);
  v5 = *(_OWORD *)(a2 + 40);
  v4 = a2 + 40;
  *(_OWORD *)(result + 40) = v5;
  *(_OWORD *)(result + 56) = *(_OWORD *)(v4 + 16);
  *(_QWORD *)(result + 72) = *(_QWORD *)(v4 + 32);
  *(_OWORD *)(result + 80) = *(_OWORD *)(v4 + 40);
  v6 = *(_QWORD *)(v4 + 56);
  *(_QWORD *)(result + 120) = 0LL;
  *(_QWORD *)(result + 104) = result + 48;
  *(_QWORD *)(result + 112) = result + 120;
  *(_QWORD *)(result + 96) = v6;
  *(_QWORD *)(result + 128) = 0LL;
  if ( v6 )
  {
    v7 = (unsigned int *)(v6 + 20);
    do
      v8 = __ldaxr(v7);
    while ( __stlxr(v8 + 1, v7) );
  }
  if ( *(int *)(a2 + 44) > 2 )
  {
    *(_DWORD *)(result + 44) = 0;
    result = cv::Mat::copySize((cv::Mat *)(result + 40), (const cv::Mat *)v4);
  }
  else
  {
    v9 = *(_QWORD **)(a2 + 112);
    v10 = *(_QWORD **)(result + 112);
    *v10 = *v9;
    v10[1] = v9[1];
  }
  *(_QWORD *)(v3 + 136) = *(_QWORD *)(a2 + 136);
  *(_DWORD *)(v3 + 144) = *(_DWORD *)(a2 + 144);
  *(_DWORD *)(v3 + 148) = *(_DWORD *)(a2 + 148);
  *(_DWORD *)(v3 + 152) = *(_DWORD *)(a2 + 152);
  *(_DWORD *)(v3 + 156) = *(_DWORD *)(a2 + 156);
  *(_DWORD *)(v3 + 160) = *(_DWORD *)(a2 + 160);
  *(_QWORD *)(v3 + 164) = *(_QWORD *)(a2 + 164);
  return result;
}

//----- (0000000000026F58) ----------------------------------------------------
void __fastcall std::vector<int>::__push_back_slow_path<int>(__int64 a1, _DWORD *a2)
{
  void *v2; // x20
  signed __int64 v4; // x21
  unsigned __int64 v5; // x8
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x25
  char *v10; // x23
  char *v11; // x24
  _DWORD *v12; // x24

  v2 = *(void **)a1;
  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v5 = (v4 >> 2) + 1;
  if ( v5 >> 62 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 2) > 0x1FFFFFFFFFFFFFFELL )
  {
    v9 = 0x3FFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = (char *)operator new(4 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 1;
  if ( v8 >= v5 )
    v9 = v8;
  else
    v9 = (v4 >> 2) + 1;
  if ( v9 )
  {
    if ( v9 >> 62 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = &v10[4 * (v4 >> 2)];
  *(_DWORD *)v11 = *a2;
  v12 = v11 + 4;
  if ( v4 >= 1 )
    memcpy(v10, v2, v4);
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = &v10[4 * v9];
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000027050) ----------------------------------------------------
unsigned __int64 __fastcall std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>>(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3)
{
  unsigned __int64 result; // x0
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x11
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  __int64 v12; // x12
  int v13; // w9
  bool v14; // zf
  unsigned __int64 v15; // x10
  char v16; // w8
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x0
  __int64 v19; // [xsp+0h] [xbp-70h] BYREF
  __int128 v20; // [xsp+8h] [xbp-68h]
  int64x2_t v21; // [xsp+18h] [xbp-58h]
  __int128 v22; // [xsp+28h] [xbp-48h]
  __int128 v23; // [xsp+38h] [xbp-38h]
  __int64 v24; // [xsp+48h] [xbp-28h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = *a3;
  v4 = a3[1] - *a3;
  if ( !v4 )
    return result;
  v5 = v4 + 1;
  if ( v4 == -1LL )
  {
    v19 = a2;
    v20 = xmmword_54750;
    v21 = vdupq_n_s64(2uLL);
    v22 = xmmword_54760;
    v23 = xmmword_54770;
    return std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(&v19);
  }
  v6 = 64 - __clz(v5);
  v7 = (__PAIR128__(v6, (0xFFFFFFFFFFFFFFFFLL >> (65 - (unsigned __int8)v6)) & v5) - 1) >> 64;
  if ( (v7 & 0x1F) != 0 )
    v8 = (v7 >> 5) + 1;
  else
    v8 = v7 >> 5;
  v9 = v7 / v8;
  v10 = (-1LL << (v7 / v8)) & 0x100000000LL;
  if ( v7 / v8 >= 0x40 )
    v10 = 0LL;
  v19 = a2;
  *(_QWORD *)&v20 = v7;
  *((_QWORD *)&v20 + 1) = v7 / v8;
  v21.n128_u64[0] = v8;
  *(_QWORD *)&v22 = v10;
  if ( 0x100000000LL - v10 <= v10 / v8 )
    goto LABEL_11;
  ++v8;
  v9 = v7 / v8;
  *((_QWORD *)&v20 + 1) = v7 / v8;
  v21.n128_u64[0] = v8;
  if ( v7 / v8 <= 0x3F )
  {
    *(_QWORD *)&v22 = (-1LL << v9) & 0x100000000LL;
LABEL_11:
    v21.n128_u64[1] = v8 + v7 / v8 * v8 - v7;
    if ( v9 > 0x3E )
    {
      v12 = 0LL;
      v13 = 0;
    }
    else
    {
      v12 = (-1LL << ((unsigned __int8)v9 + 1)) & 0x100000000LL;
      v13 = 1;
    }
    goto LABEL_16;
  }
  v12 = 0LL;
  v13 = 0;
  v21.n128_u64[1] = v8 + v9 * v8 - v7;
  *(_QWORD *)&v22 = 0LL;
LABEL_16:
  *((_QWORD *)&v22 + 1) = v12;
  v14 = v9 == 0;
  v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
  v16 = 63 - v9;
  if ( v14 )
    v15 = 0LL;
  v17 = 0xFFFFFFFFFFFFFFFFLL >> v16;
  if ( !v13 )
    v17 = -1LL;
  *(_QWORD *)&v23 = v15;
  *((_QWORD *)&v23 + 1) = v17;
  do
    v18 = std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(&v19);
  while ( v18 >= v5 );
  return *a3 + v18;
}
// 54750: using guessed type __int128 xmmword_54750;
// 54760: using guessed type __int128 xmmword_54760;
// 54770: using guessed type __int128 xmmword_54770;

//----- (000000000002721C) ----------------------------------------------------
unsigned __int64 __fastcall std::__independent_bits_engine<std::mersenne_twister_engine<unsigned long,32ul,624ul,397ul,31ul,2567483615ul,11ul,4294967295ul,7ul,2636928640ul,15ul,4022730752ul,18ul,1812433253ul>,unsigned long>::__eval(
        _QWORD *a1)
{
  unsigned __int64 v1; // x8
  __int64 v2; // x14
  unsigned __int64 v3; // x17
  unsigned __int64 v4; // x13
  __int64 v5; // x1
  unsigned __int64 v6; // x2
  unsigned __int64 v7; // x12
  __int64 v8; // x12
  unsigned __int64 v9; // x1
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x12
  __int64 v12; // x8
  unsigned __int64 v13; // x1
  __int64 v14; // x13
  unsigned __int64 v15; // x16
  __int64 v16; // x1
  unsigned __int64 v17; // x2
  unsigned __int64 v18; // x17
  __int64 v19; // x17
  unsigned __int64 v20; // x17
  unsigned __int64 v21; // x1
  __int64 v22; // x8
  unsigned __int64 v23; // x17

  v1 = a1[4];
  if ( v1 )
  {
    v2 = *a1;
    v3 = *(_QWORD *)(*a1 + 4992LL);
    v1 = 0LL;
    v4 = 0LL;
    do
    {
      do
      {
        v5 = 8 * v3;
        v6 = v3 + 397;
        v3 = (v3 + 1) % 0x270;
        *(_QWORD *)(v2 + v5) = (2567483615u * (*(_QWORD *)(v2 + 8 * v3) & 1LL)) ^ *(_QWORD *)(v2 + 8 * (v6 % 0x270)) ^ ((*(_QWORD *)(v2 + 8 * v3) & 0x7FFFFFFELL | *(_QWORD *)(v2 + v5) & 0xFFFFFFFF80000000LL) >> 1);
        v7 = *(_QWORD *)(v2 + 8LL * *(_QWORD *)(v2 + 4992));
        *(_QWORD *)(v2 + 4992) = v3;
        v8 = (((unsigned int)(v7 >> 11) ^ v7) << 7) & 0x9D2C5680 ^ (unsigned int)(v7 >> 11) ^ v7;
        v9 = (v8 << 15) & 0xEFC60000LL ^ v8 ^ (((v8 << 15) & 0xEFC60000LL ^ (unsigned __int64)v8) >> 18);
      }
      while ( v9 >= a1[5] );
      v10 = a1[2];
      v11 = a1[4];
      ++v4;
      v12 = v1 << v10;
      v13 = a1[7] & v9;
      if ( v10 >= 0x40 )
        v12 = 0LL;
      v1 = v12 + v13;
    }
    while ( v4 < v11 );
  }
  else
  {
    v11 = 0LL;
  }
  if ( v11 < a1[3] )
  {
    v14 = *a1;
    v15 = *(_QWORD *)(*a1 + 4992LL);
    do
    {
      do
      {
        v16 = 8 * v15;
        v17 = v15 + 397;
        v15 = (v15 + 1) % 0x270;
        *(_QWORD *)(v14 + v16) = (2567483615u * (*(_QWORD *)(v14 + 8 * v15) & 1LL)) ^ *(_QWORD *)(v14 + 8 * (v17 % 0x270)) ^ ((*(_QWORD *)(v14 + 8 * v15) & 0x7FFFFFFELL | *(_QWORD *)(v14 + v16) & 0xFFFFFFFF80000000LL) >> 1);
        v18 = *(_QWORD *)(v14 + 8LL * *(_QWORD *)(v14 + 4992));
        *(_QWORD *)(v14 + 4992) = v15;
        v19 = (((unsigned int)(v18 >> 11) ^ v18) << 7) & 0x9D2C5680 ^ (unsigned int)(v18 >> 11) ^ v18;
        v20 = (v19 << 15) & 0xEFC60000LL ^ v19 ^ (((v19 << 15) & 0xEFC60000LL ^ (unsigned __int64)v19) >> 18);
      }
      while ( v20 >= a1[6] );
      v21 = a1[2];
      ++v11;
      v22 = v1 << ((unsigned __int8)v21 + 1);
      v23 = a1[8] & v20;
      if ( v21 >= 0x3F )
        v22 = 0LL;
      v1 = v22 + v23;
    }
    while ( v11 < a1[3] );
  }
  return v1;
}

//----- (000000000002740C) ----------------------------------------------------
void __fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(
        __int64 a1,
        __int64 *a2)
{
  _DWORD *v2; // x20
  _DWORD *v3; // x22
  unsigned __int64 v4; // x24
  __int64 v5; // x23
  __int64 v8; // x0
  __int64 v9; // x10
  __int64 v10; // x8
  __int64 i; // x10
  int v12; // t1

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD **)(a1 + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v3 - *(_QWORD *)a1) >> 2);
  v5 = 0x1555555555555555LL;
  if ( v4 + 1 > 0x1555555555555555LL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) > 0xAAAAAAAAAAAAAA9LL
    || (0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2) >= v4 + 1
      ? (v5 = 0x5555555555555556LL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 2))
      : (v5 = v4 + 1),
        v5) )
  {
    v8 = operator new(12 * v5);
  }
  else
  {
    v8 = 0LL;
  }
  v9 = *a2;
  v10 = v8 + 12 * v4;
  *(_DWORD *)(v10 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)v10 = v9;
  *(_QWORD *)v10 = *a2;
  *(_DWORD *)(v10 + 8) = *((_DWORD *)a2 + 2);
  for ( i = v10 + 12; v2 != v3; *(_DWORD *)(v10 + 8) = v3[2] )
  {
    v12 = *(v3 - 3);
    v3 -= 3;
    *(_DWORD *)(v10 - 12) = v12;
    v10 -= 12LL;
    *(_DWORD *)(v10 + 4) = v3[1];
  }
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = i;
  *(_QWORD *)(a1 + 16) = v8 + 12 * v5;
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000027538) ----------------------------------------------------
__int64 __fastcall Eigen::SelfAdjointEigenSolver<Eigen::Matrix<float,3,3,0,3,3>>::compute(
        __int64 a1,
        float *a2,
        char a3)
{
  unsigned __int64 StatusReg; // x28
  float v4; // s0
  float v6; // w9
  float v7; // w10
  float v8; // s1
  float v9; // s2
  float v10; // w9
  float v11; // s3
  float v12; // s4
  float v13; // w10
  float v14; // s4
  float v15; // s5
  float v16; // w9
  float v17; // s16
  float v18; // s6
  float v19; // s17
  float v20; // s17
  float v21; // s8
  double v23; // d0
  double v24; // d1
  __int64 v25; // x9
  __int64 v26; // x25
  __int64 v27; // x11
  unsigned __int64 v28; // x24
  __int64 v29; // x8
  float v30; // s0
  __int64 v31; // x10
  float *v32; // x11
  float v33; // s2
  __int64 v34; // x10
  float *v35; // x17
  float *v36; // x11
  __int64 v37; // x16
  __int64 v38; // x27
  bool v39; // cc
  float *v40; // x12
  float v41; // t1
  float v42; // s0
  __int64 v43; // x13
  __int64 v44; // x14
  float *v45; // x15
  __int64 v46; // x9
  float *v47; // x10
  __int64 v48; // x22
  float *v49; // x21
  __int64 v50; // x20
  float v51; // s1
  __int64 v52; // x23
  float v53; // s2
  float v54; // s0
  float v55; // s6
  float v56; // s7
  float v57; // s5
  float v58; // s3
  float v59; // s4
  float v60; // s4
  float v61; // s3
  float v62; // s0
  float v63; // s13
  float v64; // s14
  __int64 v65; // x28
  float v66; // s1
  float v67; // s0
  float v68; // s0
  float v69; // s1
  float v70; // s2
  float v71; // s4
  float v72; // s3
  float v73; // s6
  float v74; // s3
  float v75; // s5
  float v76; // s7
  float v77; // w8
  float v78; // s0
  __int64 v79; // x9
  _DWORD *v80; // x8
  int v81; // w10
  int v82; // w10
  int v83; // w10
  float v84; // w8
  __int64 v85; // x9
  int v86; // w10
  int v87; // w11
  float v88; // s1
  float v89; // s2
  unsigned __int64 v91; // [xsp+0h] [xbp-160h]
  unsigned int v92; // [xsp+Ch] [xbp-154h]
  __int64 v93; // [xsp+18h] [xbp-148h]
  __int64 v94; // [xsp+28h] [xbp-138h]
  unsigned __int64 v95; // [xsp+30h] [xbp-130h]
  int v96[2]; // [xsp+38h] [xbp-128h] BYREF
  unsigned __int64 v97[4]; // [xsp+40h] [xbp-120h] BYREF
  int64x2_t v98; // [xsp+60h] [xbp-100h]
  __int64 v99; // [xsp+78h] [xbp-E8h]
  float32x4_t v100; // [xsp+80h] [xbp-E0h] BYREF
  unsigned __int64 v101; // [xsp+98h] [xbp-C8h]
  int64x2_t v102; // [xsp+A0h] [xbp-C0h]
  __int64 v103; // [xsp+B8h] [xbp-A8h]
  __int64 v104; // [xsp+C0h] [xbp-A0h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = 0.0;
  v104 = *(_QWORD *)(StatusReg + 40);
  v6 = *a2;
  v92 = a3 & 0x80;
  *(float *)a1 = *a2;
  v7 = a2[1];
  v8 = v6;
  v9 = fabsf(v6);
  *(float *)(a1 + 4) = v7;
  v10 = a2[2];
  v11 = v7;
  v12 = fabsf(v7);
  *(_QWORD *)(a1 + 8) = LODWORD(v10);
  v13 = a2[4];
  if ( v9 < v12 )
    v9 = v12;
  v14 = v10;
  v15 = fabsf(v10);
  *(float *)(a1 + 16) = v13;
  v16 = a2[5];
  *(_QWORD *)(a1 + 24) = 0LL;
  if ( v9 < v15 )
    v9 = v15;
  *(float *)(a1 + 20) = v16;
  v17 = a2[8];
  v18 = fabsf(v13);
  v19 = fabsf(v16);
  if ( v18 < v19 )
    v18 = v19;
  v20 = fabsf(v17);
  if ( v17 < 0.0 )
    v4 = v20;
  if ( v17 > 0.0 )
    v4 = v20;
  if ( v18 >= v4 )
    v4 = v18;
  if ( v9 >= v4 )
    v4 = v9;
  if ( v4 == 0.0 )
    v21 = 1.0;
  else
    v21 = v4;
  *(float *)a1 = v8 / v21;
  *(float *)(a1 + 4) = v11 / v21;
  *(float *)(a1 + 8) = v14 / v21;
  *(float *)(a1 + 16) = v13 / v21;
  *(float *)(a1 + 20) = v16 / v21;
  *(float *)(a1 + 32) = v17 / v21;
  v94 = a1 + 48;
  Eigen::internal::tridiagonalization_inplace_selector<Eigen::Matrix<float,3,3,0,3,3>,3,false>::run<Eigen::Matrix<float,3,1,0,3,1>,Eigen::Matrix<float,2,1,0,2,1>>(
    a1,
    (float *)(a1 + 36),
    (float *)(a1 + 48),
    a3 < 0);
  v25 = 0LL;
  v26 = 0LL;
  v27 = 2LL;
  if ( a3 < 0 )
    v28 = a1;
  else
    v28 = 0LL;
  while ( 1 )
  {
LABEL_21:
    v29 = v27;
    if ( v26 < v27 )
    {
      v30 = *(float *)(a1 + 4 * v26 + 36);
      v31 = v27 - v26;
      v32 = (float *)(v94 + 4 * v26);
      do
      {
        v33 = fabsf(v30);
        v30 = *(v32 - 2);
        if ( fabsf(*v32) <= (float)((float)(v33 + fabsf(v30)) * 0.00001) )
          *v32 = 0.0;
        --v31;
        ++v32;
      }
      while ( v31 );
    }
    v34 = v29 - 1;
    v35 = (float *)(v94 + 4 * v29);
    v36 = (float *)(a1 + 44 + 4 * v29);
    v37 = -12LL;
    v38 = v29;
    do
    {
      v39 = v38-- < 1;
      if ( v39 )
        goto LABEL_80;
      v40 = v36;
      v41 = *v36--;
      v42 = v41;
      v43 = v34;
      v44 = v37;
      v45 = v35;
      --v34;
      v37 -= 12LL;
      --v35;
    }
    while ( v41 == 0.0 );
    v93 = v25 + 1;
    if ( (unsigned __int64)v25 > 0x59 )
      break;
    v46 = 1LL;
    do
    {
      v26 = v43;
      v39 = v43-- < 1;
      v47 = v40;
      v48 = v44;
      v49 = v45;
      v50 = v46;
      if ( v39 )
        break;
      --v40;
      v44 -= 12LL;
      --v45;
      ++v46;
    }
    while ( *(v47 - 1) != 0.0 );
    v51 = *(v36 - 1);
    v52 = v26 + 1;
    v53 = (float)(*(v36 - 2) - v51) * 0.5;
    if ( v53 == 0.0 )
    {
      v27 = v38 + 1;
      v54 = fabsf(v42);
    }
    else
    {
      v55 = fabsf(v53);
      v56 = fabsf(v42);
      if ( v55 >= v56 )
        v57 = v55;
      else
        v57 = v56;
      v58 = v42 * v42;
      v59 = 0.0;
      if ( v57 != 0.0 )
      {
        if ( v56 >= v55 )
          v60 = v55;
        else
          v60 = v56;
        v59 = v57 * sqrtf((float)((float)(v60 / v57) * (float)(v60 / v57)) + 1.0);
      }
      v27 = v38 + 1;
      if ( v58 == 0.0 )
      {
        if ( v53 <= 0.0 )
          v61 = -1.0;
        else
          v61 = 1.0;
        v54 = (float)(v42 / (float)(v53 + v61)) * (float)(v42 / v59);
      }
      else
      {
        v62 = -v59;
        if ( v53 > 0.0 )
          v62 = v59;
        v54 = v58 / (float)(v53 + v62);
      }
    }
    v25 = v93;
    if ( v52 <= v27 )
    {
      v63 = *v47;
      v91 = StatusReg;
      v64 = *(v47 - 3) - (float)(v51 - v54);
      v65 = v26;
      v95 = v28 + 12 * v29;
      while ( 1 )
      {
        if ( v63 == 0.0 )
        {
          if ( v64 >= 0.0 )
            *(float *)&v23 = 1.0;
          else
            *(float *)&v23 = -1.0;
          LODWORD(v24) = 0;
        }
        else if ( v64 == 0.0 )
        {
          if ( v63 >= 0.0 )
            *(float *)&v24 = -1.0;
          else
            *(float *)&v24 = 1.0;
          LODWORD(v23) = 0;
        }
        else if ( fabsf(v64) <= fabsf(v63) )
        {
          v68 = v64 / v63;
          v69 = sqrtf((float)(v68 * v68) + 1.0);
          if ( v63 < 0.0 )
            v69 = -v69;
          *(float *)&v24 = -1.0 / v69;
          *(float *)&v23 = -(float)(v68 * *(float *)&v24);
        }
        else
        {
          v66 = v63 / v64;
          v67 = sqrtf((float)(v66 * v66) + 1.0);
          if ( v64 < 0.0 )
            v67 = -v67;
          *(float *)&v23 = 1.0 / v67;
          *(float *)&v24 = -(float)(v66 * *(float *)&v23);
        }
        v70 = *(v49 - 4);
        v71 = *(v49 - 3);
        v72 = *(v49 - 1);
        v73 = *(float *)&v23 * v72;
        v74 = *(float *)&v24 * v72;
        v75 = (float)(*(float *)&v24 * v70) + v73;
        v76 = v74 + (float)(*(float *)&v23 * v71);
        v64 = (float)(*(float *)&v23 * v75) - (float)(*(float *)&v24 * v76);
        *(v49 - 4) = (float)(*(float *)&v23 * (float)((float)(*(float *)&v23 * v70) - v74))
                   - (float)(*(float *)&v24 * (float)(v73 - (float)(*(float *)&v24 * v71)));
        *(v49 - 3) = (float)(*(float *)&v24 * v75) + (float)(*(float *)&v23 * v76);
        *(v49 - 1) = v64;
        if ( v65 >= v52 )
        {
          *(v49 - 2) = (float)(*(float *)&v23 * *(v49 - 2)) - (float)(v63 * *(float *)&v24);
          if ( v65 < v38 )
            goto LABEL_54;
        }
        else if ( v65 < v38 )
        {
LABEL_54:
          v63 = -(float)(*(float *)&v24 * *v49);
          *v49 = *(float *)&v23 * *v49;
          ++v65;
          if ( !v28 )
            goto LABEL_77;
LABEL_76:
          *(float *)&v24 = -*(float *)&v24;
          v100.n128_u64[0] = v95 + v48;
          v100.n128_u64[1] = 3LL;
          v96[0] = LODWORD(v23);
          v96[1] = LODWORD(v24);
          v101 = v28;
          v102 = vdupq_n_s64(3uLL);
          v103 = 3LL;
          v97[0] = v95 + v48 + 12;
          v97[1] = 3LL;
          v97[3] = v28;
          v98 = v102;
          v99 = 3LL;
          Eigen::internal::apply_rotation_in_the_plane<Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,float>(
            &v100,
            v97,
            v96,
            v23,
            v24);
          goto LABEL_77;
        }
        ++v65;
        if ( v28 )
          goto LABEL_76;
LABEL_77:
        v48 += 12LL;
        --v50;
        ++v49;
        if ( !v50 )
        {
          v27 = v38 + 1;
          v25 = v93;
          StatusReg = v91;
          goto LABEL_21;
        }
      }
    }
  }
  ++v25;
LABEL_80:
  *(_DWORD *)(a1 + 56) = 2 * (v25 > 90);
  if ( v25 < 91 )
  {
    v77 = *(float *)(a1 + 36);
    v78 = *(float *)(a1 + 40);
    if ( v78 < v77 )
    {
      v79 = 1LL;
    }
    else
    {
      v78 = *(float *)(a1 + 36);
      v79 = 0LL;
    }
    if ( *(float *)(a1 + 44) < v78 )
      v79 = 2LL;
    if ( v79 )
    {
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 36 + 4 * v79);
      *(float *)(a1 + 36 + 4 * v79) = v77;
      if ( v92 )
      {
        v80 = (_DWORD *)(a1 + 12 * v79);
        v81 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *v80;
        *v80 = v81;
        v82 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = v80[1];
        v80[1] = v82;
        v83 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v80[2];
        v80[2] = v83;
      }
    }
    v84 = *(float *)(a1 + 40);
    if ( *(float *)(a1 + 44) < v84 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
      *(float *)(a1 + 44) = v84;
      if ( v92 )
      {
        v85 = *(_QWORD *)(a1 + 12);
        v86 = *(_DWORD *)(a1 + 32);
        v87 = *(_DWORD *)(a1 + 20);
        *(_QWORD *)(a1 + 12) = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 24) = v85;
        *(_DWORD *)(a1 + 20) = v86;
        *(_DWORD *)(a1 + 32) = v87;
      }
    }
  }
  v88 = v21 * *(float *)(a1 + 40);
  v89 = v21 * *(float *)(a1 + 44);
  *(float *)(a1 + 36) = v21 * *(float *)(a1 + 36);
  *(float *)(a1 + 40) = v88;
  *(_BYTE *)(a1 + 60) = 1;
  *(_BYTE *)(a1 + 61) = v92 >> 7;
  *(float *)(a1 + 44) = v89;
  return a1;
}
// 279E4: variable 'v23' is possibly undefined
// 279E4: variable 'v24' is possibly undefined

//----- (0000000000027B48) ----------------------------------------------------
float __fastcall Eigen::internal::tridiagonalization_inplace_selector<Eigen::Matrix<float,3,3,0,3,3>,3,false>::run<Eigen::Matrix<float,3,1,0,3,1>,Eigen::Matrix<float,2,1,0,2,1>>(
        __int64 a1,
        float *a2,
        float *a3,
        char a4)
{
  float v4; // s1
  float result; // s0
  float v6; // s2
  float v7; // s4
  float v8; // s7
  float v9; // s1
  float v10; // s2

  *a2 = *(float *)a1;
  v4 = *(float *)(a1 + 8);
  result = v4 * v4;
  if ( (float)(v4 * v4) == 0.0 )
  {
    a2[1] = *(float *)(a1 + 16);
    a2[2] = *(float *)(a1 + 32);
    *a3 = *(float *)(a1 + 4);
    a3[1] = *(float *)(a1 + 20);
    if ( (a4 & 1) != 0 )
    {
      result = 1.0;
      *(_DWORD *)(a1 + 32) = 1065353216;
      *(_OWORD *)a1 = xmmword_54780;
      *(_OWORD *)(a1 + 16) = xmmword_54780;
    }
  }
  else
  {
    v6 = *(float *)(a1 + 4);
    v7 = *(float *)(a1 + 16);
    v8 = sqrtf(result + (float)(v6 * v6));
    result = v6 * (float)(1.0 / v8);
    v9 = v4 * (float)(1.0 / v8);
    v10 = (float)((float)(*(float *)(a1 + 32) - v7) * v9) + (float)(*(float *)(a1 + 20) * (float)(result + result));
    a2[1] = v7 + (float)(v9 * v10);
    a2[2] = *(float *)(a1 + 32) - (float)(v9 * v10);
    *a3 = v8;
    a3[1] = *(float *)(a1 + 20) - (float)(result * v10);
    if ( (a4 & 1) != 0 )
    {
      *(float *)(a1 + 16) = result;
      *(float *)(a1 + 20) = v9;
      result = -result;
      *(_DWORD *)(a1 + 24) = 0;
      *(_OWORD *)a1 = xmmword_54780;
      *(float *)(a1 + 28) = v9;
      *(float *)(a1 + 32) = result;
    }
  }
  return result;
}
// 54780: using guessed type __int128 xmmword_54780;

//----- (0000000000027C28) ----------------------------------------------------
float32x4_t *__fastcall Eigen::internal::apply_rotation_in_the_plane<Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,Eigen::Block<Eigen::Map<Eigen::Matrix<float,-1,-1,0,-1,-1>,0,Eigen::Stride<0,0>>,-1,1,true>,float>(
        float32x4_t *result,
        unsigned __int64 *a2,
        _DWORD *a3,
        double a4,
        double a5)
{
  unsigned __int64 v5; // x8
  __int64 v6; // x10
  unsigned __int64 v7; // x9
  __int64 v8; // x14
  __int64 v9; // x11
  __int64 v10; // x12
  __int64 v11; // x13
  __int64 v12; // x15
  __int64 v13; // x17
  __int64 v14; // x16
  float *v15; // x15
  float *v16; // x17
  float v17; // s2
  unsigned __int64 v18; // x15
  float32x4_t *v19; // x16
  float32x4_t *v20; // x17
  __int64 v21; // x13
  float32x4_t v22; // q2
  float32x4_t v23; // q3
  __int64 v24; // x14
  float32x4_t *v25; // x1
  float32x4_t v26; // t1
  float32x4_t v27; // q4
  float32x4_t v28; // t1
  __int64 v29; // x14
  signed __int64 v30; // x14
  float32x4_t v31; // q6
  float32x4_t v32; // q7
  float32x4_t v33; // q4
  __int64 v34; // x14
  float32x4_t v35; // q4
  float32x4_t v36; // q5
  unsigned __int64 v37; // x12
  __int64 v38; // x14
  float32x4_t *v39; // x11
  float32x4_t *v40; // x14
  float32x4_t v41; // q2
  float32x4_t v42; // q3
  unsigned __int64 v43; // x16
  float32x4_t *v44; // x17
  float32x4_t v45; // t1
  float32x4_t v46; // q4
  float32x4_t v47; // t1
  __int64 v48; // x10
  float *v49; // x9
  float *v50; // x8
  float v51; // s2
  float32x4_t v52; // q2
  float32x4_t v53; // q3
  unsigned __int64 v54; // x16
  float32x4_t *v55; // x2
  float32x4_t *v56; // x17
  float32x4_t *v57; // x1
  float32x4_t v58; // t1
  float32x4_t v59; // q4
  float32x4_t v60; // t1

  LODWORD(a4) = *a3;
  LODWORD(a5) = a3[1];
  v5 = result->n128_u64[0];
  v6 = result->n128_i64[1];
  v7 = *a2;
  if ( *(float *)a3 == 1.0 && *(float *)&a5 == 0.0 )
    return result;
  v8 = result->n128_i64[1];
  v9 = v8;
  if ( (v7 & 3) == 0 )
  {
    v9 = -((unsigned int)v7 >> 2) & 3LL;
    if ( v9 > v6 )
      v9 = result->n128_i64[1];
  }
  v10 = v6 - v9;
  v11 = v6 - v9 + 3;
  if ( v6 - v9 >= 0 )
    v11 = v6 - v9;
  if ( v9 >= 1 )
  {
    if ( (unsigned __int64)v9 > 3 && (v5 >= v7 + 4 * v9 || v7 >= v5 + 4 * v9) )
    {
      v12 = v9 & 0x7FFFFFFFFFFFFFFCLL;
      v52 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
      v53 = vdupq_lane_s32(*(int32x2_t *)&a5, 0);
      v54 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      result = (float32x4_t *)*a2;
      v55 = (float32x4_t *)v5;
      v56 = (float32x4_t *)v5;
      v57 = (float32x4_t *)*a2;
      do
      {
        v58 = *v56++;
        v59 = v58;
        v60 = *v57++;
        v54 -= 4LL;
        *v55 = vaddq_f32(vmulq_f32(v52, v59), vmulq_f32(v53, v60));
        *result = vsubq_f32(vmulq_f32(v52, v60), vmulq_f32(v53, v59));
        result = v57;
        v55 = v56;
      }
      while ( v54 );
      if ( v9 == v12 )
        goto LABEL_15;
    }
    else
    {
      v12 = 0LL;
    }
    v13 = 4 * v12;
    v14 = v9 - v12;
    v15 = (float *)(v7 + 4 * v12);
    v16 = (float *)(v5 + v13);
    do
    {
      --v14;
      v17 = (float)(*(float *)&a4 * *v15) - (float)(*(float *)&a5 * *v16);
      *v16 = (float)(*(float *)&a4 * *v16) + (float)(*(float *)&a5 * *v15);
      ++v16;
      *v15++ = v17;
    }
    while ( v14 );
  }
LABEL_15:
  v18 = v11 & 0xFFFFFFFFFFFFFFFCLL;
  v19 = (float32x4_t *)(v5 + 4 * v9);
  v20 = (float32x4_t *)(v7 + 4 * v9);
  if ( (v5 & 3) == 0 )
  {
    if ( (-((unsigned int)v5 >> 2) & 3LL) <= v6 )
      v8 = -((unsigned int)v5 >> 2) & 3LL;
    else
      v8 = v6;
  }
  v21 = v18 + v9;
  v22 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
  v23 = vdupq_lane_s32(*(int32x2_t *)&a5, 0);
  if ( v8 == v9 )
  {
    if ( v10 >= 4 )
    {
      v24 = v9;
      result = (float32x4_t *)(v5 + 4 * v9);
      v25 = (float32x4_t *)(v7 + 4 * v9);
      do
      {
        v26 = *result++;
        v27 = v26;
        v28 = *v25++;
        v24 += 4LL;
        *v19 = vaddq_f32(vmulq_f32(v22, v27), vmulq_f32(v23, v28));
        *v20 = vsubq_f32(vmulq_f32(v22, v28), vmulq_f32(v23, v27));
        v19 = result;
        v20 = v25;
      }
      while ( v24 < v21 );
    }
  }
  else
  {
    v29 = v10 + 7;
    if ( v10 >= 0 )
      v29 = v6 - v9;
    v30 = (v29 & 0xFFFFFFFFFFFFFFF8LL) + v9;
    if ( v10 >= 8 )
    {
      result = (float32x4_t *)v9;
      do
      {
        v31 = v19[1];
        v32 = v20[1];
        result = (float32x4_t *)((char *)result + 8);
        v33 = vsubq_f32(vmulq_f32(v22, *v20), vmulq_f32(v23, *v19));
        *v19 = vaddq_f32(vmulq_f32(v22, *v19), vmulq_f32(v23, *v20));
        v19[1] = vaddq_f32(vmulq_f32(v22, v31), vmulq_f32(v23, v32));
        v19 += 2;
        *v20 = v33;
        v20[1] = vsubq_f32(vmulq_f32(v22, v32), vmulq_f32(v23, v31));
        v20 += 2;
      }
      while ( (__int64)result < v30 );
    }
    if ( v21 != v30 )
    {
      v34 = 4 * v30;
      v35 = *(float32x4_t *)(v5 + v34);
      v36 = *(float32x4_t *)(v7 + v34);
      *(float32x4_t *)(v5 + v34) = vaddq_f32(vmulq_f32(v22, v35), vmulq_f32(v23, v36));
      *(float32x4_t *)(v7 + v34) = vsubq_f32(vmulq_f32(v22, v36), vmulq_f32(v23, v35));
    }
  }
  if ( v21 < v6 )
  {
    v37 = v10 - v18;
    if ( v37 < 4 )
      goto LABEL_38;
    v38 = 4 * (v9 + v18);
    v39 = (float32x4_t *)(v5 + v38);
    v40 = (float32x4_t *)(v7 + v38);
    if ( (unsigned __int64)v39 < v7 + 4 * v6 && (unsigned __int64)v40 < v5 + 4 * v6 )
      goto LABEL_38;
    v41 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v21 += v37 & 0xFFFFFFFFFFFFFFFCLL;
    v42 = vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    v43 = v37 & 0xFFFFFFFFFFFFFFFCLL;
    v44 = v39;
    result = v40;
    do
    {
      v45 = *v44++;
      v46 = v45;
      v47 = *result++;
      v43 -= 4LL;
      *v39 = vaddq_f32(vmulq_f32(v41, v46), vmulq_f32(v42, v47));
      *v40 = vsubq_f32(vmulq_f32(v41, v47), vmulq_f32(v42, v46));
      v40 = result;
      v39 = v44;
    }
    while ( v43 );
    if ( v37 != (v37 & 0xFFFFFFFFFFFFFFFCLL) )
    {
LABEL_38:
      v48 = v6 - v21;
      v49 = (float *)(v7 + 4 * v21);
      v50 = (float *)(v5 + 4 * v21);
      do
      {
        --v48;
        v51 = (float)(*(float *)&a4 * *v49) - (float)(*(float *)&a5 * *v50);
        *v50 = (float)(*(float *)&a4 * *v50) + (float)(*(float *)&a5 * *v49);
        ++v50;
        *v49++ = v51;
      }
      while ( v48 );
    }
  }
  return result;
}
// 27EF8: mask 0xFFFFFFFFFFFFFFFC is shortened because x11.8 <= 0x7FFFFFFFFFFFFFFF

//----- (0000000000027F5C) ----------------------------------------------------
__int64 __fastcall feasibal_region::getDirectorySize(__int64 a1)
{
  const char *v1; // x19
  DIR *v2; // x0
  DIR *v3; // x21
  __off_t st_size; // x20
  struct dirent *v5; // x0
  unsigned __int64 v6; // x27
  char *v7; // x26
  __off_t DirectorySize; // x25
  const char *d_name; // x25
  size_t v10; // x0
  size_t v11; // x25
  unsigned __int64 v13; // [xsp+8h] [xbp-1F8h] BYREF
  size_t v14; // [xsp+10h] [xbp-1F0h]
  void *v15; // [xsp+18h] [xbp-1E8h]
  struct stat buf; // [xsp+20h] [xbp-1E0h] BYREF
  __int64 v17; // [xsp+1A0h] [xbp-60h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v1 = *(const char **)(a1 + 16);
  else
    v1 = (const char *)(a1 + 1);
  v2 = opendir(v1);
  if ( v2 )
  {
    v3 = v2;
    lstat(v1, &buf);
    st_size = buf.st_size;
    v5 = readdir(v3);
    if ( v5 )
    {
      while ( 1 )
      {
        d_name = v5->d_name;
        sprintf((char *)&buf.__unused[1], "%s/%s", v1, v5->d_name);
        lstat((const char *)&buf.__unused[1], &buf);
        if ( (buf.st_nlink & 0xF000) == 0x4000 )
          break;
        DirectorySize = buf.st_size;
LABEL_19:
        st_size += DirectorySize;
LABEL_20:
        v5 = readdir(v3);
        if ( !v5 )
          goto LABEL_21;
      }
      if ( !strcmp(".", d_name) || !strcmp("..", d_name) )
        goto LABEL_20;
      v13 = 0LL;
      v14 = 0LL;
      v15 = 0LL;
      v10 = strlen((const char *)&buf.__unused[1]);
      if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v11 = v10;
      if ( v10 >= 0x17 )
      {
        v6 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v7 = (char *)operator new(v6);
        v14 = v11;
        v15 = v7;
        v13 = v6 | 1;
      }
      else
      {
        v7 = (char *)&v13 + 1;
        LOBYTE(v13) = 2 * v10;
        if ( !v10 )
        {
LABEL_9:
          v7[v11] = 0;
          DirectorySize = feasibal_region::getDirectorySize(&v13);
          if ( (v13 & 1) != 0 )
            operator delete(v15);
          goto LABEL_19;
        }
      }
      memcpy(v7, &buf.__unused[1], v11);
      goto LABEL_9;
    }
LABEL_21:
    closedir(v3);
  }
  else
  {
    fprintf(stderr, "Cannot open dir: %s\n", v1);
    return -1LL;
  }
  return st_size;
}

//----- (0000000000028170) ----------------------------------------------------
bool __fastcall feasibal_region::cleanDirectory(__int64 a1)
{
  const char *v1; // x2
  char s[100]; // [xsp+4h] [xbp-7Ch] BYREF
  __int64 v4; // [xsp+68h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v1 = *(const char **)(a1 + 16);
  else
    v1 = (const char *)(a1 + 1);
  sprintf(s, "rm %s/*.*", v1);
  return system(s) == 0;
}

//----- (00000000000281E4) ----------------------------------------------------
long double __fastcall feasibal_region::ground_process::ground_process(feasibal_region::ground_process *this)
{
  long double result; // q0

  feasibal_region::PreParamInfo::PreParamInfo((feasibal_region::ground_process *)((char *)this + 16));
  *((_QWORD *)this + 64) = 0LL;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 620) = 0u;
  *(_OWORD *)((char *)this + 604) = 0u;
  *(_OWORD *)((char *)this + 588) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *((_QWORD *)this + 81) = (char *)this + 592;
  *((_QWORD *)this + 82) = (char *)this + 664;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((_DWORD *)this + 146) = 1124007940;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 716) = 0u;
  *(_OWORD *)((char *)this + 700) = 0u;
  *(_OWORD *)((char *)this + 684) = 0u;
  *((_QWORD *)this + 93) = (char *)this + 688;
  *((_QWORD *)this + 94) = (char *)this + 760;
  *(_OWORD *)((char *)this + 760) = 0u;
  *((_DWORD *)this + 170) = 1124007941;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 812) = 0u;
  *(_OWORD *)((char *)this + 796) = 0u;
  *(_OWORD *)((char *)this + 780) = 0u;
  *((_QWORD *)this + 105) = (char *)this + 784;
  *((_QWORD *)this + 106) = (char *)this + 856;
  *(_OWORD *)((char *)this + 856) = 0u;
  *((_DWORD *)this + 194) = 1124007941;
  *(_OWORD *)((char *)this + 920) = 0u;
  *(_OWORD *)((char *)this + 908) = 0u;
  *(_OWORD *)((char *)this + 892) = 0u;
  *(_OWORD *)((char *)this + 876) = 0u;
  *((_QWORD *)this + 117) = (char *)this + 880;
  *((_QWORD *)this + 118) = (char *)this + 952;
  *(_OWORD *)((char *)this + 952) = 0u;
  *((_DWORD *)this + 218) = 1124007941;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1004) = 0u;
  *(_OWORD *)((char *)this + 988) = 0u;
  *(_OWORD *)((char *)this + 972) = 0u;
  *((_QWORD *)this + 129) = (char *)this + 976;
  *((_QWORD *)this + 130) = (char *)this + 1048;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *((_DWORD *)this + 242) = 1124007941;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1100) = 0u;
  *(_OWORD *)((char *)this + 1084) = 0u;
  *(_OWORD *)((char *)this + 1068) = 0u;
  *((_QWORD *)this + 141) = (char *)this + 1072;
  *((_QWORD *)this + 142) = (char *)this + 1144;
  *(_OWORD *)((char *)this + 1144) = 0u;
  *((_DWORD *)this + 266) = 1124007936;
  *((_DWORD *)this + 290) = 1124007936;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1196) = 0u;
  *(_OWORD *)((char *)this + 1180) = 0u;
  *(_OWORD *)((char *)this + 1164) = 0u;
  *((_QWORD *)this + 153) = (char *)this + 1168;
  *((_QWORD *)this + 154) = (char *)this + 1240;
  *(_OWORD *)((char *)this + 1240) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1276) = 0u;
  *(_OWORD *)((char *)this + 1292) = 0u;
  *(_OWORD *)((char *)this + 1260) = 0u;
  *((_QWORD *)this + 165) = (char *)this + 1264;
  *((_QWORD *)this + 166) = (char *)this + 1336;
  *(_OWORD *)((char *)this + 1336) = 0u;
  *((_DWORD *)this + 314) = 1124007941;
  *(_OWORD *)((char *)this + 1400) = 0u;
  *(_OWORD *)((char *)this + 1388) = 0u;
  *(_OWORD *)((char *)this + 1372) = 0u;
  *(_OWORD *)((char *)this + 1356) = 0u;
  *((_QWORD *)this + 177) = (char *)this + 1360;
  *((_QWORD *)this + 178) = (char *)this + 1432;
  *(_OWORD *)((char *)this + 1432) = 0u;
  *((_DWORD *)this + 338) = 1124007941;
  *(_OWORD *)((char *)this + 1496) = 0u;
  *(_OWORD *)((char *)this + 1484) = 0u;
  *(_OWORD *)((char *)this + 1468) = 0u;
  *(_OWORD *)((char *)this + 1452) = 0u;
  *((_QWORD *)this + 189) = (char *)this + 1456;
  *((_QWORD *)this + 190) = (char *)this + 1528;
  *(_OWORD *)((char *)this + 1528) = 0u;
  *((_DWORD *)this + 362) = 1124007941;
  *(_OWORD *)((char *)this + 1592) = 0u;
  *(_OWORD *)((char *)this + 1580) = 0u;
  *(_OWORD *)((char *)this + 1564) = 0u;
  __asm { FMOV            V1.2S, #1.0 }
  *(_OWORD *)((char *)this + 1548) = 0u;
  *((_QWORD *)this + 201) = (char *)this + 1552;
  *((_QWORD *)this + 202) = (char *)this + 1624;
  *(_OWORD *)((char *)this + 1624) = 0u;
  *((_DWORD *)this + 386) = 1124007941;
  *((_QWORD *)this + 207) = 0LL;
  *(_OWORD *)((char *)this + 1640) = 0u;
  *((_DWORD *)this + 416) = 1065353216;
  *(_OWORD *)((char *)this + 1668) = 0u;
  *((_DWORD *)this + 421) = 1065353216;
  *(_OWORD *)((char *)this + 1688) = 0u;
  *((_DWORD *)this + 426) = 1065353216;
  *(_OWORD *)((char *)this + 1708) = 0u;
  *(_QWORD *)((char *)this + 1724) = _D1;
  *(_OWORD *)((char *)this + 1732) = 0u;
  *((_DWORD *)this + 437) = 1065353216;
  *(_OWORD *)((char *)this + 1752) = 0u;
  *((_DWORD *)this + 442) = 1065353216;
  *(_OWORD *)((char *)this + 1772) = 0u;
  *((_DWORD *)this + 447) = 1065353216;
  *((_WORD *)this + 896) = 0;
  *(_OWORD *)((char *)this + 1812) = 0u;
  *(_OWORD *)((char *)this + 1944) = 0u;
  *(_OWORD *)((char *)this + 1932) = 0u;
  *(_OWORD *)((char *)this + 1916) = 0u;
  *(_OWORD *)((char *)this + 1900) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  *(_OWORD *)((char *)this + 1864) = 0u;
  *(_OWORD *)((char *)this + 1848) = 0u;
  *((_QWORD *)this + 245) = (char *)this + 1904;
  *((_QWORD *)this + 246) = (char *)this + 1976;
  *(_OWORD *)((char *)this + 1976) = 0u;
  *((_DWORD *)this + 474) = 1124007936;
  *((_DWORD *)this + 498) = 1124007936;
  *(_OWORD *)((char *)this + 2040) = 0u;
  *(_OWORD *)((char *)this + 2028) = 0u;
  *(_OWORD *)((char *)this + 2012) = 0u;
  *(_OWORD *)((char *)this + 1996) = 0u;
  *((_QWORD *)this + 257) = (char *)this + 2000;
  *((_QWORD *)this + 258) = (char *)this + 2072;
  *(_OWORD *)((char *)this + 2072) = 0u;
  *((_DWORD *)this + 522) = 1124007936;
  *(_OWORD *)((char *)this + 2136) = 0u;
  *(_OWORD *)((char *)this + 2124) = 0u;
  *(_OWORD *)((char *)this + 2108) = 0u;
  *(_OWORD *)((char *)this + 2092) = 0u;
  *((_QWORD *)this + 269) = (char *)this + 2096;
  *((_QWORD *)this + 270) = (char *)this + 2168;
  *((_DWORD *)this + 546) = 0;
  *(_OWORD *)((char *)this + 2168) = 0u;
  *((_DWORD *)this + 548) = 1124007936;
  *((_OWORD *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 2228) = 0u;
  *(_OWORD *)((char *)this + 2212) = 0u;
  *(_OWORD *)((char *)this + 2196) = 0u;
  *((_QWORD *)this + 282) = (char *)this + 2200;
  *((_QWORD *)this + 283) = (char *)this + 2272;
  *((_OWORD *)this + 142) = 0u;
  *((_DWORD *)this + 572) = 1124007936;
  *((_OWORD *)this + 146) = 0u;
  *(_OWORD *)((char *)this + 2324) = 0u;
  *(_OWORD *)((char *)this + 2308) = 0u;
  *(_OWORD *)((char *)this + 2292) = 0u;
  *((_QWORD *)this + 294) = (char *)this + 2296;
  *((_QWORD *)this + 295) = (char *)this + 2368;
  *((_OWORD *)this + 148) = 0u;
  *((_BYTE *)this + 2384) = 1;
  *(_OWORD *)((char *)this + 2488) = 0u;
  *(_OWORD *)((char *)this + 2472) = 0u;
  *(_OWORD *)((char *)this + 2456) = 0u;
  *(_OWORD *)((char *)this + 2440) = 0u;
  *(_OWORD *)((char *)this + 2424) = 0u;
  *(_OWORD *)((char *)this + 2408) = 0u;
  *((_QWORD *)this + 313) = 0LL;
  *(_OWORD *)((char *)this + 2392) = 0u;
  *(_QWORD *)((char *)this + 2521) = 0LL;
  *(_QWORD *)((char *)this + 2516) = 0LL;
  *((_BYTE *)this + 2529) = 1;
  *(_OWORD *)((char *)this + 2552) = 0u;
  *(_OWORD *)((char *)this + 2536) = 0u;
  *((_DWORD *)this + 652) = 1124007936;
  *((_DWORD *)this + 642) = 0;
  *((_DWORD *)this + 650) = 0;
  *((_QWORD *)this + 324) = 0LL;
  *((_OWORD *)this + 161) = 0u;
  *((_OWORD *)this + 166) = 0u;
  *(_OWORD *)((char *)this + 2644) = 0u;
  *(_OWORD *)((char *)this + 2628) = 0u;
  *(_OWORD *)((char *)this + 2612) = 0u;
  *((_QWORD *)this + 334) = (char *)this + 2616;
  *((_QWORD *)this + 335) = (char *)this + 2688;
  *((_QWORD *)this + 339) = 0LL;
  *(_QWORD *)((char *)this + 2701) = 0LL;
  *((_QWORD *)this + 336) = 0LL;
  *((_QWORD *)this + 342) = off_6DF88;
  *((_QWORD *)this + 364) = off_6DFB0;
  *((_QWORD *)this + 337) = 0LL;
  *((_OWORD *)this + 170) = xmmword_547A0;
  std::ios_base::init((feasibal_region::ground_process *)((char *)this + 2912), (char *)this + 2744);
  *((_QWORD *)this + 381) = 0LL;
  *((_DWORD *)this + 764) = -1;
  *((_QWORD *)this + 342) = off_6DF38;
  *((_QWORD *)this + 364) = off_6DF60;
  std::filebuf::basic_filebuf((__int64)this + 2744);
  *(_OWORD *)&result = 0uLL;
  *((_DWORD *)this + 767) = 0;
  *((_BYTE *)this + 3072) = 1;
  *(_OWORD *)((char *)this + 3080) = 0u;
  return result;
}
// 547A0: using guessed type __int128 xmmword_547A0;
// 6DF38: using guessed type __int64 (__fastcall *[2])();
// 6DF60: using guessed type __int64 (__fastcall *[2])();
// 6DF88: using guessed type __int64 (__fastcall *[2])();
// 6DFB0: using guessed type __int64 (__fastcall *[2])();

//----- (00000000000291B0) ----------------------------------------------------
__int64 *__fastcall feasibal_region::PreParamInfo::PreParamInfo(feasibal_region::PreParamInfo *this)
{
  __int64 *result; // x0

  *((_DWORD *)this + 68) = 1124007936;
  *((_OWORD *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 308) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *((_DWORD *)this + 92) = 1124007936;
  *((_QWORD *)this + 42) = (char *)this + 280;
  *((_QWORD *)this + 43) = (char *)this + 352;
  *((_QWORD *)this + 44) = 0LL;
  *((_QWORD *)this + 45) = 0LL;
  *((_OWORD *)this + 26) = 0u;
  *(_OWORD *)((char *)this + 404) = 0u;
  *(_OWORD *)((char *)this + 388) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *((_QWORD *)this + 54) = (char *)this + 376;
  *((_QWORD *)this + 55) = (char *)this + 448;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *(_OWORD *)((char *)this + 473) = 0u;
  *((int32x2_t *)this + 1) = vdup_n_s32(0x44FA0000u);
  *((int32x2_t *)this + 15) = vdup_n_s32(0x42480000u);
  *(_BYTE *)this = 1;
  *((_QWORD *)this + 6) = 1142865920LL;
  *((_DWORD *)this + 20) = 1065353216;
  *(_QWORD *)((char *)this + 60) = 0x441EC00000000000LL;
  *((_DWORD *)this + 32) = 1106247680;
  *((_QWORD *)this + 9) = 0x4370000043A00000LL;
  *((_BYTE *)this + 489) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 17) = 0;
  *(_QWORD *)((char *)this + 260) = 0x14000000014LL;
  *((_DWORD *)this + 67) = 640;
  *((_BYTE *)this + 44) = 0;
  *((_QWORD *)this + 2) = 0x4170000043480000LL;
  *((_DWORD *)this + 6) = 1148698624;
  *((_DWORD *)this + 10) = 1062836634;
  *((_DWORD *)this + 123) = 0;
  result = std::string::assign((__int64 *)this + 58, "./mask.png", 0xAuLL);
  *((_DWORD *)this + 1) = 0;
  return result;
}

//----- (0000000000029418) ----------------------------------------------------
void __fastcall std::ofstream::~ofstream(_QWORD *a1)
{
  *a1 = off_6DF38;
  a1[22] = off_6DF60;
  std::filebuf::~filebuf((__int64)(a1 + 1));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 22));
}
// 6DF38: using guessed type __int64 (__fastcall *off_6DF38[2])();
// 6DF60: using guessed type __int64 (__fastcall *off_6DF60[2])();

//----- (0000000000029454) ----------------------------------------------------
void __fastcall feasibal_region::PreParamInfo::~PreParamInfo(void **this, void *a2)
{
  char *v3; // x8
  unsigned int *v4; // x8
  unsigned int v5; // w9
  unsigned int v6; // w9
  int v7; // w8
  _DWORD *v8; // x8
  __int64 v9; // x9
  cv *v10; // x0
  char *v11; // x8
  unsigned int *v12; // x8
  unsigned int v13; // w9
  unsigned int v14; // w9
  int v15; // w8
  _DWORD *v16; // x8
  __int64 v17; // x9
  cv *v18; // x0

  if ( ((_BYTE)this[58] & 1) != 0 )
    operator delete(this[60]);
  v3 = (char *)this[53];
  if ( v3 )
  {
    v4 = (unsigned int *)(v3 + 20);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while ( __stlxr(v6, v4) );
    if ( !v6 )
      cv::Mat::deallocate((cv::Mat *)(this + 46));
  }
  v7 = *((_DWORD *)this + 93);
  this[53] = 0LL;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  if ( v7 >= 1 )
  {
    v8 = this[54];
    v9 = 0LL;
    do
      v8[v9++] = 0;
    while ( v9 < *((int *)this + 93) );
  }
  v10 = (cv *)this[55];
  if ( v10 != (cv *)(this + 56) )
    cv::fastFree(v10, a2);
  v11 = (char *)this[41];
  if ( v11 )
  {
    v12 = (unsigned int *)(v11 + 20);
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while ( __stlxr(v14, v12) );
    if ( !v14 )
      cv::Mat::deallocate((cv::Mat *)(this + 34));
  }
  v15 = *((_DWORD *)this + 69);
  this[41] = 0LL;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  if ( v15 >= 1 )
  {
    v16 = this[42];
    v17 = 0LL;
    do
      v16[v17++] = 0;
    while ( v17 < *((int *)this + 69) );
  }
  v18 = (cv *)this[43];
  if ( v18 != (cv *)(this + 44) )
    cv::fastFree(v18, a2);
}
// 294E0: variable 'a2' is possibly undefined

//----- (0000000000029568) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::init(__int64 a1, __int64 a2)
{
  _BYTE *v2; // x20
  int v5; // w9
  int v6; // w10
  __int64 v7; // x11
  __int128 v8; // q0
  __int128 v9; // q1
  int v10; // w12
  char v11; // w8
  __int128 v12; // q2
  int v13; // w9
  int v14; // w10
  int v15; // w23
  int v16; // w24
  int v17; // w25
  float v18; // s8
  float v19; // s9
  CAPE *v20; // x22
  CAPE *v21; // x23
  __int64 v22; // x11
  const char *v23; // x23
  size_t v24; // x0
  size_t v25; // x22
  char *v26; // x24
  __int64 v27; // x10
  int64x2_t v28; // q1
  _QWORD *v29; // x11
  __int64 v30; // x12
  int64x2_t v31; // q0
  __int64 v32; // d2
  __int64 v33; // x12
  int *v34; // x9
  __int64 v35; // t1
  const char *v36; // x23
  size_t v37; // x0
  size_t v38; // x22
  char *v39; // x24
  unsigned __int64 v40; // x25
  char v41; // w22
  unsigned __int64 v42; // x25
  char v43; // w22
  unsigned int *v44; // x8
  unsigned int v45; // w9
  cv *v46; // x8
  cv *v47; // x10
  void *v48; // x1
  unsigned int *v49; // x8
  unsigned int v50; // w9
  unsigned int v51; // w9
  __int64 v52; // x8
  __int64 v53; // x9
  unsigned int v54; // w13
  unsigned int v55; // w12
  unsigned int v56; // w9
  float v57; // w14
  unsigned int v58; // w8
  float v59; // w11
  unsigned int v60; // w15
  float v61; // s1
  unsigned int v62; // w10
  float v63; // w16
  float v64; // s0
  float v65; // s2
  float v66; // s6
  unsigned __int64 v67; // d0
  int v68; // w8
  float v69; // s8
  int v70; // w22
  int v71; // w23
  int v72; // w21
  __int64 v73; // x0
  int v74; // w9
  float v75; // s0
  int v76; // w8
  const char *v77; // x21
  size_t v78; // x0
  size_t v79; // x20
  char *v80; // x22
  unsigned __int64 v81; // x23
  char v82; // w20
  __int64 v83; // x0
  int tv_sec; // s8
  const char *v85; // x22
  size_t v86; // x0
  size_t v87; // x21
  char *v88; // x23
  __int64 v89; // x8
  int *v90; // x26
  _DWORD *v91; // x24
  int i; // w25
  __int64 v93; // x1
  __int64 v94; // x0
  char v95; // w24
  __int64 *v96; // x0
  const char *v97; // x0
  int v98; // w20
  FILE *v99; // x23
  unsigned __int64 v100; // x24
  char v101; // w21
  int v102; // w22
  __time_t v103; // x20
  __suseconds_t tv_usec; // x25
  __time_t v105; // x21
  __suseconds_t v106; // x27
  const char *v107; // x22
  size_t v108; // x0
  size_t v109; // x19
  char *v110; // x23
  _DWORD *v111; // x28
  unsigned __int64 v112; // x24
  char v113; // w19
  float v114; // s0
  __int64 DirectorySize; // x19
  unsigned int *v116; // x8
  unsigned int v117; // w9
  unsigned int v118; // w9
  __int64 v119; // x8
  __int64 v120; // x9
  void *v122[3]; // [xsp+30h] [xbp-570h] BYREF
  char v123; // [xsp+48h] [xbp-558h] BYREF
  char v124[23]; // [xsp+49h] [xbp-557h] BYREF
  int v125; // [xsp+60h] [xbp-540h] BYREF
  unsigned __int64 v126; // [xsp+68h] [xbp-538h] BYREF
  size_t v127; // [xsp+70h] [xbp-530h]
  void *v128; // [xsp+78h] [xbp-528h]
  struct timeval v129; // [xsp+80h] [xbp-520h] BYREF
  struct timeval tv; // [xsp+90h] [xbp-510h] BYREF
  char v131; // [xsp+A0h] [xbp-500h] BYREF
  char v132[15]; // [xsp+A1h] [xbp-4FFh] BYREF
  void *v133; // [xsp+B0h] [xbp-4F0h]
  int v134; // [xsp+B8h] [xbp-4E8h] BYREF
  unsigned __int64 v135; // [xsp+C0h] [xbp-4E0h] BYREF
  size_t v136; // [xsp+C8h] [xbp-4D8h]
  void *v137; // [xsp+D0h] [xbp-4D0h]
  char v138; // [xsp+D8h] [xbp-4C8h] BYREF
  char v139[15]; // [xsp+D9h] [xbp-4C7h] BYREF
  void *v140; // [xsp+E8h] [xbp-4B8h]
  int v141; // [xsp+F0h] [xbp-4B0h] BYREF
  unsigned __int64 v142; // [xsp+F8h] [xbp-4A8h] BYREF
  size_t v143; // [xsp+100h] [xbp-4A0h]
  void *v144; // [xsp+108h] [xbp-498h]
  __int128 v145; // [xsp+110h] [xbp-490h] BYREF
  char v146; // [xsp+128h] [xbp-478h] BYREF
  char v147[15]; // [xsp+129h] [xbp-477h] BYREF
  void *v148; // [xsp+138h] [xbp-468h]
  int v149; // [xsp+140h] [xbp-460h] BYREF
  unsigned __int64 v150; // [xsp+148h] [xbp-458h] BYREF
  size_t v151; // [xsp+150h] [xbp-450h]
  void *v152; // [xsp+158h] [xbp-448h]
  char v153; // [xsp+160h] [xbp-440h] BYREF
  char v154[15]; // [xsp+161h] [xbp-43Fh] BYREF
  void *v155; // [xsp+170h] [xbp-430h]
  int v156; // [xsp+178h] [xbp-428h] BYREF
  unsigned __int64 v157; // [xsp+180h] [xbp-420h] BYREF
  size_t v158; // [xsp+188h] [xbp-418h]
  void *v159; // [xsp+190h] [xbp-410h]
  __int64 v160; // [xsp+198h] [xbp-408h] BYREF
  __int64 v161; // [xsp+1A0h] [xbp-400h] BYREF
  float32x2_t v162; // [xsp+1A8h] [xbp-3F8h] BYREF
  __int128 *v163; // [xsp+1B0h] [xbp-3F0h]
  void *v164; // [xsp+1B8h] [xbp-3E8h]
  __int128 v165; // [xsp+2F0h] [xbp-2B0h] BYREF
  __int64 v166[15]; // [xsp+300h] [xbp-2A0h] BYREF
  FILE *v167; // [xsp+378h] [xbp-228h]
  int v168; // [xsp+398h] [xbp-208h]
  __int64 v169[18]; // [xsp+3A8h] [xbp-1F8h] BYREF
  int v170; // [xsp+438h] [xbp-168h]
  unsigned __int64 v171; // [xsp+440h] [xbp-160h] BYREF
  int v172; // [xsp+448h] [xbp-158h]
  int v173[4]; // [xsp+450h] [xbp-150h] BYREF
  __int128 v174; // [xsp+460h] [xbp-140h] BYREF
  __int128 v175; // [xsp+470h] [xbp-130h]
  __int128 v176; // [xsp+480h] [xbp-120h]
  __int64 v177; // [xsp+490h] [xbp-110h]
  __int64 v178; // [xsp+498h] [xbp-108h]
  __int64 v179; // [xsp+4A0h] [xbp-100h]
  cv *v180; // [xsp+4A8h] [xbp-F8h]
  __int64 v181[2]; // [xsp+4B0h] [xbp-F0h] BYREF
  __int128 v182; // [xsp+4C0h] [xbp-E0h] BYREF
  __int128 v183; // [xsp+4D0h] [xbp-D0h]
  __int128 v184; // [xsp+4E0h] [xbp-C0h]
  __int64 v185; // [xsp+4F0h] [xbp-B0h]
  __int64 v186; // [xsp+4F8h] [xbp-A8h]
  __int64 v187; // [xsp+500h] [xbp-A0h]
  cv *v188; // [xsp+508h] [xbp-98h]
  __int64 v189; // [xsp+510h] [xbp-90h] BYREF

  v2 = (_BYTE *)(a1 + 16);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  feasibal_region::PreParamInfo::operator=(a1 + 16, (__int128 *)a2);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_DWORD *)(a1 + 80);
  v7 = *(_QWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 2512) = *(_DWORD *)(a2 + 16);
  v8 = *(_OWORD *)(a1 + 148);
  v9 = *(_OWORD *)(a1 + 164);
  v10 = *(_DWORD *)(a1 + 180);
  *(_BYTE *)(a1 + 2528) = *(_BYTE *)(a2 + 488);
  v11 = *(_BYTE *)(a2 + 489);
  v12 = *(_OWORD *)(a1 + 184);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = v6;
  *(_QWORD *)(a1 + 8) = v7;
  *(_OWORD *)(a1 + 1728) = v8;
  *(_OWORD *)(a1 + 1744) = v9;
  *(_DWORD *)(a1 + 1760) = v10;
  *(_BYTE *)(a1 + 2529) = v11;
  *(_OWORD *)(a1 + 1764) = v12;
  v13 = *(_DWORD *)(a1 + 204);
  v14 = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(a1 + 1780) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(a1 + 1784) = v13;
  *(_DWORD *)(a1 + 1788) = v14;
  v15 = *(_DWORD *)(a2 + 264);
  *(_DWORD *)(a1 + 520) = v15;
  v16 = *(_DWORD *)(a2 + 268);
  *(_DWORD *)(a1 + 524) = v16;
  v17 = *(_DWORD *)(a2 + 260);
  *(_DWORD *)(a1 + 528) = v17;
  v18 = *(float *)(a2 + 128);
  v19 = cos((float)(*(float *)(a2 + 20) + -1.0) * 3.14159265 / 180.0);
  v20 = (CAPE *)operator new(0x628uLL);
  CAPE::CAPE(v20, v15, v16, v17, v17, *(_BYTE *)(a2 + 497), v19, *(float *)(a2 + 500), v18);
  v21 = *(CAPE **)(a1 + 512);
  *(_QWORD *)(a1 + 512) = v20;
  if ( v21 )
  {
    CAPE::~CAPE(v21);
    operator delete(v21);
  }
  cv::imread(&v182, a1 + 480, 1LL);
  if ( !(_QWORD)v183 )
  {
LABEL_22:
    if ( (word_6FDF0 & 1) != 0 )
      v36 = (const char *)qword_6FE00;
    else
      v36 = (char *)&word_6FDF0 + 1;
    v149 = dword_6FDE8;
    v151 = 0LL;
    v152 = 0LL;
    v150 = 0LL;
    v37 = strlen(v36);
    if ( v37 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v38 = v37;
    if ( v37 >= 0x17 )
    {
      v40 = (v37 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v39 = (char *)operator new(v40);
      v151 = v38;
      v152 = v39;
      v150 = v40 | 1;
    }
    else
    {
      v39 = (char *)&v150 + 1;
      LOBYTE(v150) = 2 * v37;
      if ( !v37 )
      {
LABEL_31:
        v39[v38] = 0;
        if ( (g3::logLevel(&v149) & 1) != 0 )
        {
          *(_QWORD *)&v147[7] = 0LL;
          v148 = 0LL;
          v146 = 12;
          strcpy(v147, "region");
          v41 = g3::logTag(&v146);
          if ( (v146 & 1) == 0 )
          {
            if ( (v150 & 1) == 0 )
              goto LABEL_34;
LABEL_37:
            operator delete(v152);
            if ( (v41 & 1) == 0 )
              goto LABEL_52;
LABEL_38:
            LogCapture::LogCapture((LogCapture *)&v165, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)&v165, "can't read extern mask!\n");
LABEL_51:
            LogCapture::~LogCapture((LogCapture *)&v165);
            goto LABEL_52;
          }
          operator delete(v148);
          if ( (v150 & 1) != 0 )
            goto LABEL_37;
        }
        else
        {
          v41 = 0;
          if ( (v150 & 1) != 0 )
            goto LABEL_37;
        }
LABEL_34:
        if ( (v41 & 1) == 0 )
          goto LABEL_52;
        goto LABEL_38;
      }
    }
    memcpy(v39, v36, v38);
    goto LABEL_31;
  }
  if ( SDWORD1(v182) >= 3 )
  {
    if ( DWORD1(v182) == 3 )
    {
      v27 = 0LL;
      v22 = 1LL;
    }
    else
    {
      v27 = DWORD1(v182) & 0xFFFFFFFC;
      v28 = vdupq_n_s64(1uLL);
      v29 = (_QWORD *)(v187 + 8);
      v30 = v27;
      v31 = v28;
      do
      {
        v32 = *(v29 - 1);
        v28.n128_u64[0] *= (int)v32;
        v31.n128_u64[0] *= (int)*v29;
        v30 -= 4LL;
        v28.n128_u64[1] *= SHIDWORD(v32);
        v31.n128_u64[1] *= (int)HIDWORD(*v29);
        v29 += 2;
      }
      while ( v30 );
      v22 = v31.n128_u64[0] * v28.n128_u64[0] * v31.n128_u64[1] * v28.n128_u64[1];
      if ( v27 == DWORD1(v182) )
        goto LABEL_6;
    }
    v33 = DWORD1(v182) - v27;
    v34 = (int *)(v187 + 4 * v27);
    do
    {
      v35 = *v34++;
      --v33;
      v22 *= v35;
    }
    while ( v33 );
    goto LABEL_6;
  }
  v22 = SHIDWORD(v182) * (__int64)SDWORD2(v182);
  if ( !DWORD1(v182) )
    goto LABEL_22;
LABEL_6:
  if ( !v22 )
    goto LABEL_22;
  LODWORD(v165) = 16842752;
  v166[0] = 0LL;
  v163 = &v182;
  v164 = 0LL;
  *((_QWORD *)&v165 + 1) = &v182;
  v162.n64_u32[0] = 33619968;
  v160 = 0xF000000140LL;
  cv::resize(&v165, &v162, &v160, 1LL, 0.0, 0.0);
  if ( (word_6FDF0 & 1) != 0 )
    v23 = (const char *)qword_6FE00;
  else
    v23 = (char *)&word_6FDF0 + 1;
  v156 = dword_6FDE8;
  v158 = 0LL;
  v159 = 0LL;
  v157 = 0LL;
  v24 = strlen(v23);
  if ( v24 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v25 = v24;
  if ( v24 >= 0x17 )
  {
    v42 = (v24 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v26 = (char *)operator new(v42);
    v158 = v25;
    v159 = v26;
    v157 = v42 | 1;
    goto LABEL_42;
  }
  v26 = (char *)&v157 + 1;
  LOBYTE(v157) = 2 * v24;
  if ( v24 )
LABEL_42:
    memcpy(v26, v23, v25);
  v26[v25] = 0;
  if ( (g3::logLevel(&v156) & 1) != 0 )
  {
    *(_QWORD *)&v154[7] = 0LL;
    v155 = 0LL;
    v153 = 12;
    strcpy(v154, "region");
    v43 = g3::logTag(&v153);
    if ( (v153 & 1) == 0 )
    {
      if ( (v157 & 1) == 0 )
        goto LABEL_46;
LABEL_49:
      operator delete(v159);
      if ( (v43 & 1) == 0 )
        goto LABEL_52;
      goto LABEL_50;
    }
    operator delete(v155);
    if ( (v157 & 1) != 0 )
      goto LABEL_49;
  }
  else
  {
    v43 = 0;
    if ( (v157 & 1) != 0 )
      goto LABEL_49;
  }
LABEL_46:
  if ( (v43 & 1) != 0 )
  {
LABEL_50:
    LogCapture::LogCapture((LogCapture *)&v165, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v165, "read extern mask success!\n");
    goto LABEL_51;
  }
LABEL_52:
  v175 = v183;
  v177 = v185;
  v174 = v182;
  v176 = v184;
  v178 = v186;
  v179 = (__int64)&v174 + 8;
  v180 = (cv *)v181;
  v181[1] = 0LL;
  v181[0] = 0LL;
  if ( v186 )
  {
    v44 = (unsigned int *)(v186 + 20);
    do
      v45 = __ldaxr(v44);
    while ( __stlxr(v45 + 1, v44) );
    if ( SDWORD1(v182) <= 2 )
      goto LABEL_56;
LABEL_58:
    DWORD1(v174) = 0;
    cv::Mat::copySize((cv::Mat *)&v174, (const cv::Mat *)&v182);
    goto LABEL_59;
  }
  if ( SDWORD1(v182) > 2 )
    goto LABEL_58;
LABEL_56:
  v46 = v188;
  v47 = v180;
  *(_QWORD *)v180 = *(_QWORD *)v188;
  *((_QWORD *)v47 + 1) = *((_QWORD *)v46 + 1);
LABEL_59:
  feasibal_region::ground_process::init_data_pre(a1, (__int64)&v174);
  if ( v178 )
  {
    v49 = (unsigned int *)(v178 + 20);
    do
    {
      v50 = __ldaxr(v49);
      v51 = v50 - 1;
    }
    while ( __stlxr(v51, v49) );
    if ( !v51 )
      cv::Mat::deallocate((cv::Mat *)&v174);
  }
  v178 = 0LL;
  v175 = 0u;
  v176 = 0u;
  if ( SDWORD1(v174) >= 1 )
  {
    v52 = v179;
    v53 = 0LL;
    do
      *(_DWORD *)(v52 + 4 * v53++) = 0;
    while ( v53 < SDWORD1(v174) );
  }
  if ( v180 != (cv *)v181 )
    cv::fastFree(v180, v48);
  if ( *v2 )
  {
    v54 = *(_DWORD *)(a1 + 1732);
    v55 = *(_DWORD *)(a1 + 1728);
    v56 = *(_DWORD *)(a1 + 1748);
    v57 = *(float *)(a1 + 1764);
    v58 = *(_DWORD *)(a1 + 1744);
    v59 = *(float *)(a1 + 1760);
    v60 = *(_DWORD *)(a1 + 1736);
    v61 = *(float *)(a1 + 1780);
    v62 = *(_DWORD *)(a1 + 1752);
    *(_DWORD *)(a1 + 1724) = 1065353216;
    v63 = *(float *)(a1 + 1768);
    v64 = *(float *)(a1 + 1776);
    v65 = *(float *)(a1 + 1784);
    v66 = v64 * v59;
    *(_DWORD *)(a1 + 1668) = v58;
    v67 = vsub_f32(
            vsub_f32(
              vneg_f32(vmul_n_f32((float32x2_t)__PAIR64__(v56, v54), v61)),
              vmul_n_f32((float32x2_t)__PAIR64__(v58, v55), v64)),
            vmul_n_f32((float32x2_t)__PAIR64__(v62, v60), v65)).n64_u64[0];
    v68 = 1;
    *(_DWORD *)(a1 + 1676) = 0;
    *(_DWORD *)(a1 + 1692) = 0;
    *(_DWORD *)(a1 + 1708) = 0;
    *(_DWORD *)(a1 + 1664) = v55;
    *(_DWORD *)(a1 + 1680) = v54;
    *(_DWORD *)(a1 + 1696) = v60;
    *(float *)(a1 + 1672) = v59;
    *(float *)(a1 + 1688) = v57;
    *(float *)(a1 + 1704) = v63;
    *(_DWORD *)(a1 + 1684) = v56;
    *(_DWORD *)(a1 + 1700) = v62;
    *(float *)(a1 + 1720) = (float)((float)-(float)(v61 * v57) - v66) - (float)(v65 * v63);
    *(_QWORD *)(a1 + 1712) = v67;
  }
  else
  {
    v69 = *(float *)(a2 + 24);
    v71 = *(_DWORD *)(a2 + 28);
    v70 = *(_DWORD *)(a2 + 32);
    v72 = *(_DWORD *)(a2 + 36);
    v73 = *(_QWORD *)(a1 + 512);
    *(float *)(a1 + 2184) = v69;
    v173[0] = v71;
    v173[1] = v70;
    v173[2] = v72;
    CAPE::updateDefaultPlane(v73, v173, v69);
    *(_QWORD *)&v165 = __PAIR64__(v70, v71);
    *((_QWORD *)&v165 + 1) = __PAIR64__(LODWORD(v69), v72);
    feasibal_region::ground_process::getExtrinsicFromPlane(a1, (__int64)&v165);
    v68 = (unsigned __int8)*v2;
  }
  v74 = *(_DWORD *)(a1 + 24);
  v75 = *(float *)(a1 + 28);
  *(_DWORD *)(a1 + 1828) = 0;
  *(_DWORD *)(a1 + 1832) = v74;
  *(float32x2_t *)(a1 + 1836) = vmul_n_f32((float32x2_t)0x3F000000BF000000LL, v75);
  if ( v68 )
  {
    v76 = *(unsigned __int8 *)(a1 + 60);
    *(_BYTE *)(a1 + 16) = 0;
    if ( !v76 )
      *(_BYTE *)(a1 + 1792) = 1;
    feasibal_region::ground_process::getPlaneFromExtrinsic(a1, &v162, (float *)&tv);
    v145 = *(_OWORD *)(a1 + 1828);
    if ( !(unsigned int)feasibal_region::ground_process::set_calib(a1, &v145) )
    {
      v83 = *(_QWORD *)(a1 + 512);
      tv_sec = tv.tv_sec;
      v171 = v162.n64_u64[0];
      v172 = (int)v163;
      CAPE::updateDefaultPlane(v83, &v171, *(float *)&tv.tv_sec);
      *(_DWORD *)(a1 + 2184) = tv_sec;
      if ( (word_6FDF0 & 1) != 0 )
        v85 = (const char *)qword_6FE00;
      else
        v85 = (char *)&word_6FDF0 + 1;
      v141 = dword_6FDE8;
      v143 = 0LL;
      v144 = 0LL;
      v142 = 0LL;
      v86 = strlen(v85);
      if ( v86 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v87 = v86;
      if ( v86 >= 0x17 )
      {
        v100 = (v86 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v88 = (char *)operator new(v100);
        v143 = v87;
        v144 = v88;
        v142 = v100 | 1;
      }
      else
      {
        v88 = (char *)&v142 + 1;
        LOBYTE(v142) = 2 * v86;
        if ( !v86 )
        {
LABEL_120:
          v88[v87] = 0;
          if ( (g3::logLevel(&v141) & 1) != 0 )
          {
            *(_QWORD *)&v139[7] = 0LL;
            v140 = 0LL;
            v138 = 12;
            strcpy(v139, "region");
            v101 = g3::logTag(&v138);
            if ( (v138 & 1) == 0 )
            {
              if ( (v142 & 1) == 0 )
                goto LABEL_123;
LABEL_126:
              operator delete(v144);
              if ( (v101 & 1) == 0 )
                goto LABEL_128;
              goto LABEL_127;
            }
            operator delete(v140);
            if ( (v142 & 1) != 0 )
              goto LABEL_126;
          }
          else
          {
            v101 = 0;
            if ( (v142 & 1) != 0 )
              goto LABEL_126;
          }
LABEL_123:
          if ( (v101 & 1) == 0 )
          {
LABEL_128:
            *v2 = 1;
            if ( !*(_BYTE *)(a1 + 2529) )
              goto LABEL_165;
            goto LABEL_77;
          }
LABEL_127:
          LogCapture::LogCapture((LogCapture *)&v165, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
          LogCapture::capturef((LogCapture *)&v165, "plane_detector init suc!\n");
          LogCapture::~LogCapture((LogCapture *)&v165);
          goto LABEL_128;
        }
      }
      memcpy(v88, v85, v87);
      goto LABEL_120;
    }
  }
  if ( !*(_BYTE *)(a1 + 2529) )
    goto LABEL_165;
LABEL_77:
  if ( (word_6FDF0 & 1) != 0 )
    v77 = (const char *)qword_6FE00;
  else
    v77 = (char *)&word_6FDF0 + 1;
  v134 = dword_6FDE8;
  v136 = 0LL;
  v137 = 0LL;
  v135 = 0LL;
  v78 = strlen(v77);
  if ( v78 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v79 = v78;
  if ( v78 >= 0x17 )
  {
    v81 = (v78 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v80 = (char *)operator new(v81);
    v136 = v79;
    v137 = v80;
    v135 = v81 | 1;
    goto LABEL_85;
  }
  v80 = (char *)&v135 + 1;
  LOBYTE(v135) = 2 * v78;
  if ( v78 )
LABEL_85:
    memcpy(v80, v77, v79);
  v80[v79] = 0;
  if ( (g3::logLevel(&v134) & 1) == 0 )
  {
    v82 = 0;
    if ( (v135 & 1) != 0 )
      goto LABEL_92;
    goto LABEL_89;
  }
  *(_QWORD *)&v132[7] = 0LL;
  v133 = 0LL;
  v131 = 12;
  strcpy(v132, "region");
  v82 = g3::logTag(&v131);
  if ( (v131 & 1) != 0 )
  {
    operator delete(v133);
    if ( (v135 & 1) != 0 )
      goto LABEL_92;
LABEL_89:
    if ( (v82 & 1) == 0 )
      goto LABEL_94;
    goto LABEL_93;
  }
  if ( (v135 & 1) == 0 )
    goto LABEL_89;
LABEL_92:
  operator delete(v137);
  if ( (v82 & 1) != 0 )
  {
LABEL_93:
    LogCapture::LogCapture((LogCapture *)&v165, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v165, "relocate data index!");
    LogCapture::~LogCapture((LogCapture *)&v165);
  }
LABEL_94:
  gettimeofday(&tv, 0LL);
  v169[0] = (__int64)off_6E1D0;
  v165 = (unsigned __int64)off_6E1A8;
  std::ios_base::init((std::ios_base *)v169, v166);
  v169[17] = 0LL;
  v170 = -1;
  *(_QWORD *)&v165 = off_6E158;
  v169[0] = (__int64)off_6E180;
  std::filebuf::basic_filebuf((__int64)v166);
  if ( v167 || (v167 = fopen("/sdcard/pudu/picture/record.txt", "r")) == 0LL )
    std::ios_base::clear(
      (std::ios_base *)((char *)&v166[-2] + *(_QWORD *)(v165 - 24)),
      *(_DWORD *)((char *)&v166[2] + *(_QWORD *)(v165 - 24)) | 4);
  else
    v168 = 8;
  v89 = v165;
  if ( (*((_BYTE *)&v166[2] + *(_QWORD *)(v165 - 24)) & 5) != 0 )
  {
    v90 = (int *)(a1 + 3064);
    v91 = (_DWORD *)(a1 + 3068);
    *(_QWORD *)(a1 + 3064) = 0LL;
  }
  else
  {
    v162.n64_u64[0] = 0LL;
    v163 = 0LL;
    v164 = 0LL;
    for ( i = 0; ; ++i )
    {
      std::ios_base::getloc(&v161, (std::ios_base *)((char *)&v166[-2] + *(_QWORD *)(v89 - 24)));
      v94 = std::locale::use_facet(&v161, &std::ctype<char>::id);
      v95 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v94 + 56LL))(v94, 10LL);
      std::locale::~locale((std::locale *)&v161);
      v96 = std::getline<char,std::char_traits<char>,std::allocator<char>>((__int64 *)&v165, (__int64)&v162, v95);
      if ( (*((_BYTE *)v96 + *(_QWORD *)(*v96 - 24) + 32) & 5) != 0 )
      {
        v98 = 0;
        v99 = v167;
        if ( !v167 )
          goto LABEL_138;
        goto LABEL_131;
      }
      v97 = (v162.n64_u8[0] & 1) != 0 ? (const char *)v164 : (char *)v162.n64_u64 + 1;
      LODWORD(v161) = 0;
      sscanf(v97, "/sdcard/pudu/picture/ar_%d.png", &v161);
      if ( i != (_DWORD)v161 )
        break;
      *(_QWORD *)(a1 + 3080) = std::istream::tellg(&v165);
      *(_QWORD *)(a1 + 3088) = v93;
      v89 = v165;
    }
    v98 = 1;
    v99 = v167;
    if ( !v167 )
      goto LABEL_138;
LABEL_131:
    v102 = (*(__int64 (__fastcall **)(__int64 *))(v166[0] + 48))(v166);
    if ( fclose(v99) )
    {
      (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v166[0] + 24))(v166, 0LL, 0LL);
    }
    else
    {
      v167 = 0LL;
      (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v166[0] + 24))(v166, 0LL, 0LL);
      if ( !v102 )
        goto LABEL_139;
    }
LABEL_138:
    std::ios_base::clear(
      (std::ios_base *)((char *)&v166[-2] + *(_QWORD *)(v165 - 24)),
      *(_DWORD *)((char *)&v166[2] + *(_QWORD *)(v165 - 24)) | 4);
LABEL_139:
    *(_DWORD *)(a1 + 3064) = i;
    v90 = (int *)(a1 + 3064);
    if ( (v162.n64_u8[0] & 1) != 0 )
    {
      operator delete(v164);
      i = *v90;
    }
    v91 = (_DWORD *)(a1 + 3068);
    *(_DWORD *)(a1 + 3068) = i;
    if ( v98 )
      *v90 = 25000;
  }
  gettimeofday(&v129, 0LL);
  v103 = v129.tv_sec;
  tv_usec = v129.tv_usec;
  v105 = tv.tv_sec;
  v106 = tv.tv_usec;
  v125 = dword_6FDE8;
  if ( (word_6FDF0 & 1) != 0 )
    v107 = (const char *)qword_6FE00;
  else
    v107 = (char *)&word_6FDF0 + 1;
  v127 = 0LL;
  v128 = 0LL;
  v126 = 0LL;
  v108 = strlen(v107);
  if ( v108 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v109 = v108;
  if ( v108 >= 0x17 )
  {
    v111 = v91;
    v112 = (v108 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v110 = (char *)operator new(v112);
    v127 = v109;
    v128 = v110;
    v126 = v112 | 1;
    v91 = v111;
    goto LABEL_151;
  }
  v110 = (char *)&v126 + 1;
  LOBYTE(v126) = 2 * v108;
  if ( v108 )
LABEL_151:
    memcpy(v110, v107, v109);
  v110[v109] = 0;
  if ( (g3::logLevel(&v125) & 1) == 0 )
  {
    v113 = 0;
    if ( (v126 & 1) != 0 )
      goto LABEL_158;
    goto LABEL_155;
  }
  v123 = 30;
  strcpy(v124, "feasibal_region");
  v124[16] = 0;
  *(_WORD *)&v124[17] = 0;
  *(_DWORD *)&v124[19] = 0;
  v113 = g3::logTag(&v123);
  if ( (v123 & 1) != 0 )
  {
    operator delete(*(void **)&v124[15]);
    if ( (v126 & 1) != 0 )
      goto LABEL_158;
LABEL_155:
    if ( (v113 & 1) == 0 )
      goto LABEL_160;
    goto LABEL_159;
  }
  if ( (v126 & 1) == 0 )
    goto LABEL_155;
LABEL_158:
  operator delete(v128);
  if ( (v113 & 1) != 0 )
  {
LABEL_159:
    LogCapture::LogCapture((LogCapture *)&v162, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    v114 = (double)(v103 - v105) * 1000.0 + (double)(tv_usec - v106) / 1000.0;
    LogCapture::capturef((LogCapture *)&v162, "%s:%3fms\n", "data record init:", v114);
    LogCapture::~LogCapture((LogCapture *)&v162);
  }
LABEL_160:
  strcpy((char *)v122, "*/sdcard/pudu/picture/");
  HIBYTE(v122[2]) = 0;
  DirectorySize = feasibal_region::getDirectorySize((__int64)v122);
  if ( ((__int64)v122[0] & 1) != 0 )
    operator delete(v122[2]);
  if ( DirectorySize >= 1074790400 )
  {
    *v91 = 0;
    *v90 = 25000;
  }
  *(_QWORD *)&v165 = off_6E158;
  v169[0] = (__int64)off_6E180;
  std::filebuf::~filebuf((__int64)v166);
  std::ios_base::~ios_base((std::ios_base *)v169);
LABEL_165:
  if ( v186 )
  {
    v116 = (unsigned int *)(v186 + 20);
    do
    {
      v117 = __ldaxr(v116);
      v118 = v117 - 1;
    }
    while ( __stlxr(v118, v116) );
    if ( !v118 )
      cv::Mat::deallocate((cv::Mat *)&v182);
  }
  v186 = 0LL;
  v183 = 0u;
  v184 = 0u;
  if ( SDWORD1(v182) >= 1 )
  {
    v119 = v187;
    v120 = 0LL;
    do
      *(_DWORD *)(v119 + 4 * v120++) = 0;
    while ( v120 < SDWORD1(v182) );
  }
  if ( v188 != (cv *)&v189 )
    cv::fastFree(v188, v48);
  return 0LL;
}
// 2985C: conditional instruction was optimized away because %var_E0@4.4>=3
// 29BA4: variable 'v48' is possibly undefined
// 2A02C: variable 'v93' is possibly undefined
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 132B0: using guessed type _QWORD *__fastcall cv::imread(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 13940: using guessed type __int64 __fastcall cv::resize(_QWORD, _QWORD, _QWORD, _QWORD, double, double);
// 6E158: using guessed type __int64 (__fastcall *[2])();
// 6E180: using guessed type __int64 (__fastcall *[2])();
// 6E1A8: using guessed type __int64 (__fastcall *[2])();
// 6E1D0: using guessed type __int64 (__fastcall *[2])();
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;
// 29568: using guessed type __int128 var_490;

//----- (000000000002A940) ----------------------------------------------------
__int64 __fastcall feasibal_region::PreParamInfo::operator=(__int64 a1, __int128 *a2)
{
  __int128 v2; // q1
  int v5; // w9
  __int64 v6; // x9
  __int64 v7; // x8
  unsigned int *v8; // x8
  unsigned int v9; // w9
  __int64 v10; // x8
  _DWORD *v11; // x21
  unsigned int *v12; // x8
  unsigned int v13; // w9
  unsigned int v14; // w9
  int v15; // w8
  const cv::Mat *v16; // x1
  __int64 v17; // x8
  __int64 v18; // x9
  __int64 v19; // x10
  int v20; // w8
  _QWORD *v21; // x10
  _QWORD *v22; // x8
  __int64 v23; // x8
  unsigned int *v24; // x8
  unsigned int v25; // w9
  __int64 v26; // x8
  _DWORD *v27; // x21
  unsigned int *v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w9
  int v31; // w8
  const cv::Mat *v32; // x1
  __int64 v33; // x8
  __int64 v34; // x9
  __int64 v35; // x10
  int v36; // w8
  _QWORD *v37; // x10
  _QWORD *v38; // x8
  unsigned __int64 v39; // x9
  void *v40; // x1
  size_t v41; // x2
  __int64 result; // x0

  v2 = *a2;
  *(_OWORD *)(a1 + 12) = *(__int128 *)((char *)a2 + 12);
  *(_OWORD *)a1 = v2;
  *(_DWORD *)(a1 + 28) = *((_DWORD *)a2 + 7);
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 9);
  v5 = *((_DWORD *)a2 + 10);
  *(_BYTE *)(a1 + 44) = *((_BYTE *)a2 + 44);
  *(_DWORD *)(a1 + 40) = v5;
  *(_DWORD *)(a1 + 48) = *((_DWORD *)a2 + 12);
  *(_DWORD *)(a1 + 52) = *((_DWORD *)a2 + 13);
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 14);
  *(_DWORD *)(a1 + 60) = *((_DWORD *)a2 + 15);
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a2 + 16);
  *(_DWORD *)(a1 + 68) = *((_DWORD *)a2 + 17);
  *(_DWORD *)(a1 + 72) = *((_DWORD *)a2 + 18);
  *(_DWORD *)(a1 + 76) = *((_DWORD *)a2 + 19);
  *(_DWORD *)(a1 + 80) = *((_DWORD *)a2 + 20);
  *(_DWORD *)(a1 + 84) = *((_DWORD *)a2 + 21);
  *(_DWORD *)(a1 + 88) = *((_DWORD *)a2 + 22);
  *(_DWORD *)(a1 + 92) = *((_DWORD *)a2 + 23);
  *(_DWORD *)(a1 + 96) = *((_DWORD *)a2 + 24);
  *(_DWORD *)(a1 + 100) = *((_DWORD *)a2 + 25);
  *(_DWORD *)(a1 + 104) = *((_DWORD *)a2 + 26);
  *(_DWORD *)(a1 + 108) = *((_DWORD *)a2 + 27);
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  *(_DWORD *)(a1 + 116) = *((_DWORD *)a2 + 29);
  *(_DWORD *)(a1 + 120) = *((_DWORD *)a2 + 30);
  *(_DWORD *)(a1 + 124) = *((_DWORD *)a2 + 31);
  *(_DWORD *)(a1 + 128) = *((_DWORD *)a2 + 32);
  *(_DWORD *)(a1 + 132) = *((_DWORD *)a2 + 33);
  *(_DWORD *)(a1 + 136) = *((_DWORD *)a2 + 34);
  *(_DWORD *)(a1 + 140) = *((_DWORD *)a2 + 35);
  *(_DWORD *)(a1 + 144) = *((_DWORD *)a2 + 36);
  *(_DWORD *)(a1 + 148) = *((_DWORD *)a2 + 37);
  *(_DWORD *)(a1 + 152) = *((_DWORD *)a2 + 38);
  *(_DWORD *)(a1 + 156) = *((_DWORD *)a2 + 39);
  *(_DWORD *)(a1 + 160) = *((_DWORD *)a2 + 40);
  *(_DWORD *)(a1 + 164) = *((_DWORD *)a2 + 41);
  *(_DWORD *)(a1 + 168) = *((_DWORD *)a2 + 42);
  *(_DWORD *)(a1 + 172) = *((_DWORD *)a2 + 43);
  *(_DWORD *)(a1 + 176) = *((_DWORD *)a2 + 44);
  *(_DWORD *)(a1 + 180) = *((_DWORD *)a2 + 45);
  *(_DWORD *)(a1 + 184) = *((_DWORD *)a2 + 46);
  *(_DWORD *)(a1 + 188) = *((_DWORD *)a2 + 47);
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  *(_DWORD *)(a1 + 196) = *((_DWORD *)a2 + 49);
  *(_DWORD *)(a1 + 200) = *((_DWORD *)a2 + 50);
  *(_DWORD *)(a1 + 204) = *((_DWORD *)a2 + 51);
  *(_DWORD *)(a1 + 208) = *((_DWORD *)a2 + 52);
  *(_DWORD *)(a1 + 212) = *((_DWORD *)a2 + 53);
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a2 + 54);
  *(_DWORD *)(a1 + 220) = *((_DWORD *)a2 + 55);
  *(_DWORD *)(a1 + 224) = *((_DWORD *)a2 + 56);
  *(_DWORD *)(a1 + 228) = *((_DWORD *)a2 + 57);
  *(_DWORD *)(a1 + 232) = *((_DWORD *)a2 + 58);
  *(_DWORD *)(a1 + 236) = *((_DWORD *)a2 + 59);
  *(_DWORD *)(a1 + 240) = *((_DWORD *)a2 + 60);
  *(_DWORD *)(a1 + 244) = *((_DWORD *)a2 + 61);
  *(_DWORD *)(a1 + 248) = *((_DWORD *)a2 + 62);
  *(_DWORD *)(a1 + 252) = *((_DWORD *)a2 + 63);
  *(_DWORD *)(a1 + 256) = *((_DWORD *)a2 + 64);
  v6 = *(_QWORD *)((char *)a2 + 260);
  *(_DWORD *)(a1 + 268) = *((_DWORD *)a2 + 67);
  *(_QWORD *)(a1 + 260) = v6;
  if ( (__int128 *)a1 == a2 )
    goto LABEL_45;
  v7 = *((_QWORD *)a2 + 41);
  if ( v7 )
  {
    v8 = (unsigned int *)(v7 + 20);
    do
      v9 = __ldaxr(v8);
    while ( __stlxr(v9 + 1, v8) );
  }
  v10 = *(_QWORD *)(a1 + 328);
  v11 = (_DWORD *)(a1 + 272);
  if ( v10 )
  {
    v12 = (unsigned int *)(v10 + 20);
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while ( __stlxr(v14, v12) );
    if ( !v14 )
      cv::Mat::deallocate((cv::Mat *)(a1 + 272));
  }
  v15 = *(_DWORD *)(a1 + 276);
  v16 = (const cv::Mat *)(a2 + 17);
  *(_QWORD *)(a1 + 328) = 0LL;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  if ( v15 <= 0 )
  {
    *v11 = *(_DWORD *)v16;
  }
  else
  {
    v17 = *(_QWORD *)(a1 + 336);
    v18 = 0LL;
    do
    {
      *(_DWORD *)(v17 + 4 * v18) = 0;
      v19 = *(int *)(a1 + 276);
      ++v18;
    }
    while ( v18 < v19 );
    *v11 = *(_DWORD *)v16;
    if ( (int)v19 > 2 )
      goto LABEL_18;
  }
  v20 = *((_DWORD *)a2 + 69);
  if ( v20 <= 2 )
  {
    *(_DWORD *)(a1 + 276) = v20;
    v21 = *(_QWORD **)(a1 + 344);
    *(_QWORD *)(a1 + 280) = *((_QWORD *)a2 + 35);
    v22 = (_QWORD *)*((_QWORD *)a2 + 43);
    *v21 = *v22;
    v21[1] = v22[1];
    goto LABEL_19;
  }
LABEL_18:
  cv::Mat::copySize((cv::Mat *)(a1 + 272), v16);
LABEL_19:
  *(_OWORD *)(a1 + 288) = a2[18];
  *(_OWORD *)(a1 + 304) = a2[19];
  *(_OWORD *)(a1 + 320) = a2[20];
  if ( (__int128 *)a1 == a2 )
    goto LABEL_45;
  v23 = *((_QWORD *)a2 + 53);
  if ( v23 )
  {
    v24 = (unsigned int *)(v23 + 20);
    do
      v25 = __ldaxr(v24);
    while ( __stlxr(v25 + 1, v24) );
  }
  v26 = *(_QWORD *)(a1 + 424);
  v27 = (_DWORD *)(a1 + 368);
  if ( v26 )
  {
    v28 = (unsigned int *)(v26 + 20);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while ( __stlxr(v30, v28) );
    if ( !v30 )
      cv::Mat::deallocate((cv::Mat *)(a1 + 368));
  }
  v31 = *(_DWORD *)(a1 + 372);
  v32 = (const cv::Mat *)(a2 + 23);
  *(_QWORD *)(a1 + 424) = 0LL;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  if ( v31 <= 0 )
  {
    *v27 = *(_DWORD *)v32;
  }
  else
  {
    v33 = *(_QWORD *)(a1 + 432);
    v34 = 0LL;
    do
    {
      *(_DWORD *)(v33 + 4 * v34) = 0;
      v35 = *(int *)(a1 + 372);
      ++v34;
    }
    while ( v34 < v35 );
    *v27 = *(_DWORD *)v32;
    if ( (int)v35 > 2 )
      goto LABEL_36;
  }
  v36 = *((_DWORD *)a2 + 93);
  if ( v36 <= 2 )
  {
    *(_DWORD *)(a1 + 372) = v36;
    v37 = *(_QWORD **)(a1 + 440);
    *(_QWORD *)(a1 + 376) = *((_QWORD *)a2 + 47);
    v38 = (_QWORD *)*((_QWORD *)a2 + 55);
    *v37 = *v38;
    v37[1] = v38[1];
    goto LABEL_37;
  }
LABEL_36:
  cv::Mat::copySize((cv::Mat *)(a1 + 368), v32);
LABEL_37:
  *(_OWORD *)(a1 + 384) = a2[24];
  *(_OWORD *)(a1 + 400) = a2[25];
  *(_OWORD *)(a1 + 416) = a2[26];
  if ( (__int128 *)a1 != a2 )
  {
    v39 = *((unsigned __int8 *)a2 + 464);
    if ( (v39 & 1) != 0 )
      v40 = (void *)*((_QWORD *)a2 + 60);
    else
      v40 = (char *)a2 + 465;
    if ( (v39 & 1) != 0 )
      v41 = *((_QWORD *)a2 + 59);
    else
      v41 = v39 >> 1;
    std::string::assign((__int64 *)(a1 + 464), v40, v41);
  }
LABEL_45:
  result = a1;
  *(_QWORD *)(a1 + 488) = *((_QWORD *)a2 + 61);
  return result;
}

//----- (000000000002AD88) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::init_data_pre(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 v5; // x9
  void *v6; // d0
  __int128 v7; // q1
  __int64 v8; // x9
  __int64 v9; // x8
  __int64 v10; // x9
  void *v11; // d0
  __int128 v12; // q1
  __int64 v13; // x9
  __int64 v14; // x8
  void *v15; // x1
  __int64 v16; // x8
  unsigned int *v17; // x8
  unsigned int v18; // w9
  unsigned int v19; // w9
  __int64 v20; // x8
  __int64 v21; // x9
  int v22; // v0.s[1]
  __int128 v23; // q1
  cv *v24; // x0
  int v25; // w8
  unsigned int *v26; // x8
  unsigned int v27; // w9
  unsigned int v28; // w9
  cv *v29; // x9
  cv *v30; // x8
  __int64 v31; // x9
  __int64 v32; // x8
  void *v33; // x1
  __int64 v34; // x8
  unsigned int *v35; // x8
  unsigned int v36; // w9
  unsigned int v37; // w9
  __int64 v38; // x9
  __int64 v39; // x10
  int v40; // v0.s[1]
  __int128 v41; // q1
  cv *v42; // x0
  int v43; // w8
  unsigned int *v44; // x8
  unsigned int v45; // w9
  unsigned int v46; // w9
  cv *v47; // x9
  cv *v48; // x8
  __int64 v49; // x9
  __int64 v50; // x8
  void *v51; // x1
  _BYTE *v52; // x22
  __int64 v53; // x8
  unsigned int *v54; // x8
  unsigned int v55; // w9
  unsigned int v56; // w9
  __int64 v57; // x9
  __int64 v58; // x10
  int v59; // v0.s[1]
  __int128 v60; // q1
  cv *v61; // x0
  int v62; // w8
  unsigned int *v63; // x8
  unsigned int v64; // w9
  unsigned int v65; // w9
  cv *v66; // x9
  cv *v67; // x8
  __int64 v68; // x9
  __int64 v69; // x8
  void *v70; // x1
  int v71; // w3
  __int64 v72; // x8
  unsigned int *v73; // x8
  unsigned int v74; // w9
  unsigned int v75; // w9
  __int64 v76; // x8
  __int64 v77; // x9
  int v78; // v0.s[1]
  __int128 v79; // q1
  cv *v80; // x0
  int v81; // w8
  unsigned int *v82; // x8
  unsigned int v83; // w9
  unsigned int v84; // w9
  cv *v85; // x9
  cv *v86; // x8
  __int64 v87; // x9
  _BYTE *v88; // x22
  _BYTE *v89; // x23
  _BYTE *v90; // x20
  void *v91; // x1
  __int64 v92; // x9
  unsigned __int64 v93; // x8
  __int64 i; // x10
  int v95; // w14
  __int64 v96; // x13
  float v97; // s1
  __int64 v98; // x16
  __int64 v99; // x9
  __int64 v100; // x10
  int v101; // w16
  __int64 v102; // x12
  unsigned __int64 v103; // x13
  unsigned __int64 v104; // x15
  unsigned __int64 v105; // x9
  unsigned __int64 v106; // x10
  int v107; // w14
  __int64 v108; // x9
  unsigned __int64 v109; // x12
  unsigned __int64 v110; // x15
  __int64 v111; // x10
  __int64 v112; // x13
  __int64 v113; // x11
  __int64 v114; // x12
  int64x2_t v115; // q1
  _QWORD *v116; // x13
  __int64 v117; // x14
  int64x2_t v118; // q0
  __int64 v119; // d2
  __int64 v120; // x14
  int *v121; // x11
  __int64 v122; // t1
  void *v123; // x1
  void *v124; // x1
  unsigned __int64 v125; // x10
  __int64 v126; // x9
  unsigned __int64 v127; // x12
  int v128; // w9
  int v129; // w8
  int v130; // w11
  __int64 v131; // x9
  int v132; // w12
  __int64 v133; // x8
  int v134; // w10
  __int64 v135; // x11
  int v136; // w13
  int v137; // w14
  __int64 v138; // x15
  void *v139; // x1
  __int64 v140; // x8
  unsigned int *v141; // x8
  unsigned int v142; // w9
  unsigned int v143; // w9
  __int64 v144; // x8
  __int64 v145; // x9
  int v146; // v0.s[1]
  __int128 v147; // q1
  cv *v148; // x0
  int v149; // w8
  unsigned int *v150; // x8
  unsigned int v151; // w9
  unsigned int v152; // w9
  cv *v153; // x9
  cv *v154; // x8
  __int64 v155; // x9
  __int64 v156; // x8
  void *v157; // x1
  __int64 v158; // x8
  unsigned int *v159; // x8
  unsigned int v160; // w9
  unsigned int v161; // w9
  __int64 v162; // x9
  __int64 v163; // x10
  int v164; // v0.s[1]
  __int128 v165; // q1
  cv *v166; // x0
  int v167; // w8
  unsigned int *v168; // x8
  unsigned int v169; // w9
  unsigned int v170; // w9
  cv *v171; // x9
  cv *v172; // x8
  __int64 v173; // x9
  __int64 v174; // x8
  void *v175; // x1
  __int64 v176; // x8
  unsigned int *v177; // x8
  unsigned int v178; // w9
  unsigned int v179; // w9
  __int64 v180; // x8
  __int64 v181; // x9
  int v182; // v0.s[1]
  __int128 v183; // q1
  cv *v184; // x0
  int v185; // w8
  unsigned int *v186; // x8
  unsigned int v187; // w9
  unsigned int v188; // w9
  cv *v189; // x9
  cv *v190; // x8
  __int64 v191; // x9
  __int64 v192; // x8
  void *v193; // x1
  __int64 v194; // x8
  unsigned int *v195; // x8
  unsigned int v196; // w9
  unsigned int v197; // w9
  __int64 v198; // x8
  __int64 v199; // x9
  int v200; // v0.s[1]
  __int128 v201; // q1
  cv *v202; // x0
  int v203; // w8
  unsigned int *v204; // x8
  unsigned int v205; // w9
  unsigned int v206; // w9
  cv *v207; // x9
  cv *v208; // x8
  __int64 v209; // x9
  __int64 v210; // x8
  void *v211; // x1
  __int64 v212; // x8
  unsigned int *v213; // x8
  unsigned int v214; // w9
  unsigned int v215; // w9
  __int64 v216; // x8
  __int64 v217; // x9
  int v218; // v0.s[1]
  __int128 v219; // q1
  cv *v220; // x0
  int v221; // w8
  unsigned int *v222; // x8
  unsigned int v223; // w9
  unsigned int v224; // w9
  cv *v225; // x9
  cv *v226; // x8
  __int64 v227; // x9
  __int64 v228; // x8
  void *v229; // x1
  __int64 v230; // x8
  unsigned int *v231; // x8
  unsigned int v232; // w9
  unsigned int v233; // w9
  __int64 v234; // x8
  __int64 v235; // x9
  int v236; // v0.s[1]
  __int128 v237; // q1
  cv *v238; // x0
  int v239; // w8
  unsigned int *v240; // x8
  unsigned int v241; // w9
  unsigned int v242; // w9
  cv *v243; // x9
  cv *v244; // x8
  __int64 v245; // x9
  int v246; // w21
  int v247; // w0
  int v248; // w0
  __int64 v249; // x8
  int v251[2]; // [xsp+0h] [xbp-1E0h] BYREF
  int v252[2]; // [xsp+8h] [xbp-1D8h] BYREF
  __int64 v253; // [xsp+10h] [xbp-1D0h]
  __int64 v254; // [xsp+18h] [xbp-1C8h]
  _BYTE ptr[64]; // [xsp+20h] [xbp-1C0h] BYREF
  cv *v256[2]; // [xsp+60h] [xbp-180h]
  __int64 v257; // [xsp+70h] [xbp-170h] BYREF
  __int64 v258; // [xsp+78h] [xbp-168h]
  __int64 v259; // [xsp+180h] [xbp-60h]

  v259 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(int *)(a1 + 524);
  v5 = *(int *)(a1 + 520);
  memset(ptr, 0, 24);
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize((__int64)ptr, v5 * v4, 3LL);
  v7 = *(_OWORD *)ptr;
  *(_OWORD *)ptr = *(_OWORD *)(a1 + 536);
  v6 = *(void **)ptr;
  *(_OWORD *)(a1 + 536) = v7;
  v8 = *(_QWORD *)&ptr[16];
  *(_QWORD *)&ptr[16] = *(_QWORD *)(a1 + 552);
  *(_QWORD *)(a1 + 552) = v8;
  free(v6);
  v9 = *(int *)(a1 + 524);
  v10 = *(int *)(a1 + 520);
  memset(ptr, 0, 24);
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize((__int64)ptr, v10 * v9, 3LL);
  v12 = *(_OWORD *)ptr;
  *(_OWORD *)ptr = *(_OWORD *)(a1 + 560);
  v11 = *(void **)ptr;
  *(_OWORD *)(a1 + 560) = v12;
  v13 = *(_QWORD *)&ptr[16];
  *(_QWORD *)&ptr[16] = *(_QWORD *)(a1 + 576);
  *(_QWORD *)(a1 + 576) = v13;
  free(v11);
  v14 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v14;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 4);
  if ( (_BYTE *)(a1 + 584) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v26 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v27 = __ldaxr(v26);
        v28 = v27 - 1;
      }
      while ( __stlxr(v28, v26) );
      if ( !v28 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 640);
    if ( v16 )
    {
      v17 = (unsigned int *)(v16 + 20);
      do
      {
        v18 = __ldaxr(v17);
        v19 = v18 - 1;
      }
      while ( __stlxr(v19, v17) );
      if ( !v19 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 584));
    }
    *(_QWORD *)(a1 + 640) = 0LL;
    *(_OWORD *)(a1 + 600) = 0u;
    *(_OWORD *)(a1 + 616) = 0u;
    if ( *(int *)(a1 + 588) >= 1 )
    {
      v20 = *(_QWORD *)(a1 + 648);
      v21 = 0LL;
      do
        *(_DWORD *)(v20 + 4 * v21++) = 0;
      while ( v21 < *(int *)(a1 + 588) );
    }
    v22 = *(_DWORD *)&ptr[4];
    v23 = *(_OWORD *)&ptr[16];
    *(_OWORD *)(a1 + 584) = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 600) = v23;
    *(_OWORD *)(a1 + 616) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 632) = *(_OWORD *)&ptr[48];
    v24 = *(cv **)(a1 + 656);
    if ( v24 == (cv *)(a1 + 664) )
    {
      v25 = v22;
    }
    else
    {
      cv::fastFree(v24, v15);
      *(_QWORD *)(a1 + 656) = a1 + 664;
      *(_QWORD *)(a1 + 648) = a1 + 592;
      v25 = *(_DWORD *)&ptr[4];
      v24 = (cv *)(a1 + 664);
    }
    if ( v25 <= 2 )
    {
      v29 = v256[1];
      *(_QWORD *)v24 = *(_QWORD *)v256[1];
      *((_QWORD *)v24 + 1) = *((_QWORD *)v29 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 648) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v30 = v256[0];
    v31 = 0LL;
    do
      *((_DWORD *)v30 + v31++) = 0;
    while ( v31 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v15);
  v32 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v32;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( (_BYTE *)(a1 + 680) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v44 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v45 = __ldaxr(v44);
        v46 = v45 - 1;
      }
      while ( __stlxr(v46, v44) );
      if ( !v46 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v34 = *(_QWORD *)(a1 + 736);
    if ( v34 )
    {
      v35 = (unsigned int *)(v34 + 20);
      do
      {
        v36 = __ldaxr(v35);
        v37 = v36 - 1;
      }
      while ( __stlxr(v37, v35) );
      if ( !v37 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 680));
    }
    *(_QWORD *)(a1 + 736) = 0LL;
    *(_OWORD *)(a1 + 696) = 0u;
    *(_OWORD *)(a1 + 712) = 0u;
    if ( *(int *)(a1 + 684) >= 1 )
    {
      v38 = *(_QWORD *)(a1 + 744);
      v39 = 0LL;
      do
        *(_DWORD *)(v38 + 4 * v39++) = 0;
      while ( v39 < *(int *)(a1 + 684) );
    }
    v40 = *(_DWORD *)&ptr[4];
    v41 = *(_OWORD *)&ptr[16];
    *(_OWORD *)(a1 + 680) = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 696) = v41;
    *(_OWORD *)(a1 + 712) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 728) = *(_OWORD *)&ptr[48];
    v42 = *(cv **)(a1 + 752);
    if ( v42 == (cv *)(a1 + 760) )
    {
      v43 = v40;
    }
    else
    {
      cv::fastFree(v42, v33);
      *(_QWORD *)(a1 + 752) = a1 + 760;
      *(_QWORD *)(a1 + 744) = a1 + 688;
      v43 = *(_DWORD *)&ptr[4];
      v42 = (cv *)(a1 + 760);
    }
    if ( v43 <= 2 )
    {
      v47 = v256[1];
      *(_QWORD *)v42 = *(_QWORD *)v256[1];
      *((_QWORD *)v42 + 1) = *((_QWORD *)v47 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 744) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v48 = v256[0];
    v49 = 0LL;
    do
      *((_DWORD *)v48 + v49++) = 0;
    while ( v49 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v33);
  v50 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v50;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  v52 = (_BYTE *)(a1 + 776);
  if ( (_BYTE *)(a1 + 776) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v63 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v64 = __ldaxr(v63);
        v65 = v64 - 1;
      }
      while ( __stlxr(v65, v63) );
      if ( !v65 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v53 = *(_QWORD *)(a1 + 832);
    if ( v53 )
    {
      v54 = (unsigned int *)(v53 + 20);
      do
      {
        v55 = __ldaxr(v54);
        v56 = v55 - 1;
      }
      while ( __stlxr(v56, v54) );
      if ( !v56 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 776));
    }
    *(_QWORD *)(a1 + 832) = 0LL;
    *(_OWORD *)(a1 + 792) = 0u;
    *(_OWORD *)(a1 + 808) = 0u;
    if ( *(int *)(a1 + 780) >= 1 )
    {
      v57 = *(_QWORD *)(a1 + 840);
      v58 = 0LL;
      do
        *(_DWORD *)(v57 + 4 * v58++) = 0;
      while ( v58 < *(int *)(a1 + 780) );
    }
    v59 = *(_DWORD *)&ptr[4];
    v60 = *(_OWORD *)&ptr[16];
    *(_OWORD *)v52 = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 792) = v60;
    *(_OWORD *)(a1 + 808) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 824) = *(_OWORD *)&ptr[48];
    v61 = *(cv **)(a1 + 848);
    if ( v61 == (cv *)(a1 + 856) )
    {
      v62 = v59;
    }
    else
    {
      cv::fastFree(v61, v51);
      *(_QWORD *)(a1 + 848) = a1 + 856;
      *(_QWORD *)(a1 + 840) = a1 + 784;
      v62 = *(_DWORD *)&ptr[4];
      v61 = (cv *)(a1 + 856);
    }
    if ( v62 <= 2 )
    {
      v66 = v256[1];
      *(_QWORD *)v61 = *(_QWORD *)v256[1];
      *((_QWORD *)v61 + 1) = *((_QWORD *)v66 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 840) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v67 = v256[0];
    v68 = 0LL;
    do
      *((_DWORD *)v67 + v68++) = 0;
    while ( v68 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v51);
  v69 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v69;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( v52 == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v82 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v83 = __ldaxr(v82);
        v84 = v83 - 1;
      }
      while ( __stlxr(v84, v82) );
      if ( !v84 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v72 = *(_QWORD *)(a1 + 832);
    if ( v72 )
    {
      v73 = (unsigned int *)(v72 + 20);
      do
      {
        v74 = __ldaxr(v73);
        v75 = v74 - 1;
      }
      while ( __stlxr(v75, v73) );
      if ( !v75 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 776));
    }
    *(_QWORD *)(a1 + 832) = 0LL;
    *(_OWORD *)(a1 + 792) = 0u;
    *(_OWORD *)(a1 + 808) = 0u;
    if ( *(int *)(a1 + 780) >= 1 )
    {
      v76 = *(_QWORD *)(a1 + 840);
      v77 = 0LL;
      do
        *(_DWORD *)(v76 + 4 * v77++) = 0;
      while ( v77 < *(int *)(a1 + 780) );
    }
    v78 = *(_DWORD *)&ptr[4];
    v79 = *(_OWORD *)&ptr[16];
    *(_OWORD *)v52 = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 792) = v79;
    *(_OWORD *)(a1 + 808) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 824) = *(_OWORD *)&ptr[48];
    v80 = *(cv **)(a1 + 848);
    if ( v80 == (cv *)(a1 + 856) )
    {
      v81 = v78;
    }
    else
    {
      cv::fastFree(v80, v70);
      *(_QWORD *)(a1 + 848) = a1 + 856;
      *(_QWORD *)(a1 + 840) = a1 + 784;
      v81 = *(_DWORD *)&ptr[4];
    }
    if ( v81 <= 2 )
    {
      v85 = v256[1];
      *(_QWORD *)(a1 + 856) = *(_QWORD *)v256[1];
      *(_QWORD *)(a1 + 864) = *((_QWORD *)v85 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 840) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v86 = v256[0];
    v87 = 0LL;
    do
      *((_DWORD *)v86 + v87++) = 0;
    while ( v87 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v70);
  cv::Mat::ones(ptr, (cv::Mat *)*(unsigned int *)(a1 + 520), *(_DWORD *)(a1 + 524), 0, v71);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int64, _QWORD))(**(_QWORD **)ptr + 24LL))(
    *(_QWORD *)ptr,
    ptr,
    a1 + 1064,
    0LL);
  v88 = (_BYTE *)(a1 + 1544);
  v89 = (_BYTE *)(a1 + 1256);
  v90 = (_BYTE *)(a1 + 872);
  cv::MatExpr::~MatExpr((cv::MatExpr *)ptr, v91);
  v92 = *(int *)(a1 + 520);
  LODWORD(v93) = *(_DWORD *)(a1 + 524);
  if ( (int)v92 >= 1 )
  {
    for ( i = 0LL; i < v92; ++i )
    {
      if ( (int)v93 >= 1 )
      {
        v95 = *(_DWORD *)(a1 + 20);
        v96 = 0LL;
        do
        {
          switch ( v95 )
          {
            case 0:
            case 2:
            case 3:
              v97 = -(float)((float)(int)v96 - *(float *)(a1 + 8));
              goto LABEL_112;
            case 1:
              v97 = (float)(int)v96 - *(float *)(a1 + 8);
LABEL_112:
              v98 = 4 * v96;
              *(float *)(*(_QWORD *)(a1 + 696) + i * **(_QWORD **)(a1 + 752) + v98) = v97 / *(float *)a1;
              *(float *)(*(_QWORD *)(a1 + 792) + i * **(_QWORD **)(a1 + 848) + v98) = (float)((float)(int)i
                                                                                            - *(float *)(a1 + 12))
                                                                                    / *(float *)(a1 + 4);
              break;
            default:
              break;
          }
          ++v96;
        }
        while ( v96 < (int)v93 );
      }
    }
  }
  v99 = 0LL;
  v100 = 50LL;
  v101 = v93;
  do
  {
    if ( v101 )
    {
      v102 = 0LL;
      v103 = 0LL;
      v104 = v101;
      do
      {
        if ( v99 + v103 < 0x32 || v100 + v103 > v104 )
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 1080) + **(_QWORD **)(a1 + 1136) * (int)v99 + (v102 >> 32)) = 0;
          LODWORD(v93) = *(_DWORD *)(a1 + 524);
        }
        ++v103;
        v104 = (int)v93;
        v102 += 0x100000000LL;
        v101 = v93;
      }
      while ( v103 < (int)v93 );
    }
    ++v99;
    --v100;
  }
  while ( v99 != 50 );
  LODWORD(v105) = *(_DWORD *)(a1 + 520);
  if ( (_DWORD)v105 )
  {
    v106 = 0LL;
    v107 = v93;
    do
    {
      if ( v107 )
      {
        v108 = 0LL;
        v109 = 0LL;
        do
        {
          v110 = 2LL * *(int *)(a1 + 528);
          if ( v109 < v110 || v109 > v107 - (int)v110 )
          {
            *(_BYTE *)(*(_QWORD *)(a1 + 1080) + **(_QWORD **)(a1 + 1136) * (int)v106 + (v108 >> 32)) = 0;
            LODWORD(v93) = *(_DWORD *)(a1 + 524);
          }
          ++v109;
          v108 += 0x100000000LL;
          v107 = v93;
        }
        while ( v109 < (int)v93 );
      }
      v105 = *(int *)(a1 + 520);
      ++v106;
    }
    while ( v106 < v105 );
  }
  if ( !*(_QWORD *)(a2 + 16) )
    goto LABEL_147;
  v111 = *(unsigned int *)(a2 + 4);
  if ( (int)v111 >= 3 )
  {
    v113 = *(_QWORD *)(a2 + 64);
    if ( (_DWORD)v111 == 3 )
    {
      v114 = 0LL;
      v112 = 1LL;
    }
    else
    {
      v114 = v111 & 0x7FFFFFFC;
      v115 = vdupq_n_s64(1uLL);
      v116 = (_QWORD *)(v113 + 8);
      v117 = (unsigned int)v111 & 0xFFFFFFFC;
      v118 = v115;
      do
      {
        v119 = *(v116 - 1);
        v115.n128_u64[0] *= (int)v119;
        v118.n128_u64[0] *= (int)*v116;
        v117 -= 4LL;
        v115.n128_u64[1] *= SHIDWORD(v119);
        v118.n128_u64[1] *= (int)HIDWORD(*v116);
        v116 += 2;
      }
      while ( v117 );
      v112 = v118.n128_u64[0] * v115.n128_u64[0] * v118.n128_u64[1] * v115.n128_u64[1];
      if ( v114 == v111 )
        goto LABEL_143;
    }
    v120 = v111 - v114;
    v121 = (int *)(v113 + 4 * v114);
    do
    {
      v122 = *v121++;
      --v120;
      v112 *= v122;
    }
    while ( v120 );
    goto LABEL_143;
  }
  v112 = *(int *)(a2 + 12) * (__int64)*(int *)(a2 + 8);
  if ( !(_DWORD)v111 )
  {
LABEL_147:
    v125 = (int)v105 - (__int64)*(int *)(a1 + 508);
    if ( (unsigned int)v125 < (unsigned int)v105 )
    {
      do
      {
        if ( (_DWORD)v93 )
        {
          v126 = 0LL;
          v127 = 0LL;
          do
          {
            ++v127;
            *(_BYTE *)(*(_QWORD *)(a1 + 1080) + **(_QWORD **)(a1 + 1136) * (int)v125 + (v126 >> 32)) = 0;
            v93 = *(int *)(a1 + 524);
            v126 += 0x100000000LL;
          }
          while ( v127 < v93 );
          LODWORD(v105) = *(_DWORD *)(a1 + 520);
        }
        ++v125;
      }
      while ( v125 < (int)v105 );
    }
    goto LABEL_153;
  }
LABEL_143:
  if ( !v112 )
    goto LABEL_147;
  if ( (*(_WORD *)a2 & 0xFF8) != 0 )
  {
    *(_QWORD *)&ptr[8] = a2;
    *(_QWORD *)&ptr[16] = 0LL;
    v253 = a2;
    v254 = 0LL;
    v252[0] = 33619968;
    *(_DWORD *)ptr = 16842752;
    cv::cvtColor(ptr, v252, 6LL, 0LL);
  }
  cv::operator>(ptr, a2, 0.0);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int64, __int64))(**(_QWORD **)ptr + 24LL))(
    *(_QWORD *)ptr,
    ptr,
    a2,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)ptr, v123);
  cv::operator&(ptr, a1 + 1064, a2);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int64, _QWORD))(**(_QWORD **)ptr + 24LL))(
    *(_QWORD *)ptr,
    ptr,
    a1 + 1064,
    0LL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)ptr, v124);
LABEL_153:
  *(_QWORD *)&ptr[8] = a1 + 1064;
  *(_QWORD *)&ptr[16] = 0LL;
  v252[0] = 33619968;
  *(_DWORD *)ptr = -2130640896;
  v253 = a1 + 1160;
  v254 = 0LL;
  v128 = *(_DWORD *)(a1 + 528);
  v129 = **(_DWORD **)(a1 + 1128) / v128;
  v251[0] = *(_DWORD *)(*(_QWORD *)(a1 + 1128) + 4LL) / v128;
  v251[1] = v129;
  cv::resize(ptr, v252, v251, 1LL, 0.0, 0.0);
  v130 = *(_DWORD *)(a1 + 520);
  LODWORD(v131) = *(_DWORD *)(a1 + 524);
  if ( v130 >= 1 )
  {
    v132 = *(_DWORD *)(a1 + 528);
    v133 = 0LL;
    v134 = (int)v131 / v132;
    if ( (int)v131 >= 1 )
      goto LABEL_157;
    while ( ++v133 < v130 )
    {
      v132 = *(_DWORD *)(a1 + 528);
      if ( (int)v131 >= 1 )
      {
LABEL_157:
        v135 = 0LL;
        v136 = (int)v133 % v132;
        v137 = v134 * ((int)v133 / v132);
        v138 = *(_QWORD *)(a1 + 600) + **(_QWORD **)(a1 + 656) * v133;
        while ( 1 )
        {
          *(_DWORD *)(v138 + 4 * v135) = v135 + v132 * (v136 + v132 * (v137 + (int)v135 / v132) - (int)v135 / v132);
          v131 = *(int *)(a1 + 524);
          if ( ++v135 >= v131 )
            break;
          v132 = *(_DWORD *)(a1 + 528);
        }
        v130 = *(_DWORD *)(a1 + 520);
      }
    }
  }
  *(_DWORD *)ptr = 1124007936;
  v252[0] = v130;
  v252[1] = v131;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( v89 == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v150 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v151 = __ldaxr(v150);
        v152 = v151 - 1;
      }
      while ( __stlxr(v152, v150) );
      if ( !v152 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v140 = *(_QWORD *)(a1 + 1312);
    if ( v140 )
    {
      v141 = (unsigned int *)(v140 + 20);
      do
      {
        v142 = __ldaxr(v141);
        v143 = v142 - 1;
      }
      while ( __stlxr(v143, v141) );
      if ( !v143 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 1256));
    }
    *(_QWORD *)(a1 + 1312) = 0LL;
    *(_OWORD *)(a1 + 1272) = 0u;
    *(_OWORD *)(a1 + 1288) = 0u;
    if ( *(int *)(a1 + 1260) >= 1 )
    {
      v144 = *(_QWORD *)(a1 + 1320);
      v145 = 0LL;
      do
        *(_DWORD *)(v144 + 4 * v145++) = 0;
      while ( v145 < *(int *)(a1 + 1260) );
    }
    v146 = *(_DWORD *)&ptr[4];
    v147 = *(_OWORD *)&ptr[16];
    *(_OWORD *)v89 = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 1272) = v147;
    *(_OWORD *)(a1 + 1288) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 1304) = *(_OWORD *)&ptr[48];
    v148 = *(cv **)(a1 + 1328);
    if ( v148 == (cv *)(a1 + 1336) )
    {
      v149 = v146;
    }
    else
    {
      cv::fastFree(v148, v139);
      *(_QWORD *)(a1 + 1328) = a1 + 1336;
      *(_QWORD *)(a1 + 1320) = a1 + 1264;
      v149 = *(_DWORD *)&ptr[4];
      v148 = (cv *)(a1 + 1336);
    }
    if ( v149 <= 2 )
    {
      v153 = v256[1];
      *(_QWORD *)v148 = *(_QWORD *)v256[1];
      *((_QWORD *)v148 + 1) = *((_QWORD *)v153 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 1320) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v154 = v256[0];
    v155 = 0LL;
    do
      *((_DWORD *)v154 + v155++) = 0;
    while ( v155 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v139);
  v156 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v156;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( (_BYTE *)(a1 + 1352) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v168 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v169 = __ldaxr(v168);
        v170 = v169 - 1;
      }
      while ( __stlxr(v170, v168) );
      if ( !v170 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v158 = *(_QWORD *)(a1 + 1408);
    if ( v158 )
    {
      v159 = (unsigned int *)(v158 + 20);
      do
      {
        v160 = __ldaxr(v159);
        v161 = v160 - 1;
      }
      while ( __stlxr(v161, v159) );
      if ( !v161 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 1352));
    }
    *(_QWORD *)(a1 + 1408) = 0LL;
    *(_OWORD *)(a1 + 1368) = 0u;
    *(_OWORD *)(a1 + 1384) = 0u;
    if ( *(int *)(a1 + 1356) >= 1 )
    {
      v162 = *(_QWORD *)(a1 + 1416);
      v163 = 0LL;
      do
        *(_DWORD *)(v162 + 4 * v163++) = 0;
      while ( v163 < *(int *)(a1 + 1356) );
    }
    v164 = *(_DWORD *)&ptr[4];
    v165 = *(_OWORD *)&ptr[16];
    *(_OWORD *)(a1 + 1352) = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 1368) = v165;
    *(_OWORD *)(a1 + 1384) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 1400) = *(_OWORD *)&ptr[48];
    v166 = *(cv **)(a1 + 1424);
    if ( v166 == (cv *)(a1 + 1432) )
    {
      v167 = v164;
    }
    else
    {
      cv::fastFree(v166, v157);
      *(_QWORD *)(a1 + 1424) = a1 + 1432;
      *(_QWORD *)(a1 + 1416) = a1 + 1360;
      v167 = *(_DWORD *)&ptr[4];
      v166 = (cv *)(a1 + 1432);
    }
    if ( v167 <= 2 )
    {
      v171 = v256[1];
      *(_QWORD *)v166 = *(_QWORD *)v256[1];
      *((_QWORD *)v166 + 1) = *((_QWORD *)v171 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 1416) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v172 = v256[0];
    v173 = 0LL;
    do
      *((_DWORD *)v172 + v173++) = 0;
    while ( v173 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v157);
  v174 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v174;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( (_BYTE *)(a1 + 1448) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v186 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v187 = __ldaxr(v186);
        v188 = v187 - 1;
      }
      while ( __stlxr(v188, v186) );
      if ( !v188 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v176 = *(_QWORD *)(a1 + 1504);
    if ( v176 )
    {
      v177 = (unsigned int *)(v176 + 20);
      do
      {
        v178 = __ldaxr(v177);
        v179 = v178 - 1;
      }
      while ( __stlxr(v179, v177) );
      if ( !v179 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 1448));
    }
    *(_QWORD *)(a1 + 1504) = 0LL;
    *(_OWORD *)(a1 + 1464) = 0u;
    *(_OWORD *)(a1 + 1480) = 0u;
    if ( *(int *)(a1 + 1452) >= 1 )
    {
      v180 = *(_QWORD *)(a1 + 1512);
      v181 = 0LL;
      do
        *(_DWORD *)(v180 + 4 * v181++) = 0;
      while ( v181 < *(int *)(a1 + 1452) );
    }
    v182 = *(_DWORD *)&ptr[4];
    v183 = *(_OWORD *)&ptr[16];
    *(_OWORD *)(a1 + 1448) = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 1464) = v183;
    *(_OWORD *)(a1 + 1480) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 1496) = *(_OWORD *)&ptr[48];
    v184 = *(cv **)(a1 + 1520);
    if ( v184 == (cv *)(a1 + 1528) )
    {
      v185 = v182;
    }
    else
    {
      cv::fastFree(v184, v175);
      *(_QWORD *)(a1 + 1520) = a1 + 1528;
      *(_QWORD *)(a1 + 1512) = a1 + 1456;
      v185 = *(_DWORD *)&ptr[4];
      v184 = (cv *)(a1 + 1528);
    }
    if ( v185 <= 2 )
    {
      v189 = v256[1];
      *(_QWORD *)v184 = *(_QWORD *)v256[1];
      *((_QWORD *)v184 + 1) = *((_QWORD *)v189 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 1512) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v190 = v256[0];
    v191 = 0LL;
    do
      *((_DWORD *)v190 + v191++) = 0;
    while ( v191 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v175);
  v192 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v192;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( v88 == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v204 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v205 = __ldaxr(v204);
        v206 = v205 - 1;
      }
      while ( __stlxr(v206, v204) );
      if ( !v206 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v194 = *(_QWORD *)(a1 + 1600);
    if ( v194 )
    {
      v195 = (unsigned int *)(v194 + 20);
      do
      {
        v196 = __ldaxr(v195);
        v197 = v196 - 1;
      }
      while ( __stlxr(v197, v195) );
      if ( !v197 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 1544));
    }
    *(_QWORD *)(a1 + 1600) = 0LL;
    *(_OWORD *)(a1 + 1560) = 0u;
    *(_OWORD *)(a1 + 1576) = 0u;
    if ( *(int *)(a1 + 1548) >= 1 )
    {
      v198 = *(_QWORD *)(a1 + 1608);
      v199 = 0LL;
      do
        *(_DWORD *)(v198 + 4 * v199++) = 0;
      while ( v199 < *(int *)(a1 + 1548) );
    }
    v200 = *(_DWORD *)&ptr[4];
    v201 = *(_OWORD *)&ptr[16];
    *(_OWORD *)v88 = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 1560) = v201;
    *(_OWORD *)(a1 + 1576) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 1592) = *(_OWORD *)&ptr[48];
    v202 = *(cv **)(a1 + 1616);
    if ( v202 == (cv *)(a1 + 1624) )
    {
      v203 = v200;
    }
    else
    {
      cv::fastFree(v202, v193);
      *(_QWORD *)(a1 + 1616) = a1 + 1624;
      *(_QWORD *)(a1 + 1608) = a1 + 1552;
      v203 = *(_DWORD *)&ptr[4];
      v202 = (cv *)(a1 + 1624);
    }
    if ( v203 <= 2 )
    {
      v207 = v256[1];
      *(_QWORD *)v202 = *(_QWORD *)v256[1];
      *((_QWORD *)v202 + 1) = *((_QWORD *)v207 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 1608) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v208 = v256[0];
    v209 = 0LL;
    do
      *((_DWORD *)v208 + v209++) = 0;
    while ( v209 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v193);
  v210 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v210;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( v90 == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v222 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v223 = __ldaxr(v222);
        v224 = v223 - 1;
      }
      while ( __stlxr(v224, v222) );
      if ( !v224 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v212 = *(_QWORD *)(a1 + 928);
    if ( v212 )
    {
      v213 = (unsigned int *)(v212 + 20);
      do
      {
        v214 = __ldaxr(v213);
        v215 = v214 - 1;
      }
      while ( __stlxr(v215, v213) );
      if ( !v215 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 872));
    }
    *(_QWORD *)(a1 + 928) = 0LL;
    *(_OWORD *)(a1 + 888) = 0u;
    *(_OWORD *)(a1 + 904) = 0u;
    if ( *(int *)(a1 + 876) >= 1 )
    {
      v216 = *(_QWORD *)(a1 + 936);
      v217 = 0LL;
      do
        *(_DWORD *)(v216 + 4 * v217++) = 0;
      while ( v217 < *(int *)(a1 + 876) );
    }
    v218 = *(_DWORD *)&ptr[4];
    v219 = *(_OWORD *)&ptr[16];
    *(_OWORD *)v90 = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 888) = v219;
    *(_OWORD *)(a1 + 904) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 920) = *(_OWORD *)&ptr[48];
    v220 = *(cv **)(a1 + 944);
    if ( v220 == (cv *)(a1 + 952) )
    {
      v221 = v218;
    }
    else
    {
      cv::fastFree(v220, v211);
      *(_QWORD *)(a1 + 944) = a1 + 952;
      *(_QWORD *)(a1 + 936) = a1 + 880;
      v221 = *(_DWORD *)&ptr[4];
      v220 = (cv *)(a1 + 952);
    }
    if ( v221 <= 2 )
    {
      v225 = v256[1];
      *(_QWORD *)v220 = *(_QWORD *)v256[1];
      *((_QWORD *)v220 + 1) = *((_QWORD *)v225 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 936) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v226 = v256[0];
    v227 = 0LL;
    do
      *((_DWORD *)v226 + v227++) = 0;
    while ( v227 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v211);
  v228 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)ptr = 1124007936;
  memset(&ptr[4], 0, 60);
  v256[0] = (cv *)&ptr[8];
  v256[1] = (cv *)&v257;
  v257 = 0LL;
  v258 = 0LL;
  *(_QWORD *)v252 = v228;
  cv::Mat::create((cv::Mat *)ptr, 2, v252, 5);
  if ( (_BYTE *)(a1 + 968) == ptr )
  {
    if ( *(_QWORD *)&ptr[56] )
    {
      v240 = (unsigned int *)(*(_QWORD *)&ptr[56] + 20LL);
      do
      {
        v241 = __ldaxr(v240);
        v242 = v241 - 1;
      }
      while ( __stlxr(v242, v240) );
      if ( !v242 )
        cv::Mat::deallocate((cv::Mat *)ptr);
    }
  }
  else
  {
    v230 = *(_QWORD *)(a1 + 1024);
    if ( v230 )
    {
      v231 = (unsigned int *)(v230 + 20);
      do
      {
        v232 = __ldaxr(v231);
        v233 = v232 - 1;
      }
      while ( __stlxr(v233, v231) );
      if ( !v233 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 968));
    }
    *(_QWORD *)(a1 + 1024) = 0LL;
    *(_OWORD *)(a1 + 984) = 0u;
    *(_OWORD *)(a1 + 1000) = 0u;
    if ( *(int *)(a1 + 972) >= 1 )
    {
      v234 = *(_QWORD *)(a1 + 1032);
      v235 = 0LL;
      do
        *(_DWORD *)(v234 + 4 * v235++) = 0;
      while ( v235 < *(int *)(a1 + 972) );
    }
    v236 = *(_DWORD *)&ptr[4];
    v237 = *(_OWORD *)&ptr[16];
    *(_OWORD *)(a1 + 968) = *(_OWORD *)ptr;
    *(_OWORD *)(a1 + 984) = v237;
    *(_OWORD *)(a1 + 1000) = *(_OWORD *)&ptr[32];
    *(_OWORD *)(a1 + 1016) = *(_OWORD *)&ptr[48];
    v238 = *(cv **)(a1 + 1040);
    if ( v238 == (cv *)(a1 + 1048) )
    {
      v239 = v236;
    }
    else
    {
      cv::fastFree(v238, v229);
      *(_QWORD *)(a1 + 1040) = a1 + 1048;
      *(_QWORD *)(a1 + 1032) = a1 + 976;
      v239 = *(_DWORD *)&ptr[4];
      v238 = (cv *)(a1 + 1048);
    }
    if ( v239 <= 2 )
    {
      v243 = v256[1];
      *(_QWORD *)v238 = *(_QWORD *)v256[1];
      *((_QWORD *)v238 + 1) = *((_QWORD *)v243 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 1032) = *(_OWORD *)v256;
      v256[0] = (cv *)&ptr[8];
      v256[1] = (cv *)&v257;
    }
    *(_DWORD *)ptr = 1124007936;
    memset(&ptr[4], 0, 60);
  }
  *(_QWORD *)&ptr[56] = 0LL;
  memset(&ptr[16], 0, 32);
  if ( *(int *)&ptr[4] >= 1 )
  {
    v244 = v256[0];
    v245 = 0LL;
    do
      *((_DWORD *)v244 + v245++) = 0;
    while ( v245 < *(int *)&ptr[4] );
  }
  if ( (__int64 *)v256[1] != &v257 )
    cv::fastFree(v256[1], v229);
  v246 = 100;
  do
  {
    ptr[2] = 0;
    *(_WORD *)ptr = 0;
    v247 = rand();
    ptr[0] = v247 + v247 / 255;
    v248 = rand();
    ptr[1] = v248 + v248 / 255;
    rand();
    ptr[2] = 0;
    v249 = *(_QWORD *)(a1 + 1648);
    if ( v249 == *(_QWORD *)(a1 + 1656) )
    {
      std::vector<cv::Vec<unsigned char,3>>::__push_back_slow_path<cv::Vec<unsigned char,3> const&>(a1 + 1640, ptr);
    }
    else
    {
      *(_WORD *)v249 = *(_WORD *)ptr;
      *(_BYTE *)(v249 + 2) = ptr[2];
      *(_QWORD *)(a1 + 1648) += 3LL;
    }
    --v246;
  }
  while ( v246 );
  **(_BYTE **)(a1 + 1640) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 1LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 2LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 3LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 4LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 5LL) = -52;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 6LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 7LL) = 100;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 8LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 9LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 10LL) = -103;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 11LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 150LL) = -78;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 151LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 152LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 153LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 154LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 155LL) = 51;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 156LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 157LL) = -1;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 158LL) = 51;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 159LL) = -103;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 160LL) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1640) + 161LL) = -1;
  return 0LL;
}
// 2B854: conditional instruction was optimized away because w10.4>=3
// 2B7AC: mask 0xFFFFFFFC is shortened because x10.8 <= 0x7FFFFFFF
// 2AF34: variable 'v15' is possibly undefined
// 2B0F8: variable 'v33' is possibly undefined
// 2B2BC: variable 'v51' is possibly undefined
// 2B478: variable 'v70' is possibly undefined
// 2B55C: variable 'v71' is possibly undefined
// 2B590: variable 'v91' is possibly undefined
// 2B8C0: variable 'v123' is possibly undefined
// 2B8F4: variable 'v124' is possibly undefined
// 2BB20: variable 'v139' is possibly undefined
// 2BCE4: variable 'v157' is possibly undefined
// 2BEA4: variable 'v175' is possibly undefined
// 2C058: variable 'v193' is possibly undefined
// 2C20C: variable 'v211' is possibly undefined
// 2C3CC: variable 'v229' is possibly undefined
// 28: using guessed type __int64;
// 12A10: using guessed type _QWORD *__fastcall cv::operator&(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13230: using guessed type __int64 __fastcall cv::cvtColor(_QWORD, _QWORD, _QWORD, _QWORD);
// 13670: using guessed type _QWORD *__fastcall cv::operator>(_QWORD *__return_ptr, _QWORD, double);
// 13940: using guessed type __int64 __fastcall cv::resize(_QWORD, _QWORD, _QWORD, _QWORD, double, double);

//----- (000000000002CB98) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromPlane(__int64 a1, __int64 a2)
{
  float v2; // s1
  float v3; // s2
  float v4; // s0
  void *v6; // x1
  double *v7; // x8
  double *v8; // x9
  float v9; // s0
  __int64 v10; // x11
  __int64 v11; // x10
  double *v12; // x13
  float v13; // s0
  double *v14; // x15
  float v15; // s0
  float v16; // s0
  float v17; // s0
  float v18; // s0
  float v19; // s0
  double v20; // d0
  double *v21; // x9
  double v22; // d0
  double *v23; // x13
  double *v24; // x8
  float v25; // s1
  float v26; // s1
  float v27; // s2
  float v28; // s2
  float v29; // s2
  float v30; // s2
  float v31; // s2
  float v32; // s2
  float v33; // s3
  float v34; // s3
  float v35; // s4
  float v36; // s4
  float v37; // s5
  float v38; // s5
  double v39; // d6
  __int64 v40; // x8
  __int64 v41; // x8
  __int64 v42; // x8
  const char *v43; // x20
  size_t v44; // x0
  size_t v45; // x19
  char *v46; // x21
  unsigned __int64 v47; // x22
  char v48; // w19
  unsigned int *v49; // x8
  unsigned int v50; // w9
  unsigned int v51; // w9
  _QWORD *v52; // x8
  __int64 v53; // x9
  unsigned int *v54; // x8
  unsigned int v55; // w9
  unsigned int v56; // w9
  _QWORD *v57; // x8
  __int64 v58; // x9
  char v60; // [xsp+8h] [xbp-278h] BYREF
  char v61[15]; // [xsp+9h] [xbp-277h] BYREF
  void *v62; // [xsp+18h] [xbp-268h]
  int v63; // [xsp+20h] [xbp-260h] BYREF
  unsigned __int64 v64; // [xsp+28h] [xbp-258h] BYREF
  size_t v65; // [xsp+30h] [xbp-250h]
  void *v66; // [xsp+38h] [xbp-248h]
  _QWORD v67[8]; // [xsp+40h] [xbp-240h] BYREF
  _QWORD *v68; // [xsp+80h] [xbp-200h]
  cv *v69; // [xsp+88h] [xbp-1F8h]
  __int64 v70[31]; // [xsp+90h] [xbp-1F0h] BYREF
  __int64 v71; // [xsp+188h] [xbp-F8h]
  __int64 v72; // [xsp+190h] [xbp-F0h]
  __int64 v73; // [xsp+198h] [xbp-E8h]
  __int64 v74; // [xsp+1A0h] [xbp-E0h]
  __int64 v75; // [xsp+1A8h] [xbp-D8h]
  float v76; // [xsp+1B0h] [xbp-D0h]
  __int128 v77; // [xsp+1B4h] [xbp-CCh]
  float v78; // [xsp+1C4h] [xbp-BCh]
  float32x2_t v79; // [xsp+1C8h] [xbp-B8h] BYREF
  float v80; // [xsp+1D0h] [xbp-B0h]
  int v81; // [xsp+1D4h] [xbp-ACh]
  _QWORD v82[8]; // [xsp+1D8h] [xbp-A8h] BYREF
  _QWORD *v83; // [xsp+218h] [xbp-68h]
  cv *v84; // [xsp+220h] [xbp-60h]
  __int64 v85[3]; // [xsp+228h] [xbp-58h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = *(float *)a2;
  v2 = *(float *)(a2 + 4);
  v4 = *(float *)(a2 + 8);
  if ( (float)((float)(fabsf(*(float *)a2) + fabsf(v2)) + fabsf(v4)) <= 0.1 )
  {
    if ( (word_6FDF0 & 1) != 0 )
      v43 = (const char *)qword_6FE00;
    else
      v43 = (char *)&word_6FDF0 + 1;
    v63 = dword_6FDE8;
    v65 = 0LL;
    v66 = 0LL;
    v64 = 0LL;
    v44 = strlen(v43);
    if ( v44 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v45 = v44;
    if ( v44 >= 0x17 )
    {
      v47 = (v44 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v46 = (char *)operator new(v47);
      v65 = v45;
      v66 = v46;
      v64 = v47 | 1;
    }
    else
    {
      v46 = (char *)&v64 + 1;
      LOBYTE(v64) = 2 * v44;
      if ( !v44 )
      {
LABEL_14:
        v46[v45] = 0;
        if ( (g3::logLevel(&v63) & 1) != 0 )
        {
          *(_QWORD *)&v61[7] = 0LL;
          v62 = 0LL;
          v60 = 12;
          strcpy(v61, "region");
          v48 = g3::logTag(&v60);
          if ( (v60 & 1) == 0 )
          {
            if ( (v64 & 1) == 0 )
              goto LABEL_17;
LABEL_43:
            operator delete(v66);
            if ( (v48 & 1) == 0 )
              return 1LL;
LABEL_44:
            LogCapture::LogCapture((LogCapture *)v67, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)v67, "clib from plane err!\n");
            LogCapture::~LogCapture((LogCapture *)v67);
            return 1LL;
          }
          operator delete(v62);
          if ( (v64 & 1) != 0 )
            goto LABEL_43;
        }
        else
        {
          v48 = 0;
          if ( (v64 & 1) != 0 )
            goto LABEL_43;
        }
LABEL_17:
        if ( (v48 & 1) == 0 )
          return 1LL;
        goto LABEL_44;
      }
    }
    memcpy(v46, v43, v45);
    goto LABEL_14;
  }
  LODWORD(v67[0]) = 1124007936;
  LODWORD(v82[0]) = 1124007936;
  v79.n64_u64[0] = __PAIR64__(LODWORD(v2), LODWORD(v3));
  memset((char *)v67 + 4, 0, 60);
  v68 = &v67[1];
  v69 = (cv *)v70;
  memset((char *)v82 + 4, 0, 60);
  v70[0] = 0LL;
  v70[1] = 0LL;
  v83 = &v82[1];
  v84 = (cv *)v85;
  v85[0] = 0LL;
  v85[1] = 0LL;
  v80 = v4;
  v81 = *(_DWORD *)(a2 + 12);
  feasibal_region::ground_process::GetCameraPlaneRT_(a1, &v79, (__int64)v67, (__int64)v82);
  v7 = (double *)v67[2];
  v72 = 0LL;
  v74 = 0LL;
  v76 = 1.0;
  v77 = 0uLL;
  v78 = 1.0;
  v8 = (double *)v82[2];
  v9 = *(double *)v67[2];
  v10 = *(_QWORD *)v69;
  v11 = *(_QWORD *)v84;
  *(float *)&v71 = v9;
  v12 = (double *)(v82[2] + v11);
  v13 = *(double *)v82[2];
  *(float *)(a1 + 1664) = v13;
  v14 = (double *)((char *)v8 + 2 * v11);
  v15 = v7[1];
  *(float *)&v73 = v15;
  v16 = v8[1];
  *(float *)(a1 + 1680) = v16;
  v17 = v7[2];
  *(float *)&v75 = v17;
  v18 = v8[2];
  *(float *)(a1 + 1696) = v18;
  v19 = v7[3];
  *((float *)&v77 + 1) = v19;
  v20 = v8[3];
  v21 = (double *)((char *)v8 + 3 * v11);
  *(float *)&v20 = v20;
  *(_DWORD *)(a1 + 1712) = LODWORD(v20);
  *(float *)&v20 = *(double *)((char *)v7 + v10);
  HIDWORD(v71) = LODWORD(v20);
  *(float *)&v20 = *v12;
  *(_DWORD *)(a1 + 1668) = LODWORD(v20);
  *(float *)&v20 = *(double *)((char *)v7 + v10 + 8);
  HIDWORD(v73) = LODWORD(v20);
  *(float *)&v20 = v12[1];
  *(_DWORD *)(a1 + 1684) = LODWORD(v20);
  *(float *)&v20 = *(double *)((char *)v7 + v10 + 16);
  HIDWORD(v75) = LODWORD(v20);
  *(float *)&v20 = v12[2];
  *(_DWORD *)(a1 + 1700) = LODWORD(v20);
  *(float *)&v20 = *(double *)((char *)v7 + v10 + 24);
  DWORD2(v77) = LODWORD(v20);
  v22 = v12[3];
  v23 = (double *)((char *)v7 + 2 * v10);
  v24 = (double *)((char *)v7 + 3 * v10);
  *(float *)&v22 = v22;
  *(_DWORD *)(a1 + 1716) = LODWORD(v22);
  *(float *)&v22 = *v23;
  LODWORD(v72) = LODWORD(v22);
  v25 = *v14;
  *(float *)(a1 + 1672) = v25;
  v26 = v23[1];
  *(float *)&v74 = v26;
  v27 = v14[1];
  *(float *)(a1 + 1688) = v27;
  v28 = v23[2];
  v76 = v28;
  v29 = v14[2];
  *(float *)(a1 + 1704) = v29;
  v30 = v23[3];
  *((float *)&v77 + 3) = v30;
  v31 = v14[3];
  *(float *)(a1 + 1720) = v31;
  v32 = *v24;
  *((float *)&v72 + 1) = v32;
  v33 = *v21;
  *(float *)(a1 + 1676) = v33;
  v34 = v24[1];
  *((float *)&v74 + 1) = v34;
  v35 = v21[1];
  *(float *)(a1 + 1692) = v35;
  v36 = v24[2];
  *(float *)&v77 = v36;
  v37 = v21[2];
  *(float *)(a1 + 1708) = v37;
  v38 = v24[3];
  v78 = v38;
  v39 = v21[3];
  LODWORD(v21) = *(unsigned __int8 *)(a1 + 60);
  *(float *)&v39 = v39;
  *(_DWORD *)(a1 + 1724) = LODWORD(v39);
  v40 = v71;
  *(_DWORD *)(a1 + 1736) = LODWORD(v22);
  *(float *)(a1 + 1740) = v32;
  *(_QWORD *)(a1 + 1728) = v40;
  v41 = v73;
  *(float *)(a1 + 1752) = v26;
  *(float *)(a1 + 1756) = v34;
  *(_QWORD *)(a1 + 1744) = v41;
  *(_QWORD *)(a1 + 1760) = v75;
  *(float *)&v41 = v76;
  *(float *)(a1 + 1772) = v36;
  *(_DWORD *)(a1 + 1768) = v41;
  *(_QWORD *)(a1 + 1776) = *(_QWORD *)((char *)&v77 + 4);
  LODWORD(v41) = HIDWORD(v77);
  *(float *)(a1 + 1788) = v38;
  *(_DWORD *)(a1 + 1784) = v41;
  if ( (_DWORD)v21 )
  {
    v42 = v82[7];
    if ( !v82[7] )
      goto LABEL_26;
LABEL_22:
    v49 = (unsigned int *)(v42 + 20);
    do
    {
      v50 = __ldaxr(v49);
      v51 = v50 - 1;
    }
    while ( __stlxr(v51, v49) );
    if ( !v51 )
      cv::Mat::deallocate((cv::Mat *)v82);
    goto LABEL_26;
  }
  *(_BYTE *)(a1 + 1792) = 1;
  v42 = v82[7];
  if ( v82[7] )
    goto LABEL_22;
LABEL_26:
  v82[7] = 0LL;
  memset(&v82[2], 0, 32);
  if ( SHIDWORD(v82[0]) >= 1 )
  {
    v52 = v83;
    v53 = 0LL;
    do
      *((_DWORD *)v52 + v53++) = 0;
    while ( v53 < SHIDWORD(v82[0]) );
  }
  if ( v84 != (cv *)v85 )
    cv::fastFree(v84, v6);
  if ( v67[7] )
  {
    v54 = (unsigned int *)(v67[7] + 20LL);
    do
    {
      v55 = __ldaxr(v54);
      v56 = v55 - 1;
    }
    while ( __stlxr(v56, v54) );
    if ( !v56 )
      cv::Mat::deallocate((cv::Mat *)v67);
  }
  v67[7] = 0LL;
  memset(&v67[2], 0, 32);
  if ( SHIDWORD(v67[0]) >= 1 )
  {
    v57 = v68;
    v58 = 0LL;
    do
      *((_DWORD *)v57 + v58++) = 0;
    while ( v58 < SHIDWORD(v67[0]) );
  }
  if ( v69 != (cv *)v70 )
    cv::fastFree(v69, v6);
  return 0LL;
}
// 2D018: variable 'v6' is possibly undefined
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;

//----- (000000000002D274) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::getPlaneFromExtrinsic(__int64 a1, float32x2_t *a2, float *a3)
{
  float32x2_t v3; // d1
  float v4; // s3
  float v5; // s4
  float32x2_t v6; // d2
  float v7; // s1
  float v8; // s3
  float v9; // s0
  float v10; // s0
  unsigned __int32 v11; // w9
  unsigned __int32 v12; // w9
  float v13; // w10

  v3.n64_u64[0] = vadd_f32(
                    *(float32x2_t *)(a1 + 1712),
                    vadd_f32(
                      *(float32x2_t *)(a1 + 1696),
                      vadd_f32(vmul_f32(*(float32x2_t *)(a1 + 1664), 0LL), vmul_f32(*(float32x2_t *)(a1 + 1680), 0LL)))).n64_u64[0];
  v4 = *(float *)(a1 + 1720)
     + (float)(*(float *)(a1 + 1704)
             + (float)((float)(*(float *)(a1 + 1672) * 0.0) + (float)(*(float *)(a1 + 1688) * 0.0)));
  v5 = 1.0 / sqrtf(vaddv_f32(vmul_f32(v3, v3)) + (float)(v4 * v4));
  v6.n64_u64[0] = vmul_n_f32(v3, v5).n64_u64[0];
  a2->n64_u64[0] = v6.n64_u64[0];
  a2[1].n64_f32[0] = v4 * v5;
  if ( (float)(v4 * v5) > 0.0 )
  {
    a2->n64_u64[0] = vneg_f32(v6).n64_u64[0];
    a2[1].n64_f32[0] = -(float)(v4 * v5);
  }
  v7 = (float)(*(float *)(a1 + 1728) * 0.0) + (float)(*(float *)(a1 + 1744) * 0.0);
  v8 = *(float *)(a1 + 1764) + (float)((float)(*(float *)(a1 + 1732) * 0.0) + (float)(*(float *)(a1 + 1748) * 0.0));
  v9 = *(float *)(a1 + 1784)
     + (float)(*(float *)(a1 + 1768)
             + (float)((float)(*(float *)(a1 + 1736) * 0.0) + (float)(*(float *)(a1 + 1752) * 0.0)));
  v10 = fabsf(
          sqrtf(
            (float)((float)(*(float *)(a1 + 1776) + (float)(*(float *)(a1 + 1760) + v7))
                  * (float)(*(float *)(a1 + 1776) + (float)(*(float *)(a1 + 1760) + v7)))
          + (float)((float)((float)(*(float *)(a1 + 1780) + v8) * (float)(*(float *)(a1 + 1780) + v8)) + (float)(v9 * v9))));
  *a3 = v10;
  v11 = a2[1].n64_u32[0];
  *(float32x2_t *)(a1 + 1796) = (float32x2_t)a2->n64_u64[0];
  *(_DWORD *)(a1 + 1804) = v11;
  *(float *)(a1 + 1808) = v10;
  v12 = a2[1].n64_u32[0];
  v13 = *a3;
  *(float32x2_t *)(a1 + 1812) = (float32x2_t)a2->n64_u64[0];
  *(_DWORD *)(a1 + 1820) = v12;
  *(float *)(a1 + 1824) = v13;
  return 0LL;
}

//----- (000000000002D3D0) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::set_calib(__int64 a1, __int128 *a2)
{
  const char *v3; // x20
  size_t v4; // x0
  size_t v5; // x19
  char *v6; // x21
  unsigned __int64 v7; // x22
  char v8; // w19
  __int64 v9; // x0
  __int64 result; // x0
  char v11; // [xsp+8h] [xbp-218h] BYREF
  char v12[15]; // [xsp+9h] [xbp-217h] BYREF
  void *v13; // [xsp+18h] [xbp-208h]
  int v14; // [xsp+20h] [xbp-200h] BYREF
  unsigned __int64 v15; // [xsp+28h] [xbp-1F8h] BYREF
  size_t v16; // [xsp+30h] [xbp-1F0h]
  void *v17; // [xsp+38h] [xbp-1E8h]
  __int128 v18; // [xsp+40h] [xbp-1E0h] BYREF
  char v19[328]; // [xsp+58h] [xbp-1C8h] BYREF
  _OWORD v20[5]; // [xsp+1A0h] [xbp-80h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( *(_BYTE *)(a1 + 1792) && !*(_BYTE *)(a1 + 1793) )
  {
    v9 = *(_QWORD *)(a1 + 512);
    v20[0] = *(_OWORD *)(a1 + 1664);
    v20[1] = *(_OWORD *)(a1 + 1680);
    v20[2] = *(_OWORD *)(a1 + 1696);
    v20[3] = *(_OWORD *)(a1 + 1712);
    v18 = *a2;
    CAPE::set_extrinsic(v9, v20, &v18);
    result = 0LL;
    *(_BYTE *)(a1 + 1793) = 1;
    return result;
  }
  if ( (word_6FDF0 & 1) != 0 )
    v3 = (const char *)qword_6FE00;
  else
    v3 = (char *)&word_6FDF0 + 1;
  v14 = dword_6FDE8;
  v16 = 0LL;
  v17 = 0LL;
  v15 = 0LL;
  v4 = strlen(v3);
  if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v5 = v4;
  if ( v4 >= 0x17 )
  {
    v7 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v6 = (char *)operator new(v7);
    v16 = v5;
    v17 = v6;
    v15 = v7 | 1;
    goto LABEL_11;
  }
  v6 = (char *)&v15 + 1;
  LOBYTE(v15) = 2 * v4;
  if ( v4 )
LABEL_11:
    memcpy(v6, v3, v5);
  v6[v5] = 0;
  if ( (g3::logLevel(&v14) & 1) == 0 )
  {
    v8 = 0;
    if ( (v15 & 1) != 0 )
      goto LABEL_21;
LABEL_15:
    if ( (v8 & 1) == 0 )
      return 1LL;
    goto LABEL_22;
  }
  *(_QWORD *)&v12[7] = 0LL;
  v13 = 0LL;
  v11 = 12;
  strcpy(v12, "region");
  v8 = g3::logTag(&v11);
  if ( (v11 & 1) != 0 )
  {
    operator delete(v13);
    if ( (v15 & 1) != 0 )
      goto LABEL_21;
    goto LABEL_15;
  }
  if ( (v15 & 1) == 0 )
    goto LABEL_15;
LABEL_21:
  operator delete(v17);
  if ( (v8 & 1) != 0 )
  {
LABEL_22:
    LogCapture::LogCapture((LogCapture *)v19, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v19, "clib set err!\n");
    LogCapture::~LogCapture((LogCapture *)v19);
  }
  return 1LL;
}
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;
// 2D3D0: using guessed type _OWORD var_80[5];
// 2D3D0: using guessed type __int128 var_1E0;

//----- (000000000002D63C) ----------------------------------------------------
__int64 __fastcall std::istream::tellg(_QWORD *a1)
{
  __int64 v2; // x8
  char *v3; // x0
  int v4; // w9
  _QWORD *v6; // x0

  v2 = *(_QWORD *)(*a1 - 24LL);
  v3 = (char *)a1 + v2;
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 )
  {
    std::ios_base::clear((std::ios_base *)v3, v4 | 4);
    return 0LL;
  }
  v6 = (_QWORD *)*((_QWORD *)v3 + 17);
  if ( v6 )
  {
    std::ostream::flush(v6);
    v2 = *(_QWORD *)(*a1 - 24LL);
    if ( *(_DWORD *)((char *)a1 + v2 + 32) )
      return 0LL;
  }
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(**(_QWORD **)((char *)a1 + v2 + 40) + 32LL))(
           *(_QWORD *)((char *)a1 + v2 + 40),
           0LL,
           1LL,
           8LL);
}

//----- (000000000002D6F4) ----------------------------------------------------
void __fastcall std::ifstream::~ifstream(_QWORD *a1)
{
  *a1 = off_6E158;
  a1[23] = off_6E180;
  std::filebuf::~filebuf((__int64)(a1 + 2));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 23));
}
// 6E158: using guessed type __int64 (__fastcall *off_6E158[2])();
// 6E180: using guessed type __int64 (__fastcall *off_6E180[2])();

//----- (000000000002D730) ----------------------------------------------------
double __fastcall feasibal_region::norm_vec(double *a1)
{
  return sqrt(*a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2]);
}

//----- (000000000002D754) ----------------------------------------------------
double __fastcall feasibal_region::dot_vec(__int64 a1, __int64 a2)
{
  float64x2_t v2; // q1

  v2 = vmulq_f64(*(float64x2_t *)(a1 + 8), *(float64x2_t *)(a2 + 8));
  return *(double *)a1 * *(double *)a2 + v2.n128_f64[0] + v2.n128_f64[1];
}

//----- (000000000002D77C) ----------------------------------------------------
cv *__usercall feasibal_region::rotationMatrixFromAxisAndAngle@<X0>(double *a1@<X0>, __int64 a2@<X8>, double a3@<D0>)
{
  double v4; // d11
  double v5; // d13
  double v6; // d10
  double v7; // d9
  cv *v8; // x23
  __int64 v9; // x8
  __int64 v10; // x13
  __int64 v11; // x12
  int64x2_t v12; // q1
  _QWORD *v13; // x13
  __int64 v14; // x14
  int64x2_t v15; // q0
  __int64 v16; // d2
  __int64 v17; // x10
  int *v18; // x11
  __int64 v19; // t1
  double v20; // d8
  double v21; // d13
  double *v22; // x8
  double v23; // d12
  cv::Mat *v24; // x1
  double v25; // d11
  __int64 v26; // x9
  double v27; // d14
  unsigned __int64 v28; // x10
  double v29; // d8
  double v30; // d15
  double *v31; // x9
  double *v32; // x8
  double *v33; // x9
  double *v34; // x8
  double v35; // d9
  double *v36; // x9
  double *v37; // x8
  double v38; // d0
  double *v39; // x9
  void *v40; // x1
  __int64 v41; // x8
  unsigned int *v42; // x8
  unsigned int v43; // w9
  unsigned int v44; // w9
  int v45; // w8
  __int64 v46; // x8
  __int64 v47; // x9
  cv *v48; // x0
  int v49; // v0.s[1]
  __int128 v50; // q1
  __int128 v51; // q2
  __int128 v52; // q3
  int v53; // w8
  unsigned int *v54; // x8
  unsigned int v55; // w9
  unsigned int v56; // w9
  cv *v57; // x9
  __int128 v58; // q0
  cv *v59; // x8
  __int64 v60; // x9
  unsigned int *v61; // x8
  unsigned int v62; // w9
  unsigned int v63; // w9
  _QWORD *v64; // x8
  __int64 v65; // x9
  cv *result; // x0
  double v67; // [xsp+0h] [xbp-1F0h]
  double v68; // [xsp+8h] [xbp-1E8h]
  double v69; // [xsp+10h] [xbp-1E0h]
  double cosx; // [xsp+20h] [xbp-1D0h] BYREF
  double sinx; // [xsp+28h] [xbp-1C8h] BYREF
  cv::Mat *v72; // [xsp+30h] [xbp-1C0h] BYREF
  __int64 v73; // [xsp+38h] [xbp-1B8h]
  double *v74; // [xsp+40h] [xbp-1B0h]
  __int64 v75; // [xsp+48h] [xbp-1A8h]
  unsigned __int64 v76; // [xsp+50h] [xbp-1A0h]
  int v77[2]; // [xsp+58h] [xbp-198h] BYREF
  __int64 v78; // [xsp+60h] [xbp-190h]
  double *v79; // [xsp+68h] [xbp-188h]
  __int64 v80; // [xsp+70h] [xbp-180h]
  unsigned __int64 v81; // [xsp+78h] [xbp-178h]
  _QWORD v82[8]; // [xsp+80h] [xbp-170h] BYREF
  _QWORD *v83; // [xsp+C0h] [xbp-130h]
  cv *v84; // [xsp+C8h] [xbp-128h]
  __int64 v85[2]; // [xsp+D0h] [xbp-120h] BYREF
  _BYTE v86[64]; // [xsp+E0h] [xbp-110h] BYREF
  cv *v87[2]; // [xsp+120h] [xbp-D0h]
  __int64 v88[6]; // [xsp+130h] [xbp-C0h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v5 = *a1;
  v4 = a1[1];
  v6 = a1[2];
  sincos(a3, &sinx, &cosx);
  v7 = cosx;
  v69 = sinx;
  *(_DWORD *)a2 = 1124007936;
  LODWORD(v82[0]) = 1124007936;
  memset((char *)v82 + 4, 0, 60);
  *(_OWORD *)(a2 + 4) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 36) = 0u;
  *(_OWORD *)(a2 + 20) = 0u;
  *(_QWORD *)(a2 + 64) = a2 + 8;
  *(_QWORD *)(a2 + 80) = 0LL;
  v8 = (cv *)(a2 + 80);
  *(_QWORD *)(a2 + 88) = 0LL;
  v83 = &v82[1];
  v84 = (cv *)v85;
  v85[0] = 0LL;
  v85[1] = 0LL;
  *(_QWORD *)(a2 + 72) = a2 + 80;
  *(_QWORD *)v77 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v82, 2, v77, 6);
  *(_QWORD *)v77 = v82;
  if ( SHIDWORD(v82[0]) < 1 )
    v9 = 0LL;
  else
    v9 = *((_QWORD *)v84 + HIDWORD(v82[0]) - 1);
  v78 = v9;
  v79 = 0LL;
  v80 = 0LL;
  v81 = 0LL;
  if ( (v82[0] & 0x4000LL) != 0 )
  {
    v80 = v82[2];
    if ( SHIDWORD(v82[0]) >= 3 )
    {
      if ( HIDWORD(v82[0]) == 3 )
      {
        v11 = 0LL;
        v10 = 1LL;
      }
      else
      {
        v11 = HIDWORD(v82[0]) & 0xFFFFFFFC;
        v12 = vdupq_n_s64(1uLL);
        v13 = v83 + 1;
        v14 = v11;
        v15 = v12;
        do
        {
          v16 = *(v13 - 1);
          v12.n128_u64[0] *= (int)v16;
          v15.n128_u64[0] *= (int)*v13;
          v14 -= 4LL;
          v12.n128_u64[1] *= SHIDWORD(v16);
          v15.n128_u64[1] *= (int)HIDWORD(*v13);
          v13 += 2;
        }
        while ( v14 );
        v10 = v15.n128_u64[0] * v12.n128_u64[0] * v15.n128_u64[1] * v12.n128_u64[1];
        if ( v11 == HIDWORD(v82[0]) )
          goto LABEL_14;
      }
      v17 = HIDWORD(v82[0]) - v11;
      v18 = (int *)v83 + v11;
      do
      {
        v19 = *v18++;
        --v17;
        v10 *= v19;
      }
      while ( v17 );
    }
    else
    {
      v10 = SHIDWORD(v82[1]) * (__int64)SLODWORD(v82[1]);
    }
LABEL_14:
    v81 = v82[2] + v10 * v9;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v77, 0LL, 0);
  v20 = 1.0 / sqrt(v5 * v5 + v4 * v4 + v6 * v6);
  v21 = v5 * v20;
  v22 = v79;
  v23 = 1.0 - v7;
  *v79 = v7 + (1.0 - v7) * (v21 * v21);
  v24 = *(cv::Mat **)v77;
  if ( *(_QWORD *)v77 )
  {
    v79 = (double *)((char *)v22 + v78);
    if ( (unsigned __int64)v22 + v78 >= v81 )
    {
      v79 = v22;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v77, 1LL, 1);
      v24 = *(cv::Mat **)v77;
      v22 = v79;
    }
    else
    {
      v22 = (double *)((char *)v22 + v78);
    }
  }
  v25 = v4 * v20;
  v26 = v78;
  v27 = v6 * v20;
  v74 = v22;
  v75 = v80;
  v28 = v81;
  v29 = v69 * (v6 * v20);
  v30 = v23 * (v21 * v25);
  v72 = v24;
  v73 = v78;
  v76 = v81;
  *v22 = v30 - v29;
  if ( !v24 )
  {
    *v22 = v7 + v23 * (v27 * v27);
    goto LABEL_51;
  }
  v31 = (double *)((char *)v22 + v26);
  v68 = v7 + v23 * (v27 * v27);
  v74 = v31;
  if ( (unsigned __int64)v31 >= v28 )
  {
    v74 = v22;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
    v31 = v74;
    v24 = v72;
  }
  v67 = v23 * (v21 * v27);
  *v31 = v69 * v25 + v67;
  if ( v24 )
  {
    v32 = (double *)((char *)v31 + v73);
    v74 = (double *)((char *)v31 + v73);
    if ( (unsigned __int64)v31 + v73 >= v76 )
    {
      v74 = v31;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v32 = v74;
      v24 = v72;
    }
  }
  else
  {
    v32 = v31;
  }
  *v32 = v29 + v30;
  if ( v24 )
  {
    v33 = (double *)((char *)v32 + v73);
    v74 = (double *)((char *)v32 + v73);
    if ( (unsigned __int64)v32 + v73 >= v76 )
    {
      v74 = v32;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v33 = v74;
      v24 = v72;
    }
  }
  else
  {
    v33 = v32;
  }
  *v33 = v7 + v23 * (v25 * v25);
  if ( v24 )
  {
    v34 = (double *)((char *)v33 + v73);
    v74 = (double *)((char *)v33 + v73);
    if ( (unsigned __int64)v33 + v73 >= v76 )
    {
      v74 = v33;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v34 = v74;
      v24 = v72;
    }
  }
  else
  {
    v34 = v33;
  }
  v35 = v23 * (v25 * v27);
  *v34 = v35 - v69 * v21;
  if ( v24 )
  {
    v36 = (double *)((char *)v34 + v73);
    v74 = (double *)((char *)v34 + v73);
    if ( (unsigned __int64)v34 + v73 >= v76 )
    {
      v74 = v34;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v36 = v74;
      v24 = v72;
    }
  }
  else
  {
    v36 = v34;
  }
  *v36 = v67 - v69 * v25;
  if ( v24 )
  {
    v37 = (double *)((char *)v36 + v73);
    v74 = (double *)((char *)v36 + v73);
    if ( (unsigned __int64)v36 + v73 >= v76 )
    {
      v74 = v36;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v37 = v74;
      v24 = v72;
    }
  }
  else
  {
    v37 = v36;
  }
  *v37 = v69 * v21 + v35;
  if ( !v24 )
  {
    v39 = v37;
    goto LABEL_47;
  }
  v38 = v68;
  v39 = (double *)((char *)v37 + v73);
  v74 = (double *)((char *)v37 + v73);
  if ( (unsigned __int64)v37 + v73 >= v76 )
  {
    v74 = v37;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
    v39 = v74;
    v24 = v72;
LABEL_47:
    v38 = v68;
  }
  *v39 = v38;
  if ( v24 )
  {
    v74 = (double *)((char *)v39 + v73);
    if ( (unsigned __int64)v39 + v73 >= v76 )
    {
      v74 = v39;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v72, 1LL, 1);
      v24 = v72;
    }
  }
LABEL_51:
  memset(&v86[4], 0, 60);
  v87[0] = (cv *)&v86[8];
  v87[1] = (cv *)v88;
  v88[0] = 0LL;
  v88[1] = 0LL;
  *(_DWORD *)v86 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v86, v24);
  if ( v86 == (_BYTE *)a2 )
  {
    if ( *(_QWORD *)&v86[56] )
    {
      v54 = (unsigned int *)(*(_QWORD *)&v86[56] + 20LL);
      do
      {
        v55 = __ldaxr(v54);
        v56 = v55 - 1;
      }
      while ( __stlxr(v56, v54) );
      if ( !v56 )
        cv::Mat::deallocate((cv::Mat *)v86);
    }
  }
  else
  {
    v41 = *(_QWORD *)(a2 + 56);
    if ( v41 )
    {
      v42 = (unsigned int *)(v41 + 20);
      do
      {
        v43 = __ldaxr(v42);
        v44 = v43 - 1;
      }
      while ( __stlxr(v44, v42) );
      if ( !v44 )
        cv::Mat::deallocate((cv::Mat *)a2);
    }
    v45 = *(_DWORD *)(a2 + 4);
    *(_QWORD *)(a2 + 56) = 0LL;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    if ( v45 >= 1 )
    {
      v46 = *(_QWORD *)(a2 + 64);
      v47 = 0LL;
      do
        *(_DWORD *)(v46 + 4 * v47++) = 0;
      while ( v47 < *(int *)(a2 + 4) );
    }
    v48 = *(cv **)(a2 + 72);
    v49 = *(_DWORD *)&v86[4];
    v50 = *(_OWORD *)&v86[16];
    v51 = *(_OWORD *)&v86[32];
    v52 = *(_OWORD *)&v86[48];
    *(_OWORD *)a2 = *(_OWORD *)v86;
    *(_OWORD *)(a2 + 16) = v50;
    *(_OWORD *)(a2 + 32) = v51;
    *(_OWORD *)(a2 + 48) = v52;
    if ( v48 == v8 )
    {
      v53 = v49;
    }
    else
    {
      cv::fastFree(v48, v40);
      v53 = *(_DWORD *)&v86[4];
      *(_QWORD *)(a2 + 64) = a2 + 8;
      *(_QWORD *)(a2 + 72) = v8;
    }
    if ( v53 <= 2 )
    {
      v57 = v87[1];
      *(_QWORD *)(a2 + 80) = *(_QWORD *)v87[1];
      *(_QWORD *)(a2 + 88) = *((_QWORD *)v57 + 1);
    }
    else
    {
      v58 = *(_OWORD *)v87;
      v87[0] = (cv *)&v86[8];
      v87[1] = (cv *)v88;
      *(_OWORD *)(a2 + 64) = v58;
    }
    *(_DWORD *)v86 = 1124007936;
    memset(&v86[4], 0, 60);
  }
  *(_QWORD *)&v86[56] = 0LL;
  memset(&v86[16], 0, 32);
  if ( *(int *)&v86[4] >= 1 )
  {
    v59 = v87[0];
    v60 = 0LL;
    do
      *((_DWORD *)v59 + v60++) = 0;
    while ( v60 < *(int *)&v86[4] );
  }
  if ( (__int64 *)v87[1] != v88 )
    cv::fastFree(v87[1], v40);
  if ( v82[7] )
  {
    v61 = (unsigned int *)(v82[7] + 20LL);
    do
    {
      v62 = __ldaxr(v61);
      v63 = v62 - 1;
    }
    while ( __stlxr(v63, v61) );
    if ( !v63 )
      cv::Mat::deallocate((cv::Mat *)v82);
  }
  v82[7] = 0LL;
  memset(&v82[2], 0, 32);
  if ( SHIDWORD(v82[0]) >= 1 )
  {
    v64 = v83;
    v65 = 0LL;
    do
      *((_DWORD *)v64 + v65++) = 0;
    while ( v65 < SHIDWORD(v82[0]) );
  }
  result = v84;
  if ( v84 != (cv *)v85 )
    return (cv *)cv::fastFree(v84, v40);
  return result;
}
// 2DD58: variable 'v40' is possibly undefined
// 28: using guessed type __int64;

//----- (000000000002E0C4) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT(
        __int64 a1,
        float32x2_t *a2,
        __int64 a3,
        __int64 a4)
{
  float v6; // s0
  float v7; // s1
  unsigned __int64 v8; // d7
  double v9; // d12
  double v10; // d13
  double v11; // d3
  double v12; // d1
  double v13; // d2
  double v14; // d10
  double v15; // d8
  double v16; // d15
  double v17; // d9
  double v18; // d2
  double v19; // d1
  double v20; // d5
  double v21; // d11
  double v22; // d0
  double v23; // d11
  double v24; // d8
  void *v25; // x1
  void *v26; // x1
  void *v27; // x1
  void *v28; // x1
  __int64 v29; // x8
  __int64 v30; // x13
  __int64 v31; // x12
  int64x2_t v32; // q1
  _QWORD *v33; // x13
  __int64 v34; // x14
  int64x2_t v35; // q0
  __int64 v36; // d2
  __int64 v37; // x10
  int *v38; // x11
  __int64 v39; // t1
  double *v40; // x23
  cv::Mat *v41; // x21
  __int64 v42; // x8
  unsigned __int64 v43; // x9
  double v44; // d9
  double *v45; // x25
  void *v46; // x1
  cv *v47; // x0
  __int128 v48; // q0
  unsigned int *v49; // x8
  unsigned int v50; // w9
  unsigned int v51; // w9
  __int64 v52; // x8
  __int64 v53; // x9
  void *v54; // x1
  void *v55; // x1
  __int64 v56; // x21
  __int64 v57; // x8
  __int64 v58; // x13
  __int64 v59; // x12
  int64x2_t v60; // q1
  _QWORD *v61; // x13
  __int64 v62; // x14
  int64x2_t v63; // q0
  __int64 v64; // d2
  __int64 v65; // x10
  int *v66; // x11
  __int64 v67; // t1
  double *v68; // x8
  cv::Mat *v69; // x1
  __int64 v70; // x9
  unsigned __int64 v71; // x11
  __int64 v72; // x10
  double *v73; // x9
  double *v74; // x10
  __int64 v75; // x9
  double *v76; // x10
  double *v77; // x8
  double *v78; // x9
  double *v79; // x10
  __int64 v80; // x8
  double *v81; // x9
  double *v82; // x10
  double *v83; // x8
  double *v84; // x9
  double *v85; // x8
  double *v86; // x9
  double *v87; // x8
  void *v88; // x1
  cv *v89; // x0
  __int128 v90; // q0
  unsigned int *v91; // x8
  unsigned int v92; // w9
  unsigned int v93; // w9
  __int64 v94; // x8
  __int64 v95; // x9
  __int64 v96; // x8
  __int64 v97; // x13
  __int64 v98; // x12
  int64x2_t v99; // q1
  _QWORD *v100; // x13
  __int64 v101; // x14
  int64x2_t v102; // q0
  __int64 v103; // d2
  __int64 v104; // x10
  int *v105; // x11
  __int64 v106; // t1
  double *v107; // x8
  cv::Mat *v108; // x1
  __int64 v109; // x9
  unsigned __int64 v110; // x10
  double *v111; // x9
  double *v112; // x8
  double *v113; // x9
  double *v114; // x8
  double *v115; // x9
  double *v116; // x9
  double *v117; // x8
  double *v118; // x9
  double *v119; // x8
  double *v120; // x9
  double *v121; // x8
  double *v122; // x9
  double *v123; // x8
  void *v124; // x1
  cv *v125; // x0
  __int128 v126; // q0
  unsigned int *v127; // x8
  unsigned int v128; // w9
  unsigned int v129; // w9
  _BYTE *v130; // x8
  __int64 v131; // x9
  __int64 v132; // x23
  __int64 v133; // x8
  __int64 v134; // x13
  __int64 v135; // x12
  int64x2_t v136; // q1
  _QWORD *v137; // x13
  __int64 v138; // x14
  int64x2_t v139; // q0
  __int64 v140; // d2
  __int64 v141; // x10
  int *v142; // x11
  __int64 v143; // t1
  double *v144; // x8
  cv::Mat *v145; // x1
  __int64 v146; // x9
  unsigned __int64 v147; // x11
  __int64 v148; // x10
  double *v149; // x9
  double *v150; // x10
  __int64 v151; // x9
  double *v152; // x10
  double *v153; // x8
  double *v154; // x9
  double *v155; // x10
  __int64 v156; // x8
  double *v157; // x9
  double *v158; // x10
  double *v159; // x8
  double *v160; // x9
  double *v161; // x8
  double *v162; // x9
  double *v163; // x8
  void *v164; // x1
  __int64 v165; // x8
  unsigned int *v166; // x8
  unsigned int v167; // w9
  unsigned int v168; // w9
  int v169; // w8
  __int64 v170; // x8
  __int64 v171; // x9
  int v172; // v0.s[1]
  __int128 v173; // q1
  cv *v174; // x0
  int v175; // w8
  unsigned int *v176; // x8
  unsigned int v177; // w9
  unsigned int v178; // w9
  __int64 v179; // x9
  __int64 v180; // x8
  __int64 v181; // x9
  unsigned int *v182; // x8
  unsigned int v183; // w9
  unsigned int v184; // w9
  _BYTE *v185; // x8
  __int64 v186; // x9
  void *v187; // x1
  void *v188; // x1
  unsigned int *v189; // x8
  unsigned int v190; // w9
  unsigned int v191; // w9
  __int64 v192; // x8
  __int64 v193; // x9
  unsigned int *v194; // x8
  unsigned int v195; // w9
  unsigned int v196; // w9
  __int64 v197; // x8
  __int64 v198; // x9
  unsigned int *v199; // x8
  unsigned int v200; // w9
  unsigned int v201; // w9
  _QWORD *v202; // x8
  __int64 v203; // x9
  unsigned int *v204; // x8
  unsigned int v205; // w9
  unsigned int v206; // w9
  __int64 v207; // x8
  __int64 i; // x9
  unsigned int *v209; // x8
  unsigned int v210; // w9
  unsigned int v211; // w9
  __int64 v212; // x8
  __int64 v213; // x9
  unsigned int *v214; // x8
  unsigned int v215; // w9
  unsigned int v216; // w9
  __int64 v217; // x8
  __int64 v218; // x9
  unsigned int *v219; // x8
  unsigned int v220; // w9
  unsigned int v221; // w9
  __int64 v222; // x8
  __int64 v223; // x9
  unsigned int *v224; // x8
  unsigned int v225; // w9
  unsigned int v226; // w9
  __int64 v227; // x8
  __int64 j; // x9
  unsigned int *v229; // x8
  unsigned int v230; // w9
  unsigned int v231; // w9
  __int64 v232; // x8
  __int64 k; // x9
  unsigned int *v234; // x8
  unsigned int v235; // w9
  unsigned int v236; // w9
  _QWORD *v237; // x8
  __int64 v238; // x9
  unsigned int *v239; // x8
  unsigned int v240; // w9
  unsigned int v241; // w9
  __int64 v242; // x8
  __int64 m; // x9
  unsigned int *v244; // x8
  unsigned int v245; // w9
  unsigned int v246; // w9
  __int64 v247; // x8
  __int64 n; // x9
  unsigned int *v249; // x8
  unsigned int v250; // w9
  unsigned int v251; // w9
  __int64 v252; // x8
  __int64 ii; // x9
  double v255; // [xsp+38h] [xbp-988h]
  float v256; // [xsp+44h] [xbp-97Ch]
  cv::Mat *v257; // [xsp+58h] [xbp-968h] BYREF
  __int64 v258; // [xsp+60h] [xbp-960h]
  double *v259; // [xsp+68h] [xbp-958h]
  __int64 v260; // [xsp+70h] [xbp-950h]
  unsigned __int64 v261; // [xsp+78h] [xbp-948h]
  int v262[2]; // [xsp+80h] [xbp-940h] BYREF
  cv::Mat *v263; // [xsp+88h] [xbp-938h] BYREF
  __int64 v264; // [xsp+90h] [xbp-930h]
  double *v265; // [xsp+98h] [xbp-928h]
  __int64 v266; // [xsp+A0h] [xbp-920h]
  unsigned __int64 v267; // [xsp+A8h] [xbp-918h]
  _BYTE v268[64]; // [xsp+B0h] [xbp-910h] BYREF
  _BYTE *v269; // [xsp+F0h] [xbp-8D0h]
  cv *v270; // [xsp+F8h] [xbp-8C8h]
  __int64 v271; // [xsp+100h] [xbp-8C0h] BYREF
  __int64 v272; // [xsp+108h] [xbp-8B8h]
  _BYTE v273[64]; // [xsp+110h] [xbp-8B0h] BYREF
  __int128 v274; // [xsp+150h] [xbp-870h]
  __int64 v275; // [xsp+160h] [xbp-860h] BYREF
  __int64 v276; // [xsp+168h] [xbp-858h]
  _QWORD v277[8]; // [xsp+178h] [xbp-848h] BYREF
  _QWORD *v278; // [xsp+1B8h] [xbp-808h]
  cv *v279; // [xsp+1C0h] [xbp-800h]
  __int64 v280[2]; // [xsp+1C8h] [xbp-7F8h] BYREF
  __int64 v281[3]; // [xsp+1D8h] [xbp-7E8h] BYREF
  char v282[4]; // [xsp+1F0h] [xbp-7D0h] BYREF
  int v283; // [xsp+1F4h] [xbp-7CCh]
  __int128 v284; // [xsp+200h] [xbp-7C0h]
  __int128 v285; // [xsp+210h] [xbp-7B0h]
  __int64 v286; // [xsp+228h] [xbp-798h]
  __int64 v287; // [xsp+230h] [xbp-790h]
  cv *v288; // [xsp+238h] [xbp-788h]
  __int64 v289; // [xsp+240h] [xbp-780h] BYREF
  __int64 v290[3]; // [xsp+250h] [xbp-770h] BYREF
  cv::Mat *v291; // [xsp+268h] [xbp-758h] BYREF
  __int64 v292; // [xsp+270h] [xbp-750h]
  __int128 v293; // [xsp+278h] [xbp-748h]
  __int128 v294; // [xsp+288h] [xbp-738h]
  __int64 v295; // [xsp+2A0h] [xbp-720h]
  __int64 v296; // [xsp+2A8h] [xbp-718h]
  cv *v297; // [xsp+2B0h] [xbp-710h]
  __int64 v298; // [xsp+2B8h] [xbp-708h] BYREF
  __int64 v299[3]; // [xsp+2C8h] [xbp-6F8h] BYREF
  cv::Mat *v300; // [xsp+2E0h] [xbp-6E0h] BYREF
  __int64 v301; // [xsp+2E8h] [xbp-6D8h]
  __int128 v302; // [xsp+2F0h] [xbp-6D0h]
  __int128 v303; // [xsp+300h] [xbp-6C0h]
  __int64 v304; // [xsp+318h] [xbp-6A8h]
  __int64 v305; // [xsp+320h] [xbp-6A0h]
  cv *v306; // [xsp+328h] [xbp-698h]
  __int64 v307; // [xsp+330h] [xbp-690h] BYREF
  __int128 v308; // [xsp+340h] [xbp-680h] BYREF
  __int128 v309; // [xsp+350h] [xbp-670h]
  __int128 v310; // [xsp+360h] [xbp-660h]
  __int128 v311; // [xsp+370h] [xbp-650h]
  __int128 v312; // [xsp+380h] [xbp-640h]
  __int64 v313; // [xsp+390h] [xbp-630h] BYREF
  __int64 v314; // [xsp+398h] [xbp-628h]
  __int64 v315[3]; // [xsp+3A0h] [xbp-620h] BYREF
  char v316[4]; // [xsp+3B8h] [xbp-608h] BYREF
  int v317; // [xsp+3BCh] [xbp-604h]
  __int128 v318; // [xsp+3C8h] [xbp-5F8h]
  __int128 v319; // [xsp+3D8h] [xbp-5E8h]
  __int64 v320; // [xsp+3F0h] [xbp-5D0h]
  __int64 v321; // [xsp+3F8h] [xbp-5C8h]
  cv *v322; // [xsp+400h] [xbp-5C0h]
  __int64 v323; // [xsp+408h] [xbp-5B8h] BYREF
  __int64 v324[3]; // [xsp+418h] [xbp-5A8h] BYREF
  char v325[4]; // [xsp+430h] [xbp-590h] BYREF
  int v326; // [xsp+434h] [xbp-58Ch]
  __int128 v327; // [xsp+440h] [xbp-580h]
  __int128 v328; // [xsp+450h] [xbp-570h]
  __int64 v329; // [xsp+468h] [xbp-558h]
  __int64 v330; // [xsp+470h] [xbp-550h]
  cv *v331; // [xsp+478h] [xbp-548h]
  __int64 v332; // [xsp+480h] [xbp-540h] BYREF
  _BYTE v333[64]; // [xsp+490h] [xbp-530h] BYREF
  __int128 v334; // [xsp+4D0h] [xbp-4F0h]
  __int64 v335; // [xsp+4E0h] [xbp-4E0h] BYREF
  __int64 v336; // [xsp+4E8h] [xbp-4D8h]
  _BYTE v337[64]; // [xsp+5F0h] [xbp-3D0h] BYREF
  __int128 v338; // [xsp+630h] [xbp-390h]
  __int64 v339; // [xsp+640h] [xbp-380h] BYREF
  __int64 v340; // [xsp+648h] [xbp-378h]
  _QWORD v341[8]; // [xsp+750h] [xbp-270h] BYREF
  _QWORD *v342; // [xsp+790h] [xbp-230h]
  cv *v343; // [xsp+798h] [xbp-228h]
  __int64 v344[2]; // [xsp+7A0h] [xbp-220h] BYREF
  __int64 v345[3]; // [xsp+7B0h] [xbp-210h] BYREF
  char v346; // [xsp+7C8h] [xbp-1F8h] BYREF
  int v347; // [xsp+7CCh] [xbp-1F4h]
  __int128 v348; // [xsp+7D8h] [xbp-1E8h]
  __int128 v349; // [xsp+7E8h] [xbp-1D8h]
  __int64 v350; // [xsp+800h] [xbp-1C0h]
  __int64 v351; // [xsp+808h] [xbp-1B8h]
  cv *v352; // [xsp+810h] [xbp-1B0h]
  __int64 v353; // [xsp+818h] [xbp-1A8h] BYREF
  __int64 v354[3]; // [xsp+828h] [xbp-198h] BYREF
  char v355[4]; // [xsp+840h] [xbp-180h] BYREF
  int v356; // [xsp+844h] [xbp-17Ch]
  __int128 v357; // [xsp+850h] [xbp-170h]
  __int128 v358; // [xsp+860h] [xbp-160h]
  __int64 v359; // [xsp+878h] [xbp-148h]
  __int64 v360; // [xsp+880h] [xbp-140h]
  cv *v361; // [xsp+888h] [xbp-138h]
  __int64 v362; // [xsp+890h] [xbp-130h] BYREF
  __int64 v363[3]; // [xsp+8A0h] [xbp-120h] BYREF
  char v364[4]; // [xsp+8B8h] [xbp-108h] BYREF
  int v365; // [xsp+8BCh] [xbp-104h]
  __int128 v366; // [xsp+8C8h] [xbp-F8h]
  __int128 v367; // [xsp+8D8h] [xbp-E8h]
  __int64 v368; // [xsp+8F0h] [xbp-D0h]
  __int64 v369; // [xsp+8F8h] [xbp-C8h]
  cv *v370; // [xsp+900h] [xbp-C0h]
  __int64 v371; // [xsp+908h] [xbp-B8h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v7 = a2->n64_f32[0];
  v6 = a2->n64_f32[1];
  if ( v6 >= 0.0 )
  {
    v8 = a2[1].n64_u64[0];
  }
  else
  {
    v7 = -v7;
    v6 = -v6;
    v8 = vneg_f32(a2[1]).n64_u64[0];
  }
  v9 = v7;
  v10 = v6;
  v11 = 1.0 / sqrt((float)((float)((float)(v7 * v7) + (float)(v6 * v6)) + vmuls_n_f32(*(float *)&v8, *(float *)&v8)));
  v12 = v11 * v7;
  v13 = v11 * v6;
  v14 = v11 * *(float *)&v8;
  v15 = v12 * v12 + v13 * v13;
  if ( sqrt(v15 + (v14 + -1.0) * (v14 + -1.0)) < 0.000001 )
    return 0LL;
  v16 = v12 * 0.0;
  v17 = v13 * 0.0;
  v18 = v13 - v14 * 0.0;
  v19 = v14 * 0.0 - v12;
  v20 = sqrt((v16 - v17) * (v16 - v17) + v18 * v18 + v19 * v19) + 2.22507386e-308;
  v21 = v19 * (1.0 / v20);
  v255 = *(float *)&v8;
  v256 = *((float *)&v8 + 1);
  v22 = acos(
          ((v16 - v17) * (1.0 / v20) * 0.0 + v18 * (1.0 / v20) + v21 * 0.0)
        / (sqrt(
             (v16 - v17) * (1.0 / v20) * ((v16 - v17) * (1.0 / v20))
           + v18 * (1.0 / v20) * (v18 * (1.0 / v20))
           + v21 * v21)
         + 2.22507386e-308));
  if ( v21 <= 0.0 )
    v23 = v22;
  else
    v23 = -v22;
  v363[1] = 0LL;
  v363[0] = 0LL;
  v363[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v363, v23, (__int64)v364);
  v354[1] = 0LL;
  v354[0] = 0LL;
  v354[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v354, -3.14159265, (__int64)v355);
  v24 = acos((v14 + v16 + v17) / sqrt(v14 * v14 + v15) + 2.22507386e-308);
  v345[0] = 0x3FF0000000000000LL;
  v345[2] = 0LL;
  v345[1] = 0LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v345, -v24, (__int64)&v346);
  cv::operator*(v333, &v346, v355);
  cv::operator*(v337, v333, v364);
  LODWORD(v341[0]) = 1124007936;
  memset((char *)v341 + 4, 0, 60);
  v342 = &v341[1];
  v343 = (cv *)v344;
  v344[1] = 0LL;
  v344[0] = 0LL;
  (*(void (__fastcall **)(_QWORD, _BYTE *, _QWORD *, __int64))(**(_QWORD **)v337 + 24LL))(
    *(_QWORD *)v337,
    v337,
    v341,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v337, v25);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v333, v26);
  v324[0] = 0x3FF0000000000000LL;
  v324[2] = 0LL;
  v324[1] = 0LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v324, 3.14159265, (__int64)v325);
  v315[1] = 0LL;
  v315[0] = 0LL;
  v315[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v315, -1.57079633, (__int64)v316);
  cv::operator*(v333, v325, v316);
  cv::operator*(v337, v333, v341);
  (*(void (__fastcall **)(_QWORD, _BYTE *, _QWORD *, __int64))(**(_QWORD **)v337 + 24LL))(
    *(_QWORD *)v337,
    v337,
    v341,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v337, v27);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v333, v28);
  *(_DWORD *)v333 = 1124007936;
  memset(&v333[4], 0, 60);
  *(_QWORD *)&v334 = &v333[8];
  *((_QWORD *)&v334 + 1) = &v335;
  v336 = 0LL;
  v335 = 0LL;
  *(_QWORD *)v262 = 0x100000003LL;
  cv::Mat::create((cv::Mat *)v333, 2, v262, 6);
  v300 = (cv::Mat *)v333;
  if ( *(int *)&v333[4] < 1 )
    v29 = 0LL;
  else
    v29 = *(_QWORD *)(*((_QWORD *)&v334 + 1) + 8LL * (*(_DWORD *)&v333[4] - 1));
  v301 = v29;
  *(_QWORD *)&v303 = 0LL;
  v302 = 0uLL;
  if ( (v333[1] & 0x40) != 0 )
  {
    *((_QWORD *)&v302 + 1) = *(_QWORD *)&v333[16];
    if ( *(int *)&v333[4] >= 3 )
    {
      if ( *(_DWORD *)&v333[4] == 3 )
      {
        v31 = 0LL;
        v30 = 1LL;
      }
      else
      {
        v31 = *(_DWORD *)&v333[4] & 0xFFFFFFFC;
        v32 = vdupq_n_s64(1uLL);
        v33 = (_QWORD *)(v334 + 8);
        v34 = v31;
        v35 = v32;
        do
        {
          v36 = *(v33 - 1);
          v32.n128_u64[0] *= (int)v36;
          v35.n128_u64[0] *= (int)*v33;
          v34 -= 4LL;
          v32.n128_u64[1] *= SHIDWORD(v36);
          v35.n128_u64[1] *= (int)HIDWORD(*v33);
          v33 += 2;
        }
        while ( v34 );
        v30 = v35.n128_u64[0] * v32.n128_u64[0] * v35.n128_u64[1] * v32.n128_u64[1];
        if ( v31 == *(unsigned int *)&v333[4] )
          goto LABEL_21;
      }
      v37 = *(unsigned int *)&v333[4] - v31;
      v38 = (int *)(v334 + 4 * v31);
      do
      {
        v39 = *v38++;
        --v37;
        v30 *= v39;
      }
      while ( v37 );
    }
    else
    {
      v30 = *(int *)&v333[12] * (__int64)*(int *)&v333[8];
    }
LABEL_21:
    *(_QWORD *)&v303 = *(_QWORD *)&v333[16] + v30 * v29;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v300, 0LL, 0);
  v40 = (double *)v302;
  *(_QWORD *)v302 = 0LL;
  v41 = v300;
  if ( v300 )
  {
    *(_QWORD *)&v302 = (char *)v40 + v301;
    if ( (unsigned __int64)v40 + v301 >= (unsigned __int64)v303 )
    {
      *(_QWORD *)&v302 = v40;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v300, 1LL, 1);
      v41 = v300;
      v40 = (double *)v302;
    }
    else
    {
      v40 = (double *)((char *)v40 + v301);
    }
  }
  v42 = v301;
  *((_QWORD *)&v293 + 1) = *((_QWORD *)&v302 + 1);
  v43 = v303;
  v44 = fabsf(v256) / sqrt(v9 * v9 + v10 * v10 + v255 * v255);
  v291 = v41;
  v292 = v301;
  *(_QWORD *)&v293 = v40;
  *(_QWORD *)&v294 = v303;
  *v40 = 0.0;
  if ( v41 )
  {
    v45 = (double *)((char *)v40 + v42);
    *(_QWORD *)&v293 = (char *)v40 + v42;
    if ( (unsigned __int64)v40 + v42 >= v43 )
    {
      *(_QWORD *)&v293 = v40;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v291, 1LL, 1);
      v45 = (double *)v293;
      v41 = v291;
    }
    *v45 = -v44 / cos(v24);
    if ( v41 )
    {
      *(_QWORD *)&v293 = (char *)v45 + v292;
      if ( (unsigned __int64)v45 + v292 >= (unsigned __int64)v294 )
      {
        *(_QWORD *)&v293 = v45;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v291, 1LL, 1);
        v41 = v291;
      }
    }
  }
  else
  {
    *v40 = -v44 / cos(v24);
  }
  memset(&v337[4], 0, 60);
  *(_QWORD *)&v338 = &v337[8];
  *((_QWORD *)&v338 + 1) = &v339;
  v340 = 0LL;
  v339 = 0LL;
  *(_DWORD *)v337 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v337, v41);
  v309 = *(_OWORD *)&v337[16];
  v310 = *(_OWORD *)&v337[32];
  v308 = *(_OWORD *)v337;
  v311 = *(_OWORD *)&v337[48];
  *(_QWORD *)&v312 = (char *)&v308 + 8;
  *((_QWORD *)&v312 + 1) = &v313;
  v314 = 0LL;
  v313 = 0LL;
  if ( *(int *)&v337[4] > 2 )
  {
    v48 = v338;
    v47 = (cv *)&v339;
    *((_QWORD *)&v338 + 1) = &v339;
    *(_QWORD *)&v338 = &v337[8];
    v312 = v48;
  }
  else
  {
    v47 = (cv *)*((_QWORD *)&v338 + 1);
    v313 = **((_QWORD **)&v338 + 1);
    v314 = *(_QWORD *)(*((_QWORD *)&v338 + 1) + 8LL);
  }
  *(_DWORD *)v337 = 1124007936;
  memset(&v337[4], 0, 60);
  if ( v47 != (cv *)&v339 )
    cv::fastFree(v47, v46);
  if ( *(_QWORD *)&v333[56] )
  {
    v49 = (unsigned int *)(*(_QWORD *)&v333[56] + 20LL);
    do
    {
      v50 = __ldaxr(v49);
      v51 = v50 - 1;
    }
    while ( __stlxr(v51, v49) );
    if ( !v51 )
      cv::Mat::deallocate((cv::Mat *)v333);
  }
  *(_QWORD *)&v333[56] = 0LL;
  memset(&v333[16], 0, 32);
  if ( *(int *)&v333[4] >= 1 )
  {
    v52 = v334;
    v53 = 0LL;
    do
      *(_DWORD *)(v52 + 4 * v53++) = 0;
    while ( v53 < *(int *)&v333[4] );
  }
  if ( *((__int64 **)&v334 + 1) != &v335 )
    cv::fastFree(*((cv **)&v334 + 1), v46);
  v299[1] = 0LL;
  v299[0] = 0LL;
  v299[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v299, -v23, (__int64)&v300);
  v290[1] = 0LL;
  v290[0] = 0LL;
  v290[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v290, 3.14159265, (__int64)&v291);
  v281[0] = 0x3FF0000000000000LL;
  v281[1] = 0LL;
  v281[2] = 0LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v281, v24, (__int64)v282);
  cv::operator*(v333, &v300, &v291);
  cv::operator*(v337, v333, v282);
  LODWORD(v277[0]) = 1124007936;
  memset((char *)v277 + 4, 0, 60);
  v278 = &v277[1];
  v279 = (cv *)v280;
  v280[0] = 0LL;
  v280[1] = 0LL;
  (*(void (__fastcall **)(_QWORD, _BYTE *, _QWORD *, __int64))(**(_QWORD **)v337 + 24LL))(
    *(_QWORD *)v337,
    v337,
    v277,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v337, v54);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v333, v55);
  *(_DWORD *)v273 = 1124007936;
  memset(&v273[4], 0, 60);
  *(_QWORD *)&v274 = &v273[8];
  *((_QWORD *)&v274 + 1) = &v275;
  v275 = 0LL;
  v276 = 0LL;
  *(_QWORD *)v262 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v273, 2, v262, 6);
  v56 = *(_QWORD *)v277[2];
  *(_QWORD *)v268 = v273;
  if ( *(int *)&v273[4] < 1 )
    v57 = 0LL;
  else
    v57 = *(_QWORD *)(*((_QWORD *)&v274 + 1) + 8LL * (*(_DWORD *)&v273[4] - 1));
  *(_QWORD *)&v268[8] = v57;
  memset(&v268[16], 0, 24);
  if ( (v273[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v268[24] = *(_QWORD *)&v273[16];
    if ( *(int *)&v273[4] >= 3 )
    {
      if ( *(_DWORD *)&v273[4] == 3 )
      {
        v59 = 0LL;
        v58 = 1LL;
      }
      else
      {
        v59 = *(_DWORD *)&v273[4] & 0xFFFFFFFC;
        v60 = vdupq_n_s64(1uLL);
        v61 = (_QWORD *)(v274 + 8);
        v62 = v59;
        v63 = v60;
        do
        {
          v64 = *(v61 - 1);
          v60.n128_u64[0] *= (int)v64;
          v63.n128_u64[0] *= (int)*v61;
          v62 -= 4LL;
          v60.n128_u64[1] *= SHIDWORD(v64);
          v63.n128_u64[1] *= (int)HIDWORD(*v61);
          v61 += 2;
        }
        while ( v62 );
        v58 = v63.n128_u64[0] * v60.n128_u64[0] * v63.n128_u64[1] * v60.n128_u64[1];
        if ( v59 == *(unsigned int *)&v273[4] )
          goto LABEL_61;
      }
      v65 = *(unsigned int *)&v273[4] - v59;
      v66 = (int *)(v274 + 4 * v59);
      do
      {
        v67 = *v66++;
        --v65;
        v58 *= v67;
      }
      while ( v65 );
    }
    else
    {
      v58 = *(int *)&v273[12] * (__int64)*(int *)&v273[8];
    }
LABEL_61:
    *(_QWORD *)&v268[32] = *(_QWORD *)&v273[16] + v58 * v57;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v268, 0LL, 0);
  v68 = *(double **)&v268[16];
  **(_QWORD **)&v268[16] = v56;
  v69 = *(cv::Mat **)v268;
  if ( *(_QWORD *)v268 )
  {
    *(_QWORD *)&v268[16] = (char *)v68 + *(_QWORD *)&v268[8];
    if ( (unsigned __int64)v68 + *(_QWORD *)&v268[8] >= *(_QWORD *)&v268[32] )
    {
      *(_QWORD *)&v268[16] = v68;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v268, 1LL, 1);
      v69 = *(cv::Mat **)v268;
      v68 = *(double **)&v268[16];
    }
    else
    {
      v68 = (double *)((char *)v68 + *(_QWORD *)&v268[8]);
    }
  }
  v70 = *(_QWORD *)&v268[8];
  v71 = *(_QWORD *)&v268[32];
  v72 = v277[2];
  v263 = v69;
  v264 = *(_QWORD *)&v268[8];
  v265 = v68;
  v266 = *(_QWORD *)&v268[24];
  v267 = *(_QWORD *)&v268[32];
  *v68 = *(double *)(v277[2] + 8LL);
  if ( !v69 )
  {
    *v68 = 0.0;
    goto LABEL_78;
  }
  v73 = (double *)((char *)v68 + v70);
  v265 = v73;
  if ( (unsigned __int64)v73 >= v71 )
  {
    v265 = v68;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v72 = v277[2];
    v73 = v265;
    v69 = v263;
  }
  *v73 = *(double *)(v72 + 16);
  if ( !v69 )
  {
    v74 = v73;
    *v73 = 0.0;
LABEL_77:
    v68 = v74;
    goto LABEL_78;
  }
  v74 = (double *)((char *)v73 + v264);
  v265 = (double *)((char *)v73 + v264);
  if ( (unsigned __int64)v73 + v264 >= v267 )
  {
    v265 = v73;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v74 = v265;
    v69 = v263;
  }
  *v74 = 0.0;
  if ( !v69 )
    goto LABEL_77;
  v68 = (double *)((char *)v74 + v264);
  v265 = (double *)((char *)v74 + v264);
  if ( (unsigned __int64)v74 + v264 >= v267 )
  {
    v265 = v74;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v68 = v265;
    v69 = v263;
  }
LABEL_78:
  v75 = v277[2];
  *v68 = *(double *)(v277[2] + *(_QWORD *)v279);
  if ( v69 )
  {
    v76 = (double *)((char *)v68 + v264);
    v265 = (double *)((char *)v68 + v264);
    if ( (unsigned __int64)v68 + v264 >= v267 )
    {
      v265 = v68;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v75 = v277[2];
      v76 = v265;
      v69 = v263;
    }
  }
  else
  {
    v76 = v68;
  }
  *v76 = *(double *)(v75 + *(_QWORD *)v279 + 8);
  if ( v69 )
  {
    v77 = (double *)((char *)v76 + v264);
    v265 = (double *)((char *)v76 + v264);
    if ( (unsigned __int64)v76 + v264 >= v267 )
    {
      v265 = v76;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v75 = v277[2];
      v77 = v265;
      v69 = v263;
    }
  }
  else
  {
    v77 = v76;
  }
  *v77 = *(double *)(v75 + *(_QWORD *)v279 + 16);
  if ( !v69 )
  {
    v78 = v77;
    *v77 = 0.0;
LABEL_93:
    v79 = v78;
    goto LABEL_94;
  }
  v78 = (double *)((char *)v77 + v264);
  v265 = (double *)((char *)v77 + v264);
  if ( (unsigned __int64)v77 + v264 >= v267 )
  {
    v265 = v77;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v78 = v265;
    v69 = v263;
  }
  *v78 = 0.0;
  if ( !v69 )
    goto LABEL_93;
  v79 = (double *)((char *)v78 + v264);
  v265 = (double *)((char *)v78 + v264);
  if ( (unsigned __int64)v78 + v264 >= v267 )
  {
    v265 = v78;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v79 = v265;
    v69 = v263;
  }
LABEL_94:
  v80 = v277[2];
  *v79 = *(double *)(v277[2] + 2LL * *(_QWORD *)v279);
  if ( v69 )
  {
    v81 = (double *)((char *)v79 + v264);
    v265 = (double *)((char *)v79 + v264);
    if ( (unsigned __int64)v79 + v264 >= v267 )
    {
      v265 = v79;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v80 = v277[2];
      v81 = v265;
      v69 = v263;
    }
  }
  else
  {
    v81 = v79;
  }
  *v81 = *(double *)(v80 + 2LL * *(_QWORD *)v279 + 8);
  if ( v69 )
  {
    v82 = (double *)((char *)v81 + v264);
    v265 = (double *)((char *)v81 + v264);
    if ( (unsigned __int64)v81 + v264 >= v267 )
    {
      v265 = v81;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v80 = v277[2];
      v82 = v265;
      v69 = v263;
    }
  }
  else
  {
    v82 = v81;
  }
  *v82 = *(double *)(v80 + 2LL * *(_QWORD *)v279 + 16);
  if ( !v69 )
  {
    v83 = v82;
    *v82 = 0.0;
LABEL_118:
    v84 = v83;
    *v83 = 0.0;
LABEL_119:
    v85 = v84;
    *v84 = 0.0;
LABEL_120:
    v86 = v85;
    *v85 = 0.0;
LABEL_121:
    v87 = v86;
    goto LABEL_122;
  }
  v83 = (double *)((char *)v82 + v264);
  v265 = (double *)((char *)v82 + v264);
  if ( (unsigned __int64)v82 + v264 >= v267 )
  {
    v265 = v82;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v83 = v265;
    v69 = v263;
  }
  *v83 = 0.0;
  if ( !v69 )
    goto LABEL_118;
  v84 = (double *)((char *)v83 + v264);
  v265 = (double *)((char *)v83 + v264);
  if ( (unsigned __int64)v83 + v264 >= v267 )
  {
    v265 = v83;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v84 = v265;
    v69 = v263;
  }
  *v84 = 0.0;
  if ( !v69 )
    goto LABEL_119;
  v85 = (double *)((char *)v84 + v264);
  v265 = (double *)((char *)v84 + v264);
  if ( (unsigned __int64)v84 + v264 >= v267 )
  {
    v265 = v84;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v85 = v265;
    v69 = v263;
  }
  *v85 = 0.0;
  if ( !v69 )
    goto LABEL_120;
  v86 = (double *)((char *)v85 + v264);
  v265 = (double *)((char *)v85 + v264);
  if ( (unsigned __int64)v85 + v264 >= v267 )
  {
    v265 = v85;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v86 = v265;
    v69 = v263;
  }
  *v86 = 0.0;
  if ( !v69 )
    goto LABEL_121;
  v87 = (double *)((char *)v86 + v264);
  v265 = (double *)((char *)v86 + v264);
  if ( (unsigned __int64)v86 + v264 >= v267 )
  {
    v265 = v86;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
    v87 = v265;
    v69 = v263;
  }
LABEL_122:
  *v87 = 1.0;
  if ( v69 )
  {
    v265 = (double *)((char *)v87 + v264);
    if ( (unsigned __int64)v87 + v264 >= v267 )
    {
      v265 = v87;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v69 = v263;
    }
  }
  memset(&v337[4], 0, 60);
  *(_QWORD *)&v338 = &v337[8];
  *((_QWORD *)&v338 + 1) = &v339;
  v340 = 0LL;
  v339 = 0LL;
  *(_DWORD *)v337 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v337, v69);
  *(_OWORD *)&v333[16] = *(_OWORD *)&v337[16];
  *(_OWORD *)&v333[32] = *(_OWORD *)&v337[32];
  *(_OWORD *)v333 = *(_OWORD *)v337;
  *(_OWORD *)&v333[48] = *(_OWORD *)&v337[48];
  *(_QWORD *)&v334 = &v333[8];
  *((_QWORD *)&v334 + 1) = &v335;
  v336 = 0LL;
  v335 = 0LL;
  if ( *(int *)&v337[4] > 2 )
  {
    v90 = v338;
    v89 = (cv *)&v339;
    *((_QWORD *)&v338 + 1) = &v339;
    *(_QWORD *)&v338 = &v337[8];
    v334 = v90;
  }
  else
  {
    v89 = (cv *)*((_QWORD *)&v338 + 1);
    v335 = **((_QWORD **)&v338 + 1);
    v336 = *(_QWORD *)(*((_QWORD *)&v338 + 1) + 8LL);
  }
  *(_DWORD *)v337 = 1124007936;
  memset(&v337[4], 0, 60);
  if ( v89 != (cv *)&v339 )
    cv::fastFree(v89, v88);
  if ( *(_QWORD *)&v273[56] )
  {
    v91 = (unsigned int *)(*(_QWORD *)&v273[56] + 20LL);
    do
    {
      v92 = __ldaxr(v91);
      v93 = v92 - 1;
    }
    while ( __stlxr(v93, v91) );
    if ( !v93 )
      cv::Mat::deallocate((cv::Mat *)v273);
  }
  *(_QWORD *)&v273[56] = 0LL;
  memset(&v273[16], 0, 32);
  if ( *(int *)&v273[4] >= 1 )
  {
    v94 = v274;
    v95 = 0LL;
    do
      *(_DWORD *)(v94 + 4 * v95++) = 0;
    while ( v95 < *(int *)&v273[4] );
  }
  if ( *((__int64 **)&v274 + 1) != &v275 )
    cv::fastFree(*((cv **)&v274 + 1), v88);
  *(_DWORD *)v268 = 1124007936;
  memset(&v268[4], 0, 60);
  v269 = &v268[8];
  v270 = (cv *)&v271;
  v271 = 0LL;
  v272 = 0LL;
  *(_QWORD *)v262 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v268, 2, v262, 6);
  v263 = (cv::Mat *)v268;
  if ( *(int *)&v268[4] < 1 )
    v96 = 0LL;
  else
    v96 = *((_QWORD *)v270 + *(_DWORD *)&v268[4] - 1);
  v264 = v96;
  v265 = 0LL;
  v266 = 0LL;
  v267 = 0LL;
  if ( (v268[1] & 0x40) != 0 )
  {
    v266 = *(_QWORD *)&v268[16];
    if ( *(int *)&v268[4] >= 3 )
    {
      if ( *(_DWORD *)&v268[4] == 3 )
      {
        v98 = 0LL;
        v97 = 1LL;
      }
      else
      {
        v98 = *(_DWORD *)&v268[4] & 0xFFFFFFFC;
        v99 = vdupq_n_s64(1uLL);
        v100 = v269 + 8;
        v101 = v98;
        v102 = v99;
        do
        {
          v103 = *(v100 - 1);
          v99.n128_u64[0] *= (int)v103;
          v102.n128_u64[0] *= (int)*v100;
          v101 -= 4LL;
          v99.n128_u64[1] *= SHIDWORD(v103);
          v102.n128_u64[1] *= (int)HIDWORD(*v100);
          v100 += 2;
        }
        while ( v101 );
        v97 = v102.n128_u64[0] * v99.n128_u64[0] * v102.n128_u64[1] * v99.n128_u64[1];
        if ( v98 == *(unsigned int *)&v268[4] )
          goto LABEL_153;
      }
      v104 = *(unsigned int *)&v268[4] - v98;
      v105 = (int *)&v269[4 * v98];
      do
      {
        v106 = *v105++;
        --v104;
        v97 *= v106;
      }
      while ( v104 );
    }
    else
    {
      v97 = *(int *)&v268[12] * (__int64)*(int *)&v268[8];
    }
LABEL_153:
    v267 = *(_QWORD *)&v268[16] + v97 * v96;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 0LL, 0);
  v107 = v265;
  *v265 = 1.0;
  v108 = v263;
  if ( v263 )
  {
    v265 = (double *)((char *)v107 + v264);
    if ( (unsigned __int64)v107 + v264 >= v267 )
    {
      v265 = v107;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v108 = v263;
      v107 = v265;
    }
    else
    {
      v107 = (double *)((char *)v107 + v264);
    }
  }
  v109 = v264;
  v110 = v267;
  v257 = v108;
  v258 = v264;
  v259 = v107;
  v260 = v266;
  v261 = v267;
  *v107 = 0.0;
  if ( !v108 )
  {
    *v107 = 0.0;
    goto LABEL_182;
  }
  v111 = (double *)((char *)v107 + v109);
  v259 = v111;
  if ( (unsigned __int64)v111 >= v110 )
  {
    v259 = v107;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v111 = v259;
    v108 = v257;
  }
  *v111 = 0.0;
  if ( v108 )
  {
    v112 = (double *)((char *)v111 + v258);
    v259 = (double *)((char *)v111 + v258);
    if ( (unsigned __int64)v111 + v258 >= v261 )
    {
      v259 = v111;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v112 = v259;
      v108 = v257;
    }
  }
  else
  {
    v112 = v111;
  }
  *v112 = -*(double *)v309;
  if ( !v108 )
  {
    v113 = v112;
    *v112 = 0.0;
LABEL_173:
    v114 = v113;
    goto LABEL_174;
  }
  v113 = (double *)((char *)v112 + v258);
  v259 = (double *)((char *)v112 + v258);
  if ( (unsigned __int64)v112 + v258 >= v261 )
  {
    v259 = v112;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v113 = v259;
    v108 = v257;
  }
  *v113 = 0.0;
  if ( !v108 )
    goto LABEL_173;
  v114 = (double *)((char *)v113 + v258);
  v259 = (double *)((char *)v113 + v258);
  if ( (unsigned __int64)v113 + v258 >= v261 )
  {
    v259 = v113;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v114 = v259;
    v108 = v257;
  }
LABEL_174:
  *v114 = 1.0;
  if ( !v108 )
  {
    v115 = v114;
    *v114 = 0.0;
LABEL_181:
    v107 = v115;
    goto LABEL_182;
  }
  v115 = (double *)((char *)v114 + v258);
  v259 = (double *)((char *)v114 + v258);
  if ( (unsigned __int64)v114 + v258 >= v261 )
  {
    v259 = v114;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v115 = v259;
    v108 = v257;
  }
  *v115 = 0.0;
  if ( !v108 )
    goto LABEL_181;
  v107 = (double *)((char *)v115 + v258);
  v259 = (double *)((char *)v115 + v258);
  if ( (unsigned __int64)v115 + v258 >= v261 )
  {
    v259 = v115;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v107 = v259;
    v108 = v257;
  }
LABEL_182:
  *v107 = -*(double *)(v309 + **((_QWORD **)&v312 + 1));
  if ( !v108 )
  {
    v116 = v107;
    *v107 = 0.0;
LABEL_192:
    v117 = v116;
    *v116 = 0.0;
LABEL_193:
    v118 = v117;
    goto LABEL_194;
  }
  v116 = (double *)((char *)v107 + v258);
  v259 = (double *)((char *)v107 + v258);
  if ( (unsigned __int64)v107 + v258 >= v261 )
  {
    v259 = v107;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v116 = v259;
    v108 = v257;
  }
  *v116 = 0.0;
  if ( !v108 )
    goto LABEL_192;
  v117 = (double *)((char *)v116 + v258);
  v259 = (double *)((char *)v116 + v258);
  if ( (unsigned __int64)v116 + v258 >= v261 )
  {
    v259 = v116;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v117 = v259;
    v108 = v257;
  }
  *v117 = 0.0;
  if ( !v108 )
    goto LABEL_193;
  v118 = (double *)((char *)v117 + v258);
  v259 = (double *)((char *)v117 + v258);
  if ( (unsigned __int64)v117 + v258 >= v261 )
  {
    v259 = v117;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v118 = v259;
    v108 = v257;
  }
LABEL_194:
  *v118 = 1.0;
  if ( v108 )
  {
    v119 = (double *)((char *)v118 + v258);
    v259 = (double *)((char *)v118 + v258);
    if ( (unsigned __int64)v118 + v258 >= v261 )
    {
      v259 = v118;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v119 = v259;
      v108 = v257;
    }
  }
  else
  {
    v119 = v118;
  }
  *v119 = -*(double *)(v309 + 2LL * **((_QWORD **)&v312 + 1));
  if ( !v108 )
  {
    v120 = v119;
    *v119 = 0.0;
LABEL_211:
    v121 = v120;
    *v120 = 0.0;
LABEL_212:
    v122 = v121;
    *v121 = 0.0;
LABEL_213:
    v123 = v122;
    goto LABEL_214;
  }
  v120 = (double *)((char *)v119 + v258);
  v259 = (double *)((char *)v119 + v258);
  if ( (unsigned __int64)v119 + v258 >= v261 )
  {
    v259 = v119;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v120 = v259;
    v108 = v257;
  }
  *v120 = 0.0;
  if ( !v108 )
    goto LABEL_211;
  v121 = (double *)((char *)v120 + v258);
  v259 = (double *)((char *)v120 + v258);
  if ( (unsigned __int64)v120 + v258 >= v261 )
  {
    v259 = v120;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v121 = v259;
    v108 = v257;
  }
  *v121 = 0.0;
  if ( !v108 )
    goto LABEL_212;
  v122 = (double *)((char *)v121 + v258);
  v259 = (double *)((char *)v121 + v258);
  if ( (unsigned __int64)v121 + v258 >= v261 )
  {
    v259 = v121;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v122 = v259;
    v108 = v257;
  }
  *v122 = 0.0;
  if ( !v108 )
    goto LABEL_213;
  v123 = (double *)((char *)v122 + v258);
  v259 = (double *)((char *)v122 + v258);
  if ( (unsigned __int64)v122 + v258 >= v261 )
  {
    v259 = v122;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v123 = v259;
    v108 = v257;
  }
LABEL_214:
  *v123 = 1.0;
  if ( v108 )
  {
    v259 = (double *)((char *)v123 + v258);
    if ( (unsigned __int64)v123 + v258 >= v261 )
    {
      v259 = v123;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v108 = v257;
    }
  }
  memset(&v337[4], 0, 60);
  *(_QWORD *)&v338 = &v337[8];
  *((_QWORD *)&v338 + 1) = &v339;
  v340 = 0LL;
  v339 = 0LL;
  *(_DWORD *)v337 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v337, v108);
  *(_OWORD *)&v273[16] = *(_OWORD *)&v337[16];
  *(_OWORD *)&v273[32] = *(_OWORD *)&v337[32];
  *(_OWORD *)v273 = *(_OWORD *)v337;
  *(_OWORD *)&v273[48] = *(_OWORD *)&v337[48];
  *(_QWORD *)&v274 = &v273[8];
  *((_QWORD *)&v274 + 1) = &v275;
  v275 = 0LL;
  v276 = 0LL;
  if ( *(int *)&v337[4] > 2 )
  {
    v126 = v338;
    v125 = (cv *)&v339;
    *((_QWORD *)&v338 + 1) = &v339;
    *(_QWORD *)&v338 = &v337[8];
    v274 = v126;
  }
  else
  {
    v125 = (cv *)*((_QWORD *)&v338 + 1);
    v275 = **((_QWORD **)&v338 + 1);
    v276 = *(_QWORD *)(*((_QWORD *)&v338 + 1) + 8LL);
  }
  *(_DWORD *)v337 = 1124007936;
  memset(&v337[4], 0, 60);
  if ( v125 != (cv *)&v339 )
    cv::fastFree(v125, v124);
  if ( *(_QWORD *)&v268[56] )
  {
    v127 = (unsigned int *)(*(_QWORD *)&v268[56] + 20LL);
    do
    {
      v128 = __ldaxr(v127);
      v129 = v128 - 1;
    }
    while ( __stlxr(v129, v127) );
    if ( !v129 )
      cv::Mat::deallocate((cv::Mat *)v268);
  }
  *(_QWORD *)&v268[56] = 0LL;
  memset(&v268[16], 0, 32);
  if ( *(int *)&v268[4] >= 1 )
  {
    v130 = v269;
    v131 = 0LL;
    do
      *(_DWORD *)&v130[4 * v131++] = 0;
    while ( v131 < *(int *)&v268[4] );
  }
  if ( v270 != (cv *)&v271 )
    cv::fastFree(v270, v124);
  *(_DWORD *)v268 = 1124007936;
  memset(&v268[4], 0, 60);
  v269 = &v268[8];
  v270 = (cv *)&v271;
  v271 = 0LL;
  v272 = 0LL;
  *(_QWORD *)v262 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v268, 2, v262, 6);
  v132 = *(_QWORD *)v341[2];
  v263 = (cv::Mat *)v268;
  if ( *(int *)&v268[4] < 1 )
    v133 = 0LL;
  else
    v133 = *((_QWORD *)v270 + *(_DWORD *)&v268[4] - 1);
  v264 = v133;
  v265 = 0LL;
  v266 = 0LL;
  v267 = 0LL;
  if ( (v268[1] & 0x40) != 0 )
  {
    v266 = *(_QWORD *)&v268[16];
    if ( *(int *)&v268[4] >= 3 )
    {
      if ( *(_DWORD *)&v268[4] == 3 )
      {
        v135 = 0LL;
        v134 = 1LL;
      }
      else
      {
        v135 = *(_DWORD *)&v268[4] & 0xFFFFFFFC;
        v136 = vdupq_n_s64(1uLL);
        v137 = v269 + 8;
        v138 = v135;
        v139 = v136;
        do
        {
          v140 = *(v137 - 1);
          v136.n128_u64[0] *= (int)v140;
          v139.n128_u64[0] *= (int)*v137;
          v138 -= 4LL;
          v136.n128_u64[1] *= SHIDWORD(v140);
          v139.n128_u64[1] *= (int)HIDWORD(*v137);
          v137 += 2;
        }
        while ( v138 );
        v134 = v139.n128_u64[0] * v136.n128_u64[0] * v139.n128_u64[1] * v136.n128_u64[1];
        if ( v135 == *(unsigned int *)&v268[4] )
          goto LABEL_245;
      }
      v141 = *(unsigned int *)&v268[4] - v135;
      v142 = (int *)&v269[4 * v135];
      do
      {
        v143 = *v142++;
        --v141;
        v134 *= v143;
      }
      while ( v141 );
    }
    else
    {
      v134 = *(int *)&v268[12] * (__int64)*(int *)&v268[8];
    }
LABEL_245:
    v267 = *(_QWORD *)&v268[16] + v134 * v133;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 0LL, 0);
  v144 = v265;
  *(_QWORD *)v265 = v132;
  v145 = v263;
  if ( v263 )
  {
    v265 = (double *)((char *)v144 + v264);
    if ( (unsigned __int64)v144 + v264 >= v267 )
    {
      v265 = v144;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v263, 1LL, 1);
      v145 = v263;
      v144 = v265;
    }
    else
    {
      v144 = (double *)((char *)v144 + v264);
    }
  }
  v146 = v264;
  v147 = v267;
  v148 = v341[2];
  v257 = v145;
  v258 = v264;
  v259 = v144;
  v260 = v266;
  v261 = v267;
  *v144 = *(double *)(v341[2] + 8LL);
  if ( v145 )
  {
    v149 = (double *)((char *)v144 + v146);
    v259 = v149;
    if ( (unsigned __int64)v149 >= v147 )
    {
      v259 = v144;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v148 = v341[2];
      v149 = v259;
      v145 = v257;
    }
    *v149 = *(double *)(v148 + 16);
    if ( v145 )
    {
      v150 = (double *)((char *)v149 + v258);
      v259 = (double *)((char *)v149 + v258);
      if ( (unsigned __int64)v149 + v258 >= v261 )
      {
        v259 = v149;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
        v150 = v259;
        v145 = v257;
      }
    }
    else
    {
      v150 = v149;
    }
    *v150 = *(double *)v309;
    if ( v145 )
    {
      v144 = (double *)((char *)v150 + v258);
      v259 = (double *)((char *)v150 + v258);
      if ( (unsigned __int64)v150 + v258 >= v261 )
      {
        v259 = v150;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
        v144 = v259;
        v145 = v257;
      }
    }
    else
    {
      v144 = v150;
    }
  }
  else
  {
    *v144 = *(double *)(v148 + 16);
    *v144 = *(double *)v309;
  }
  v151 = v341[2];
  *v144 = *(double *)(v341[2] + *(_QWORD *)v343);
  if ( v145 )
  {
    v152 = (double *)((char *)v144 + v258);
    v259 = (double *)((char *)v144 + v258);
    if ( (unsigned __int64)v144 + v258 >= v261 )
    {
      v259 = v144;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v151 = v341[2];
      v152 = v259;
      v145 = v257;
    }
  }
  else
  {
    v152 = v144;
  }
  *v152 = *(double *)(v151 + *(_QWORD *)v343 + 8);
  if ( v145 )
  {
    v153 = (double *)((char *)v152 + v258);
    v259 = (double *)((char *)v152 + v258);
    if ( (unsigned __int64)v152 + v258 >= v261 )
    {
      v259 = v152;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v151 = v341[2];
      v153 = v259;
      v145 = v257;
    }
  }
  else
  {
    v153 = v152;
  }
  *v153 = *(double *)(v151 + *(_QWORD *)v343 + 16);
  if ( v145 )
  {
    v154 = (double *)((char *)v153 + v258);
    v259 = (double *)((char *)v153 + v258);
    if ( (unsigned __int64)v153 + v258 >= v261 )
    {
      v259 = v153;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v154 = v259;
      v145 = v257;
    }
  }
  else
  {
    v154 = v153;
  }
  *v154 = *(double *)(v309 + **((_QWORD **)&v312 + 1));
  if ( v145 )
  {
    v155 = (double *)((char *)v154 + v258);
    v259 = (double *)((char *)v154 + v258);
    if ( (unsigned __int64)v154 + v258 >= v261 )
    {
      v259 = v154;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v155 = v259;
      v145 = v257;
    }
  }
  else
  {
    v155 = v154;
  }
  v156 = v341[2];
  *v155 = *(double *)(v341[2] + 2LL * *(_QWORD *)v343);
  if ( v145 )
  {
    v157 = (double *)((char *)v155 + v258);
    v259 = (double *)((char *)v155 + v258);
    if ( (unsigned __int64)v155 + v258 >= v261 )
    {
      v259 = v155;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v156 = v341[2];
      v157 = v259;
      v145 = v257;
    }
  }
  else
  {
    v157 = v155;
  }
  *v157 = *(double *)(v156 + 2LL * *(_QWORD *)v343 + 8);
  if ( v145 )
  {
    v158 = (double *)((char *)v157 + v258);
    v259 = (double *)((char *)v157 + v258);
    if ( (unsigned __int64)v157 + v258 >= v261 )
    {
      v259 = v157;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v156 = v341[2];
      v158 = v259;
      v145 = v257;
    }
  }
  else
  {
    v158 = v157;
  }
  *v158 = *(double *)(v156 + 2LL * *(_QWORD *)v343 + 16);
  if ( v145 )
  {
    v159 = (double *)((char *)v158 + v258);
    v259 = (double *)((char *)v158 + v258);
    if ( (unsigned __int64)v158 + v258 >= v261 )
    {
      v259 = v158;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v159 = v259;
      v145 = v257;
    }
  }
  else
  {
    v159 = v158;
  }
  *v159 = *(double *)(v309 + 2LL * **((_QWORD **)&v312 + 1));
  if ( !v145 )
  {
    v160 = v159;
    *v159 = 0.0;
LABEL_303:
    v161 = v160;
    *v160 = 0.0;
LABEL_304:
    v162 = v161;
    *v161 = 0.0;
    goto LABEL_305;
  }
  v160 = (double *)((char *)v159 + v258);
  v259 = (double *)((char *)v159 + v258);
  if ( (unsigned __int64)v159 + v258 >= v261 )
  {
    v259 = v159;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v160 = v259;
    v145 = v257;
  }
  *v160 = 0.0;
  if ( !v145 )
    goto LABEL_303;
  v161 = (double *)((char *)v160 + v258);
  v259 = (double *)((char *)v160 + v258);
  if ( (unsigned __int64)v160 + v258 >= v261 )
  {
    v259 = v160;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v161 = v259;
    v145 = v257;
  }
  *v161 = 0.0;
  if ( !v145 )
    goto LABEL_304;
  v162 = (double *)((char *)v161 + v258);
  v259 = (double *)((char *)v161 + v258);
  if ( (unsigned __int64)v161 + v258 >= v261 )
  {
    v259 = v161;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
    v162 = v259;
    v145 = v257;
  }
  *v162 = 0.0;
  if ( v145 )
  {
    v163 = (double *)((char *)v162 + v258);
    v259 = (double *)((char *)v162 + v258);
    if ( (unsigned __int64)v162 + v258 >= v261 )
    {
      v259 = v162;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v163 = v259;
      v145 = v257;
    }
    goto LABEL_306;
  }
LABEL_305:
  v163 = v162;
LABEL_306:
  *v163 = 1.0;
  if ( v145 )
  {
    v259 = (double *)((char *)v163 + v258);
    if ( (unsigned __int64)v163 + v258 >= v261 )
    {
      v259 = v163;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v257, 1LL, 1);
      v145 = v257;
    }
  }
  memset(&v337[4], 0, 60);
  *(_QWORD *)&v338 = &v337[8];
  *((_QWORD *)&v338 + 1) = &v339;
  v340 = 0LL;
  v339 = 0LL;
  *(_DWORD *)v337 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v337, v145);
  if ( v337 == (_BYTE *)a3 )
  {
    if ( *(_QWORD *)&v337[56] )
    {
      v176 = (unsigned int *)(*(_QWORD *)&v337[56] + 20LL);
      do
      {
        v177 = __ldaxr(v176);
        v178 = v177 - 1;
      }
      while ( __stlxr(v178, v176) );
      if ( !v178 )
        cv::Mat::deallocate((cv::Mat *)v337);
    }
  }
  else
  {
    v165 = *(_QWORD *)(a3 + 56);
    if ( v165 )
    {
      v166 = (unsigned int *)(v165 + 20);
      do
      {
        v167 = __ldaxr(v166);
        v168 = v167 - 1;
      }
      while ( __stlxr(v168, v166) );
      if ( !v168 )
        cv::Mat::deallocate((cv::Mat *)a3);
    }
    v169 = *(_DWORD *)(a3 + 4);
    *(_QWORD *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    if ( v169 >= 1 )
    {
      v170 = *(_QWORD *)(a3 + 64);
      v171 = 0LL;
      do
        *(_DWORD *)(v170 + 4 * v171++) = 0;
      while ( v171 < *(int *)(a3 + 4) );
    }
    v172 = *(_DWORD *)&v337[4];
    v173 = *(_OWORD *)&v337[16];
    v174 = *(cv **)(a3 + 72);
    *(_OWORD *)a3 = *(_OWORD *)v337;
    *(_OWORD *)(a3 + 16) = v173;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v337[32];
    *(_OWORD *)(a3 + 48) = *(_OWORD *)&v337[48];
    if ( v174 == (cv *)(a3 + 80) )
    {
      v175 = v172;
    }
    else
    {
      cv::fastFree(v174, v164);
      *(_QWORD *)(a3 + 64) = a3 + 8;
      *(_QWORD *)(a3 + 72) = a3 + 80;
      v175 = *(_DWORD *)&v337[4];
      v174 = (cv *)(a3 + 80);
    }
    if ( v175 <= 2 )
    {
      v179 = *((_QWORD *)&v338 + 1);
      *(_QWORD *)v174 = **((_QWORD **)&v338 + 1);
      *((_QWORD *)v174 + 1) = *(_QWORD *)(v179 + 8);
    }
    else
    {
      *(_OWORD *)(a3 + 64) = v338;
      *((_QWORD *)&v338 + 1) = &v339;
      *(_QWORD *)&v338 = &v337[8];
    }
    *(_DWORD *)v337 = 1124007936;
    memset(&v337[4], 0, 60);
  }
  *(_QWORD *)&v337[56] = 0LL;
  memset(&v337[16], 0, 32);
  if ( *(int *)&v337[4] >= 1 )
  {
    v180 = v338;
    v181 = 0LL;
    do
      *(_DWORD *)(v180 + 4 * v181++) = 0;
    while ( v181 < *(int *)&v337[4] );
  }
  if ( *((__int64 **)&v338 + 1) != &v339 )
    cv::fastFree(*((cv **)&v338 + 1), v164);
  if ( *(_QWORD *)&v268[56] )
  {
    v182 = (unsigned int *)(*(_QWORD *)&v268[56] + 20LL);
    do
    {
      v183 = __ldaxr(v182);
      v184 = v183 - 1;
    }
    while ( __stlxr(v184, v182) );
    if ( !v184 )
      cv::Mat::deallocate((cv::Mat *)v268);
  }
  *(_QWORD *)&v268[56] = 0LL;
  memset(&v268[16], 0, 32);
  if ( *(int *)&v268[4] >= 1 )
  {
    v185 = v269;
    v186 = 0LL;
    do
      *(_DWORD *)&v185[4 * v186++] = 0;
    while ( v186 < *(int *)&v268[4] );
  }
  if ( v270 != (cv *)&v271 )
    cv::fastFree(v270, v164);
  cv::operator*(v337, v333, v273);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int64, __int64))(**(_QWORD **)v337 + 24LL))(
    *(_QWORD *)v337,
    v337,
    a4,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v337, v187);
  if ( *(_QWORD *)&v273[56] )
  {
    v189 = (unsigned int *)(*(_QWORD *)&v273[56] + 20LL);
    do
    {
      v190 = __ldaxr(v189);
      v191 = v190 - 1;
    }
    while ( __stlxr(v191, v189) );
    if ( !v191 )
      cv::Mat::deallocate((cv::Mat *)v273);
  }
  *(_QWORD *)&v273[56] = 0LL;
  memset(&v273[16], 0, 32);
  if ( *(int *)&v273[4] >= 1 )
  {
    v192 = v274;
    v193 = 0LL;
    do
      *(_DWORD *)(v192 + 4 * v193++) = 0;
    while ( v193 < *(int *)&v273[4] );
  }
  if ( *((__int64 **)&v274 + 1) != &v275 )
    cv::fastFree(*((cv **)&v274 + 1), v188);
  if ( *(_QWORD *)&v333[56] )
  {
    v194 = (unsigned int *)(*(_QWORD *)&v333[56] + 20LL);
    do
    {
      v195 = __ldaxr(v194);
      v196 = v195 - 1;
    }
    while ( __stlxr(v196, v194) );
    if ( !v196 )
      cv::Mat::deallocate((cv::Mat *)v333);
  }
  *(_QWORD *)&v333[56] = 0LL;
  memset(&v333[16], 0, 32);
  if ( *(int *)&v333[4] >= 1 )
  {
    v197 = v334;
    v198 = 0LL;
    do
      *(_DWORD *)(v197 + 4 * v198++) = 0;
    while ( v198 < *(int *)&v333[4] );
  }
  if ( *((__int64 **)&v334 + 1) != &v335 )
    cv::fastFree(*((cv **)&v334 + 1), v188);
  if ( v277[7] )
  {
    v199 = (unsigned int *)(v277[7] + 20LL);
    do
    {
      v200 = __ldaxr(v199);
      v201 = v200 - 1;
    }
    while ( __stlxr(v201, v199) );
    if ( !v201 )
      cv::Mat::deallocate((cv::Mat *)v277);
  }
  v277[7] = 0LL;
  memset(&v277[2], 0, 32);
  if ( SHIDWORD(v277[0]) >= 1 )
  {
    v202 = v278;
    v203 = 0LL;
    do
      *((_DWORD *)v202 + v203++) = 0;
    while ( v203 < SHIDWORD(v277[0]) );
  }
  if ( v279 != (cv *)v280 )
    cv::fastFree(v279, v188);
  if ( v286 )
  {
    v204 = (unsigned int *)(v286 + 20);
    do
    {
      v205 = __ldaxr(v204);
      v206 = v205 - 1;
    }
    while ( __stlxr(v206, v204) );
    if ( !v206 )
      cv::Mat::deallocate((cv::Mat *)v282);
  }
  v286 = 0LL;
  v284 = 0u;
  v285 = 0u;
  if ( v283 >= 1 )
  {
    v207 = v287;
    for ( i = 0LL; i < v283; *(_DWORD *)(v207 + 4 * i++) = 0 )
      ;
  }
  if ( v288 != (cv *)&v289 )
    cv::fastFree(v288, v188);
  if ( v295 )
  {
    v209 = (unsigned int *)(v295 + 20);
    do
    {
      v210 = __ldaxr(v209);
      v211 = v210 - 1;
    }
    while ( __stlxr(v211, v209) );
    if ( !v211 )
      cv::Mat::deallocate((cv::Mat *)&v291);
  }
  v295 = 0LL;
  v294 = 0u;
  v293 = 0u;
  if ( SHIDWORD(v291) >= 1 )
  {
    v212 = v296;
    v213 = 0LL;
    do
      *(_DWORD *)(v212 + 4 * v213++) = 0;
    while ( v213 < SHIDWORD(v291) );
  }
  if ( v297 != (cv *)&v298 )
    cv::fastFree(v297, v188);
  if ( v304 )
  {
    v214 = (unsigned int *)(v304 + 20);
    do
    {
      v215 = __ldaxr(v214);
      v216 = v215 - 1;
    }
    while ( __stlxr(v216, v214) );
    if ( !v216 )
      cv::Mat::deallocate((cv::Mat *)&v300);
  }
  v304 = 0LL;
  v302 = 0u;
  v303 = 0u;
  if ( SHIDWORD(v300) >= 1 )
  {
    v217 = v305;
    v218 = 0LL;
    do
      *(_DWORD *)(v217 + 4 * v218++) = 0;
    while ( v218 < SHIDWORD(v300) );
  }
  if ( v306 != (cv *)&v307 )
    cv::fastFree(v306, v188);
  if ( *((_QWORD *)&v311 + 1) )
  {
    v219 = (unsigned int *)(*((_QWORD *)&v311 + 1) + 20LL);
    do
    {
      v220 = __ldaxr(v219);
      v221 = v220 - 1;
    }
    while ( __stlxr(v221, v219) );
    if ( !v221 )
      cv::Mat::deallocate((cv::Mat *)&v308);
  }
  *((_QWORD *)&v311 + 1) = 0LL;
  v309 = 0u;
  v310 = 0u;
  if ( SDWORD1(v308) >= 1 )
  {
    v222 = v312;
    v223 = 0LL;
    do
      *(_DWORD *)(v222 + 4 * v223++) = 0;
    while ( v223 < SDWORD1(v308) );
  }
  if ( *((__int64 **)&v312 + 1) != &v313 )
    cv::fastFree(*((cv **)&v312 + 1), v188);
  if ( v320 )
  {
    v224 = (unsigned int *)(v320 + 20);
    do
    {
      v225 = __ldaxr(v224);
      v226 = v225 - 1;
    }
    while ( __stlxr(v226, v224) );
    if ( !v226 )
      cv::Mat::deallocate((cv::Mat *)v316);
  }
  v320 = 0LL;
  v319 = 0u;
  v318 = 0u;
  if ( v317 >= 1 )
  {
    v227 = v321;
    for ( j = 0LL; j < v317; *(_DWORD *)(v227 + 4 * j++) = 0 )
      ;
  }
  if ( v322 != (cv *)&v323 )
    cv::fastFree(v322, v188);
  if ( v329 )
  {
    v229 = (unsigned int *)(v329 + 20);
    do
    {
      v230 = __ldaxr(v229);
      v231 = v230 - 1;
    }
    while ( __stlxr(v231, v229) );
    if ( !v231 )
      cv::Mat::deallocate((cv::Mat *)v325);
  }
  v329 = 0LL;
  v327 = 0u;
  v328 = 0u;
  if ( v326 >= 1 )
  {
    v232 = v330;
    for ( k = 0LL; k < v326; *(_DWORD *)(v232 + 4 * k++) = 0 )
      ;
  }
  if ( v331 != (cv *)&v332 )
    cv::fastFree(v331, v188);
  if ( v341[7] )
  {
    v234 = (unsigned int *)(v341[7] + 20LL);
    do
    {
      v235 = __ldaxr(v234);
      v236 = v235 - 1;
    }
    while ( __stlxr(v236, v234) );
    if ( !v236 )
      cv::Mat::deallocate((cv::Mat *)v341);
  }
  v341[7] = 0LL;
  memset(&v341[2], 0, 32);
  if ( SHIDWORD(v341[0]) >= 1 )
  {
    v237 = v342;
    v238 = 0LL;
    do
      *((_DWORD *)v237 + v238++) = 0;
    while ( v238 < SHIDWORD(v341[0]) );
  }
  if ( v343 != (cv *)v344 )
    cv::fastFree(v343, v188);
  if ( v350 )
  {
    v239 = (unsigned int *)(v350 + 20);
    do
    {
      v240 = __ldaxr(v239);
      v241 = v240 - 1;
    }
    while ( __stlxr(v241, v239) );
    if ( !v241 )
      cv::Mat::deallocate((cv::Mat *)&v346);
  }
  v350 = 0LL;
  v349 = 0u;
  v348 = 0u;
  if ( v347 >= 1 )
  {
    v242 = v351;
    for ( m = 0LL; m < v347; *(_DWORD *)(v242 + 4 * m++) = 0 )
      ;
  }
  if ( v352 != (cv *)&v353 )
    cv::fastFree(v352, v188);
  if ( v359 )
  {
    v244 = (unsigned int *)(v359 + 20);
    do
    {
      v245 = __ldaxr(v244);
      v246 = v245 - 1;
    }
    while ( __stlxr(v246, v244) );
    if ( !v246 )
      cv::Mat::deallocate((cv::Mat *)v355);
  }
  v359 = 0LL;
  v357 = 0u;
  v358 = 0u;
  if ( v356 >= 1 )
  {
    v247 = v360;
    for ( n = 0LL; n < v356; *(_DWORD *)(v247 + 4 * n++) = 0 )
      ;
  }
  if ( v361 != (cv *)&v362 )
    cv::fastFree(v361, v188);
  if ( v368 )
  {
    v249 = (unsigned int *)(v368 + 20);
    do
    {
      v250 = __ldaxr(v249);
      v251 = v250 - 1;
    }
    while ( __stlxr(v251, v249) );
    if ( !v251 )
      cv::Mat::deallocate((cv::Mat *)v364);
  }
  v368 = 0LL;
  v367 = 0u;
  v366 = 0u;
  if ( v365 >= 1 )
  {
    v252 = v369;
    for ( ii = 0LL; ii < v365; *(_DWORD *)(v252 + 4 * ii++) = 0 )
      ;
  }
  if ( v370 != (cv *)&v371 )
    cv::fastFree(v370, v188);
  return 0LL;
}
// 2EEDC: conditional instruction was optimized away because x1.8==0
// 2EEE8: conditional instruction was optimized away because x1.8==0
// 2EEF4: conditional instruction was optimized away because x1.8==0
// 2F4EC: conditional instruction was optimized away because x1.8==0
// 2F65C: conditional instruction was optimized away because x1.8==0
// 2F668: conditional instruction was optimized away because x1.8==0
// 2FE38: conditional instruction was optimized away because x1.8==0
// 2FE44: conditional instruction was optimized away because x1.8==0
// 2E338: variable 'v25' is possibly undefined
// 2E340: variable 'v26' is possibly undefined
// 2E3D4: variable 'v27' is possibly undefined
// 2E3E0: variable 'v28' is possibly undefined
// 2E780: variable 'v46' is possibly undefined
// 2E8C4: variable 'v54' is possibly undefined
// 2E8CC: variable 'v55' is possibly undefined
// 2F014: variable 'v88' is possibly undefined
// 2F77C: variable 'v124' is possibly undefined
// 2FF54: variable 'v164' is possibly undefined
// 300D4: variable 'v187' is possibly undefined
// 30144: variable 'v188' is possibly undefined
// 28: using guessed type __int64;
// 12C90: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);
// 136C0: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);

//----- (0000000000031478) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::GetCameraPlaneRT_(
        __int64 a1,
        float32x2_t *a2,
        __int64 a3,
        __int64 a4)
{
  float v7; // s0
  float v8; // s1
  unsigned __int64 v9; // d7
  double v10; // d4
  double v11; // d1
  double v12; // d2
  double v13; // d8
  double v14; // d9
  double v15; // d10
  double v16; // d11
  double v17; // d2
  double v18; // d1
  double v19; // d0
  double v20; // d13
  int v21; // w19
  double v22; // d0
  double v23; // d2
  double v24; // d10
  double v25; // d8
  float v26; // s1
  __int64 v27; // x9
  __int64 v28; // x8
  double *v29; // x10
  double *v30; // x8
  float v31; // s11
  __int64 v32; // x8
  __int64 v33; // x13
  __int64 v34; // x12
  int64x2_t v35; // q1
  _QWORD *v36; // x13
  __int64 v37; // x14
  int64x2_t v38; // q0
  __int64 v39; // d2
  __int64 v40; // x10
  int *v41; // x11
  __int64 v42; // t1
  double *v43; // x8
  cv::Mat *v44; // x1
  __int64 v45; // x9
  unsigned __int64 v46; // x10
  double *v47; // x9
  void *v48; // x1
  cv *v49; // x0
  __int128 v50; // q0
  unsigned int *v51; // x8
  unsigned int v52; // w9
  unsigned int v53; // w9
  __int64 v54; // x8
  __int64 v55; // x9
  void *v56; // x1
  void *v57; // x1
  __int64 v58; // x24
  __int64 v59; // x8
  __int64 v60; // x13
  __int64 v61; // x12
  int64x2_t v62; // q1
  _QWORD *v63; // x13
  __int64 v64; // x14
  int64x2_t v65; // q0
  __int64 v66; // d2
  __int64 v67; // x10
  int *v68; // x11
  __int64 v69; // t1
  double *v70; // x8
  cv::Mat *v71; // x1
  __int64 v72; // x9
  unsigned __int64 v73; // x11
  __int64 v74; // x10
  double *v75; // x9
  double *v76; // x10
  __int64 v77; // x9
  double *v78; // x10
  double *v79; // x8
  double *v80; // x9
  double *v81; // x10
  __int64 v82; // x8
  double *v83; // x9
  double *v84; // x10
  double *v85; // x8
  double *v86; // x9
  double *v87; // x8
  double *v88; // x9
  double *v89; // x8
  void *v90; // x1
  cv *v91; // x0
  __int128 v92; // q0
  unsigned int *v93; // x8
  unsigned int v94; // w9
  unsigned int v95; // w9
  __int64 v96; // x8
  __int64 v97; // x9
  __int64 v98; // x8
  __int64 v99; // x13
  __int64 v100; // x12
  int64x2_t v101; // q1
  _QWORD *v102; // x13
  __int64 v103; // x14
  int64x2_t v104; // q0
  __int64 v105; // d2
  __int64 v106; // x10
  int *v107; // x11
  __int64 v108; // t1
  double *v109; // x8
  cv::Mat *v110; // x1
  __int64 v111; // x9
  unsigned __int64 v112; // x10
  double *v113; // x9
  double *v114; // x8
  double *v115; // x9
  double *v116; // x8
  double *v117; // x9
  double *v118; // x9
  double *v119; // x8
  double *v120; // x9
  double *v121; // x8
  double *v122; // x9
  double *v123; // x8
  double *v124; // x9
  double *v125; // x8
  void *v126; // x1
  cv *v127; // x0
  __int128 v128; // q0
  unsigned int *v129; // x8
  unsigned int v130; // w9
  unsigned int v131; // w9
  _BYTE *v132; // x8
  __int64 v133; // x9
  __int64 v134; // x25
  __int64 v135; // x8
  __int64 v136; // x13
  __int64 v137; // x12
  int64x2_t v138; // q1
  _QWORD *v139; // x13
  __int64 v140; // x14
  int64x2_t v141; // q0
  __int64 v142; // d2
  __int64 v143; // x10
  int *v144; // x11
  __int64 v145; // t1
  double *v146; // x8
  cv::Mat *v147; // x1
  __int64 v148; // x9
  unsigned __int64 v149; // x11
  __int64 v150; // x10
  double *v151; // x9
  double *v152; // x10
  double *v153; // x9
  double *v154; // x10
  double *v155; // x8
  double *v156; // x10
  double *v157; // x9
  double *v158; // x8
  double *v159; // x10
  double *v160; // x9
  double *v161; // x8
  double *v162; // x9
  double *v163; // x8
  double *v164; // x9
  double *v165; // x8
  void *v166; // x1
  __int64 v167; // x8
  unsigned int *v168; // x8
  unsigned int v169; // w9
  unsigned int v170; // w9
  int v171; // w8
  __int64 v172; // x8
  __int64 v173; // x9
  int v174; // v0.s[1]
  __int128 v175; // q1
  cv *v176; // x0
  int v177; // w8
  unsigned int *v178; // x8
  unsigned int v179; // w9
  unsigned int v180; // w9
  __int64 v181; // x9
  __int64 v182; // x8
  __int64 v183; // x9
  unsigned int *v184; // x8
  unsigned int v185; // w9
  unsigned int v186; // w9
  _BYTE *v187; // x8
  __int64 v188; // x9
  void *v189; // x1
  void *v190; // x1
  unsigned int *v191; // x8
  unsigned int v192; // w9
  unsigned int v193; // w9
  __int64 v194; // x8
  __int64 v195; // x9
  unsigned int *v196; // x8
  unsigned int v197; // w9
  unsigned int v198; // w9
  __int64 v199; // x8
  __int64 v200; // x9
  unsigned int *v201; // x8
  unsigned int v202; // w9
  unsigned int v203; // w9
  _QWORD *v204; // x8
  __int64 v205; // x9
  unsigned int *v206; // x8
  unsigned int v207; // w9
  unsigned int v208; // w9
  __int64 v209; // x8
  __int64 i; // x9
  unsigned int *v211; // x8
  unsigned int v212; // w9
  unsigned int v213; // w9
  __int64 v214; // x8
  __int64 v215; // x9
  unsigned int *v216; // x8
  unsigned int v217; // w9
  unsigned int v218; // w9
  __int64 v219; // x8
  __int64 v220; // x9
  unsigned int *v221; // x8
  unsigned int v222; // w9
  unsigned int v223; // w9
  __int64 v224; // x8
  __int64 v225; // x9
  unsigned int *v226; // x8
  unsigned int v227; // w9
  unsigned int v228; // w9
  _QWORD *v229; // x8
  __int64 v230; // x9
  __int64 v232; // [xsp+10h] [xbp-7B0h]
  float v233; // [xsp+44h] [xbp-77Ch]
  cv::Mat *v234; // [xsp+58h] [xbp-768h] BYREF
  __int64 v235; // [xsp+60h] [xbp-760h]
  double *v236; // [xsp+68h] [xbp-758h]
  __int64 v237; // [xsp+70h] [xbp-750h]
  unsigned __int64 v238; // [xsp+78h] [xbp-748h]
  int v239[2]; // [xsp+80h] [xbp-740h] BYREF
  cv::Mat *v240; // [xsp+88h] [xbp-738h] BYREF
  __int64 v241; // [xsp+90h] [xbp-730h]
  double *v242; // [xsp+98h] [xbp-728h]
  __int64 v243; // [xsp+A0h] [xbp-720h]
  unsigned __int64 v244; // [xsp+A8h] [xbp-718h]
  _BYTE v245[64]; // [xsp+B0h] [xbp-710h] BYREF
  _BYTE *v246; // [xsp+F0h] [xbp-6D0h]
  cv *v247; // [xsp+F8h] [xbp-6C8h]
  __int64 v248; // [xsp+100h] [xbp-6C0h] BYREF
  __int64 v249; // [xsp+108h] [xbp-6B8h]
  _BYTE v250[64]; // [xsp+110h] [xbp-6B0h] BYREF
  __int128 v251; // [xsp+150h] [xbp-670h]
  __int64 v252; // [xsp+160h] [xbp-660h] BYREF
  __int64 v253; // [xsp+168h] [xbp-658h]
  _BYTE v254[64]; // [xsp+170h] [xbp-650h] BYREF
  __int128 v255; // [xsp+1B0h] [xbp-610h]
  __int64 v256; // [xsp+1C0h] [xbp-600h] BYREF
  __int64 v257; // [xsp+1C8h] [xbp-5F8h]
  _BYTE v258[64]; // [xsp+2D0h] [xbp-4F0h] BYREF
  __int128 v259; // [xsp+310h] [xbp-4B0h]
  __int64 v260; // [xsp+320h] [xbp-4A0h] BYREF
  __int64 v261; // [xsp+328h] [xbp-498h]
  _QWORD v262[8]; // [xsp+438h] [xbp-388h] BYREF
  _QWORD *v263; // [xsp+478h] [xbp-348h]
  cv *v264; // [xsp+480h] [xbp-340h]
  __int64 v265[2]; // [xsp+488h] [xbp-338h] BYREF
  __int64 v266[3]; // [xsp+498h] [xbp-328h] BYREF
  char v267[4]; // [xsp+4B0h] [xbp-310h] BYREF
  int v268; // [xsp+4B4h] [xbp-30Ch]
  __int128 v269; // [xsp+4C0h] [xbp-300h]
  __int128 v270; // [xsp+4D0h] [xbp-2F0h]
  __int64 v271; // [xsp+4E8h] [xbp-2D8h]
  __int64 v272; // [xsp+4F0h] [xbp-2D0h]
  cv *v273; // [xsp+4F8h] [xbp-2C8h]
  __int64 v274; // [xsp+500h] [xbp-2C0h] BYREF
  __int64 v275[3]; // [xsp+510h] [xbp-2B0h] BYREF
  cv::Mat *v276; // [xsp+528h] [xbp-298h] BYREF
  __int64 v277; // [xsp+530h] [xbp-290h]
  __int128 v278; // [xsp+538h] [xbp-288h]
  __int128 v279; // [xsp+548h] [xbp-278h]
  __int64 v280; // [xsp+560h] [xbp-260h]
  __int64 v281; // [xsp+568h] [xbp-258h]
  cv *v282; // [xsp+570h] [xbp-250h]
  __int64 v283; // [xsp+578h] [xbp-248h] BYREF
  __int64 v284[3]; // [xsp+588h] [xbp-238h] BYREF
  cv::Mat *v285; // [xsp+5A0h] [xbp-220h] BYREF
  __int64 v286; // [xsp+5A8h] [xbp-218h]
  __int128 v287; // [xsp+5B0h] [xbp-210h]
  __int128 v288; // [xsp+5C0h] [xbp-200h]
  __int64 v289; // [xsp+5D8h] [xbp-1E8h]
  __int64 v290; // [xsp+5E0h] [xbp-1E0h]
  cv *v291; // [xsp+5E8h] [xbp-1D8h]
  __int64 v292; // [xsp+5F0h] [xbp-1D0h] BYREF
  __int128 v293; // [xsp+600h] [xbp-1C0h] BYREF
  __int128 v294; // [xsp+610h] [xbp-1B0h]
  __int128 v295; // [xsp+620h] [xbp-1A0h]
  __int128 v296; // [xsp+630h] [xbp-190h]
  __int128 v297; // [xsp+640h] [xbp-180h]
  __int64 v298; // [xsp+650h] [xbp-170h] BYREF
  __int64 v299; // [xsp+658h] [xbp-168h]
  float32x2_t v300; // [xsp+668h] [xbp-158h] BYREF
  float v301; // [xsp+670h] [xbp-150h]
  float v302; // [xsp+678h] [xbp-148h]
  float v303; // [xsp+67Ch] [xbp-144h]
  float v304; // [xsp+680h] [xbp-140h]
  float v305; // [xsp+688h] [xbp-138h]
  float v306; // [xsp+68Ch] [xbp-134h]
  float v307; // [xsp+690h] [xbp-130h]
  float v308; // [xsp+698h] [xbp-128h]
  float v309; // [xsp+69Ch] [xbp-124h]
  float v310; // [xsp+6A0h] [xbp-120h]
  float32x2_t v311; // [xsp+6A8h] [xbp-118h] BYREF
  float v312; // [xsp+6B0h] [xbp-110h]
  float v313; // [xsp+6B8h] [xbp-108h] BYREF
  float v314; // [xsp+6BCh] [xbp-104h]
  int v315; // [xsp+6C0h] [xbp-100h]
  _QWORD v316[8]; // [xsp+6C8h] [xbp-F8h] BYREF
  _QWORD *v317; // [xsp+708h] [xbp-B8h]
  cv *v318; // [xsp+710h] [xbp-B0h]
  __int64 v319[5]; // [xsp+718h] [xbp-A8h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = a2->n64_f32[0];
  v7 = a2->n64_f32[1];
  if ( v7 >= 0.0 )
  {
    v9 = a2[1].n64_u64[0];
  }
  else
  {
    v8 = -v8;
    v7 = -v7;
    v9 = vneg_f32(a2[1]).n64_u64[0];
  }
  v10 = 1.0 / sqrt((float)((float)((float)(v8 * v8) + (float)(v7 * v7)) + vmuls_n_f32(*(float *)&v9, *(float *)&v9)));
  v11 = v10 * v8;
  v12 = v10 * v7;
  v13 = v10 * *(float *)&v9;
  v14 = v11 * v11 + v12 * v12;
  if ( sqrt(v14 + (v13 + -1.0) * (v13 + -1.0)) < 0.000001 )
    return 0LL;
  v15 = v11 * 0.0;
  v16 = v12 * 0.0;
  v17 = v12 - v13 * 0.0;
  v18 = v13 * 0.0 - v11;
  v19 = 1.0 / (sqrt((v15 - v16) * (v15 - v16) + v17 * v17 + v18 * v18) + 2.22507386e-308);
  v20 = v18 * v19;
  v233 = *((float *)&v9 + 1);
  v21 = -1077342245;
  v22 = acos(
          ((v15 - v16) * v19 * 0.0 + v17 * v19 + v18 * v19 * 0.0)
        / (sqrt((v15 - v16) * v19 * ((v15 - v16) * v19) + v17 * v19 * (v17 * v19) + v20 * v20) + 2.22507386e-308));
  v23 = v15 + v16;
  if ( v20 <= 0.0 )
    v24 = v22;
  else
    v24 = -v22;
  v25 = acos((v13 + v23) / sqrt(v13 * v13 + v14) + 2.22507386e-308);
  LODWORD(v316[0]) = 1124007936;
  memset((char *)v316 + 4, 0, 60);
  v317 = &v316[1];
  v318 = (cv *)v319;
  v319[0] = 0LL;
  v319[1] = 0LL;
  *(_QWORD *)v239 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v316, 2, v239, 6);
  if ( *(_DWORD *)(a1 + 20) == 1 )
  {
    v313 = v25 + 3.14159265;
    v314 = 0.0;
  }
  else
  {
    v26 = v24;
    v21 = -1068953637;
    v313 = v25 + 3.14159265;
    v314 = v26;
  }
  v315 = v21;
  v311.n64_u64[0] = 0LL;
  v312 = fabsf(v233);
  feasibal_region::ground_process::getTFMatrix(&v313, &v311, &v300);
  v27 = v316[2];
  v28 = *(_QWORD *)v318;
  *(double *)v316[2] = v300.n64_f32[0];
  v29 = (double *)(v27 + v28);
  v30 = (double *)(v27 + 2 * v28);
  *(double *)(v27 + 8) = v302;
  *(double *)(v27 + 16) = v305;
  *v29 = v300.n64_f32[1];
  v29[1] = v303;
  v29[2] = v306;
  *v30 = v301;
  v30[1] = v304;
  v30[2] = v307;
  *(_DWORD *)v254 = 1124007936;
  memset(&v254[4], 0, 60);
  *(_QWORD *)&v255 = &v254[8];
  *((_QWORD *)&v255 + 1) = &v256;
  v256 = 0LL;
  v257 = 0LL;
  *(_QWORD *)v239 = 0x100000003LL;
  cv::Mat::create((cv::Mat *)v254, 2, v239, 6);
  v31 = v308;
  v285 = (cv::Mat *)v254;
  if ( *(int *)&v254[4] < 1 )
    v32 = 0LL;
  else
    v32 = *(_QWORD *)(*((_QWORD *)&v255 + 1) + 8LL * (*(_DWORD *)&v254[4] - 1));
  v286 = v32;
  *(_QWORD *)&v288 = 0LL;
  v287 = 0uLL;
  if ( (v254[1] & 0x40) != 0 )
  {
    *((_QWORD *)&v287 + 1) = *(_QWORD *)&v254[16];
    if ( *(int *)&v254[4] >= 3 )
    {
      if ( *(_DWORD *)&v254[4] == 3 )
      {
        v34 = 0LL;
        v33 = 1LL;
      }
      else
      {
        v34 = *(_DWORD *)&v254[4] & 0xFFFFFFFC;
        v35 = vdupq_n_s64(1uLL);
        v36 = (_QWORD *)(v255 + 8);
        v37 = v34;
        v38 = v35;
        do
        {
          v39 = *(v36 - 1);
          v35.n128_u64[0] *= (int)v39;
          v38.n128_u64[0] *= (int)*v36;
          v37 -= 4LL;
          v35.n128_u64[1] *= SHIDWORD(v39);
          v38.n128_u64[1] *= (int)HIDWORD(*v36);
          v36 += 2;
        }
        while ( v37 );
        v33 = v38.n128_u64[0] * v35.n128_u64[0] * v38.n128_u64[1] * v35.n128_u64[1];
        if ( v34 == *(unsigned int *)&v254[4] )
          goto LABEL_24;
      }
      v40 = *(unsigned int *)&v254[4] - v34;
      v41 = (int *)(v255 + 4 * v34);
      do
      {
        v42 = *v41++;
        --v40;
        v33 *= v42;
      }
      while ( v40 );
    }
    else
    {
      v33 = *(int *)&v254[12] * (__int64)*(int *)&v254[8];
    }
LABEL_24:
    *(_QWORD *)&v288 = *(_QWORD *)&v254[16] + v33 * v32;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v285, 0LL, 0);
  v43 = (double *)v287;
  *(double *)v287 = v31;
  v44 = v285;
  if ( v285 )
  {
    *(_QWORD *)&v287 = (char *)v43 + v286;
    if ( (unsigned __int64)v43 + v286 >= (unsigned __int64)v288 )
    {
      *(_QWORD *)&v287 = v43;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v285, 1LL, 1);
      v44 = v285;
      v43 = (double *)v287;
    }
    else
    {
      v43 = (double *)((char *)v43 + v286);
    }
  }
  v45 = v286;
  v46 = v288;
  v276 = v44;
  v277 = v286;
  *(_QWORD *)&v278 = v43;
  *((_QWORD *)&v278 + 1) = *((_QWORD *)&v287 + 1);
  *(_QWORD *)&v279 = v288;
  *v43 = v309;
  if ( v44 )
  {
    v47 = (double *)((char *)v43 + v45);
    *(_QWORD *)&v278 = v47;
    if ( (unsigned __int64)v47 >= v46 )
    {
      *(_QWORD *)&v278 = v43;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v276, 1LL, 1);
      v47 = (double *)v278;
      v44 = v276;
    }
    *v47 = v310;
    if ( v44 )
    {
      *(_QWORD *)&v278 = (char *)v47 + v277;
      if ( (unsigned __int64)v47 + v277 >= (unsigned __int64)v279 )
      {
        *(_QWORD *)&v278 = v47;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v276, 1LL, 1);
        v44 = v276;
      }
    }
  }
  else
  {
    *v43 = v310;
  }
  v232 = a4;
  memset(&v258[4], 0, 60);
  *(_QWORD *)&v259 = &v258[8];
  *((_QWORD *)&v259 + 1) = &v260;
  v261 = 0LL;
  v260 = 0LL;
  *(_DWORD *)v258 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v258, v44);
  v294 = *(_OWORD *)&v258[16];
  v293 = *(_OWORD *)v258;
  v295 = *(_OWORD *)&v258[32];
  v296 = *(_OWORD *)&v258[48];
  *(_QWORD *)&v297 = (char *)&v293 + 8;
  *((_QWORD *)&v297 + 1) = &v298;
  v299 = 0LL;
  v298 = 0LL;
  if ( *(int *)&v258[4] > 2 )
  {
    v50 = v259;
    v49 = (cv *)&v260;
    *((_QWORD *)&v259 + 1) = &v260;
    *(_QWORD *)&v259 = &v258[8];
    v297 = v50;
  }
  else
  {
    v49 = (cv *)*((_QWORD *)&v259 + 1);
    v298 = **((_QWORD **)&v259 + 1);
    v299 = *(_QWORD *)(*((_QWORD *)&v259 + 1) + 8LL);
  }
  *(_DWORD *)v258 = 1124007936;
  memset(&v258[4], 0, 60);
  if ( v49 != (cv *)&v260 )
    cv::fastFree(v49, v48);
  if ( *(_QWORD *)&v254[56] )
  {
    v51 = (unsigned int *)(*(_QWORD *)&v254[56] + 20LL);
    do
    {
      v52 = __ldaxr(v51);
      v53 = v52 - 1;
    }
    while ( __stlxr(v53, v51) );
    if ( !v53 )
      cv::Mat::deallocate((cv::Mat *)v254);
  }
  *(_QWORD *)&v254[56] = 0LL;
  memset(&v254[16], 0, 32);
  if ( *(int *)&v254[4] >= 1 )
  {
    v54 = v255;
    v55 = 0LL;
    do
      *(_DWORD *)(v54 + 4 * v55++) = 0;
    while ( v55 < *(int *)&v254[4] );
  }
  if ( *((__int64 **)&v255 + 1) != &v256 )
    cv::fastFree(*((cv **)&v255 + 1), v48);
  v284[1] = 0LL;
  v284[0] = 0LL;
  v284[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v284, -v24, (__int64)&v285);
  v275[1] = 0LL;
  v275[0] = 0LL;
  v275[2] = 0x3FF0000000000000LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v275, 3.14159265, (__int64)&v276);
  v266[0] = 0x3FF0000000000000LL;
  v266[2] = 0LL;
  v266[1] = 0LL;
  feasibal_region::rotationMatrixFromAxisAndAngle((double *)v266, v25, (__int64)v267);
  cv::operator*(v254, &v285, &v276);
  cv::operator*(v258, v254, v267);
  LODWORD(v262[0]) = 1124007936;
  memset((char *)v262 + 4, 0, 60);
  v263 = &v262[1];
  v264 = (cv *)v265;
  v265[1] = 0LL;
  v265[0] = 0LL;
  (*(void (__fastcall **)(_QWORD, _BYTE *, _QWORD *, __int64))(**(_QWORD **)v258 + 24LL))(
    *(_QWORD *)v258,
    v258,
    v262,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v258, v56);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v254, v57);
  *(_DWORD *)v250 = 1124007936;
  memset(&v250[4], 0, 60);
  *(_QWORD *)&v251 = &v250[8];
  *((_QWORD *)&v251 + 1) = &v252;
  v252 = 0LL;
  v253 = 0LL;
  *(_QWORD *)v239 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v250, 2, v239, 6);
  v58 = *(_QWORD *)v262[2];
  *(_QWORD *)v245 = v250;
  if ( *(int *)&v250[4] < 1 )
    v59 = 0LL;
  else
    v59 = *(_QWORD *)(*((_QWORD *)&v251 + 1) + 8LL * (*(_DWORD *)&v250[4] - 1));
  *(_QWORD *)&v245[8] = v59;
  memset(&v245[16], 0, 24);
  if ( (v250[1] & 0x40) != 0 )
  {
    *(_QWORD *)&v245[24] = *(_QWORD *)&v250[16];
    if ( *(int *)&v250[4] >= 3 )
    {
      if ( *(_DWORD *)&v250[4] == 3 )
      {
        v61 = 0LL;
        v60 = 1LL;
      }
      else
      {
        v61 = *(_DWORD *)&v250[4] & 0xFFFFFFFC;
        v62 = vdupq_n_s64(1uLL);
        v63 = (_QWORD *)(v251 + 8);
        v64 = v61;
        v65 = v62;
        do
        {
          v66 = *(v63 - 1);
          v62.n128_u64[0] *= (int)v66;
          v65.n128_u64[0] *= (int)*v63;
          v64 -= 4LL;
          v62.n128_u64[1] *= SHIDWORD(v66);
          v65.n128_u64[1] *= (int)HIDWORD(*v63);
          v63 += 2;
        }
        while ( v64 );
        v60 = v65.n128_u64[0] * v62.n128_u64[0] * v65.n128_u64[1] * v62.n128_u64[1];
        if ( v61 == *(unsigned int *)&v250[4] )
          goto LABEL_64;
      }
      v67 = *(unsigned int *)&v250[4] - v61;
      v68 = (int *)(v251 + 4 * v61);
      do
      {
        v69 = *v68++;
        --v67;
        v60 *= v69;
      }
      while ( v67 );
    }
    else
    {
      v60 = *(int *)&v250[12] * (__int64)*(int *)&v250[8];
    }
LABEL_64:
    *(_QWORD *)&v245[32] = *(_QWORD *)&v250[16] + v60 * v59;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)v245, 0LL, 0);
  v70 = *(double **)&v245[16];
  **(_QWORD **)&v245[16] = v58;
  v71 = *(cv::Mat **)v245;
  if ( *(_QWORD *)v245 )
  {
    *(_QWORD *)&v245[16] = (char *)v70 + *(_QWORD *)&v245[8];
    if ( (unsigned __int64)v70 + *(_QWORD *)&v245[8] >= *(_QWORD *)&v245[32] )
    {
      *(_QWORD *)&v245[16] = v70;
      cv::MatConstIterator::seek((cv::MatConstIterator *)v245, 1LL, 1);
      v71 = *(cv::Mat **)v245;
      v70 = *(double **)&v245[16];
    }
    else
    {
      v70 = (double *)((char *)v70 + *(_QWORD *)&v245[8]);
    }
  }
  v72 = *(_QWORD *)&v245[8];
  v73 = *(_QWORD *)&v245[32];
  v74 = v262[2];
  v240 = v71;
  v241 = *(_QWORD *)&v245[8];
  v242 = v70;
  v243 = *(_QWORD *)&v245[24];
  v244 = *(_QWORD *)&v245[32];
  *v70 = *(double *)(v262[2] + 8LL);
  if ( !v71 )
  {
    *v70 = 0.0;
    goto LABEL_81;
  }
  v75 = (double *)((char *)v70 + v72);
  v242 = v75;
  if ( (unsigned __int64)v75 >= v73 )
  {
    v242 = v70;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v74 = v262[2];
    v75 = v242;
    v71 = v240;
  }
  *v75 = *(double *)(v74 + 16);
  if ( !v71 )
  {
    v76 = v75;
    *v75 = 0.0;
LABEL_80:
    v70 = v76;
    goto LABEL_81;
  }
  v76 = (double *)((char *)v75 + v241);
  v242 = (double *)((char *)v75 + v241);
  if ( (unsigned __int64)v75 + v241 >= v244 )
  {
    v242 = v75;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v76 = v242;
    v71 = v240;
  }
  *v76 = 0.0;
  if ( !v71 )
    goto LABEL_80;
  v70 = (double *)((char *)v76 + v241);
  v242 = (double *)((char *)v76 + v241);
  if ( (unsigned __int64)v76 + v241 >= v244 )
  {
    v242 = v76;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v70 = v242;
    v71 = v240;
  }
LABEL_81:
  v77 = v262[2];
  *v70 = *(double *)(v262[2] + *(_QWORD *)v264);
  if ( v71 )
  {
    v78 = (double *)((char *)v70 + v241);
    v242 = (double *)((char *)v70 + v241);
    if ( (unsigned __int64)v70 + v241 >= v244 )
    {
      v242 = v70;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v77 = v262[2];
      v78 = v242;
      v71 = v240;
    }
  }
  else
  {
    v78 = v70;
  }
  *v78 = *(double *)(v77 + *(_QWORD *)v264 + 8);
  if ( v71 )
  {
    v79 = (double *)((char *)v78 + v241);
    v242 = (double *)((char *)v78 + v241);
    if ( (unsigned __int64)v78 + v241 >= v244 )
    {
      v242 = v78;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v77 = v262[2];
      v79 = v242;
      v71 = v240;
    }
  }
  else
  {
    v79 = v78;
  }
  *v79 = *(double *)(v77 + *(_QWORD *)v264 + 16);
  if ( !v71 )
  {
    v80 = v79;
    *v79 = 0.0;
LABEL_96:
    v81 = v80;
    goto LABEL_97;
  }
  v80 = (double *)((char *)v79 + v241);
  v242 = (double *)((char *)v79 + v241);
  if ( (unsigned __int64)v79 + v241 >= v244 )
  {
    v242 = v79;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v80 = v242;
    v71 = v240;
  }
  *v80 = 0.0;
  if ( !v71 )
    goto LABEL_96;
  v81 = (double *)((char *)v80 + v241);
  v242 = (double *)((char *)v80 + v241);
  if ( (unsigned __int64)v80 + v241 >= v244 )
  {
    v242 = v80;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v81 = v242;
    v71 = v240;
  }
LABEL_97:
  v82 = v262[2];
  *v81 = *(double *)(v262[2] + 2LL * *(_QWORD *)v264);
  if ( v71 )
  {
    v83 = (double *)((char *)v81 + v241);
    v242 = (double *)((char *)v81 + v241);
    if ( (unsigned __int64)v81 + v241 >= v244 )
    {
      v242 = v81;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v82 = v262[2];
      v83 = v242;
      v71 = v240;
    }
  }
  else
  {
    v83 = v81;
  }
  *v83 = *(double *)(v82 + 2LL * *(_QWORD *)v264 + 8);
  if ( v71 )
  {
    v84 = (double *)((char *)v83 + v241);
    v242 = (double *)((char *)v83 + v241);
    if ( (unsigned __int64)v83 + v241 >= v244 )
    {
      v242 = v83;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v82 = v262[2];
      v84 = v242;
      v71 = v240;
    }
  }
  else
  {
    v84 = v83;
  }
  *v84 = *(double *)(v82 + 2LL * *(_QWORD *)v264 + 16);
  if ( !v71 )
  {
    v85 = v84;
    *v84 = 0.0;
LABEL_121:
    v86 = v85;
    *v85 = 0.0;
LABEL_122:
    v87 = v86;
    *v86 = 0.0;
LABEL_123:
    v88 = v87;
    *v87 = 0.0;
LABEL_124:
    v89 = v88;
    goto LABEL_125;
  }
  v85 = (double *)((char *)v84 + v241);
  v242 = (double *)((char *)v84 + v241);
  if ( (unsigned __int64)v84 + v241 >= v244 )
  {
    v242 = v84;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v85 = v242;
    v71 = v240;
  }
  *v85 = 0.0;
  if ( !v71 )
    goto LABEL_121;
  v86 = (double *)((char *)v85 + v241);
  v242 = (double *)((char *)v85 + v241);
  if ( (unsigned __int64)v85 + v241 >= v244 )
  {
    v242 = v85;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v86 = v242;
    v71 = v240;
  }
  *v86 = 0.0;
  if ( !v71 )
    goto LABEL_122;
  v87 = (double *)((char *)v86 + v241);
  v242 = (double *)((char *)v86 + v241);
  if ( (unsigned __int64)v86 + v241 >= v244 )
  {
    v242 = v86;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v87 = v242;
    v71 = v240;
  }
  *v87 = 0.0;
  if ( !v71 )
    goto LABEL_123;
  v88 = (double *)((char *)v87 + v241);
  v242 = (double *)((char *)v87 + v241);
  if ( (unsigned __int64)v87 + v241 >= v244 )
  {
    v242 = v87;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v88 = v242;
    v71 = v240;
  }
  *v88 = 0.0;
  if ( !v71 )
    goto LABEL_124;
  v89 = (double *)((char *)v88 + v241);
  v242 = (double *)((char *)v88 + v241);
  if ( (unsigned __int64)v88 + v241 >= v244 )
  {
    v242 = v88;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
    v89 = v242;
    v71 = v240;
  }
LABEL_125:
  *v89 = 1.0;
  if ( v71 )
  {
    v242 = (double *)((char *)v89 + v241);
    if ( (unsigned __int64)v89 + v241 >= v244 )
    {
      v242 = v89;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v71 = v240;
    }
  }
  memset(&v258[4], 0, 60);
  *(_QWORD *)&v259 = &v258[8];
  *((_QWORD *)&v259 + 1) = &v260;
  v261 = 0LL;
  v260 = 0LL;
  *(_DWORD *)v258 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v258, v71);
  *(_OWORD *)&v254[16] = *(_OWORD *)&v258[16];
  *(_OWORD *)&v254[32] = *(_OWORD *)&v258[32];
  *(_OWORD *)v254 = *(_OWORD *)v258;
  *(_OWORD *)&v254[48] = *(_OWORD *)&v258[48];
  *(_QWORD *)&v255 = &v254[8];
  *((_QWORD *)&v255 + 1) = &v256;
  v256 = 0LL;
  v257 = 0LL;
  if ( *(int *)&v258[4] > 2 )
  {
    v92 = v259;
    v91 = (cv *)&v260;
    *((_QWORD *)&v259 + 1) = &v260;
    *(_QWORD *)&v259 = &v258[8];
    v255 = v92;
  }
  else
  {
    v91 = (cv *)*((_QWORD *)&v259 + 1);
    v256 = **((_QWORD **)&v259 + 1);
    v257 = *(_QWORD *)(*((_QWORD *)&v259 + 1) + 8LL);
  }
  *(_DWORD *)v258 = 1124007936;
  memset(&v258[4], 0, 60);
  if ( v91 != (cv *)&v260 )
    cv::fastFree(v91, v90);
  if ( *(_QWORD *)&v250[56] )
  {
    v93 = (unsigned int *)(*(_QWORD *)&v250[56] + 20LL);
    do
    {
      v94 = __ldaxr(v93);
      v95 = v94 - 1;
    }
    while ( __stlxr(v95, v93) );
    if ( !v95 )
      cv::Mat::deallocate((cv::Mat *)v250);
  }
  *(_QWORD *)&v250[56] = 0LL;
  memset(&v250[16], 0, 32);
  if ( *(int *)&v250[4] >= 1 )
  {
    v96 = v251;
    v97 = 0LL;
    do
      *(_DWORD *)(v96 + 4 * v97++) = 0;
    while ( v97 < *(int *)&v250[4] );
  }
  if ( *((__int64 **)&v251 + 1) != &v252 )
    cv::fastFree(*((cv **)&v251 + 1), v90);
  *(_DWORD *)v245 = 1124007936;
  memset(&v245[4], 0, 60);
  v246 = &v245[8];
  v247 = (cv *)&v248;
  v248 = 0LL;
  v249 = 0LL;
  *(_QWORD *)v239 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v245, 2, v239, 6);
  v240 = (cv::Mat *)v245;
  if ( *(int *)&v245[4] < 1 )
    v98 = 0LL;
  else
    v98 = *((_QWORD *)v247 + *(_DWORD *)&v245[4] - 1);
  v241 = v98;
  v242 = 0LL;
  v243 = 0LL;
  v244 = 0LL;
  if ( (v245[1] & 0x40) != 0 )
  {
    v243 = *(_QWORD *)&v245[16];
    if ( *(int *)&v245[4] >= 3 )
    {
      if ( *(_DWORD *)&v245[4] == 3 )
      {
        v100 = 0LL;
        v99 = 1LL;
      }
      else
      {
        v100 = *(_DWORD *)&v245[4] & 0xFFFFFFFC;
        v101 = vdupq_n_s64(1uLL);
        v102 = v246 + 8;
        v103 = v100;
        v104 = v101;
        do
        {
          v105 = *(v102 - 1);
          v101.n128_u64[0] *= (int)v105;
          v104.n128_u64[0] *= (int)*v102;
          v103 -= 4LL;
          v101.n128_u64[1] *= SHIDWORD(v105);
          v104.n128_u64[1] *= (int)HIDWORD(*v102);
          v102 += 2;
        }
        while ( v103 );
        v99 = v104.n128_u64[0] * v101.n128_u64[0] * v104.n128_u64[1] * v101.n128_u64[1];
        if ( v100 == *(unsigned int *)&v245[4] )
          goto LABEL_156;
      }
      v106 = *(unsigned int *)&v245[4] - v100;
      v107 = (int *)&v246[4 * v100];
      do
      {
        v108 = *v107++;
        --v106;
        v99 *= v108;
      }
      while ( v106 );
    }
    else
    {
      v99 = *(int *)&v245[12] * (__int64)*(int *)&v245[8];
    }
LABEL_156:
    v244 = *(_QWORD *)&v245[16] + v99 * v98;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 0LL, 0);
  v109 = v242;
  *v242 = 1.0;
  v110 = v240;
  if ( v240 )
  {
    v242 = (double *)((char *)v109 + v241);
    if ( (unsigned __int64)v109 + v241 >= v244 )
    {
      v242 = v109;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v110 = v240;
      v109 = v242;
    }
    else
    {
      v109 = (double *)((char *)v109 + v241);
    }
  }
  v111 = v241;
  v112 = v244;
  v234 = v110;
  v235 = v241;
  v236 = v109;
  v237 = v243;
  v238 = v244;
  *v109 = 0.0;
  if ( !v110 )
  {
    *v109 = 0.0;
    goto LABEL_185;
  }
  v113 = (double *)((char *)v109 + v111);
  v236 = v113;
  if ( (unsigned __int64)v113 >= v112 )
  {
    v236 = v109;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v113 = v236;
    v110 = v234;
  }
  *v113 = 0.0;
  if ( v110 )
  {
    v114 = (double *)((char *)v113 + v235);
    v236 = (double *)((char *)v113 + v235);
    if ( (unsigned __int64)v113 + v235 >= v238 )
    {
      v236 = v113;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v114 = v236;
      v110 = v234;
    }
  }
  else
  {
    v114 = v113;
  }
  *v114 = -*(double *)v294;
  if ( !v110 )
  {
    v115 = v114;
    *v114 = 0.0;
LABEL_176:
    v116 = v115;
    goto LABEL_177;
  }
  v115 = (double *)((char *)v114 + v235);
  v236 = (double *)((char *)v114 + v235);
  if ( (unsigned __int64)v114 + v235 >= v238 )
  {
    v236 = v114;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v115 = v236;
    v110 = v234;
  }
  *v115 = 0.0;
  if ( !v110 )
    goto LABEL_176;
  v116 = (double *)((char *)v115 + v235);
  v236 = (double *)((char *)v115 + v235);
  if ( (unsigned __int64)v115 + v235 >= v238 )
  {
    v236 = v115;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v116 = v236;
    v110 = v234;
  }
LABEL_177:
  *v116 = 1.0;
  if ( !v110 )
  {
    v117 = v116;
    *v116 = 0.0;
LABEL_184:
    v109 = v117;
    goto LABEL_185;
  }
  v117 = (double *)((char *)v116 + v235);
  v236 = (double *)((char *)v116 + v235);
  if ( (unsigned __int64)v116 + v235 >= v238 )
  {
    v236 = v116;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v117 = v236;
    v110 = v234;
  }
  *v117 = 0.0;
  if ( !v110 )
    goto LABEL_184;
  v109 = (double *)((char *)v117 + v235);
  v236 = (double *)((char *)v117 + v235);
  if ( (unsigned __int64)v117 + v235 >= v238 )
  {
    v236 = v117;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v109 = v236;
    v110 = v234;
  }
LABEL_185:
  *v109 = -*(double *)(v294 + **((_QWORD **)&v297 + 1));
  if ( !v110 )
  {
    v118 = v109;
    *v109 = 0.0;
LABEL_195:
    v119 = v118;
    *v118 = 0.0;
LABEL_196:
    v120 = v119;
    goto LABEL_197;
  }
  v118 = (double *)((char *)v109 + v235);
  v236 = (double *)((char *)v109 + v235);
  if ( (unsigned __int64)v109 + v235 >= v238 )
  {
    v236 = v109;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v118 = v236;
    v110 = v234;
  }
  *v118 = 0.0;
  if ( !v110 )
    goto LABEL_195;
  v119 = (double *)((char *)v118 + v235);
  v236 = (double *)((char *)v118 + v235);
  if ( (unsigned __int64)v118 + v235 >= v238 )
  {
    v236 = v118;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v119 = v236;
    v110 = v234;
  }
  *v119 = 0.0;
  if ( !v110 )
    goto LABEL_196;
  v120 = (double *)((char *)v119 + v235);
  v236 = (double *)((char *)v119 + v235);
  if ( (unsigned __int64)v119 + v235 >= v238 )
  {
    v236 = v119;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v120 = v236;
    v110 = v234;
  }
LABEL_197:
  *v120 = 1.0;
  if ( v110 )
  {
    v121 = (double *)((char *)v120 + v235);
    v236 = (double *)((char *)v120 + v235);
    if ( (unsigned __int64)v120 + v235 >= v238 )
    {
      v236 = v120;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v121 = v236;
      v110 = v234;
    }
  }
  else
  {
    v121 = v120;
  }
  *v121 = -*(double *)(v294 + 2LL * **((_QWORD **)&v297 + 1));
  if ( !v110 )
  {
    v122 = v121;
    *v121 = 0.0;
LABEL_214:
    v123 = v122;
    *v122 = 0.0;
LABEL_215:
    v124 = v123;
    *v123 = 0.0;
LABEL_216:
    v125 = v124;
    goto LABEL_217;
  }
  v122 = (double *)((char *)v121 + v235);
  v236 = (double *)((char *)v121 + v235);
  if ( (unsigned __int64)v121 + v235 >= v238 )
  {
    v236 = v121;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v122 = v236;
    v110 = v234;
  }
  *v122 = 0.0;
  if ( !v110 )
    goto LABEL_214;
  v123 = (double *)((char *)v122 + v235);
  v236 = (double *)((char *)v122 + v235);
  if ( (unsigned __int64)v122 + v235 >= v238 )
  {
    v236 = v122;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v123 = v236;
    v110 = v234;
  }
  *v123 = 0.0;
  if ( !v110 )
    goto LABEL_215;
  v124 = (double *)((char *)v123 + v235);
  v236 = (double *)((char *)v123 + v235);
  if ( (unsigned __int64)v123 + v235 >= v238 )
  {
    v236 = v123;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v124 = v236;
    v110 = v234;
  }
  *v124 = 0.0;
  if ( !v110 )
    goto LABEL_216;
  v125 = (double *)((char *)v124 + v235);
  v236 = (double *)((char *)v124 + v235);
  if ( (unsigned __int64)v124 + v235 >= v238 )
  {
    v236 = v124;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v125 = v236;
    v110 = v234;
  }
LABEL_217:
  *v125 = 1.0;
  if ( v110 )
  {
    v236 = (double *)((char *)v125 + v235);
    if ( (unsigned __int64)v125 + v235 >= v238 )
    {
      v236 = v125;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v110 = v234;
    }
  }
  memset(&v258[4], 0, 60);
  *(_QWORD *)&v259 = &v258[8];
  *((_QWORD *)&v259 + 1) = &v260;
  v261 = 0LL;
  v260 = 0LL;
  *(_DWORD *)v258 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v258, v110);
  *(_OWORD *)&v250[16] = *(_OWORD *)&v258[16];
  *(_OWORD *)&v250[32] = *(_OWORD *)&v258[32];
  *(_OWORD *)v250 = *(_OWORD *)v258;
  *(_OWORD *)&v250[48] = *(_OWORD *)&v258[48];
  *(_QWORD *)&v251 = &v250[8];
  *((_QWORD *)&v251 + 1) = &v252;
  v252 = 0LL;
  v253 = 0LL;
  if ( *(int *)&v258[4] > 2 )
  {
    v128 = v259;
    v127 = (cv *)&v260;
    *((_QWORD *)&v259 + 1) = &v260;
    *(_QWORD *)&v259 = &v258[8];
    v251 = v128;
  }
  else
  {
    v127 = (cv *)*((_QWORD *)&v259 + 1);
    v252 = **((_QWORD **)&v259 + 1);
    v253 = *(_QWORD *)(*((_QWORD *)&v259 + 1) + 8LL);
  }
  *(_DWORD *)v258 = 1124007936;
  memset(&v258[4], 0, 60);
  if ( v127 != (cv *)&v260 )
    cv::fastFree(v127, v126);
  if ( *(_QWORD *)&v245[56] )
  {
    v129 = (unsigned int *)(*(_QWORD *)&v245[56] + 20LL);
    do
    {
      v130 = __ldaxr(v129);
      v131 = v130 - 1;
    }
    while ( __stlxr(v131, v129) );
    if ( !v131 )
      cv::Mat::deallocate((cv::Mat *)v245);
  }
  *(_QWORD *)&v245[56] = 0LL;
  memset(&v245[16], 0, 32);
  if ( *(int *)&v245[4] >= 1 )
  {
    v132 = v246;
    v133 = 0LL;
    do
      *(_DWORD *)&v132[4 * v133++] = 0;
    while ( v133 < *(int *)&v245[4] );
  }
  if ( v247 != (cv *)&v248 )
    cv::fastFree(v247, v126);
  *(_DWORD *)v245 = 1124007936;
  memset(&v245[4], 0, 60);
  v246 = &v245[8];
  v247 = (cv *)&v248;
  v248 = 0LL;
  v249 = 0LL;
  *(_QWORD *)v239 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v245, 2, v239, 6);
  v134 = *(_QWORD *)v316[2];
  v240 = (cv::Mat *)v245;
  if ( *(int *)&v245[4] < 1 )
    v135 = 0LL;
  else
    v135 = *((_QWORD *)v247 + *(_DWORD *)&v245[4] - 1);
  v241 = v135;
  v242 = 0LL;
  v243 = 0LL;
  v244 = 0LL;
  if ( (v245[1] & 0x40) != 0 )
  {
    v243 = *(_QWORD *)&v245[16];
    if ( *(int *)&v245[4] >= 3 )
    {
      if ( *(_DWORD *)&v245[4] == 3 )
      {
        v137 = 0LL;
        v136 = 1LL;
      }
      else
      {
        v137 = *(_DWORD *)&v245[4] & 0xFFFFFFFC;
        v138 = vdupq_n_s64(1uLL);
        v139 = v246 + 8;
        v140 = v137;
        v141 = v138;
        do
        {
          v142 = *(v139 - 1);
          v138.n128_u64[0] *= (int)v142;
          v141.n128_u64[0] *= (int)*v139;
          v140 -= 4LL;
          v138.n128_u64[1] *= SHIDWORD(v142);
          v141.n128_u64[1] *= (int)HIDWORD(*v139);
          v139 += 2;
        }
        while ( v140 );
        v136 = v141.n128_u64[0] * v138.n128_u64[0] * v141.n128_u64[1] * v138.n128_u64[1];
        if ( v137 == *(unsigned int *)&v245[4] )
          goto LABEL_248;
      }
      v143 = *(unsigned int *)&v245[4] - v137;
      v144 = (int *)&v246[4 * v137];
      do
      {
        v145 = *v144++;
        --v143;
        v136 *= v145;
      }
      while ( v143 );
    }
    else
    {
      v136 = *(int *)&v245[12] * (__int64)*(int *)&v245[8];
    }
LABEL_248:
    v244 = *(_QWORD *)&v245[16] + v136 * v135;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 0LL, 0);
  v146 = v242;
  *(_QWORD *)v242 = v134;
  v147 = v240;
  if ( v240 )
  {
    v242 = (double *)((char *)v146 + v241);
    if ( (unsigned __int64)v146 + v241 >= v244 )
    {
      v242 = v146;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v240, 1LL, 1);
      v147 = v240;
      v146 = v242;
    }
    else
    {
      v146 = (double *)((char *)v146 + v241);
    }
  }
  v148 = v241;
  v149 = v244;
  v150 = v316[2];
  v234 = v147;
  v235 = v241;
  v236 = v146;
  v237 = v243;
  v238 = v244;
  *v146 = *(double *)(v316[2] + 8LL);
  if ( v147 )
  {
    v151 = (double *)((char *)v146 + v148);
    v236 = v151;
    if ( (unsigned __int64)v151 >= v149 )
    {
      v236 = v146;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v150 = v316[2];
      v151 = v236;
      v147 = v234;
    }
    *v151 = *(double *)(v150 + 16);
    if ( v147 )
    {
      v152 = (double *)((char *)v151 + v235);
      v236 = (double *)((char *)v151 + v235);
      if ( (unsigned __int64)v151 + v235 >= v238 )
      {
        v236 = v151;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
        v152 = v236;
        v147 = v234;
      }
    }
    else
    {
      v152 = v151;
    }
    *v152 = *(double *)v294;
    if ( v147 )
    {
      v146 = (double *)((char *)v152 + v235);
      v236 = (double *)((char *)v152 + v235);
      if ( (unsigned __int64)v152 + v235 >= v238 )
      {
        v236 = v152;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
        v146 = v236;
        v147 = v234;
      }
    }
    else
    {
      v146 = v152;
    }
  }
  else
  {
    *v146 = *(double *)(v150 + 16);
    *v146 = *(double *)v294;
  }
  v153 = (double *)(v316[2] + *(_QWORD *)v318);
  *v146 = *v153;
  if ( v147 )
  {
    v154 = (double *)((char *)v146 + v235);
    v236 = (double *)((char *)v146 + v235);
    if ( (unsigned __int64)v146 + v235 >= v238 )
    {
      v236 = v146;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v154 = v236;
      v147 = v234;
      v153 = (double *)(v316[2] + *(_QWORD *)v318);
    }
  }
  else
  {
    v154 = v146;
  }
  *v154 = v153[1];
  if ( v147 )
  {
    v155 = (double *)((char *)v154 + v235);
    v236 = (double *)((char *)v154 + v235);
    if ( (unsigned __int64)v154 + v235 >= v238 )
    {
      v236 = v154;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v147 = v234;
      v155 = v236;
      v153 = (double *)(v316[2] + *(_QWORD *)v318);
    }
  }
  else
  {
    v155 = v154;
  }
  *v155 = v153[2];
  if ( v147 )
  {
    v156 = (double *)((char *)v155 + v235);
    v236 = (double *)((char *)v155 + v235);
    if ( (unsigned __int64)v155 + v235 >= v238 )
    {
      v236 = v155;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v156 = v236;
      v147 = v234;
    }
  }
  else
  {
    v156 = v155;
  }
  *v156 = *(double *)(v294 + **((_QWORD **)&v297 + 1));
  if ( v147 )
  {
    v157 = (double *)((char *)v156 + v235);
    v236 = (double *)((char *)v156 + v235);
    if ( (unsigned __int64)v156 + v235 >= v238 )
    {
      v236 = v156;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v157 = v236;
      v147 = v234;
    }
  }
  else
  {
    v157 = v156;
  }
  v158 = (double *)(v316[2] + 2LL * *(_QWORD *)v318);
  *v157 = *v158;
  if ( v147 )
  {
    v159 = (double *)((char *)v157 + v235);
    v236 = (double *)((char *)v157 + v235);
    if ( (unsigned __int64)v157 + v235 >= v238 )
    {
      v236 = v157;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v159 = v236;
      v147 = v234;
      v158 = (double *)(v316[2] + 2LL * *(_QWORD *)v318);
    }
  }
  else
  {
    v159 = v157;
  }
  *v159 = v158[1];
  if ( v147 )
  {
    v160 = (double *)((char *)v159 + v235);
    v236 = (double *)((char *)v159 + v235);
    if ( (unsigned __int64)v159 + v235 >= v238 )
    {
      v236 = v159;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v160 = v236;
      v147 = v234;
      v158 = (double *)(v316[2] + 2LL * *(_QWORD *)v318);
    }
  }
  else
  {
    v160 = v159;
  }
  *v160 = v158[2];
  if ( v147 )
  {
    v161 = (double *)((char *)v160 + v235);
    v236 = (double *)((char *)v160 + v235);
    if ( (unsigned __int64)v160 + v235 >= v238 )
    {
      v236 = v160;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v161 = v236;
      v147 = v234;
    }
  }
  else
  {
    v161 = v160;
  }
  *v161 = *(double *)(v294 + 2LL * **((_QWORD **)&v297 + 1));
  if ( !v147 )
  {
    v162 = v161;
    *v161 = 0.0;
LABEL_306:
    v163 = v162;
    *v162 = 0.0;
LABEL_307:
    v164 = v163;
    *v163 = 0.0;
    goto LABEL_308;
  }
  v162 = (double *)((char *)v161 + v235);
  v236 = (double *)((char *)v161 + v235);
  if ( (unsigned __int64)v161 + v235 >= v238 )
  {
    v236 = v161;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v162 = v236;
    v147 = v234;
  }
  *v162 = 0.0;
  if ( !v147 )
    goto LABEL_306;
  v163 = (double *)((char *)v162 + v235);
  v236 = (double *)((char *)v162 + v235);
  if ( (unsigned __int64)v162 + v235 >= v238 )
  {
    v236 = v162;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v163 = v236;
    v147 = v234;
  }
  *v163 = 0.0;
  if ( !v147 )
    goto LABEL_307;
  v164 = (double *)((char *)v163 + v235);
  v236 = (double *)((char *)v163 + v235);
  if ( (unsigned __int64)v163 + v235 >= v238 )
  {
    v236 = v163;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
    v164 = v236;
    v147 = v234;
  }
  *v164 = 0.0;
  if ( v147 )
  {
    v165 = (double *)((char *)v164 + v235);
    v236 = (double *)((char *)v164 + v235);
    if ( (unsigned __int64)v164 + v235 >= v238 )
    {
      v236 = v164;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v165 = v236;
      v147 = v234;
    }
    goto LABEL_309;
  }
LABEL_308:
  v165 = v164;
LABEL_309:
  *v165 = 1.0;
  if ( v147 )
  {
    v236 = (double *)((char *)v165 + v235);
    if ( (unsigned __int64)v165 + v235 >= v238 )
    {
      v236 = v165;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v234, 1LL, 1);
      v147 = v234;
    }
  }
  memset(&v258[4], 0, 60);
  *(_QWORD *)&v259 = &v258[8];
  *((_QWORD *)&v259 + 1) = &v260;
  v261 = 0LL;
  v260 = 0LL;
  *(_DWORD *)v258 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v258, v147);
  if ( v258 == (_BYTE *)a3 )
  {
    if ( *(_QWORD *)&v258[56] )
    {
      v178 = (unsigned int *)(*(_QWORD *)&v258[56] + 20LL);
      do
      {
        v179 = __ldaxr(v178);
        v180 = v179 - 1;
      }
      while ( __stlxr(v180, v178) );
      if ( !v180 )
        cv::Mat::deallocate((cv::Mat *)v258);
    }
  }
  else
  {
    v167 = *(_QWORD *)(a3 + 56);
    if ( v167 )
    {
      v168 = (unsigned int *)(v167 + 20);
      do
      {
        v169 = __ldaxr(v168);
        v170 = v169 - 1;
      }
      while ( __stlxr(v170, v168) );
      if ( !v170 )
        cv::Mat::deallocate((cv::Mat *)a3);
    }
    v171 = *(_DWORD *)(a3 + 4);
    *(_QWORD *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    if ( v171 >= 1 )
    {
      v172 = *(_QWORD *)(a3 + 64);
      v173 = 0LL;
      do
        *(_DWORD *)(v172 + 4 * v173++) = 0;
      while ( v173 < *(int *)(a3 + 4) );
    }
    v174 = *(_DWORD *)&v258[4];
    v175 = *(_OWORD *)&v258[16];
    v176 = *(cv **)(a3 + 72);
    *(_OWORD *)a3 = *(_OWORD *)v258;
    *(_OWORD *)(a3 + 16) = v175;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v258[32];
    *(_OWORD *)(a3 + 48) = *(_OWORD *)&v258[48];
    if ( v176 == (cv *)(a3 + 80) )
    {
      v177 = v174;
    }
    else
    {
      cv::fastFree(v176, v166);
      *(_QWORD *)(a3 + 64) = a3 + 8;
      *(_QWORD *)(a3 + 72) = a3 + 80;
      v177 = *(_DWORD *)&v258[4];
      v176 = (cv *)(a3 + 80);
    }
    if ( v177 <= 2 )
    {
      v181 = *((_QWORD *)&v259 + 1);
      *(_QWORD *)v176 = **((_QWORD **)&v259 + 1);
      *((_QWORD *)v176 + 1) = *(_QWORD *)(v181 + 8);
    }
    else
    {
      *(_OWORD *)(a3 + 64) = v259;
      *((_QWORD *)&v259 + 1) = &v260;
      *(_QWORD *)&v259 = &v258[8];
    }
    *(_DWORD *)v258 = 1124007936;
    memset(&v258[4], 0, 60);
  }
  *(_QWORD *)&v258[56] = 0LL;
  memset(&v258[16], 0, 32);
  if ( *(int *)&v258[4] >= 1 )
  {
    v182 = v259;
    v183 = 0LL;
    do
      *(_DWORD *)(v182 + 4 * v183++) = 0;
    while ( v183 < *(int *)&v258[4] );
  }
  if ( *((__int64 **)&v259 + 1) != &v260 )
    cv::fastFree(*((cv **)&v259 + 1), v166);
  if ( *(_QWORD *)&v245[56] )
  {
    v184 = (unsigned int *)(*(_QWORD *)&v245[56] + 20LL);
    do
    {
      v185 = __ldaxr(v184);
      v186 = v185 - 1;
    }
    while ( __stlxr(v186, v184) );
    if ( !v186 )
      cv::Mat::deallocate((cv::Mat *)v245);
  }
  *(_QWORD *)&v245[56] = 0LL;
  memset(&v245[16], 0, 32);
  if ( *(int *)&v245[4] >= 1 )
  {
    v187 = v246;
    v188 = 0LL;
    do
      *(_DWORD *)&v187[4 * v188++] = 0;
    while ( v188 < *(int *)&v245[4] );
  }
  if ( v247 != (cv *)&v248 )
    cv::fastFree(v247, v166);
  cv::operator*(v258, v254, v250);
  (*(void (__fastcall **)(_QWORD, _BYTE *, __int64, __int64))(**(_QWORD **)v258 + 24LL))(
    *(_QWORD *)v258,
    v258,
    v232,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v258, v189);
  if ( *(_QWORD *)&v250[56] )
  {
    v191 = (unsigned int *)(*(_QWORD *)&v250[56] + 20LL);
    do
    {
      v192 = __ldaxr(v191);
      v193 = v192 - 1;
    }
    while ( __stlxr(v193, v191) );
    if ( !v193 )
      cv::Mat::deallocate((cv::Mat *)v250);
  }
  *(_QWORD *)&v250[56] = 0LL;
  memset(&v250[16], 0, 32);
  if ( *(int *)&v250[4] >= 1 )
  {
    v194 = v251;
    v195 = 0LL;
    do
      *(_DWORD *)(v194 + 4 * v195++) = 0;
    while ( v195 < *(int *)&v250[4] );
  }
  if ( *((__int64 **)&v251 + 1) != &v252 )
    cv::fastFree(*((cv **)&v251 + 1), v190);
  if ( *(_QWORD *)&v254[56] )
  {
    v196 = (unsigned int *)(*(_QWORD *)&v254[56] + 20LL);
    do
    {
      v197 = __ldaxr(v196);
      v198 = v197 - 1;
    }
    while ( __stlxr(v198, v196) );
    if ( !v198 )
      cv::Mat::deallocate((cv::Mat *)v254);
  }
  *(_QWORD *)&v254[56] = 0LL;
  memset(&v254[16], 0, 32);
  if ( *(int *)&v254[4] >= 1 )
  {
    v199 = v255;
    v200 = 0LL;
    do
      *(_DWORD *)(v199 + 4 * v200++) = 0;
    while ( v200 < *(int *)&v254[4] );
  }
  if ( *((__int64 **)&v255 + 1) != &v256 )
    cv::fastFree(*((cv **)&v255 + 1), v190);
  if ( v262[7] )
  {
    v201 = (unsigned int *)(v262[7] + 20LL);
    do
    {
      v202 = __ldaxr(v201);
      v203 = v202 - 1;
    }
    while ( __stlxr(v203, v201) );
    if ( !v203 )
      cv::Mat::deallocate((cv::Mat *)v262);
  }
  v262[7] = 0LL;
  memset(&v262[2], 0, 32);
  if ( SHIDWORD(v262[0]) >= 1 )
  {
    v204 = v263;
    v205 = 0LL;
    do
      *((_DWORD *)v204 + v205++) = 0;
    while ( v205 < SHIDWORD(v262[0]) );
  }
  if ( v264 != (cv *)v265 )
    cv::fastFree(v264, v190);
  if ( v271 )
  {
    v206 = (unsigned int *)(v271 + 20);
    do
    {
      v207 = __ldaxr(v206);
      v208 = v207 - 1;
    }
    while ( __stlxr(v208, v206) );
    if ( !v208 )
      cv::Mat::deallocate((cv::Mat *)v267);
  }
  v271 = 0LL;
  v270 = 0u;
  v269 = 0u;
  if ( v268 >= 1 )
  {
    v209 = v272;
    for ( i = 0LL; i < v268; *(_DWORD *)(v209 + 4 * i++) = 0 )
      ;
  }
  if ( v273 != (cv *)&v274 )
    cv::fastFree(v273, v190);
  if ( v280 )
  {
    v211 = (unsigned int *)(v280 + 20);
    do
    {
      v212 = __ldaxr(v211);
      v213 = v212 - 1;
    }
    while ( __stlxr(v213, v211) );
    if ( !v213 )
      cv::Mat::deallocate((cv::Mat *)&v276);
  }
  v280 = 0LL;
  v279 = 0u;
  v278 = 0u;
  if ( SHIDWORD(v276) >= 1 )
  {
    v214 = v281;
    v215 = 0LL;
    do
      *(_DWORD *)(v214 + 4 * v215++) = 0;
    while ( v215 < SHIDWORD(v276) );
  }
  if ( v282 != (cv *)&v283 )
    cv::fastFree(v282, v190);
  if ( v289 )
  {
    v216 = (unsigned int *)(v289 + 20);
    do
    {
      v217 = __ldaxr(v216);
      v218 = v217 - 1;
    }
    while ( __stlxr(v218, v216) );
    if ( !v218 )
      cv::Mat::deallocate((cv::Mat *)&v285);
  }
  v289 = 0LL;
  v287 = 0u;
  v288 = 0u;
  if ( SHIDWORD(v285) >= 1 )
  {
    v219 = v290;
    v220 = 0LL;
    do
      *(_DWORD *)(v219 + 4 * v220++) = 0;
    while ( v220 < SHIDWORD(v285) );
  }
  if ( v291 != (cv *)&v292 )
    cv::fastFree(v291, v190);
  if ( *((_QWORD *)&v296 + 1) )
  {
    v221 = (unsigned int *)(*((_QWORD *)&v296 + 1) + 20LL);
    do
    {
      v222 = __ldaxr(v221);
      v223 = v222 - 1;
    }
    while ( __stlxr(v223, v221) );
    if ( !v223 )
      cv::Mat::deallocate((cv::Mat *)&v293);
  }
  *((_QWORD *)&v296 + 1) = 0LL;
  v294 = 0u;
  v295 = 0u;
  if ( SDWORD1(v293) >= 1 )
  {
    v224 = v297;
    v225 = 0LL;
    do
      *(_DWORD *)(v224 + 4 * v225++) = 0;
    while ( v225 < SDWORD1(v293) );
  }
  if ( *((__int64 **)&v297 + 1) != &v298 )
    cv::fastFree(*((cv **)&v297 + 1), v190);
  if ( v316[7] )
  {
    v226 = (unsigned int *)(v316[7] + 20LL);
    do
    {
      v227 = __ldaxr(v226);
      v228 = v227 - 1;
    }
    while ( __stlxr(v228, v226) );
    if ( !v228 )
      cv::Mat::deallocate((cv::Mat *)v316);
  }
  v316[7] = 0LL;
  memset(&v316[2], 0, 32);
  if ( SHIDWORD(v316[0]) >= 1 )
  {
    v229 = v317;
    v230 = 0LL;
    do
      *((_DWORD *)v229 + v230++) = 0;
    while ( v230 < SHIDWORD(v316[0]) );
  }
  if ( v318 != (cv *)v319 )
    cv::fastFree(v318, v190);
  return 0LL;
}
// 32224: conditional instruction was optimized away because x1.8==0
// 32230: conditional instruction was optimized away because x1.8==0
// 3223C: conditional instruction was optimized away because x1.8==0
// 3282C: conditional instruction was optimized away because x1.8==0
// 3299C: conditional instruction was optimized away because x1.8==0
// 329A8: conditional instruction was optimized away because x1.8==0
// 33178: conditional instruction was optimized away because x1.8==0
// 33184: conditional instruction was optimized away because x1.8==0
// 31AB8: variable 'v48' is possibly undefined
// 31C0C: variable 'v56' is possibly undefined
// 31C14: variable 'v57' is possibly undefined
// 32354: variable 'v90' is possibly undefined
// 32ABC: variable 'v126' is possibly undefined
// 33294: variable 'v166' is possibly undefined
// 3341C: variable 'v189' is possibly undefined
// 33488: variable 'v190' is possibly undefined
// 12C90: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);
// 136C0: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, _QWORD);

//----- (00000000000341A8) ----------------------------------------------------
float32x2_t __usercall feasibal_region::ground_process::getTFMatrix@<D0>(
        float *a1@<X1>,
        float32x2_t *a2@<X2>,
        float32x2_t *a3@<X8>)
{
  float v3; // s9
  float v4; // s13
  float v7; // s10
  float v8; // s11
  float v9; // s12
  float v10; // s7
  float v11; // s16
  float v12; // s2
  float v13; // s1
  float v14; // s3
  float v15; // s5
  float v16; // s11
  float v17; // s2
  float v18; // s12
  float v19; // s9
  float v20; // s10
  float v21; // s0
  float v22; // s1
  float v23; // s4
  float v24; // s16
  float v25; // s6
  float v26; // s7
  float v27; // s17
  float v28; // s18
  float v29; // s3
  float v30; // s0
  float v31; // s6
  float v32; // s3
  float v33; // s0
  float v34; // s4
  float v35; // s16
  float v36; // s1
  float v37; // s17
  float v38; // s4
  float v39; // s18
  float v40; // s6
  float v41; // s5
  float v42; // s3
  float v43; // s0
  float v44; // s7
  float v45; // s19
  float v46; // s20
  float v47; // s4
  float v48; // s18
  float v49; // s6
  float v50; // s3
  float v51; // s0
  float v52; // s1
  float v53; // s5
  float32x2_t result; // d0
  float v55; // s1
  float v56; // [xsp+0h] [xbp-60h] BYREF
  float v57; // [xsp+4h] [xbp-5Ch] BYREF
  float cosx; // [xsp+8h] [xbp-58h] BYREF
  float sinx; // [xsp+Ch] [xbp-54h] BYREF
  float v60; // [xsp+18h] [xbp-48h] BYREF
  float v61; // [xsp+1Ch] [xbp-44h] BYREF

  v3 = a1[1];
  v4 = *a1;
  sincosf(a1[2] * 0.5, &sinx, &cosx);
  v8 = cosx;
  v7 = sinx;
  v9 = sinx * 0.0;
  sincosf(v3 * 0.5, &v57, &v56);
  v10 = (float)(v57 * 0.0) * v9;
  v11 = v7 * (float)(v57 * 0.0);
  v12 = v8 * (float)(v57 * 0.0);
  v13 = (float)(v56 * v7) + v12;
  v14 = (float)(v56 * v8) - v10;
  v15 = v12 + (float)(v56 * v9);
  v16 = (float)(v11 + (float)((float)(v57 * v8) + (float)(v56 * v9))) - v10;
  v17 = v14 - (float)(v57 * v9);
  v18 = (float)((float)(v57 * v9) + v13) - v10;
  v19 = v17 - v11;
  v20 = (float)(v10 + v15) - (float)(v57 * v7);
  sincosf(v4 * 0.5, &v61, &v60);
  v21 = v60;
  v22 = v61;
  a3[1].n64_u32[1] = 0;
  v23 = v21 * v19;
  v24 = v21 * v16;
  v25 = (float)(v22 * v19) + (float)(v21 * v20);
  v26 = (float)(v22 * 0.0) * v19;
  v27 = (float)(v22 * 0.0) * v16;
  v28 = (float)(v22 * 0.0) * v18;
  v29 = (float)(v22 * 0.0) * v20;
  v30 = v29 + (float)((float)(v21 * v18) + v26);
  v31 = (float)(v27 + v25) - v28;
  v32 = (float)((float)(v22 * v18) + (float)(v26 + v24)) - v29;
  v33 = v30 - (float)(v22 * v16);
  v34 = (float)((float)(v23 - (float)(v22 * v20)) - v27) - v28;
  v35 = v34 * (float)(v31 + v31);
  v36 = v31 * (float)(v31 + v31);
  v37 = v34 * (float)(v32 + v32);
  v38 = v34 * (float)(v33 + v33);
  v39 = v31 * (float)(v32 + v32);
  v40 = v31 * (float)(v33 + v33);
  v41 = v32 * (float)(v32 + v32);
  v42 = v32 * (float)(v33 + v33);
  v43 = v33 * (float)(v33 + v33);
  v44 = v41 + v43;
  v45 = v39 - v38;
  v46 = v40 + v37;
  v47 = v39 + v38;
  v48 = v42 - v35;
  v49 = v40 - v37;
  v50 = v42 + v35;
  v51 = 1.0 - (float)(v36 + v43);
  v52 = 1.0 - (float)(v36 + v41);
  v53 = (float)(1.0 - v44) * 0.0;
  a3[3].n64_u32[1] = 0;
  a3[5].n64_u32[1] = 0;
  a3[7].n64_u32[1] = 1065353216;
  a3[4].n64_f32[0] = (float)(v46 + (float)(v48 * 0.0)) + (float)(v52 * 0.0);
  a3[4].n64_f32[1] = (float)(v48 + (float)(v46 * 0.0)) + (float)(v52 * 0.0);
  a3[5].n64_f32[0] = v52 + (float)((float)(v46 * 0.0) + (float)(v48 * 0.0));
  a3->n64_f32[0] = (float)(v49 * 0.0) + (float)((float)(1.0 - v44) + (float)(v47 * 0.0));
  a3->n64_f32[1] = (float)(v49 * 0.0) + (float)(v47 + v53);
  a3[1].n64_f32[0] = v49 + (float)((float)(v47 * 0.0) + v53);
  a3[2].n64_f32[0] = (float)(v50 * 0.0) + (float)(v45 + (float)(v51 * 0.0));
  a3[2].n64_f32[1] = (float)(v50 * 0.0) + (float)((float)(v45 * 0.0) + v51);
  a3[3].n64_f32[0] = v50 + (float)((float)(v45 * 0.0) + (float)(v51 * 0.0));
  result.n64_u64[0] = vadd_f32((float32x2_t)a2->n64_u64[0], 0LL).n64_u64[0];
  v55 = a2[1].n64_f32[0] + 0.0;
  a3[6].n64_u64[0] = result.n64_u64[0];
  a3[7].n64_f32[0] = v55;
  return result;
}

//----- (0000000000034414) ----------------------------------------------------
float __usercall feasibal_region::rotationMatrixFromAxisAndAngle@<S0>(float *a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  float v3; // s8
  float v4; // s9
  float v5; // s10
  float v7; // s5
  float v8; // s6
  float v9; // s18
  float result; // s0
  float v11; // s7
  float v12; // s4
  float v13; // s16
  float v14; // s3
  float v15; // s5
  float v16; // s6
  float v17; // s1
  float cosx; // [xsp+8h] [xbp-28h] BYREF
  float sinx; // [xsp+Ch] [xbp-24h] BYREF

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  sincosf(a3, &sinx, &cosx);
  v7 = (float)(1.0 - cosx) * v3;
  v8 = (float)(1.0 - cosx) * v4;
  v9 = (float)(v4 * v7) - (float)(sinx * v5);
  result = (float)(v4 * v7) + (float)(sinx * v5);
  v11 = (float)(sinx * v4) + (float)(v7 * v5);
  v12 = (float)(v7 * v5) - (float)(sinx * v4);
  v13 = (float)(v8 * v5) - (float)(sinx * v3);
  v14 = (float)(sinx * v3) + (float)(v8 * v5);
  v15 = cosx + (float)(v3 * v7);
  v16 = cosx + (float)(v4 * v8);
  v17 = cosx + (float)(v5 * (float)((float)(1.0 - cosx) * v5));
  a2[2] = v12;
  a2[3] = v9;
  *a2 = v15;
  a2[1] = result;
  a2[6] = v11;
  a2[7] = v13;
  a2[4] = v16;
  a2[5] = v14;
  a2[8] = v17;
  return result;
}

//----- (00000000000344D0) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::getExtrinsicFromYPR(int32x2_t *a1, float *a2, float32x2_t *a3)
{
  float v4; // w8
  float v5; // w9
  int32x2_t v6; // d0
  float v7; // w10
  float v8; // w11
  int32x2_t v9; // d1
  float v10; // w12
  float v11; // w13
  float v12; // s2
  float v13; // w14
  float v14; // w15
  __int64 v15; // d6
  float32x2_t v17; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int64 v18; // [xsp+10h] [xbp-50h]
  float v19; // [xsp+18h] [xbp-48h]
  float v20; // [xsp+1Ch] [xbp-44h]
  unsigned __int64 v21; // [xsp+20h] [xbp-40h]
  float v22; // [xsp+28h] [xbp-38h]
  float v23; // [xsp+2Ch] [xbp-34h]
  unsigned __int64 v24; // [xsp+30h] [xbp-30h]
  float v25; // [xsp+38h] [xbp-28h]
  float v26; // [xsp+3Ch] [xbp-24h]
  __int64 v27; // [xsp+40h] [xbp-20h]
  __int64 v28; // [xsp+48h] [xbp-18h]

  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  feasibal_region::ground_process::getTFMatrix(a2, a3, &v17);
  v4 = v17.n64_f32[0];
  v5 = v17.n64_f32[1];
  a1[216].n64_u32[0] = v17.n64_u32[0];
  a1[216].n64_f32[1] = v5;
  v6.n64_u64[0] = v18;
  a1[217].n64_u64[0] = v18;
  v7 = v19;
  v8 = v20;
  a1[218].n64_f32[0] = v19;
  a1[218].n64_f32[1] = v8;
  v9.n64_u64[0] = v21;
  a1[219].n64_u64[0] = v21;
  v10 = v22;
  v11 = v23;
  a1[220].n64_f32[0] = v22;
  a1[220].n64_f32[1] = v11;
  v12 = *(float *)&v24;
  a1[221].n64_u64[0] = v24;
  v13 = v25;
  v14 = v26;
  a1[222].n64_f32[0] = v25;
  a1[222].n64_f32[1] = v14;
  v15 = v27;
  a1[212].n64_u64[0] = vzip1_s32(v6, v9).n64_u64[0];
  a1[213].n64_f32[0] = v12;
  a1[208].n64_f32[0] = v4;
  a1[210].n64_f32[0] = v5;
  a1[208].n64_f32[1] = v7;
  a1[210].n64_f32[1] = v8;
  a1[209].n64_f32[0] = v10;
  a1[211].n64_f32[0] = v11;
  a1[209].n64_u32[1] = 0;
  a1[211].n64_u32[1] = 0;
  a1[213].n64_u32[1] = 0;
  a1[215].n64_u32[1] = 1065353216;
  a1[223].n64_u64[0] = v15;
  a1[214].n64_f32[0] = (float)((float)-(float)(v14 * v5) - (float)(v13 * v4))
                     - vmuls_n_f32(v6.n64_f32[0], *(float *)&v15);
  a1[214].n64_f32[1] = (float)((float)-(float)(v14 * v8) - (float)(v13 * v7))
                     - vmuls_n_f32(v9.n64_f32[0], *(float *)&v15);
  a1[215].n64_f32[0] = (float)((float)-(float)(v14 * v11) - (float)(v13 * v10)) - vmuls_n_f32(v12, *(float *)&v15);
  return 0LL;
}

//----- (0000000000034610) ----------------------------------------------------
float __fastcall feasibal_region::ground_process::getVectorAngle(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // d2
  float v4; // s0
  float v6; // s0
  float v7; // s1

  v3 = vmul_f32(*(float32x2_t *)(a2 + 4), *(float32x2_t *)(a3 + 4)).n64_u64[0];
  v4 = (float)((float)(*(float *)a2 * *(float *)a3) + *(float *)&v3) + *((float *)&v3 + 1);
  if ( fabsf(fabsf(v4) + -1.0) < 0.0001 )
    return 0.0;
  v6 = acosf(v4);
  if ( v6 > 1.57079633 )
  {
    v7 = v6 + -1.57079633;
    v6 = v7;
  }
  return fabsf(v6);
}

//----- (000000000003469C) ----------------------------------------------------
float __usercall feasibal_region::ground_process::getPlanePoints@<S0>(float *a1@<X1>, _QWORD *a2@<X8>)
{
  __int64 v4; // x0
  float v5; // s1
  float v6; // s2
  float v7; // s3
  float v8; // s4
  float v9; // s1
  float v10; // s0
  float v11; // s5
  float v12; // s4
  float result; // s0

  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  v4 = operator new(0x30uLL);
  a2[1] = v4 + 48;
  a2[2] = v4 + 48;
  *a2 = v4;
  *(int32x2_t *)(v4 + 36) = vdup_n_s32(0x44160000u);
  *(_QWORD *)v4 = 0x44160000C4160000LL;
  *(_QWORD *)(v4 + 12) = 0xC4160000C42F0000LL;
  *(_QWORD *)(v4 + 24) = 0xC416000044160000LL;
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  v8 = v5 * -600.0;
  v9 = v5 * 600.0;
  v10 = *a1 * 600.0;
  v11 = v7 + (float)((float)(*a1 * -700.0) + v8);
  v12 = v7 + (float)(v10 + v8);
  result = (float)-(float)(v7 + (float)(v10 + v9)) / v6;
  *(float *)(v4 + 8) = (float)-(float)(v7 + (float)((float)(*a1 * -600.0) + v9)) / v6;
  *(float *)(v4 + 20) = (float)-v11 / v6;
  *(float *)(v4 + 32) = (float)-v12 / v6;
  *(float *)(v4 + 44) = result;
  return result;
}

//----- (000000000003478C) ----------------------------------------------------
cv *__fastcall feasibal_region::depth2color(
        feasibal_region *this,
        cv::Mat *a2,
        const cv::Mat *a3,
        double a4,
        double a5)
{
  void *v6; // x1
  unsigned int *v7; // x8
  unsigned int v8; // w9
  unsigned int v9; // w9
  _QWORD *v10; // x8
  __int64 v11; // x9
  cv *result; // x0
  int v13; // [xsp+8h] [xbp-C8h] BYREF
  feasibal_region *v14; // [xsp+10h] [xbp-C0h]
  __int64 v15; // [xsp+18h] [xbp-B8h]
  int v16; // [xsp+20h] [xbp-B0h] BYREF
  _QWORD *v17; // [xsp+28h] [xbp-A8h]
  __int64 v18; // [xsp+30h] [xbp-A0h]
  _QWORD v19[8]; // [xsp+38h] [xbp-98h] BYREF
  _QWORD *v20; // [xsp+78h] [xbp-58h]
  cv *v21; // [xsp+80h] [xbp-50h]
  __int64 v22[3]; // [xsp+88h] [xbp-48h] BYREF

  v22[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  memset((char *)v19 + 4, 0, 60);
  LODWORD(v19[0]) = 1124007936;
  v20 = &v19[1];
  v21 = (cv *)v22;
  v22[0] = 0LL;
  v22[1] = 0LL;
  v17 = v19;
  v18 = 0LL;
  v16 = 33619968;
  cv::Mat::convertTo(a2, &v16, 0LL, 255.0 / (a4 - a5), -(255.0 / (a4 - a5) * a5));
  v17 = v19;
  v18 = 0LL;
  v14 = this;
  v15 = 0LL;
  v13 = 33619968;
  v16 = 16842752;
  cv::applyColorMap(&v16, &v13, 2LL);
  if ( v19[7] )
  {
    v7 = (unsigned int *)(v19[7] + 20LL);
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while ( __stlxr(v9, v7) );
    if ( !v9 )
      cv::Mat::deallocate((cv::Mat *)v19);
  }
  v19[7] = 0LL;
  memset(&v19[2], 0, 32);
  if ( SHIDWORD(v19[0]) >= 1 )
  {
    v10 = v20;
    v11 = 0LL;
    do
      *((_DWORD *)v10 + v11++) = 0;
    while ( v11 < SHIDWORD(v19[0]) );
  }
  result = v21;
  if ( v21 != (cv *)v22 )
    return (cv *)cv::fastFree(v21, v6);
  return result;
}
// 348A8: variable 'v6' is possibly undefined
// 13040: using guessed type __int64 __fastcall cv::Mat::convertTo(_QWORD, _QWORD, _QWORD, double, double);
// 13890: using guessed type __int64 __fastcall cv::applyColorMap(_QWORD, _QWORD, _QWORD);

//----- (0000000000034960) ----------------------------------------------------
long double __usercall feasibal_region::ground_process::getExtrinsic@<Q0>(
        feasibal_region::ground_process *this@<X0>,
        __int64 a2@<X8>)
{
  long double result; // q0

  *(_OWORD *)a2 = *((_OWORD *)this + 108);
  *(_OWORD *)(a2 + 16) = *((_OWORD *)this + 109);
  *(_OWORD *)(a2 + 32) = *((_OWORD *)this + 110);
  result = *((long double *)this + 111);
  *(long double *)(a2 + 48) = result;
  return result;
}

//----- (0000000000034984) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::run(
        feasibal_region::ground_process *this,
        const feasibal_region::GroundProcessRunInData *a2,
        feasibal_region::GroundProcessRunOutData *a3)
{
  cv *v6; // x0
  _DWORD *v7; // x22
  __int64 v8; // x8
  unsigned int *v9; // x8
  unsigned int v10; // w9
  __int64 v11; // x8
  unsigned int *v12; // x8
  unsigned int v13; // w9
  unsigned int v14; // w9
  int v15; // w8
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x10
  const char *v19; // x22
  size_t v20; // x0
  size_t v21; // x20
  char *v22; // x23
  unsigned __int64 v23; // x24
  char v24; // w20
  const char *v25; // x20
  size_t v26; // x0
  size_t v27; // x19
  char *v28; // x21
  unsigned __int64 v29; // x22
  char v30; // w19
  int v32; // w8
  _QWORD *v33; // x10
  _QWORD *v34; // x8
  __int64 v35; // x0
  const cv::Mat *v36; // x2
  _DWORD *v37; // x21
  unsigned int *v38; // x8
  unsigned int v39; // w9
  __int64 v40; // x8
  unsigned int *v41; // x8
  unsigned int v42; // w9
  unsigned int v43; // w9
  int v44; // w8
  __int64 v45; // x8
  __int64 v46; // x9
  __int64 v47; // x10
  _QWORD *v48; // x10
  cv *v49; // x8
  unsigned int *v50; // x8
  unsigned int v51; // w9
  cv *v52; // x8
  cv *v53; // x10
  void *v54; // x1
  unsigned int *v55; // x8
  unsigned int v56; // w9
  unsigned int v57; // w9
  __int64 v58; // x8
  __int64 v59; // x9
  _DWORD *v60; // x21
  _DWORD *v61; // x22
  __int64 v62; // x8
  unsigned int *v63; // x8
  unsigned int v64; // w9
  __int64 v65; // x8
  unsigned int *v66; // x8
  unsigned int v67; // w9
  unsigned int v68; // w9
  int v69; // w8
  __int64 v70; // x8
  __int64 v71; // x9
  __int64 v72; // x10
  __int64 v73; // x0
  int v74; // w8
  _QWORD *v75; // x10
  _QWORD *v76; // x8
  _DWORD *v77; // x21
  _DWORD *v78; // x22
  __int64 v79; // x8
  unsigned int *v80; // x8
  unsigned int v81; // w9
  __int64 v82; // x8
  unsigned int *v83; // x8
  unsigned int v84; // w9
  unsigned int v85; // w9
  int v86; // w8
  __int64 v87; // x8
  __int64 v88; // x9
  __int64 v89; // x10
  int v90; // w8
  _QWORD *v91; // x10
  _QWORD *v92; // x8
  const char *v93; // x21
  size_t v94; // x0
  size_t v95; // x20
  char *v96; // x22
  unsigned __int64 v97; // x23
  char v98; // w20
  const char *v99; // x20
  size_t v100; // x0
  size_t v101; // x19
  char *v102; // x21
  const char *v103; // x20
  size_t v104; // x0
  size_t v105; // x19
  char *v106; // x21
  unsigned __int64 v107; // x22
  void *v108; // x1
  char v109; // w19
  unsigned __int64 v110; // x22
  char v111; // w19
  unsigned int *v112; // x8
  unsigned int v113; // w9
  unsigned int v114; // w9
  __int64 v115; // x8
  __int64 v116; // x9
  unsigned int *v117; // x8
  unsigned int v118; // w9
  unsigned int v119; // w9
  _BYTE *v120; // x8
  __int64 v121; // x9
  char v122; // [xsp+18h] [xbp-428h] BYREF
  char v123[15]; // [xsp+19h] [xbp-427h] BYREF
  void *v124; // [xsp+28h] [xbp-418h]
  int v125; // [xsp+30h] [xbp-410h] BYREF
  unsigned __int64 v126; // [xsp+38h] [xbp-408h] BYREF
  size_t v127; // [xsp+40h] [xbp-400h]
  void *v128; // [xsp+48h] [xbp-3F8h]
  char v129; // [xsp+50h] [xbp-3F0h] BYREF
  char v130[15]; // [xsp+51h] [xbp-3EFh] BYREF
  void *v131; // [xsp+60h] [xbp-3E0h]
  int v132; // [xsp+68h] [xbp-3D8h] BYREF
  unsigned __int64 v133; // [xsp+70h] [xbp-3D0h] BYREF
  size_t v134; // [xsp+78h] [xbp-3C8h]
  void *v135; // [xsp+80h] [xbp-3C0h]
  char v136; // [xsp+88h] [xbp-3B8h] BYREF
  char v137[15]; // [xsp+89h] [xbp-3B7h] BYREF
  void *v138; // [xsp+98h] [xbp-3A8h]
  int v139; // [xsp+A0h] [xbp-3A0h] BYREF
  unsigned __int64 v140; // [xsp+A8h] [xbp-398h] BYREF
  size_t v141; // [xsp+B0h] [xbp-390h]
  void *v142; // [xsp+B8h] [xbp-388h]
  __int128 v143; // [xsp+C0h] [xbp-380h] BYREF
  float v144; // [xsp+DCh] [xbp-364h] BYREF
  __int64 v145; // [xsp+E0h] [xbp-360h] BYREF
  __int64 v146; // [xsp+E8h] [xbp-358h] BYREF
  char v147; // [xsp+F0h] [xbp-350h] BYREF
  char v148[15]; // [xsp+F1h] [xbp-34Fh] BYREF
  void *v149; // [xsp+100h] [xbp-340h]
  int v150; // [xsp+108h] [xbp-338h] BYREF
  unsigned __int64 v151; // [xsp+110h] [xbp-330h] BYREF
  size_t v152; // [xsp+118h] [xbp-328h]
  void *v153; // [xsp+120h] [xbp-320h]
  char v154; // [xsp+128h] [xbp-318h] BYREF
  char v155[15]; // [xsp+129h] [xbp-317h] BYREF
  void *v156; // [xsp+138h] [xbp-308h]
  int v157; // [xsp+140h] [xbp-300h] BYREF
  unsigned __int64 v158; // [xsp+148h] [xbp-2F8h] BYREF
  size_t v159; // [xsp+150h] [xbp-2F0h]
  void *v160; // [xsp+158h] [xbp-2E8h]
  unsigned __int64 v161; // [xsp+160h] [xbp-2E0h] BYREF
  int v162; // [xsp+168h] [xbp-2D8h]
  __int128 v163; // [xsp+170h] [xbp-2D0h] BYREF
  __int128 v164; // [xsp+180h] [xbp-2C0h]
  __int128 v165; // [xsp+190h] [xbp-2B0h]
  __int64 v166; // [xsp+1A0h] [xbp-2A0h]
  __int64 v167; // [xsp+1A8h] [xbp-298h]
  __int64 v168; // [xsp+1B0h] [xbp-290h]
  cv *v169; // [xsp+1B8h] [xbp-288h]
  __int64 v170[2]; // [xsp+1C0h] [xbp-280h] BYREF
  _OWORD v171[4]; // [xsp+1D0h] [xbp-270h] BYREF
  __int64 v172; // [xsp+210h] [xbp-230h]
  cv *v173; // [xsp+218h] [xbp-228h]
  __int64 v174[2]; // [xsp+220h] [xbp-220h] BYREF
  _BYTE v175[64]; // [xsp+230h] [xbp-210h] BYREF
  _BYTE *v176; // [xsp+270h] [xbp-1D0h]
  cv *v177; // [xsp+278h] [xbp-1C8h]
  __int64 v178[2]; // [xsp+280h] [xbp-1C0h] BYREF
  float32x2_t v179; // [xsp+290h] [xbp-1B0h] BYREF
  _BYTE *v180; // [xsp+298h] [xbp-1A8h]
  __int64 v181; // [xsp+2A0h] [xbp-1A0h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( *((_DWORD *)a2 + 2) != *((_DWORD *)this + 130) || *((_DWORD *)a2 + 3) != *((_DWORD *)this + 131) )
  {
    if ( (word_6FDF0 & 1) != 0 )
      v19 = (const char *)qword_6FE00;
    else
      v19 = (char *)&word_6FDF0 + 1;
    v157 = dword_6FDE8;
    v159 = 0LL;
    v160 = 0LL;
    v158 = 0LL;
    v20 = strlen(v19);
    if ( v20 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v21 = v20;
    if ( v20 >= 0x17 )
    {
      v23 = (v20 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v22 = (char *)operator new(v23);
      v159 = v21;
      v160 = v22;
      v158 = v23 | 1;
    }
    else
    {
      v22 = (char *)&v158 + 1;
      LOBYTE(v158) = 2 * v20;
      if ( !v20 )
      {
LABEL_26:
        v22[v21] = 0;
        if ( (g3::logLevel(&v157) & 1) != 0 )
        {
          *(_QWORD *)&v155[7] = 0LL;
          v156 = 0LL;
          v154 = 12;
          strcpy(v155, "region");
          v24 = g3::logTag(&v154);
          if ( (v154 & 1) == 0 )
          {
            if ( (v158 & 1) == 0 )
              goto LABEL_29;
LABEL_32:
            operator delete(v160);
            if ( (v24 & 1) == 0 )
              goto LABEL_34;
            goto LABEL_33;
          }
          operator delete(v156);
          if ( (v158 & 1) != 0 )
            goto LABEL_32;
        }
        else
        {
          v24 = 0;
          if ( (v158 & 1) != 0 )
            goto LABEL_32;
        }
LABEL_29:
        if ( (v24 & 1) == 0 )
        {
LABEL_34:
          if ( (word_6FDF0 & 1) != 0 )
            v25 = (const char *)qword_6FE00;
          else
            v25 = (char *)&word_6FDF0 + 1;
          v150 = dword_6FDE8;
          v152 = 0LL;
          v153 = 0LL;
          v151 = 0LL;
          v26 = strlen(v25);
          if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v27 = v26;
          if ( v26 >= 0x17 )
          {
            v29 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v28 = (char *)operator new(v29);
            v152 = v27;
            v153 = v28;
            v151 = v29 | 1;
          }
          else
          {
            v28 = (char *)&v151 + 1;
            LOBYTE(v151) = 2 * v26;
            if ( !v26 )
            {
LABEL_43:
              v28[v27] = 0;
              if ( (g3::logLevel(&v150) & 1) != 0 )
              {
                *(_QWORD *)&v148[7] = 0LL;
                v149 = 0LL;
                v147 = 12;
                strcpy(v148, "region");
                v30 = g3::logTag(&v147);
                if ( (v147 & 1) == 0 )
                {
                  if ( (v151 & 1) == 0 )
                    goto LABEL_46;
LABEL_49:
                  operator delete(v153);
                  if ( (v30 & 1) == 0 )
                    return 1LL;
LABEL_50:
                  LogCapture::LogCapture((LogCapture *)&v179, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
                  LogCapture::capturef((LogCapture *)&v179, "set and process image size not equal!\n");
                  LogCapture::~LogCapture((LogCapture *)&v179);
                  return 1LL;
                }
                operator delete(v149);
                if ( (v151 & 1) != 0 )
                  goto LABEL_49;
              }
              else
              {
                v30 = 0;
                if ( (v151 & 1) != 0 )
                  goto LABEL_49;
              }
LABEL_46:
              if ( (v30 & 1) == 0 )
                return 1LL;
              goto LABEL_50;
            }
          }
          memcpy(v28, v25, v27);
          goto LABEL_43;
        }
LABEL_33:
        LogCapture::LogCapture((LogCapture *)&v179, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
        LogCapture::capturef(
          (LogCapture *)&v179,
          "rows:%d,cols:%d, heght:%d,widht:%d!\n",
          *((unsigned int *)a2 + 2),
          *((unsigned int *)a2 + 3),
          *((unsigned int *)this + 130),
          *((unsigned int *)this + 131));
        LogCapture::~LogCapture((LogCapture *)&v179);
        goto LABEL_34;
      }
    }
    memcpy(v22, v19, v21);
    goto LABEL_26;
  }
  *((_DWORD *)this + 678) = *((_DWORD *)a2 + 48);
  *((_DWORD *)this + 679) = *((_DWORD *)a2 + 49);
  *((_DWORD *)this + 680) = *((_DWORD *)a2 + 50);
  *(_DWORD *)v175 = 1124007936;
  memset(&v175[4], 0, 60);
  v176 = &v175[8];
  v177 = (cv *)v178;
  v178[1] = 0LL;
  v178[0] = 0LL;
  v181 = 0LL;
  v179.n64_u32[0] = 33619968;
  v180 = v175;
  cv::Mat::copyTo(a2, &v179);
  v181 = 0LL;
  *((_QWORD *)&v171[0] + 1) = v175;
  *(_QWORD *)&v171[1] = 0LL;
  LODWORD(v171[0]) = 33619968;
  v179.n64_u32[0] = 16842752;
  v180 = v175;
  v6 = (cv *)cv::medianBlur(&v179, v171, 3LL);
  v7 = (_DWORD *)((char *)this + 2192);
  if ( (feasibal_region::ground_process *)((char *)this + 2192) == a2 )
    goto LABEL_61;
  v8 = *((_QWORD *)a2 + 7);
  if ( v8 )
  {
    v9 = (unsigned int *)(v8 + 20);
    do
      v10 = __ldaxr(v9);
    while ( __stlxr(v10 + 1, v9) );
  }
  v11 = *((_QWORD *)this + 281);
  if ( v11 )
  {
    v12 = (unsigned int *)(v11 + 20);
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while ( __stlxr(v14, v12) );
    if ( !v14 )
      v6 = (cv *)cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2192));
  }
  v15 = *((_DWORD *)this + 549);
  *((_QWORD *)this + 281) = 0LL;
  *((_OWORD *)this + 139) = 0u;
  *((_OWORD *)this + 138) = 0u;
  if ( v15 <= 0 )
  {
    *v7 = *(_DWORD *)a2;
  }
  else
  {
    v16 = *((_QWORD *)this + 282);
    v17 = 0LL;
    do
    {
      *(_DWORD *)(v16 + 4 * v17) = 0;
      v18 = *((int *)this + 549);
      ++v17;
    }
    while ( v17 < v18 );
    *v7 = *(_DWORD *)a2;
    if ( (int)v18 > 2 )
      goto LABEL_59;
  }
  v32 = *((_DWORD *)a2 + 1);
  if ( v32 > 2 )
  {
LABEL_59:
    v6 = (cv *)cv::Mat::copySize((feasibal_region::ground_process *)((char *)this + 2192), a2);
    goto LABEL_60;
  }
  *((_DWORD *)this + 549) = v32;
  v33 = (_QWORD *)*((_QWORD *)this + 283);
  *((_QWORD *)this + 275) = *((_QWORD *)a2 + 1);
  v34 = (_QWORD *)*((_QWORD *)a2 + 9);
  *v33 = *v34;
  v33[1] = v34[1];
LABEL_60:
  *((_OWORD *)this + 138) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 139) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 140) = *((_OWORD *)a2 + 3);
LABEL_61:
  v179.n64_u32[0] = 16842752;
  LODWORD(v171[0]) = 1124007936;
  v181 = 0LL;
  memset((char *)v171 + 4, 0, 60);
  v172 = (__int64)v171 + 8;
  v173 = (cv *)v174;
  v174[1] = 0LL;
  v174[0] = 0LL;
  v180 = v175;
  v35 = cv::noArray(v6);
  cv::minMaxLoc(&v179, &v146, &v145, 0LL, 0LL, v35);
  v145 = 0x40A7700000000000LL;
  v146 = 0LL;
  feasibal_region::depth2color((feasibal_region *)v171, (cv::Mat *)v175, v36, 0.0, 3000.0);
  v37 = (_DWORD *)((char *)this + 2288);
  if ( (_OWORD *)((char *)this + 2288) == v171 )
    goto LABEL_80;
  if ( *((_QWORD *)&v171[3] + 1) )
  {
    v38 = (unsigned int *)(*((_QWORD *)&v171[3] + 1) + 20LL);
    do
      v39 = __ldaxr(v38);
    while ( __stlxr(v39 + 1, v38) );
  }
  v40 = *((_QWORD *)this + 293);
  if ( v40 )
  {
    v41 = (unsigned int *)(v40 + 20);
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while ( __stlxr(v43, v41) );
    if ( !v43 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2288));
  }
  v44 = *((_DWORD *)this + 573);
  *((_QWORD *)this + 293) = 0LL;
  *((_OWORD *)this + 145) = 0u;
  *((_OWORD *)this + 144) = 0u;
  if ( v44 <= 0 )
  {
    *v37 = v171[0];
  }
  else
  {
    v45 = *((_QWORD *)this + 294);
    v46 = 0LL;
    do
    {
      *(_DWORD *)(v45 + 4 * v46) = 0;
      v47 = *((int *)this + 573);
      ++v46;
    }
    while ( v46 < v47 );
    *v37 = v171[0];
    if ( (int)v47 > 2 )
      goto LABEL_78;
  }
  if ( SDWORD1(v171[0]) > 2 )
  {
LABEL_78:
    cv::Mat::copySize((feasibal_region::ground_process *)((char *)this + 2288), (const cv::Mat *)v171);
    goto LABEL_79;
  }
  *((_DWORD *)this + 573) = DWORD1(v171[0]);
  v48 = (_QWORD *)*((_QWORD *)this + 295);
  *((_QWORD *)this + 287) = *((_QWORD *)&v171[0] + 1);
  v49 = v173;
  *v48 = *(_QWORD *)v173;
  v48[1] = *((_QWORD *)v49 + 1);
LABEL_79:
  *((_OWORD *)this + 144) = v171[1];
  *((_OWORD *)this + 145) = v171[2];
  *((_OWORD *)this + 146) = v171[3];
LABEL_80:
  v163 = *(_OWORD *)v175;
  v164 = *(_OWORD *)&v175[16];
  v165 = *(_OWORD *)&v175[32];
  v166 = *(_QWORD *)&v175[48];
  v167 = *(_QWORD *)&v175[56];
  v168 = (__int64)&v163 + 8;
  v169 = (cv *)v170;
  v170[0] = 0LL;
  v170[1] = 0LL;
  if ( *(_QWORD *)&v175[56] )
  {
    v50 = (unsigned int *)(*(_QWORD *)&v175[56] + 20LL);
    do
      v51 = __ldaxr(v50);
    while ( __stlxr(v51 + 1, v50) );
    if ( *(int *)&v175[4] <= 2 )
      goto LABEL_84;
LABEL_86:
    DWORD1(v163) = 0;
    cv::Mat::copySize((cv::Mat *)&v163, (const cv::Mat *)v175);
    goto LABEL_87;
  }
  if ( *(int *)&v175[4] > 2 )
    goto LABEL_86;
LABEL_84:
  v52 = v177;
  v53 = v169;
  *(_QWORD *)v169 = *(_QWORD *)v177;
  *((_QWORD *)v53 + 1) = *((_QWORD *)v52 + 1);
LABEL_87:
  feasibal_region::ground_process::pointCloudProcess((__int64)this, (__int64)&v163);
  if ( v167 )
  {
    v55 = (unsigned int *)(v167 + 20);
    do
    {
      v56 = __ldaxr(v55);
      v57 = v56 - 1;
    }
    while ( __stlxr(v57, v55) );
    if ( !v57 )
      cv::Mat::deallocate((cv::Mat *)&v163);
  }
  v167 = 0LL;
  v164 = 0u;
  v165 = 0u;
  if ( SDWORD1(v163) >= 1 )
  {
    v58 = v168;
    v59 = 0LL;
    do
      *(_DWORD *)(v58 + 4 * v59++) = 0;
    while ( v59 < SDWORD1(v163) );
  }
  if ( v169 != (cv *)v170 )
    cv::fastFree(v169, v54);
  feasibal_region::ground_process::planeProcess(this);
  feasibal_region::ground_process::groundProcess(this);
  if ( !*((_BYTE *)this + 16) )
  {
    if ( *((_BYTE *)this + 2384) )
    {
      *(_OWORD *)((char *)this + 1812) = *(_OWORD *)((char *)this + 1796);
      if ( !(unsigned int)feasibal_region::ground_process::getExtrinsicFromPlane((__int64)this, (__int64)this + 1812) )
      {
        v143 = *(_OWORD *)((char *)this + 1828);
        if ( !(unsigned int)feasibal_region::ground_process::set_calib((__int64)this, &v143) )
        {
          feasibal_region::ground_process::getPlaneFromExtrinsic((__int64)this, &v179, &v144);
          if ( vabds_f32(v144, *((float *)this + 546)) < 20.0 )
          {
            v73 = *((_QWORD *)this + 64);
            v161 = v179.n64_u64[0];
            v162 = (int)v180;
            CAPE::updateDefaultPlane(v73, &v161, v144);
            *((_BYTE *)this + 16) = 1;
          }
        }
      }
    }
  }
  if ( (char *)a3 + 24 != (char *)this + 2416 )
    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
      (__int64)a3 + 24,
      *((char **)this + 302),
      *((char **)this + 303));
  if ( (char *)a3 + 48 != (char *)this + 2440 )
    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
      (__int64)a3 + 48,
      *((char **)this + 305),
      *((char **)this + 306));
  if ( (char *)a3 + 72 != (char *)this + 2464 )
    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
      (__int64)a3 + 72,
      *((char **)this + 308),
      *((char **)this + 309));
  if ( (char *)a3 + 96 != (char *)this + 2488 )
    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
      (__int64)a3 + 96,
      *((char **)this + 311),
      *((char **)this + 312));
  if ( a3 != (feasibal_region::ground_process *)((char *)this + 2392) )
    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
      (__int64)a3,
      *((char **)this + 299),
      *((char **)this + 300));
  v60 = (_DWORD *)((char *)this + 1992);
  v61 = (_DWORD *)((char *)a3 + 216);
  *((_DWORD *)a3 + 35) = *((_DWORD *)this + 629);
  *(_OWORD *)((char *)a3 + 120) = *(_OWORD *)((char *)this + 1796);
  *((_BYTE *)a3 + 136) = *((_BYTE *)this + 2384);
  *((_DWORD *)a3 + 36) = *((_DWORD *)this + 630);
  if ( (char *)a3 + 216 != (char *)this + 1992 )
  {
    v62 = *((_QWORD *)this + 256);
    if ( v62 )
    {
      v63 = (unsigned int *)(v62 + 20);
      do
        v64 = __ldaxr(v63);
      while ( __stlxr(v64 + 1, v63) );
    }
    v65 = *((_QWORD *)a3 + 34);
    if ( v65 )
    {
      v66 = (unsigned int *)(v65 + 20);
      do
      {
        v67 = __ldaxr(v66);
        v68 = v67 - 1;
      }
      while ( __stlxr(v68, v66) );
      if ( !v68 )
        cv::Mat::deallocate((feasibal_region::GroundProcessRunOutData *)((char *)a3 + 216));
    }
    v69 = *((_DWORD *)a3 + 55);
    *((_QWORD *)a3 + 34) = 0LL;
    *(_OWORD *)((char *)a3 + 248) = 0u;
    *(_OWORD *)((char *)a3 + 232) = 0u;
    if ( v69 <= 0 )
    {
      *v61 = *v60;
    }
    else
    {
      v70 = *((_QWORD *)a3 + 35);
      v71 = 0LL;
      do
      {
        *(_DWORD *)(v70 + 4 * v71) = 0;
        v72 = *((int *)a3 + 55);
        ++v71;
      }
      while ( v71 < v72 );
      *v61 = *v60;
      if ( (int)v72 > 2 )
        goto LABEL_130;
    }
    v74 = *((_DWORD *)this + 499);
    if ( v74 <= 2 )
    {
      *((_DWORD *)a3 + 55) = v74;
      v75 = (_QWORD *)*((_QWORD *)a3 + 36);
      *((_QWORD *)a3 + 28) = *((_QWORD *)this + 250);
      v76 = (_QWORD *)*((_QWORD *)this + 258);
      *v75 = *v76;
      v75[1] = v76[1];
LABEL_131:
      *(_OWORD *)((char *)a3 + 232) = *(_OWORD *)((char *)this + 2008);
      *(_OWORD *)((char *)a3 + 248) = *(_OWORD *)((char *)this + 2024);
      *(_OWORD *)((char *)a3 + 264) = *(_OWORD *)((char *)this + 2040);
      goto LABEL_132;
    }
LABEL_130:
    cv::Mat::copySize(
      (feasibal_region::GroundProcessRunOutData *)((char *)a3 + 216),
      (feasibal_region::ground_process *)((char *)this + 1992));
    goto LABEL_131;
  }
LABEL_132:
  v77 = (_DWORD *)((char *)this + 1064);
  v78 = (_DWORD *)((char *)a3 + 320);
  *((_DWORD *)a3 + 78) = *((_DWORD *)this + 69);
  if ( (char *)a3 + 320 == (char *)this + 1064 )
    goto LABEL_151;
  v79 = *((_QWORD *)this + 140);
  if ( v79 )
  {
    v80 = (unsigned int *)(v79 + 20);
    do
      v81 = __ldaxr(v80);
    while ( __stlxr(v81 + 1, v80) );
  }
  v82 = *((_QWORD *)a3 + 47);
  if ( v82 )
  {
    v83 = (unsigned int *)(v82 + 20);
    do
    {
      v84 = __ldaxr(v83);
      v85 = v84 - 1;
    }
    while ( __stlxr(v85, v83) );
    if ( !v85 )
      cv::Mat::deallocate((feasibal_region::GroundProcessRunOutData *)((char *)a3 + 320));
  }
  v86 = *((_DWORD *)a3 + 81);
  *((_QWORD *)a3 + 47) = 0LL;
  *((_OWORD *)a3 + 21) = 0u;
  *((_OWORD *)a3 + 22) = 0u;
  if ( v86 <= 0 )
  {
    *v78 = *v77;
  }
  else
  {
    v87 = *((_QWORD *)a3 + 48);
    v88 = 0LL;
    do
    {
      *(_DWORD *)(v87 + 4 * v88) = 0;
      v89 = *((int *)a3 + 81);
      ++v88;
    }
    while ( v88 < v89 );
    *v78 = *v77;
    if ( (int)v89 > 2 )
      goto LABEL_149;
  }
  v90 = *((_DWORD *)this + 267);
  if ( v90 > 2 )
  {
LABEL_149:
    cv::Mat::copySize(
      (feasibal_region::GroundProcessRunOutData *)((char *)a3 + 320),
      (feasibal_region::ground_process *)((char *)this + 1064));
    goto LABEL_150;
  }
  *((_DWORD *)a3 + 81) = v90;
  v91 = (_QWORD *)*((_QWORD *)a3 + 49);
  *((_QWORD *)a3 + 41) = *((_QWORD *)this + 134);
  v92 = (_QWORD *)*((_QWORD *)this + 142);
  *v91 = *v92;
  v91[1] = v92[1];
LABEL_150:
  *((_OWORD *)a3 + 21) = *(_OWORD *)((char *)this + 1080);
  *((_OWORD *)a3 + 22) = *(_OWORD *)((char *)this + 1096);
  *((_OWORD *)a3 + 23) = *(_OWORD *)((char *)this + 1112);
LABEL_151:
  if ( (word_6FDF0 & 1) != 0 )
    v93 = (const char *)qword_6FE00;
  else
    v93 = (char *)&word_6FDF0 + 1;
  v139 = dword_6FDE8;
  v141 = 0LL;
  v142 = 0LL;
  v140 = 0LL;
  v94 = strlen(v93);
  if ( v94 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v95 = v94;
  if ( v94 >= 0x17 )
  {
    v97 = (v94 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v96 = (char *)operator new(v97);
    v141 = v95;
    v142 = v96;
    v140 = v97 | 1;
    goto LABEL_159;
  }
  v96 = (char *)&v140 + 1;
  LOBYTE(v140) = 2 * v94;
  if ( v94 )
LABEL_159:
    memcpy(v96, v93, v95);
  v96[v95] = 0;
  if ( (g3::logLevel(&v139) & 1) == 0 )
  {
    v98 = 0;
    if ( (v140 & 1) != 0 )
      goto LABEL_173;
    goto LABEL_163;
  }
  *(_QWORD *)&v137[7] = 0LL;
  v138 = 0LL;
  v136 = 12;
  strcpy(v137, "region");
  v98 = g3::logTag(&v136);
  if ( (v136 & 1) != 0 )
  {
    operator delete(v138);
    if ( (v140 & 1) != 0 )
      goto LABEL_173;
LABEL_163:
    if ( (v98 & 1) != 0 )
      goto LABEL_164;
    goto LABEL_174;
  }
  if ( (v140 & 1) == 0 )
    goto LABEL_163;
LABEL_173:
  operator delete(v142);
  if ( (v98 & 1) != 0 )
  {
LABEL_164:
    LogCapture::LogCapture((LogCapture *)&v179, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v179, "plane vaild:%d", *((unsigned __int8 *)this + 2384));
    LogCapture::~LogCapture((LogCapture *)&v179);
    if ( !*((_BYTE *)this + 16) )
      goto LABEL_165;
LABEL_175:
    if ( (word_6FDF0 & 1) != 0 )
      v103 = (const char *)qword_6FE00;
    else
      v103 = (char *)&word_6FDF0 + 1;
    v132 = dword_6FDE8;
    v134 = 0LL;
    v135 = 0LL;
    v133 = 0LL;
    v104 = strlen(v103);
    if ( v104 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v105 = v104;
    if ( v104 >= 0x17 )
    {
      v107 = (v104 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v106 = (char *)operator new(v107);
      v134 = v105;
      v135 = v106;
      v133 = v107 | 1;
    }
    else
    {
      v106 = (char *)&v133 + 1;
      LOBYTE(v133) = 2 * v104;
      if ( !v104 )
      {
LABEL_184:
        v106[v105] = 0;
        if ( (g3::logLevel(&v132) & 1) != 0 )
        {
          *(_QWORD *)&v130[7] = 0LL;
          v131 = 0LL;
          v129 = 12;
          strcpy(v130, "region");
          v109 = g3::logTag(&v129);
          if ( (v129 & 1) == 0 )
          {
            if ( (v133 & 1) == 0 )
              goto LABEL_187;
LABEL_190:
            operator delete(v135);
            if ( (v109 & 1) == 0 )
              goto LABEL_205;
LABEL_191:
            LogCapture::LogCapture((LogCapture *)&v179, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)&v179, "static extrinsic:1");
LABEL_204:
            LogCapture::~LogCapture((LogCapture *)&v179);
            goto LABEL_205;
          }
          operator delete(v131);
          if ( (v133 & 1) != 0 )
            goto LABEL_190;
        }
        else
        {
          v109 = 0;
          if ( (v133 & 1) != 0 )
            goto LABEL_190;
        }
LABEL_187:
        if ( (v109 & 1) == 0 )
          goto LABEL_205;
        goto LABEL_191;
      }
    }
    memcpy(v106, v103, v105);
    goto LABEL_184;
  }
LABEL_174:
  if ( *((_BYTE *)this + 16) )
    goto LABEL_175;
LABEL_165:
  if ( (word_6FDF0 & 1) != 0 )
    v99 = (const char *)qword_6FE00;
  else
    v99 = (char *)&word_6FDF0 + 1;
  v125 = dword_6FDE8;
  v127 = 0LL;
  v128 = 0LL;
  v126 = 0LL;
  v100 = strlen(v99);
  if ( v100 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v101 = v100;
  if ( v100 >= 0x17 )
  {
    v110 = (v100 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v102 = (char *)operator new(v110);
    v127 = v101;
    v128 = v102;
    v126 = v110 | 1;
    goto LABEL_195;
  }
  v102 = (char *)&v126 + 1;
  LOBYTE(v126) = 2 * v100;
  if ( v100 )
LABEL_195:
    memcpy(v102, v99, v101);
  v102[v101] = 0;
  if ( (g3::logLevel(&v125) & 1) != 0 )
  {
    *(_QWORD *)&v123[7] = 0LL;
    v124 = 0LL;
    v122 = 12;
    strcpy(v123, "region");
    v111 = g3::logTag(&v122);
    if ( (v122 & 1) == 0 )
    {
      if ( (v126 & 1) == 0 )
        goto LABEL_199;
LABEL_202:
      operator delete(v128);
      if ( (v111 & 1) == 0 )
        goto LABEL_205;
      goto LABEL_203;
    }
    operator delete(v124);
    if ( (v126 & 1) != 0 )
      goto LABEL_202;
  }
  else
  {
    v111 = 0;
    if ( (v126 & 1) != 0 )
      goto LABEL_202;
  }
LABEL_199:
  if ( (v111 & 1) != 0 )
  {
LABEL_203:
    LogCapture::LogCapture((LogCapture *)&v179, "region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v179, "dynamic extrinsic:0");
    goto LABEL_204;
  }
LABEL_205:
  if ( *((_QWORD *)&v171[3] + 1) )
  {
    v112 = (unsigned int *)(*((_QWORD *)&v171[3] + 1) + 20LL);
    do
    {
      v113 = __ldaxr(v112);
      v114 = v113 - 1;
    }
    while ( __stlxr(v114, v112) );
    if ( !v114 )
      cv::Mat::deallocate((cv::Mat *)v171);
  }
  *((_QWORD *)&v171[3] + 1) = 0LL;
  memset(&v171[1], 0, 32);
  if ( SDWORD1(v171[0]) >= 1 )
  {
    v115 = v172;
    v116 = 0LL;
    do
      *(_DWORD *)(v115 + 4 * v116++) = 0;
    while ( v116 < SDWORD1(v171[0]) );
  }
  if ( v173 != (cv *)v174 )
    cv::fastFree(v173, v108);
  if ( *(_QWORD *)&v175[56] )
  {
    v117 = (unsigned int *)(*(_QWORD *)&v175[56] + 20LL);
    do
    {
      v118 = __ldaxr(v117);
      v119 = v118 - 1;
    }
    while ( __stlxr(v119, v117) );
    if ( !v119 )
      cv::Mat::deallocate((cv::Mat *)v175);
  }
  *(_QWORD *)&v175[56] = 0LL;
  memset(&v175[16], 0, 32);
  if ( *(int *)&v175[4] >= 1 )
  {
    v120 = v176;
    v121 = 0LL;
    do
      *(_DWORD *)&v120[4 * v121++] = 0;
    while ( v121 < *(int *)&v175[4] );
  }
  if ( v177 != (cv *)v178 )
    cv::fastFree(v177, v108);
  return 0LL;
}
// 34EBC: variable 'v36' is possibly undefined
// 350C0: variable 'v54' is possibly undefined
// 35884: variable 'v108' is possibly undefined
// 12A40: using guessed type __int64 __fastcall cv::minMaxLoc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 12C00: using guessed type __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 137D0: using guessed type __int64 __fastcall cv::medianBlur(_QWORD, _QWORD, _QWORD);
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;
// 34984: using guessed type __int128 var_380;

//----- (0000000000035CF4) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::pointCloudProcess(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int128 v4; // q0
  __int128 v5; // q1
  __int64 v6; // x8
  unsigned int *v7; // x8
  unsigned int v8; // w9
  _QWORD *v9; // x8
  cv *v10; // x10
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  float *v14; // x12
  float *v15; // x13
  _BYTE *v16; // x14
  __int16 *v17; // x15
  unsigned int *v18; // x16
  __int64 v19; // x17
  __int64 v20; // x0
  __int64 v21; // x2
  __int64 v22; // x3
  __int64 v23; // x9
  __int64 v24; // x4
  __int64 v25; // x5
  __int16 *v26; // x6
  unsigned int *v27; // x7
  _BYTE *v28; // x24
  __int64 v29; // x25
  float *v30; // x26
  float *v31; // x27
  __int64 v32; // x22
  int v33; // w28
  __int64 v34; // x22
  float v35; // s1
  __int64 v36; // x22
  _DWORD *v37; // x28
  _DWORD *v38; // x30
  _DWORD *v39; // x22
  __int64 v40; // x22
  unsigned int *v41; // x8
  unsigned int v42; // w9
  unsigned int v43; // w9
  __int64 v44; // x8
  __int64 v45; // x9
  _DWORD *v46; // x21
  __int64 v47; // x8
  unsigned int *v48; // x8
  unsigned int v49; // w9
  __int64 v50; // x8
  unsigned int *v51; // x8
  unsigned int v52; // w9
  unsigned int v53; // w9
  int v54; // w8
  __int64 v55; // x8
  __int64 v56; // x9
  __int64 v57; // x10
  int v58; // w8
  _QWORD *v59; // x10
  _QWORD *v60; // x8
  __int128 v62; // [xsp+10h] [xbp-C0h] BYREF
  __int128 v63; // [xsp+20h] [xbp-B0h]
  __int128 v64; // [xsp+30h] [xbp-A0h]
  __int64 v65; // [xsp+40h] [xbp-90h]
  __int64 v66; // [xsp+48h] [xbp-88h]
  __int64 v67; // [xsp+50h] [xbp-80h]
  cv *v68; // [xsp+58h] [xbp-78h]
  __int64 v69[4]; // [xsp+60h] [xbp-70h] BYREF

  v2 = a2;
  v69[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(_OWORD *)a2;
  v5 = *(_OWORD *)(a2 + 16);
  v62 = *(_OWORD *)a2;
  v63 = v5;
  v64 = *(_OWORD *)(a2 + 32);
  v65 = *(_QWORD *)(a2 + 48);
  v6 = *(_QWORD *)(a2 + 56);
  v68 = (cv *)v69;
  v69[0] = 0LL;
  v69[1] = 0LL;
  v66 = v6;
  v67 = (__int64)&v62 + 8;
  if ( v6 )
  {
    v7 = (unsigned int *)(v6 + 20);
    do
      v8 = __ldaxr(v7);
    while ( __stlxr(v8 + 1, v7) );
    if ( *(int *)(a2 + 4) <= 2 )
      goto LABEL_5;
  }
  else if ( SDWORD1(v4) <= 2 )
  {
LABEL_5:
    v9 = *(_QWORD **)(a2 + 72);
    v10 = v68;
    *(_QWORD *)v68 = *v9;
    *((_QWORD *)v10 + 1) = v9[1];
    goto LABEL_8;
  }
  DWORD1(v62) = 0;
  cv::Mat::copySize((cv::Mat *)&v62, (const cv::Mat *)a2);
LABEL_8:
  v11 = DWORD2(v62);
  if ( SDWORD2(v62) >= 1 )
  {
    v12 = HIDWORD(v62);
    v13 = *(_QWORD *)(a1 + 560);
    v14 = *(float **)(a1 + 696);
    v15 = *(float **)(a1 + 792);
    v16 = *(_BYTE **)(a1 + 1080);
    v17 = (__int16 *)v63;
    v18 = *(unsigned int **)(a1 + 600);
    v19 = **(_QWORD **)(a1 + 752);
    v20 = **(_QWORD **)(a1 + 848);
    a2 = **(_QWORD **)(a1 + 1136);
    v21 = *(_QWORD *)v68;
    v22 = **(_QWORD **)(a1 + 656);
    v23 = 0LL;
    v24 = v13 + 4LL * DWORD2(v62) * HIDWORD(v62);
    v25 = v13 + 8LL * DWORD2(v62) * HIDWORD(v62);
    while ( 1 )
    {
      v26 = v17;
      v27 = v18;
      v28 = v16;
      v29 = v12;
      v30 = v14;
      v31 = v15;
      if ( (int)v12 >= 1 )
        break;
LABEL_18:
      ++v23;
      v15 = (float *)((char *)v15 + v20);
      v14 = (float *)((char *)v14 + v19);
      v16 += a2;
      v18 = (unsigned int *)((char *)v18 + v22);
      v17 = (__int16 *)((char *)v17 + v21);
      if ( v23 == v11 )
        goto LABEL_19;
    }
    while ( 1 )
    {
      v32 = *v27;
      if ( !*v28 )
        break;
      v33 = *v26;
      if ( v33 <= 0 )
      {
        v40 = 4 * v32;
        v37 = (_DWORD *)(v13 + v40);
        v38 = (_DWORD *)(v24 + v40);
        v39 = (_DWORD *)(v25 + v40);
        goto LABEL_16;
      }
      v34 = 4 * v32;
      v35 = *v31 * (float)v33;
      *(float *)(v13 + v34) = *v30 * (float)v33;
      *(float *)(v24 + v34) = v35;
      *(float *)(v25 + v34) = (float)v33;
LABEL_17:
      ++v31;
      ++v30;
      --v29;
      ++v28;
      ++v27;
      ++v26;
      if ( !v29 )
        goto LABEL_18;
    }
    v36 = 4 * v32;
    v37 = (_DWORD *)(v13 + v36);
    v38 = (_DWORD *)(v24 + v36);
    v39 = (_DWORD *)(v25 + v36);
    *v37 = 0;
    *v38 = 0;
    *v39 = 0;
LABEL_16:
    *v37 = 0;
    *v38 = 0;
    *v39 = 0;
    goto LABEL_17;
  }
LABEL_19:
  if ( v66 )
  {
    v41 = (unsigned int *)(v66 + 20);
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while ( __stlxr(v43, v41) );
    if ( !v43 )
      cv::Mat::deallocate((cv::Mat *)&v62);
  }
  v66 = 0LL;
  v63 = 0u;
  v64 = 0u;
  if ( SDWORD1(v62) >= 1 )
  {
    v44 = v67;
    v45 = 0LL;
    do
      *(_DWORD *)(v44 + 4 * v45++) = 0;
    while ( v45 < SDWORD1(v62) );
  }
  if ( v68 != (cv *)v69 )
    cv::fastFree(v68, (void *)a2);
  v46 = (_DWORD *)(a1 + 2608);
  if ( a1 + 2608 != v2 )
  {
    v47 = *(_QWORD *)(v2 + 56);
    if ( v47 )
    {
      v48 = (unsigned int *)(v47 + 20);
      do
        v49 = __ldaxr(v48);
      while ( __stlxr(v49 + 1, v48) );
    }
    v50 = *(_QWORD *)(a1 + 2664);
    if ( v50 )
    {
      v51 = (unsigned int *)(v50 + 20);
      do
      {
        v52 = __ldaxr(v51);
        v53 = v52 - 1;
      }
      while ( __stlxr(v53, v51) );
      if ( !v53 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 2608));
    }
    v54 = *(_DWORD *)(a1 + 2612);
    *(_QWORD *)(a1 + 2664) = 0LL;
    *(_OWORD *)(a1 + 2640) = 0u;
    *(_OWORD *)(a1 + 2624) = 0u;
    if ( v54 <= 0 )
    {
      *v46 = *(_DWORD *)v2;
    }
    else
    {
      v55 = *(_QWORD *)(a1 + 2672);
      v56 = 0LL;
      do
      {
        *(_DWORD *)(v55 + 4 * v56) = 0;
        v57 = *(int *)(a1 + 2612);
        ++v56;
      }
      while ( v56 < v57 );
      *v46 = *(_DWORD *)v2;
      if ( (int)v57 > 2 )
        goto LABEL_46;
    }
    v58 = *(_DWORD *)(v2 + 4);
    if ( v58 <= 2 )
    {
      *(_DWORD *)(a1 + 2612) = v58;
      v59 = *(_QWORD **)(a1 + 2680);
      *(_QWORD *)(a1 + 2616) = *(_QWORD *)(v2 + 8);
      v60 = *(_QWORD **)(v2 + 72);
      *v59 = *v60;
      v59[1] = v60[1];
LABEL_47:
      *(_OWORD *)(a1 + 2624) = *(_OWORD *)(v2 + 16);
      *(_OWORD *)(a1 + 2640) = *(_OWORD *)(v2 + 32);
      *(_OWORD *)(a1 + 2656) = *(_OWORD *)(v2 + 48);
      return 0LL;
    }
LABEL_46:
    cv::Mat::copySize((cv::Mat *)(a1 + 2608), (const cv::Mat *)v2);
    goto LABEL_47;
  }
  return 0LL;
}
// 35F60: variable 'a2' is possibly undefined

//----- (00000000000360A0) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::planeProcess(feasibal_region::ground_process *this)
{
  void *v2; // x1
  __int64 v3; // x8
  unsigned int *v4; // x8
  unsigned int v5; // w9
  unsigned int v6; // w9
  __int64 v7; // x9
  __int64 v8; // x10
  int v9; // v0.s[1]
  __int128 v10; // q1
  cv *v11; // x0
  int v12; // w8
  __int64 v13; // x9
  __int64 v14; // x9
  unsigned int *v15; // x8
  unsigned int v16; // w9
  unsigned int v17; // w9
  __int64 v18; // x8
  __int64 v19; // x9
  __time_t tv_sec; // x26
  __time_t v21; // x21
  __suseconds_t tv_usec; // x20
  __suseconds_t v23; // x28
  const char *v24; // x23
  size_t v25; // x0
  size_t v26; // x22
  char *v27; // x24
  unsigned __int64 v28; // x25
  char v29; // w22
  float v30; // s0
  unsigned __int64 v31; // x8
  __int64 v32; // x9
  int v33; // w9
  __int64 v34; // x20
  __int64 i; // x21
  int v36; // w9
  int v37; // w8
  unsigned __int64 v38; // x9
  int v39; // w11
  float v40; // s3
  float v41; // s0
  float v42; // s1
  float v43; // s2
  const char *v44; // x21
  size_t v45; // x0
  size_t v46; // x20
  char *v47; // x22
  unsigned __int64 v48; // x23
  char v49; // w20
  _DWORD *v50; // x20
  int v51; // w9
  void **v52; // x20
  int v53; // w8
  int v54; // w10
  int v55; // w8
  __int64 v56; // x8
  __int64 v57; // x8
  int v58; // w8
  float *v59; // x9
  float *v60; // x10
  float v61; // s9
  float v62; // s10
  unsigned __int64 v63; // x8
  double j; // d0
  float v65; // t1
  float v66; // s0
  float *v67; // x9
  float *v68; // x10
  unsigned __int64 v69; // x8
  double k; // d0
  float v71; // t1
  float v72; // s0
  const char *v73; // x23
  size_t v74; // x0
  size_t v75; // x22
  char *v76; // x24
  unsigned __int64 v77; // x25
  char v78; // w22
  double v79; // d8
  const char *v80; // x23
  size_t v81; // x0
  size_t v82; // x22
  char *v83; // x24
  unsigned __int64 v84; // x25
  char v85; // w23
  _OWORD *v86; // x28
  int v87; // w8
  __int64 v88; // x8
  __int64 v89; // x9
  __int64 v90; // x20
  char v91; // w8
  _QWORD *v92; // x22
  FILE *v93; // x0
  __int64 v94; // x8
  const char *v95; // x23
  size_t v96; // x0
  size_t v97; // x22
  char *v98; // x24
  FILE *v99; // x25
  int v100; // w24
  unsigned __int64 v101; // x25
  char v102; // w22
  __int64 v103; // x8
  FILE *v104; // x0
  __int64 v105; // x8
  struct tm *v106; // x0
  size_t v107; // x0
  int v108; // w1
  size_t v109; // x23
  char *v110; // x24
  unsigned __int64 v111; // x25
  std::__ndk1 *v112; // x0
  char *v113; // x2
  unsigned __int64 v114; // x3
  __int64 *v115; // x0
  unsigned int v116; // w1
  void *v117; // x20
  __int64 v118; // x9
  char v119; // w21
  __int64 v120; // x8
  __int64 v121; // x9
  std::ios_base *v122; // x0
  __int64 v123; // x23
  __int64 v124; // x24
  __int64 v125; // x9
  __int64 v126; // x8
  __int64 *v127; // x9
  __int64 v128; // t1
  char *v129; // x11
  int v130; // w10
  _QWORD *v131; // x0
  __int64 v132; // x1
  __int64 v133; // x8
  __int64 *v134; // x9
  int v135; // w10
  _QWORD *v136; // x0
  __int64 v137; // x1
  std::__ndk1 *v138; // x0
  __int64 v139; // x8
  __int64 *v140; // x9
  int v141; // w10
  _QWORD *v142; // x0
  __int64 v143; // x1
  __int64 *v144; // x0
  __int128 v145; // q0
  __int64 *v146; // x0
  __int128 v147; // q0
  char *v148; // x1
  __int64 v149; // x2
  _QWORD *v150; // x0
  _QWORD *v151; // x0
  __int64 v152; // x2
  char *v153; // x1
  _QWORD *v154; // x0
  _QWORD *v155; // x0
  _QWORD *v156; // x0
  _QWORD *v157; // x0
  _QWORD *v158; // x0
  _QWORD *v159; // x0
  _QWORD *v160; // x22
  __int64 v161; // x0
  unsigned __int8 v162; // w23
  const char *v163; // x23
  size_t v164; // x0
  size_t v165; // x22
  char *v166; // x24
  unsigned __int64 v167; // x25
  char v168; // w22
  const char *v169; // x2
  const char *v170; // x3
  const char *v171; // x23
  size_t v172; // x0
  size_t v173; // x22
  char *v174; // x24
  const char *v175; // x23
  size_t v176; // x0
  size_t v177; // x22
  char *v178; // x24
  unsigned __int64 v179; // x25
  char v180; // w22
  unsigned __int64 v181; // x25
  char v182; // w22
  _BOOL4 v183; // w8
  const char *v184; // x23
  size_t v185; // x0
  size_t v186; // x22
  char *v187; // x24
  unsigned __int64 v188; // x25
  char v189; // w22
  int v190; // w1
  int v191; // w2
  void *v192; // x1
  __int64 v193; // x8
  unsigned int *v194; // x8
  unsigned int v195; // w9
  unsigned int v196; // w9
  __int64 v197; // x8
  __int64 v198; // x9
  int v199; // v0.s[1]
  __int128 v200; // q1
  cv *v201; // x0
  int v202; // w8
  unsigned int *v203; // x8
  unsigned int v204; // w9
  unsigned int v205; // w9
  __int64 v206; // x9
  __int64 v207; // x8
  __int64 v208; // x9
  void **v209; // x19
  void *v210; // x0
  int v212; // [xsp+14h] [xbp-5ECh]
  int v213; // [xsp+18h] [xbp-5E8h]
  int v214; // [xsp+1Ch] [xbp-5E4h]
  cv::Mat *v215; // [xsp+28h] [xbp-5D8h]
  __int64 v216; // [xsp+48h] [xbp-5B8h] BYREF
  void *v217[3]; // [xsp+50h] [xbp-5B0h] BYREF
  int v218; // [xsp+68h] [xbp-598h] BYREF
  unsigned __int64 v219; // [xsp+70h] [xbp-590h] BYREF
  size_t v220; // [xsp+78h] [xbp-588h]
  void *v221; // [xsp+80h] [xbp-580h]
  void *v222[3]; // [xsp+88h] [xbp-578h] BYREF
  int v223; // [xsp+A0h] [xbp-560h] BYREF
  unsigned __int64 v224; // [xsp+A8h] [xbp-558h] BYREF
  size_t v225; // [xsp+B0h] [xbp-550h]
  void *v226; // [xsp+B8h] [xbp-548h]
  void *v227[3]; // [xsp+C0h] [xbp-540h] BYREF
  int v228; // [xsp+D8h] [xbp-528h] BYREF
  unsigned __int64 v229; // [xsp+E0h] [xbp-520h] BYREF
  size_t v230; // [xsp+E8h] [xbp-518h]
  void *v231; // [xsp+F0h] [xbp-510h]
  void *v232[3]; // [xsp+F8h] [xbp-508h] BYREF
  int v233; // [xsp+110h] [xbp-4F0h] BYREF
  unsigned __int64 v234; // [xsp+118h] [xbp-4E8h] BYREF
  size_t v235; // [xsp+120h] [xbp-4E0h]
  void *v236; // [xsp+128h] [xbp-4D8h]
  void *v237; // [xsp+130h] [xbp-4D0h] BYREF
  void *v238; // [xsp+138h] [xbp-4C8h]
  void *v239; // [xsp+140h] [xbp-4C0h]
  __int128 v240; // [xsp+148h] [xbp-4B8h] BYREF
  void *v241; // [xsp+158h] [xbp-4A8h]
  struct timeval v242; // [xsp+160h] [xbp-4A0h] BYREF
  time_t timer; // [xsp+170h] [xbp-490h] BYREF
  void *v244[3]; // [xsp+178h] [xbp-488h] BYREF
  int v245; // [xsp+190h] [xbp-470h] BYREF
  unsigned __int64 v246; // [xsp+198h] [xbp-468h] BYREF
  size_t v247; // [xsp+1A0h] [xbp-460h]
  void *v248; // [xsp+1A8h] [xbp-458h]
  char v249[24]; // [xsp+1B0h] [xbp-450h] BYREF
  char v250; // [xsp+1C8h] [xbp-438h] BYREF
  char v251[23]; // [xsp+1C9h] [xbp-437h] BYREF
  int v252; // [xsp+1E0h] [xbp-420h] BYREF
  unsigned __int64 v253; // [xsp+1E8h] [xbp-418h] BYREF
  size_t v254; // [xsp+1F0h] [xbp-410h]
  void *v255; // [xsp+1F8h] [xbp-408h]
  void *v256[3]; // [xsp+200h] [xbp-400h] BYREF
  int v257; // [xsp+218h] [xbp-3E8h] BYREF
  unsigned __int64 v258; // [xsp+220h] [xbp-3E0h] BYREF
  size_t v259; // [xsp+228h] [xbp-3D8h]
  void *v260; // [xsp+230h] [xbp-3D0h]
  void *v261[3]; // [xsp+238h] [xbp-3C8h] BYREF
  int v262; // [xsp+250h] [xbp-3B0h] BYREF
  unsigned __int64 v263; // [xsp+258h] [xbp-3A8h] BYREF
  size_t v264; // [xsp+260h] [xbp-3A0h]
  void *v265; // [xsp+268h] [xbp-398h]
  void *v266[3]; // [xsp+270h] [xbp-390h] BYREF
  int v267; // [xsp+288h] [xbp-378h] BYREF
  unsigned __int64 v268; // [xsp+290h] [xbp-370h] BYREF
  size_t v269; // [xsp+298h] [xbp-368h]
  void *v270; // [xsp+2A0h] [xbp-360h]
  struct timeval v271; // [xsp+2A8h] [xbp-358h] BYREF
  struct timeval tv; // [xsp+2B8h] [xbp-348h] BYREF
  float v273; // [xsp+2CCh] [xbp-334h] BYREF
  __int128 v274; // [xsp+2D0h] [xbp-330h]
  int v275; // [xsp+2E4h] [xbp-31Ch] BYREF
  void *v276; // [xsp+2E8h] [xbp-318h] BYREF
  void **v277; // [xsp+2F0h] [xbp-310h]
  __int64 v278; // [xsp+2F8h] [xbp-308h]
  __int128 v279; // [xsp+300h] [xbp-300h] BYREF
  void *v280; // [xsp+310h] [xbp-2F0h]
  char s[8]; // [xsp+318h] [xbp-2E8h] BYREF
  __int64 v282; // [xsp+320h] [xbp-2E0h]
  __int64 v283; // [xsp+328h] [xbp-2D8h]
  __int128 src; // [xsp+330h] [xbp-2D0h] BYREF
  __int128 v285; // [xsp+340h] [xbp-2C0h]
  __int128 v286; // [xsp+350h] [xbp-2B0h]
  __int128 v287; // [xsp+360h] [xbp-2A0h]
  __int128 v288; // [xsp+370h] [xbp-290h]
  __int128 v289; // [xsp+380h] [xbp-280h]
  __int128 v290; // [xsp+390h] [xbp-270h]
  __int128 v291; // [xsp+3A0h] [xbp-260h]
  __int128 v292; // [xsp+3B0h] [xbp-250h]
  __int128 v293; // [xsp+3C0h] [xbp-240h]
  __int128 v294; // [xsp+3D0h] [xbp-230h]
  __int128 v295; // [xsp+3E0h] [xbp-220h]
  __int128 v296; // [xsp+3F0h] [xbp-210h]
  __int128 v297; // [xsp+400h] [xbp-200h]
  __int128 v298; // [xsp+410h] [xbp-1F0h]
  __int128 v299; // [xsp+420h] [xbp-1E0h]
  char name[64]; // [xsp+430h] [xbp-1D0h] BYREF
  __int128 v301; // [xsp+470h] [xbp-190h]
  __int128 v302; // [xsp+480h] [xbp-180h] BYREF
  __int128 v303; // [xsp+490h] [xbp-170h]
  __int128 v304; // [xsp+4A0h] [xbp-160h]
  __int128 v305; // [xsp+4B0h] [xbp-150h]
  __int128 v306; // [xsp+4C0h] [xbp-140h]
  __int128 v307; // [xsp+4D0h] [xbp-130h]
  __int128 v308; // [xsp+4E0h] [xbp-120h]
  __int128 v309; // [xsp+4F0h] [xbp-110h]
  __int128 v310; // [xsp+500h] [xbp-100h]
  __int128 v311; // [xsp+510h] [xbp-F0h]
  __int128 v312; // [xsp+520h] [xbp-E0h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v277 = 0LL;
  v276 = 0LL;
  v278 = 0LL;
  v275 = 0;
  v274 = xmmword_547B0;
  v273 = 0.0;
  gettimeofday(&tv, 0LL);
  v215 = (feasibal_region::ground_process *)((char *)this + 1896);
  CAPE::process_modify_opt(
    *((int **)this + 64),
    (_QWORD *)this + 70,
    (unsigned int *)&v275,
    (__int64)&v276,
    (__int64)this + 1992,
    (__int64)name);
  if ( (char *)this + 2088 == name )
  {
    v13 = *(_QWORD *)&name[56];
  }
  else
  {
    v3 = *((_QWORD *)this + 268);
    if ( v3 )
    {
      v4 = (unsigned int *)(v3 + 20);
      do
      {
        v5 = __ldaxr(v4);
        v6 = v5 - 1;
      }
      while ( __stlxr(v6, v4) );
      if ( !v6 )
        cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2088));
    }
    *((_QWORD *)this + 268) = 0LL;
    *(_OWORD *)((char *)this + 2104) = 0u;
    *(_OWORD *)((char *)this + 2120) = 0u;
    if ( *((int *)this + 523) >= 1 )
    {
      v7 = *((_QWORD *)this + 269);
      v8 = 0LL;
      do
        *(_DWORD *)(v7 + 4 * v8++) = 0;
      while ( v8 < *((int *)this + 523) );
    }
    v9 = *(_DWORD *)&name[4];
    v10 = *(_OWORD *)&name[16];
    *(_OWORD *)((char *)this + 2088) = *(_OWORD *)name;
    *(_OWORD *)((char *)this + 2104) = v10;
    *(_OWORD *)((char *)this + 2120) = *(_OWORD *)&name[32];
    *(_OWORD *)((char *)this + 2136) = *(_OWORD *)&name[48];
    v11 = (cv *)*((_QWORD *)this + 270);
    if ( v11 == (feasibal_region::ground_process *)((char *)this + 2168) )
    {
      v12 = v9;
    }
    else
    {
      cv::fastFree(v11, v2);
      *((_QWORD *)this + 270) = (char *)this + 2168;
      *((_QWORD *)this + 269) = (char *)this + 2096;
      v12 = *(_DWORD *)&name[4];
      v11 = (feasibal_region::ground_process *)((char *)this + 2168);
    }
    if ( v12 <= 2 )
    {
      v14 = *((_QWORD *)&v301 + 1);
      *(_QWORD *)v11 = **((_QWORD **)&v301 + 1);
      *((_QWORD *)v11 + 1) = *(_QWORD *)(v14 + 8);
    }
    else
    {
      *(_OWORD *)((char *)this + 2152) = v301;
      *((_QWORD *)&v301 + 1) = &v302;
      *(_QWORD *)&v301 = &name[8];
    }
    v13 = 0LL;
    *(_DWORD *)name = 1124007936;
    memset(&name[4], 0, 60);
  }
  *((_BYTE *)this + 2384) = v303;
  v273 = *((float *)&v303 + 1);
  if ( v13 )
  {
    v15 = (unsigned int *)(v13 + 20);
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while ( __stlxr(v17, v15) );
    if ( !v17 )
      cv::Mat::deallocate((cv::Mat *)name);
  }
  *(_QWORD *)&name[56] = 0LL;
  memset(&name[16], 0, 32);
  if ( *(int *)&name[4] >= 1 )
  {
    v18 = v301;
    v19 = 0LL;
    do
      *(_DWORD *)(v18 + 4 * v19++) = 0;
    while ( v19 < *(int *)&name[4] );
  }
  if ( *((__int128 **)&v301 + 1) != &v302 )
    cv::fastFree(*((cv **)&v301 + 1), v2);
  gettimeofday(&v271, 0LL);
  tv_sec = v271.tv_sec;
  v21 = tv.tv_sec;
  tv_usec = v271.tv_usec;
  v23 = tv.tv_usec;
  v267 = dword_6FDE8;
  if ( (word_6FDF0 & 1) != 0 )
    v24 = (const char *)qword_6FE00;
  else
    v24 = (char *)&word_6FDF0 + 1;
  v270 = 0LL;
  v269 = 0LL;
  v268 = 0LL;
  v25 = strlen(v24);
  if ( v25 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v26 = v25;
  if ( v25 >= 0x17 )
  {
    v28 = (v25 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v27 = (char *)operator new(v28);
    v270 = v27;
    v268 = v28 | 1;
    v269 = v26;
    goto LABEL_36;
  }
  v27 = (char *)&v268 + 1;
  LOBYTE(v268) = 2 * v25;
  if ( v25 )
LABEL_36:
    memcpy(v27, v24, v26);
  v27[v26] = 0;
  if ( (g3::logLevel(&v267) & 1) != 0 )
  {
    BYTE1(v266[2]) = 0;
    WORD1(v266[2]) = 0;
    HIDWORD(v266[2]) = 0;
    LOBYTE(v266[0]) = 30;
    strcpy((char *)v266 + 1, "feasibal_region");
    v29 = g3::logTag(v266);
    if ( ((__int64)v266[0] & 1) == 0 )
    {
      if ( (v268 & 1) == 0 )
        goto LABEL_40;
LABEL_43:
      operator delete(v270);
      if ( (v29 & 1) == 0 )
        goto LABEL_45;
      goto LABEL_44;
    }
    operator delete(v266[2]);
    if ( (v268 & 1) != 0 )
      goto LABEL_43;
  }
  else
  {
    v29 = 0;
    if ( (v268 & 1) != 0 )
      goto LABEL_43;
  }
LABEL_40:
  if ( (v29 & 1) != 0 )
  {
LABEL_44:
    LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    v30 = (double)(tv_sec - v21) * 1000.0 + (double)(tv_usec - v23) / 1000.0;
    LogCapture::capturef((LogCapture *)name, "%s:%3fms\n", "#### all planeProcess - process_modify time:", v30);
    LogCapture::~LogCapture((LogCapture *)name);
  }
LABEL_45:
  v31 = *((_QWORD *)this + 231);
  v32 = *((_QWORD *)this + 234);
  *((_QWORD *)this + 232) = v31;
  *((_QWORD *)this + 235) = v32;
  v33 = v275;
  if ( v275 >= 1 )
  {
    v34 = 0LL;
    for ( i = 1LL; ; ++i )
    {
      v36 = *(_DWORD *)((char *)v276 + v34 + 80);
      *(_DWORD *)name = v36;
      *(_DWORD *)&name[4] = *(_DWORD *)((char *)v276 + v34 + 84);
      *(_QWORD *)&name[8] = *(_QWORD *)((char *)v276 + v34 + 88);
      if ( v31 >= *((_QWORD *)this + 233) )
      {
        std::vector<Eigen::Matrix<float,4,1,0,4,1>>::__push_back_slow_path<Eigen::Matrix<float,4,1,0,4,1>>(
          (__int64)this + 1848,
          name);
      }
      else
      {
        *(_OWORD *)v31 = *(_OWORD *)name;
        *(_DWORD *)v31 = v36;
        *(_DWORD *)(v31 + 4) = *(_DWORD *)&name[4];
        *(_QWORD *)(v31 + 8) = *(_QWORD *)&name[8];
        *((_QWORD *)this + 232) += 16LL;
      }
      v37 = *(_DWORD *)((char *)v276 + v34 + 68);
      *(_DWORD *)name = v37;
      *(_DWORD *)&name[4] = *(_DWORD *)((char *)v276 + v34 + 72);
      *(_DWORD *)&name[8] = *(_DWORD *)((char *)v276 + v34 + 76);
      v38 = *((_QWORD *)this + 235);
      if ( v38 >= *((_QWORD *)this + 236) )
      {
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1>>(
          (__int64)this + 1872,
          (__int64 *)name);
      }
      else
      {
        v39 = *(_DWORD *)&name[8];
        *(_QWORD *)v38 = *(_QWORD *)name;
        *(_DWORD *)(v38 + 8) = v39;
        *(_DWORD *)v38 = v37;
        *(_DWORD *)(v38 + 4) = *(_DWORD *)&name[4];
        *(_DWORD *)(v38 + 8) = *(_DWORD *)&name[8];
        *((_QWORD *)this + 235) += 12LL;
      }
      v33 = v275;
      if ( i >= v275 )
        break;
      v31 = *((_QWORD *)this + 232);
      v34 += 168LL;
    }
  }
  v40 = *((float *)this + 683);
  if ( v40 >= 200.0
    || (v41 = *((float *)this + 680),
        v42 = *((float *)this + 678),
        v43 = *((float *)this + 679),
        vabds_f32(v40, v41) <= 0.0175)
    && (float)(vabds_f32(*((float *)this + 681), v42) + vabds_f32(*((float *)this + 682), v43)) <= 0.05 )
  {
    if ( (word_6FDF0 & 1) != 0 )
      v44 = (const char *)qword_6FE00;
    else
      v44 = (char *)&word_6FDF0 + 1;
    v262 = dword_6FDE8;
    v265 = 0LL;
    v264 = 0LL;
    v263 = 0LL;
    v45 = strlen(v44);
    if ( v45 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v46 = v45;
    if ( v45 >= 0x17 )
    {
      v48 = (v45 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v47 = (char *)operator new(v48);
      v265 = v47;
      v263 = v48 | 1;
      v264 = v46;
    }
    else
    {
      v47 = (char *)&v263 + 1;
      LOBYTE(v263) = 2 * v45;
      if ( !v45 )
      {
LABEL_67:
        v47[v46] = 0;
        if ( (g3::logLevel(&v262) & 1) != 0 )
        {
          BYTE1(v261[2]) = 0;
          WORD1(v261[2]) = 0;
          HIDWORD(v261[2]) = 0;
          LOBYTE(v261[0]) = 30;
          strcpy((char *)v261 + 1, "feasibal_region");
          v49 = g3::logTag(v261);
          if ( ((__int64)v261[0] & 1) == 0 )
          {
            if ( (v263 & 1) == 0 )
              goto LABEL_70;
LABEL_73:
            operator delete(v265);
            if ( (v49 & 1) != 0 )
              goto LABEL_71;
            goto LABEL_74;
          }
          operator delete(v261[2]);
          if ( (v263 & 1) != 0 )
            goto LABEL_73;
        }
        else
        {
          v49 = 0;
          if ( (v263 & 1) != 0 )
            goto LABEL_73;
        }
LABEL_70:
        if ( (v49 & 1) != 0 )
        {
LABEL_71:
          LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
          LogCapture::capturef(
            (LogCapture *)name,
            "no move:%.3f,%.3f,%.3f",
            *((float *)this + 681),
            *((float *)this + 682),
            *((float *)this + 683));
          v50 = (_DWORD *)((char *)this + 2728);
          LogCapture::~LogCapture((LogCapture *)name);
          goto LABEL_75;
        }
LABEL_74:
        v50 = (_DWORD *)((char *)this + 2728);
LABEL_75:
        v51 = *((_DWORD *)this + 679);
        *((_DWORD *)this + 681) = *((_DWORD *)this + 678);
        *v50 = v51;
        *((_DWORD *)this + 683) = *((_DWORD *)this + 680);
        v52 = (void **)v276;
        if ( !v276 )
          return 0LL;
        goto LABEL_356;
      }
    }
    memcpy(v47, v44, v46);
    goto LABEL_67;
  }
  v53 = *((_DWORD *)this + 640);
  v54 = *((unsigned __int8 *)this + 2384);
  *((float *)this + 681) = v42;
  *((float *)this + 682) = v43;
  v55 = v53 + 1;
  *((float *)this + 683) = v41;
  *((_DWORD *)this + 640) = v55;
  if ( !v54 )
  {
    if ( v33 )
    {
      ++*((_DWORD *)this + 650);
      if ( v55 < 701 )
        goto LABEL_87;
    }
    else
    {
      *(int32x2_t *)((char *)this + 2564) = vadd_s32(*(int32x2_t *)((char *)this + 2564), (int32x2_t)0x100000001LL);
      if ( v55 < 701 )
        goto LABEL_87;
    }
LABEL_86:
    *((_QWORD *)this + 320) = 0LL;
    goto LABEL_87;
  }
  std::vector<float>::insert((unsigned __int64 *)this + 317, *((_QWORD *)this + 317), (char *)v276 + 56);
  v56 = *((_QWORD *)this + 318);
  if ( (unsigned __int64)((v56 - *((_QWORD *)this + 317)) >> 2) >= 0x47 )
    *((_QWORD *)this + 318) = v56 - 4;
  if ( v273 > 0.0 )
  {
    std::vector<float>::insert((unsigned __int64 *)this + 322, *((_QWORD *)this + 322), (char *)&v273);
    v57 = *((_QWORD *)this + 323);
    if ( (unsigned __int64)((v57 - *((_QWORD *)this + 322)) >> 2) >= 0xB )
      *((_QWORD *)this + 323) = v57 - 4;
  }
  v58 = *((_DWORD *)this + 640);
  *((_DWORD *)this + 650) = 0;
  *((_DWORD *)this + 642) = 0;
  if ( v58 >= 701 )
    goto LABEL_86;
LABEL_87:
  v59 = (float *)*((_QWORD *)this + 323);
  v60 = (float *)*((_QWORD *)this + 322);
  v61 = 0.0;
  v62 = 0.0;
  v63 = v59 - v60;
  if ( v63 >= 5 )
  {
    for ( j = 0.0; v59 != v60; j = j + v65 )
      v65 = *v60++;
    v66 = j;
    v62 = v66 / (float)v63;
  }
  v67 = (float *)*((_QWORD *)this + 318);
  v68 = (float *)*((_QWORD *)this + 317);
  v69 = v67 - v68;
  if ( v69 >= 0x23 )
  {
    for ( k = 0.0; v67 != v68; k = k + v71 )
      v71 = *v68++;
    v72 = k;
    v61 = v72 / (float)v69;
  }
  v212 = *((_DWORD *)this + 641);
  v213 = *((_DWORD *)this + 642);
  v214 = *((_DWORD *)this + 650);
  if ( (word_6FDF0 & 1) != 0 )
    v73 = (const char *)qword_6FE00;
  else
    v73 = (char *)&word_6FDF0 + 1;
  v257 = dword_6FDE8;
  v260 = 0LL;
  v259 = 0LL;
  v258 = 0LL;
  v74 = strlen(v73);
  if ( v74 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v75 = v74;
  if ( v74 >= 0x17 )
  {
    v77 = (v74 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v76 = (char *)operator new(v77);
    v260 = v76;
    v258 = v77 | 1;
    v259 = v75;
    goto LABEL_105;
  }
  v76 = (char *)&v258 + 1;
  LOBYTE(v258) = 2 * v74;
  if ( v74 )
LABEL_105:
    memcpy(v76, v73, v75);
  v76[v75] = 0;
  if ( (g3::logLevel(&v257) & 1) != 0 )
  {
    BYTE1(v256[2]) = 0;
    WORD1(v256[2]) = 0;
    HIDWORD(v256[2]) = 0;
    LOBYTE(v256[0]) = 30;
    strcpy((char *)v256 + 1, "feasibal_region");
    v78 = g3::logTag(v256);
    if ( ((__int64)v256[0] & 1) == 0 )
    {
      if ( (v258 & 1) == 0 )
        goto LABEL_109;
LABEL_112:
      operator delete(v260);
      v79 = v62;
      if ( (v78 & 1) == 0 )
        goto LABEL_114;
      goto LABEL_113;
    }
    operator delete(v256[2]);
    if ( (v258 & 1) != 0 )
      goto LABEL_112;
  }
  else
  {
    v78 = 0;
    if ( (v258 & 1) != 0 )
      goto LABEL_112;
  }
LABEL_109:
  v79 = v62;
  if ( (v78 & 1) != 0 )
  {
LABEL_113:
    LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)name,
      "interval:%d,accu:%d,invalid:%d,mscore:%f,mmses:%f",
      *((unsigned int *)this + 641),
      *((unsigned int *)this + 642),
      *((unsigned int *)this + 650),
      v79,
      v61);
    LogCapture::~LogCapture((LogCapture *)name);
  }
LABEL_114:
  if ( (word_6FDF0 & 1) != 0 )
    v80 = (const char *)qword_6FE00;
  else
    v80 = (char *)&word_6FDF0 + 1;
  v252 = dword_6FDE8;
  v254 = 0LL;
  v255 = 0LL;
  v253 = 0LL;
  v81 = strlen(v80);
  if ( v81 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v82 = v81;
  if ( v81 >= 0x17 )
  {
    v84 = (v81 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v83 = (char *)operator new(v84);
    v254 = v82;
    v255 = v83;
    v253 = v84 | 1;
    goto LABEL_122;
  }
  v83 = (char *)&v253 + 1;
  LOBYTE(v253) = 2 * v81;
  if ( v81 )
LABEL_122:
    memcpy(v83, v80, v82);
  v83[v82] = 0;
  if ( (g3::logLevel(&v252) & 1) == 0 )
  {
    v85 = 0;
LABEL_128:
    if ( (v253 & 1) == 0 )
      goto LABEL_130;
    goto LABEL_129;
  }
  v250 = 30;
  v251[16] = 0;
  *(_WORD *)&v251[17] = 0;
  *(_DWORD *)&v251[19] = 0;
  strcpy(v251, "feasibal_region");
  v85 = g3::logTag(&v250);
  if ( (v250 & 1) == 0 )
    goto LABEL_128;
  operator delete(*(void **)&v251[15]);
  if ( (v253 & 1) != 0 )
LABEL_129:
    operator delete(v255);
LABEL_130:
  v86 = (_OWORD *)((char *)this + 1912);
  if ( (v85 & 1) != 0 )
  {
    LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef(
      (LogCapture *)name,
      "Bool: interval:%d,accu:%d,invalid:%d,mscore:%d,mmses:%d",
      v212 > 350,
      v213 > 70,
      v214 > 70,
      v79 > 1.15,
      (v61 < 1200.0) & (unsigned __int8)(v61 > 10.0));
    LogCapture::~LogCapture((LogCapture *)name);
  }
  if ( v214 > 70 || v213 > 70 || v212 > 350 || v79 > 1.15 || v61 < 1200.0 && v61 > 10.0 )
  {
    v87 = *((_DWORD *)this + 676);
    *((_DWORD *)this + 676) = v87 + 1;
    if ( v87 >= 700 )
    {
      *((_DWORD *)this + 676) = 0;
      *(_QWORD *)((char *)this + 2564) = 0LL;
      v88 = *((_QWORD *)this + 322);
      v89 = *((_QWORD *)this + 317);
      *((_DWORD *)this + 650) = 0;
      *((_QWORD *)this + 323) = v88;
      *((_QWORD *)this + 318) = v89;
    }
    if ( !*((_BYTE *)this + 2529) )
    {
LABEL_274:
      if ( *((_BYTE *)this + 2528) )
      {
        *((_QWORD *)this + 232) = *((_QWORD *)this + 231);
        v230 = 0LL;
        v231 = 0LL;
        if ( (word_6FDF0 & 1) != 0 )
          v171 = (const char *)qword_6FE00;
        else
          v171 = (char *)&word_6FDF0 + 1;
        v228 = dword_6FDE8;
        v229 = 0LL;
        v172 = strlen(v171);
        if ( v172 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v173 = v172;
        if ( v172 >= 0x17 )
        {
          v179 = (v172 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v86 = (_OWORD *)((char *)this + 1912);
          v174 = (char *)operator new(v179);
          v230 = v173;
          v231 = v174;
          v229 = v179 | 1;
        }
        else
        {
          v174 = (char *)&v229 + 1;
          LOBYTE(v229) = 2 * v172;
          if ( !v172 )
          {
LABEL_291:
            v174[v173] = 0;
            if ( (g3::logLevel(&v228) & 1) != 0 )
            {
              LOBYTE(v227[0]) = 30;
              strcpy((char *)v227 + 1, "feasibal_region");
              BYTE1(v227[2]) = 0;
              WORD1(v227[2]) = 0;
              HIDWORD(v227[2]) = 0;
              v180 = g3::logTag(v227);
              if ( ((__int64)v227[0] & 1) == 0 )
              {
                if ( (v229 & 1) == 0 )
                  goto LABEL_294;
LABEL_297:
                operator delete(v231);
                if ( (v180 & 1) == 0 )
                  goto LABEL_310;
LABEL_298:
                LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
                LogCapture::capturef((LogCapture *)name, "down rgbd data error, current will not work!\n");
LABEL_309:
                LogCapture::~LogCapture((LogCapture *)name);
                goto LABEL_310;
              }
              operator delete(v227[2]);
              if ( (v229 & 1) != 0 )
                goto LABEL_297;
            }
            else
            {
              v180 = 0;
              if ( (v229 & 1) != 0 )
                goto LABEL_297;
            }
LABEL_294:
            if ( (v180 & 1) == 0 )
              goto LABEL_310;
            goto LABEL_298;
          }
        }
        memcpy(v174, v171, v173);
        goto LABEL_291;
      }
      if ( (word_6FDF0 & 1) != 0 )
        v175 = (const char *)qword_6FE00;
      else
        v175 = (char *)&word_6FDF0 + 1;
      v223 = dword_6FDE8;
      v225 = 0LL;
      v226 = 0LL;
      v224 = 0LL;
      v176 = strlen(v175);
      if ( v176 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v177 = v176;
      if ( v176 >= 0x17 )
      {
        v181 = (v176 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v86 = (_OWORD *)((char *)this + 1912);
        v178 = (char *)operator new(v181);
        v225 = v177;
        v226 = v178;
        v224 = v181 | 1;
      }
      else
      {
        v178 = (char *)&v224 + 1;
        LOBYTE(v224) = 2 * v176;
        if ( !v176 )
        {
LABEL_301:
          v178[v177] = 0;
          if ( (g3::logLevel(&v223) & 1) != 0 )
          {
            LOBYTE(v222[0]) = 30;
            strcpy((char *)v222 + 1, "feasibal_region");
            BYTE1(v222[2]) = 0;
            WORD1(v222[2]) = 0;
            HIDWORD(v222[2]) = 0;
            v182 = g3::logTag(v222);
            if ( ((__int64)v222[0] & 1) == 0 )
            {
              if ( (v224 & 1) == 0 )
                goto LABEL_304;
LABEL_307:
              operator delete(v226);
              if ( (v182 & 1) == 0 )
                goto LABEL_310;
LABEL_308:
              LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
              LogCapture::capturef((LogCapture *)name, "down rgbd data error, but still using!\n");
              goto LABEL_309;
            }
            operator delete(v222[2]);
            if ( (v224 & 1) != 0 )
              goto LABEL_307;
          }
          else
          {
            v182 = 0;
            if ( (v224 & 1) != 0 )
              goto LABEL_307;
          }
LABEL_304:
          if ( (v182 & 1) == 0 )
          {
LABEL_310:
            ++*((_DWORD *)this + 767);
            if ( *((_BYTE *)this + 2708) )
              goto LABEL_312;
            goto LABEL_311;
          }
          goto LABEL_308;
        }
      }
      memcpy(v178, v175, v177);
      goto LABEL_301;
    }
    v311 = 0u;
    v312 = 0u;
    v309 = 0u;
    v310 = 0u;
    v307 = 0u;
    v308 = 0u;
    v305 = 0u;
    v306 = 0u;
    v303 = 0u;
    v304 = 0u;
    v301 = 0u;
    v302 = 0u;
    memset(name, 0, sizeof(name));
    v90 = 0LL;
    strcpy(v249, "*/sdcard/pudu/picture/");
    v91 = 47;
    v249[23] = 0;
    while ( 1 )
    {
      name[v90] = v91;
      if ( (v91 == 92 || v91 == 47) && access(name, 0) == -1 && mkdir(name, 0x1EDu) == -1 )
        break;
      if ( (unsigned __int64)(v90 + 1) >= 0x15 )
        goto LABEL_148;
      v91 = v249[v90++ + 2];
    }
    if ( (word_6FDF0 & 1) != 0 )
      v95 = (const char *)qword_6FE00;
    else
      v95 = (char *)&word_6FDF0 + 1;
    v245 = dword_6FDE8;
    v247 = 0LL;
    v248 = 0LL;
    v246 = 0LL;
    v96 = strlen(v95);
    if ( v96 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v97 = v96;
    if ( v96 >= 0x17 )
    {
      v101 = (v96 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v98 = (char *)operator new(v101);
      v247 = v97;
      v248 = v98;
      v246 = v101 | 1;
    }
    else
    {
      v98 = (char *)&v246 + 1;
      LOBYTE(v246) = 2 * v96;
      if ( !v96 )
      {
LABEL_171:
        v98[v97] = 0;
        if ( (g3::logLevel(&v245) & 1) != 0 )
        {
          LOBYTE(v244[0]) = 30;
          BYTE1(v244[2]) = 0;
          WORD1(v244[2]) = 0;
          HIDWORD(v244[2]) = 0;
          strcpy((char *)v244 + 1, "feasibal_region");
          v102 = g3::logTag(v244);
          if ( ((__int64)v244[0] & 1) == 0 )
          {
            if ( (v246 & 1) == 0 )
              goto LABEL_174;
LABEL_177:
            operator delete(v248);
            if ( (v102 & 1) == 0 )
              goto LABEL_148;
            goto LABEL_178;
          }
          operator delete(v244[2]);
          if ( (v246 & 1) != 0 )
            goto LABEL_177;
        }
        else
        {
          v102 = 0;
          if ( (v246 & 1) != 0 )
            goto LABEL_177;
        }
LABEL_174:
        if ( (v102 & 1) == 0 )
          goto LABEL_148;
LABEL_178:
        LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
        LogCapture::capturef((LogCapture *)name, "create fold /sdcard/pudu/picture/ error!");
        LogCapture::~LogCapture((LogCapture *)name);
LABEL_148:
        v92 = (_QWORD *)((char *)this + 2736);
        if ( *((_QWORD *)this + 358) )
          goto LABEL_185;
        v93 = fopen("/sdcard/pudu/picture/record.txt", "a");
        *((_QWORD *)this + 358) = v93;
        if ( v93 )
        {
          v94 = *((_QWORD *)this + 342);
          *((_DWORD *)this + 724) = 17;
          std::ios_base::clear((std::ios_base *)((char *)v92 + *(_QWORD *)(v94 - 24)), 0);
        }
        else
        {
          std::ios_base::clear(
            (std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)),
            *(_DWORD *)((char *)v92 + *(_QWORD *)(*v92 - 24LL) + 32) | 4);
        }
        v99 = (FILE *)*((_QWORD *)this + 358);
        if ( v99 )
        {
          v100 = (*(__int64 (__fastcall **)(char *))(*((_QWORD *)this + 343) + 48LL))((char *)this + 2744);
          if ( fclose(v99) )
          {
            (*(void (__fastcall **)(char *, _QWORD, _QWORD))(*((_QWORD *)this + 343) + 24LL))(
              (char *)this + 2744,
              0LL,
              0LL);
          }
          else
          {
            v103 = *((_QWORD *)this + 343);
            *((_QWORD *)this + 358) = 0LL;
            (*(void (__fastcall **)(char *, _QWORD, _QWORD))(v103 + 24))((char *)this + 2744, 0LL, 0LL);
            if ( !v100 )
              goto LABEL_181;
          }
        }
        std::ios_base::clear(
          (std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)),
          *(_DWORD *)((char *)v92 + *(_QWORD *)(*v92 - 24LL) + 32) | 4);
LABEL_181:
        if ( !*((_QWORD *)this + 358) )
        {
          v104 = fopen("/sdcard/pudu/picture/record.txt", "r+");
          *((_QWORD *)this + 358) = v104;
          if ( v104 )
          {
            v105 = *((_QWORD *)this + 342);
            *((_DWORD *)this + 724) = 24;
            std::ios_base::clear((std::ios_base *)((char *)v92 + *(_QWORD *)(v105 - 24)), 0);
          }
          else
          {
            std::ios_base::clear(
              (std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)),
              *(_DWORD *)((char *)v92 + *(_QWORD *)(*v92 - 24LL) + 32) | 4);
          }
        }
LABEL_185:
        v282 = 0LL;
        *(_QWORD *)s = 0LL;
        v298 = 0u;
        v299 = 0u;
        v296 = 0u;
        v297 = 0u;
        v294 = 0u;
        v295 = 0u;
        v292 = 0u;
        v293 = 0u;
        v290 = 0u;
        v291 = 0u;
        v288 = 0u;
        v289 = 0u;
        v286 = 0u;
        v287 = 0u;
        src = 0u;
        v285 = 0u;
        v283 = 0LL;
        timer = time(0LL);
        v106 = localtime(&timer);
        strftime(s, 0x18uLL, "%Y%m%d%H%M%S", v106);
        gettimeofday(&v242, 0LL);
        sprintf((char *)&src, "%s_", s);
        v240 = 0uLL;
        v241 = 0LL;
        v107 = strlen((const char *)&src);
        if ( v107 >= 0xFFFFFFFFFFFFFFF0LL )
          std::__basic_string_common<true>::__throw_length_error();
        v109 = v107;
        if ( v107 >= 0x17 )
        {
          v111 = (v107 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v110 = (char *)operator new(v111);
          *((_QWORD *)&v240 + 1) = v109;
          v241 = v110;
          *(_QWORD *)&v240 = v111 | 1;
        }
        else
        {
          v110 = (char *)&v240 + 1;
          LOBYTE(v240) = 2 * v107;
          if ( !v107 )
          {
LABEL_191:
            v112 = (std::__ndk1 *)(unsigned int)(SLODWORD(v242.tv_usec) / 1000);
            v110[v109] = 0;
            std::to_string(name, v112, v108);
            if ( (v240 & 1) != 0 )
              v113 = (char *)v241;
            else
              v113 = (char *)&v240 + 1;
            if ( (v240 & 1) != 0 )
              v114 = *((_QWORD *)&v240 + 1);
            else
              v114 = (unsigned __int64)(unsigned __int8)v240 >> 1;
            v115 = std::string::insert((__int64 *)name, 0LL, v113, v114);
            v117 = (void *)v115[2];
            v118 = *(__int64 *)((char *)v115 + 1);
            v119 = *(_BYTE *)v115;
            *(_QWORD *)((char *)&v279 + 7) = v115[1];
            *(_QWORD *)&v279 = v118;
            *v115 = 0LL;
            v115[1] = 0LL;
            v115[2] = 0LL;
            if ( (v240 & 1) != 0 )
            {
              *(_BYTE *)v241 = 0;
              *((_QWORD *)&v240 + 1) = 0LL;
              if ( (v240 & 1) != 0 )
              {
                operator delete(v241);
                *(_QWORD *)&v240 = 0LL;
              }
            }
            else
            {
              LOWORD(v240) = 0;
            }
            v120 = *(_QWORD *)((char *)&v279 + 7);
            v121 = v279;
            LOBYTE(v240) = v119;
            *(_QWORD *)((char *)&v279 + 7) = 0LL;
            *((_QWORD *)&v240 + 1) = v120;
            v241 = v117;
            *(_QWORD *)((char *)&v240 + 1) = v121;
            *(_QWORD *)&v279 = 0LL;
            if ( (name[0] & 1) != 0 )
              operator delete(*(void **)&name[16]);
            if ( !*((_BYTE *)this + 3072) )
            {
LABEL_220:
              v138 = (std::__ndk1 *)*((unsigned int *)this + 767);
              *((_BYTE *)this + 3072) = 0;
              if ( (unsigned int)v138 >> 3 >= 0xC35 )
              {
                std::ios_base::clear((std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)), 0);
                name[0] = 0;
                *(_QWORD *)&name[8] = (char *)this + 2736;
                v140 = (__int64 *)(*v92 - 24LL);
                v139 = *v140;
                v141 = *(_DWORD *)((char *)v92 + *v140 + 32);
                if ( !v141 )
                {
                  v142 = *(_QWORD **)((char *)v92 + v139 + 136);
                  if ( v142 )
                  {
                    std::ostream::flush(v142);
                    v140 = (__int64 *)(*v92 - 24LL);
                  }
                  name[0] = 1;
                  v139 = *v140;
                  v141 = *(_DWORD *)((char *)v92 + *v140 + 32);
                }
                if ( (v141 & 5) == 0 )
                {
                  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(**(_QWORD **)((char *)v92 + v139 + 40) + 32LL))(
                    *(_QWORD *)((char *)v92 + v139 + 40),
                    0LL,
                    0LL,
                    16LL);
                  if ( v143 == -1 )
                    std::ios_base::clear(
                      (std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)),
                      *(_DWORD *)((char *)v92 + *(_QWORD *)(*v92 - 24LL) + 32) | 4);
                }
                std::ostream::sentry::~sentry((__int64)name);
                v138 = 0LL;
                *((_DWORD *)this + 767) = 0;
              }
              std::to_string(&v237, v138, v116);
              v144 = std::string::insert((__int64 *)&v237, 0LL, "/sdcard/pudu/picture/ar_", 0x18uLL);
              v145 = *(_OWORD *)v144;
              *(_QWORD *)&name[16] = v144[2];
              *(_OWORD *)name = v145;
              v144[1] = 0LL;
              v144[2] = 0LL;
              *v144 = 0LL;
              v146 = std::string::append((__int64 *)name, ".png", 4uLL);
              v147 = *(_OWORD *)v146;
              v280 = (void *)v146[2];
              v279 = v147;
              v146[1] = 0LL;
              v146[2] = 0LL;
              *v146 = 0LL;
              if ( (name[0] & 1) != 0 )
                operator delete(*(void **)&name[16]);
              if ( ((unsigned __int8)v237 & 1) != 0 )
                operator delete(v239);
              if ( (v279 & 1) != 0 )
                v148 = (char *)v280;
              else
                v148 = (char *)&v279 + 1;
              if ( (v279 & 1) != 0 )
                v149 = *((_QWORD *)&v279 + 1);
              else
                v149 = (unsigned __int64)(unsigned __int8)v279 >> 1;
              v150 = std::__put_character_sequence<char,std::char_traits<char>>(
                       (_QWORD *)this + 342,
                       (__int64)v148,
                       v149);
              v151 = std::__put_character_sequence<char,std::char_traits<char>>(v150, (__int64)"\t", 1LL);
              if ( (v240 & 1) != 0 )
                v152 = *((_QWORD *)&v240 + 1);
              else
                v152 = (unsigned __int64)(unsigned __int8)v240 >> 1;
              if ( (v240 & 1) != 0 )
                v153 = (char *)v241;
              else
                v153 = (char *)&v240 + 1;
              v154 = std::__put_character_sequence<char,std::char_traits<char>>(v151, (__int64)v153, v152);
              v155 = std::__put_character_sequence<char,std::char_traits<char>>(v154, (__int64)"\t", 1LL);
              v156 = std::ostream::operator<<(v155, *((float *)this + 678));
              v157 = std::__put_character_sequence<char,std::char_traits<char>>(v156, (__int64)" ", 1LL);
              v158 = std::ostream::operator<<(v157, *((float *)this + 679));
              v159 = std::__put_character_sequence<char,std::char_traits<char>>(v158, (__int64)" ", 1LL);
              v160 = std::ostream::operator<<(v159, *((float *)this + 680));
              std::ios_base::getloc(name, (std::ios_base *)((char *)v160 + *(_QWORD *)(*v160 - 24LL)));
              v161 = std::locale::use_facet(name, &std::ctype<char>::id);
              v162 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v161 + 56LL))(v161, 10LL);
              std::locale::~locale((std::locale *)name);
              std::ostream::put(v160, v162);
              std::ostream::flush(v160);
              if ( (word_6FDF0 & 1) != 0 )
                v163 = (const char *)qword_6FE00;
              else
                v163 = (char *)&word_6FDF0 + 1;
              v233 = dword_6FDE8;
              v235 = 0LL;
              v236 = 0LL;
              v234 = 0LL;
              v164 = strlen(v163);
              if ( v164 >= 0xFFFFFFFFFFFFFFF0LL )
                std::__basic_string_common<true>::__throw_length_error();
              v165 = v164;
              if ( v164 >= 0x17 )
              {
                v167 = (v164 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                v166 = (char *)operator new(v167);
                v235 = v165;
                v236 = v166;
                v234 = v167 | 1;
              }
              else
              {
                v166 = (char *)&v234 + 1;
                LOBYTE(v234) = 2 * v164;
                if ( !v164 )
                {
LABEL_254:
                  v166[v165] = 0;
                  if ( (g3::logLevel(&v233) & 1) != 0 )
                  {
                    LOBYTE(v232[0]) = 30;
                    BYTE1(v232[2]) = 0;
                    WORD1(v232[2]) = 0;
                    HIDWORD(v232[2]) = 0;
                    strcpy((char *)v232 + 1, "feasibal_region");
                    v168 = g3::logTag(v232);
                    if ( ((__int64)v232[0] & 1) == 0 )
                    {
                      if ( (v234 & 1) == 0 )
                        goto LABEL_257;
LABEL_260:
                      operator delete(v236);
                      if ( (v168 & 1) == 0 )
                      {
LABEL_268:
                        *(_QWORD *)&name[16] = 0LL;
                        *(_DWORD *)name = 16842752;
                        v237 = 0LL;
                        v238 = 0LL;
                        *(_QWORD *)&name[8] = (char *)this + 2608;
                        v239 = 0LL;
                        cv::imwrite(&v279, name, &v237);
                        if ( v237 )
                        {
                          v238 = v237;
                          operator delete(v237);
                        }
                        if ( (v279 & 1) != 0 )
                          operator delete(v280);
                        if ( (v240 & 1) != 0 )
                          operator delete(v241);
                        goto LABEL_274;
                      }
LABEL_261:
                      LogCapture::LogCapture(
                        (LogCapture *)name,
                        "feasibal_region",
                        (const LEVELS *)&dword_6FDE8,
                        "",
                        6,
                        0LL);
                      if ( (v279 & 1) != 0 )
                        v169 = (const char *)v280;
                      else
                        v169 = (char *)&v279 + 1;
                      if ( (v240 & 1) != 0 )
                        v170 = (const char *)v241;
                      else
                        v170 = (char *)&v240 + 1;
                      LogCapture::capturef(
                        (LogCapture *)name,
                        "%f,%f,%f,save name %s : %s",
                        *((float *)this + 678),
                        *((float *)this + 679),
                        *((float *)this + 680),
                        v169,
                        v170);
                      LogCapture::~LogCapture((LogCapture *)name);
                      goto LABEL_268;
                    }
                    operator delete(v232[2]);
                    if ( (v234 & 1) != 0 )
                      goto LABEL_260;
                  }
                  else
                  {
                    v168 = 0;
                    if ( (v234 & 1) != 0 )
                      goto LABEL_260;
                  }
LABEL_257:
                  if ( (v168 & 1) == 0 )
                    goto LABEL_268;
                  goto LABEL_261;
                }
              }
              memcpy(v166, v163, v165);
              goto LABEL_254;
            }
            v122 = (std::ios_base *)((char *)v92 + *(_QWORD *)(*((_QWORD *)this + 342) - 24LL));
            if ( *((_DWORD *)this + 766) >> 3 < 0xC35u )
            {
              std::ios_base::clear(v122, 0);
              name[0] = 0;
              *(_QWORD *)&name[8] = (char *)this + 2736;
              v134 = (__int64 *)(*v92 - 24LL);
              v133 = *v134;
              v135 = *(_DWORD *)((char *)v92 + *v134 + 32);
              if ( !v135 )
              {
                v136 = *(_QWORD **)((char *)v92 + v133 + 136);
                if ( v136 )
                {
                  std::ostream::flush(v136);
                  v134 = (__int64 *)(*v92 - 24LL);
                }
                name[0] = 1;
                v133 = *v134;
                v135 = *(_DWORD *)((char *)v92 + *v134 + 32);
              }
              if ( (v135 & 5) != 0 )
                goto LABEL_219;
              (*(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(**(_QWORD **)((char *)v92 + v133 + 40) + 32LL))(
                *(_QWORD *)((char *)v92 + v133 + 40),
                0LL,
                2LL,
                16LL);
              if ( v137 != -1 )
                goto LABEL_219;
            }
            else
            {
              std::ios_base::clear(v122, 0);
              v123 = *((_QWORD *)this + 385);
              v124 = *((_QWORD *)this + 386);
              name[0] = 0;
              *(_QWORD *)&name[8] = (char *)this + 2736;
              v125 = *((_QWORD *)this + 342);
              v128 = *(_QWORD *)(v125 - 24);
              v127 = (__int64 *)(v125 - 24);
              v126 = v128;
              v129 = (char *)v92 + v128;
              v130 = *(_DWORD *)((char *)v92 + v128 + 32);
              if ( !v130 )
              {
                v131 = (_QWORD *)*((_QWORD *)v129 + 17);
                if ( v131 )
                {
                  std::ostream::flush(v131);
                  v127 = (__int64 *)(*v92 - 24LL);
                }
                name[0] = 1;
                v126 = *v127;
                v130 = *(_DWORD *)((char *)v92 + *v127 + 32);
              }
              if ( (v130 & 5) != 0 )
                goto LABEL_219;
              (*(void (__fastcall **)(_QWORD, __int64, __int64, __int64))(**(_QWORD **)((char *)v92 + v126 + 40) + 40LL))(
                *(_QWORD *)((char *)v92 + v126 + 40),
                v123,
                v124,
                16LL);
              if ( v132 != -1 )
                goto LABEL_219;
            }
            std::ios_base::clear(
              (std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24LL)),
              *(_DWORD *)((char *)v92 + *(_QWORD *)(*v92 - 24LL) + 32) | 4);
LABEL_219:
            std::ostream::sentry::~sentry((__int64)name);
            goto LABEL_220;
          }
        }
        memcpy(v110, &src, v109);
        goto LABEL_191;
      }
    }
    memcpy(v98, v95, v97);
    goto LABEL_171;
  }
  if ( *((_BYTE *)this + 2708) )
    goto LABEL_312;
LABEL_311:
  v183 = v212 > 350 && v62 != 0.0 && v61 != 0.0 && v213 > 70 && v214 > 70;
  *((_BYTE *)this + 2708) = v183;
  if ( !v183 )
    goto LABEL_329;
LABEL_312:
  *((_QWORD *)this + 232) = *((_QWORD *)this + 231);
  v220 = 0LL;
  v221 = 0LL;
  if ( (word_6FDF0 & 1) != 0 )
    v184 = (const char *)qword_6FE00;
  else
    v184 = (char *)&word_6FDF0 + 1;
  v218 = dword_6FDE8;
  v219 = 0LL;
  v185 = strlen(v184);
  if ( v185 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v186 = v185;
  if ( v185 >= 0x17 )
  {
    v188 = (v185 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v86 = (_OWORD *)((char *)this + 1912);
    v187 = (char *)operator new(v188);
    v220 = v186;
    v221 = v187;
    v219 = v188 | 1;
    goto LABEL_320;
  }
  v187 = (char *)&v219 + 1;
  LOBYTE(v219) = 2 * v185;
  if ( v185 )
LABEL_320:
    memcpy(v187, v184, v186);
  v187[v186] = 0;
  if ( (g3::logLevel(&v218) & 1) != 0 )
  {
    LOBYTE(v217[0]) = 30;
    strcpy((char *)v217 + 1, "feasibal_region");
    BYTE1(v217[2]) = 0;
    WORD1(v217[2]) = 0;
    HIDWORD(v217[2]) = 0;
    v189 = g3::logTag(v217);
    if ( ((__int64)v217[0] & 1) == 0 )
    {
      if ( (v219 & 1) == 0 )
        goto LABEL_324;
LABEL_327:
      operator delete(v221);
      if ( (v189 & 1) == 0 )
        goto LABEL_329;
      goto LABEL_328;
    }
    operator delete(v217[2]);
    if ( (v219 & 1) != 0 )
      goto LABEL_327;
  }
  else
  {
    v189 = 0;
    if ( (v219 & 1) != 0 )
      goto LABEL_327;
  }
LABEL_324:
  if ( (v189 & 1) != 0 )
  {
LABEL_328:
    LogCapture::LogCapture((LogCapture *)name, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)name, "down rgbd data error, will not work!\n");
    LogCapture::~LogCapture((LogCapture *)name);
  }
LABEL_329:
  v190 = *((_DWORD *)this + 130);
  v191 = *((_DWORD *)this + 131);
  LOBYTE(src) = 0;
  cv::Mat_<unsigned char>::Mat_((__int64)name, v190, v191, &src);
  if ( v215 == (cv::Mat *)name )
  {
    if ( *(_QWORD *)&name[56] )
    {
      v203 = (unsigned int *)(*(_QWORD *)&name[56] + 20LL);
      do
      {
        v204 = __ldaxr(v203);
        v205 = v204 - 1;
      }
      while ( __stlxr(v205, v203) );
      if ( !v205 )
        cv::Mat::deallocate((cv::Mat *)name);
    }
  }
  else
  {
    v193 = *((_QWORD *)this + 244);
    if ( v193 )
    {
      v194 = (unsigned int *)(v193 + 20);
      do
      {
        v195 = __ldaxr(v194);
        v196 = v195 - 1;
      }
      while ( __stlxr(v196, v194) );
      if ( !v196 )
        cv::Mat::deallocate(v215);
    }
    *((_QWORD *)this + 244) = 0LL;
    *v86 = 0u;
    v86[1] = 0u;
    if ( *((int *)this + 475) >= 1 )
    {
      v197 = *((_QWORD *)this + 245);
      v198 = 0LL;
      do
        *(_DWORD *)(v197 + 4 * v198++) = 0;
      while ( v198 < *((int *)this + 475) );
    }
    v199 = *(_DWORD *)&name[4];
    v200 = *(_OWORD *)&name[16];
    *(_OWORD *)v215 = *(_OWORD *)name;
    *v86 = v200;
    *(_OWORD *)((char *)this + 1928) = *(_OWORD *)&name[32];
    *(_OWORD *)((char *)this + 1944) = *(_OWORD *)&name[48];
    v201 = (cv *)*((_QWORD *)this + 246);
    if ( v201 == (feasibal_region::ground_process *)((char *)this + 1976) )
    {
      v202 = v199;
    }
    else
    {
      cv::fastFree(v201, v192);
      *((_QWORD *)this + 246) = (char *)this + 1976;
      *((_QWORD *)this + 245) = (char *)this + 1904;
      v202 = *(_DWORD *)&name[4];
      v201 = (feasibal_region::ground_process *)((char *)this + 1976);
    }
    if ( v202 <= 2 )
    {
      v206 = *((_QWORD *)&v301 + 1);
      *(_QWORD *)v201 = **((_QWORD **)&v301 + 1);
      *((_QWORD *)v201 + 1) = *(_QWORD *)(v206 + 8);
    }
    else
    {
      *(_OWORD *)((char *)this + 1960) = v301;
      *((_QWORD *)&v301 + 1) = &v302;
      *(_QWORD *)&v301 = &name[8];
    }
    *(_DWORD *)name = 1124007936;
    memset(&name[4], 0, 60);
  }
  *(_QWORD *)&name[56] = 0LL;
  memset(&name[16], 0, 32);
  if ( *(int *)&name[4] >= 1 )
  {
    v207 = v301;
    v208 = 0LL;
    do
      *(_DWORD *)(v207 + 4 * v208++) = 0;
    while ( v208 < *(int *)&name[4] );
  }
  if ( *((__int128 **)&v301 + 1) != &v302 )
    cv::fastFree(*((cv **)&v301 + 1), v192);
  *(_DWORD *)name = 16842752;
  *(_QWORD *)&name[16] = 0LL;
  *(_QWORD *)&v285 = 0LL;
  *((_QWORD *)&src + 1) = (char *)this + 1896;
  *(_QWORD *)&name[8] = (char *)this + 1992;
  LODWORD(src) = -2113863680;
  v216 = vrev64_s32((int32x2_t)(*((int32x2_t **)this + 245))->n64_u64[0]).n64_i64[0];
  cv::resize(name, &src, &v216, 1LL, 0.0, 0.0);
  v52 = (void **)v276;
  if ( v276 )
  {
LABEL_356:
    v209 = v277;
    if ( v277 == v52 )
    {
      v210 = v52;
    }
    else
    {
      do
      {
        v209 -= 21;
        PlaneSeg::~PlaneSeg(v209);
      }
      while ( v52 != v209 );
      v210 = v276;
    }
    v277 = v52;
    operator delete(v210);
  }
  return 0LL;
}
// 361E8: variable 'v2' is possibly undefined
// 371A0: variable 'v108' is possibly undefined
// 372F4: variable 'v132' is possibly undefined
// 37390: variable 'v137' is possibly undefined
// 37450: variable 'v143' is possibly undefined
// 37480: variable 'v116' is possibly undefined
// 37CF0: variable 'v192' is possibly undefined
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 13140: using guessed type __int64 __fastcall cv::imwrite(_QWORD, _QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 13940: using guessed type __int64 __fastcall cv::resize(_QWORD, _QWORD, _QWORD, _QWORD, double, double);
// 547B0: using guessed type __int128 xmmword_547B0;
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;

//----- (0000000000038454) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::groundProcess(feasibal_region::ground_process *this)
{
  __int64 v2; // x9
  int v3; // w25
  __int64 v4; // x10
  __int64 v5; // x8
  __int64 v6; // x9
  float v7; // s8
  __int64 v8; // x8
  __int64 v9; // x9
  signed __int64 v10; // x10
  __int64 v11; // x11
  signed __int64 v12; // x12
  _QWORD *v13; // x13
  __int64 v14; // x11
  float v15; // w8
  float v16; // w9
  float v17; // w10
  unsigned int v18; // w11
  int v19; // w26
  float v20; // s0
  float v21; // s3
  float v22; // s4
  float v23; // s5
  float v24; // s6
  float v25; // s0
  float v26; // s1
  float v27; // s2
  float v28; // s6
  float v29; // s0
  float v30; // s1
  float v31; // s0
  float v32; // s1
  float v33; // s0
  float v34; // s11
  const char *v35; // x22
  size_t v36; // x0
  size_t v37; // x21
  char *v38; // x23
  unsigned __int64 v39; // x24
  __int64 v40; // x1
  char v41; // w21
  float v42; // s1
  float v43; // s2
  __int64 v44; // d0
  float v45; // w10
  float v46; // w9
  int v47; // w8
  __int64 v48; // x24
  __int64 v49; // x28
  _DWORD *v50; // x27
  int v51; // w23
  float v52; // s13
  __int64 v53; // x26
  __int64 v54; // x1
  unsigned __int64 v55; // x8
  unsigned __int64 v56; // x10
  __int64 v57; // x8
  __int64 v58; // x8
  _QWORD *v59; // x24
  signed __int64 v60; // x0
  unsigned __int64 v61; // x20
  _OWORD *v62; // x0
  _DWORD *v63; // x8
  _OWORD *v64; // x10
  unsigned __int64 v65; // x9
  unsigned __int64 v66; // x12
  __int64 v67; // x9
  _DWORD *v68; // x9
  _DWORD *v69; // x11
  int v70; // w10
  _DWORD *v71; // x8
  void *v72; // x0
  __int64 v73; // x11
  __int64 v74; // x14
  __int128 v75; // q1
  __int128 v76; // q2
  __int128 v77; // q3
  __int128 v78; // q4
  __int128 v79; // q5
  float *v80; // x9
  float v81; // s0
  float v82; // w8
  float v83; // w10
  float v84; // w9
  __int64 v85; // x9
  float v86; // s4
  __int64 v87; // x8
  __int64 v88; // x9
  signed __int64 v89; // x9
  __int64 v90; // x10
  signed __int64 v91; // x11
  unsigned __int64 v92; // x12
  char *v93; // x10
  char *v94; // x11
  char *v95; // x15
  char *v96; // x14
  __int128 *v97; // x14
  _OWORD *v98; // x15
  unsigned __int64 v99; // x16
  __int128 v100; // q0
  __int128 v101; // q1
  __int64 v102; // x12
  __int64 v103; // x8
  char *v104; // x9
  char *v105; // x10
  int v106; // t1
  __int128 v107; // kr10_16
  int v108; // w20
  __int64 v109; // x8
  __int64 v110; // x9
  signed __int64 v111; // x9
  __int64 v112; // x10
  signed __int64 v113; // x11
  unsigned __int64 v114; // x12
  char *v115; // x10
  char *v116; // x11
  char *v117; // x15
  char *v118; // x14
  __int128 *v119; // x14
  _OWORD *v120; // x15
  unsigned __int64 v121; // x16
  __int128 v122; // q0
  __int128 v123; // q1
  __int64 v124; // x12
  __int64 v125; // x8
  char *v126; // x9
  char *v127; // x10
  int v128; // t1
  __int128 v129; // q0
  __int64 v130; // x8
  int v131; // w20
  int v132; // w8
  unsigned int v133; // w19
  void *v134; // x1
  __int64 v135; // x8
  __int64 v136; // x21
  unsigned __int64 v137; // x24
  unsigned __int64 v138; // x20
  float *v139; // x0
  __int64 v140; // x25
  float *v141; // x22
  float v142; // s3
  float v143; // s13
  float v144; // s14
  float v145; // s15
  float *v146; // x21
  float v147; // s0
  float v148; // s1
  float v149; // s3
  float v150; // s0
  float v151; // s1
  float v152; // s0
  float v153; // s2
  double v154; // d0
  double v155; // d1
  double v156; // d2
  int v157; // s0
  int v158; // w22
  int v159; // w8
  int v160; // w25
  unsigned __int64 v161; // x24
  unsigned __int64 v162; // x23
  unsigned __int64 v163; // x27
  unsigned __int64 v164; // x26
  __int64 *v165; // x9
  __int64 v166; // x10
  __int64 v167; // x9
  __int64 v168; // x12
  __int64 v169; // x11
  _BYTE *v170; // x13
  int v171; // w12
  _BYTE *v172; // x11
  __int64 v173; // x10
  int v174; // w9
  _DWORD *v175; // x8
  char *v176; // x8
  unsigned __int64 v177; // x26
  int v178; // w22
  int *v179; // x8
  __int64 v180; // x10
  __int64 v181; // x25
  __int64 v182; // x28
  __int64 v183; // x9
  __int64 v184; // x23
  __int64 v185; // x27
  float *v186; // x13
  float *v187; // x14
  float *v188; // x12
  float v189; // s1
  float v190; // s0
  float v191; // s2
  float v192; // w10
  float v193; // w11
  float v194; // w8
  float v195; // w9
  float v196; // s3
  float v197; // s4
  float v198; // s5
  bool v199; // cc
  int v200; // w13
  _BOOL4 v201; // w14
  _BOOL4 v202; // w15
  int v203; // w16
  float v204; // w12
  float v205; // w13
  float v206; // s4
  float v207; // s3
  float v208; // s7
  float v209; // s5
  float v210; // s6
  float v211; // s13
  float v212; // s0
  float v213; // s0
  float v214; // s0
  int v215; // w20
  __int64 v216; // x8
  __int64 v217; // x9
  signed __int64 v218; // x9
  __int64 v219; // x10
  signed __int64 v220; // x11
  unsigned __int64 v221; // x12
  char *v222; // x10
  char *v223; // x11
  char *v224; // x15
  char *v225; // x14
  __int128 *v226; // x14
  _OWORD *v227; // x15
  unsigned __int64 v228; // x16
  __int128 v229; // q0
  __int128 v230; // q1
  __int64 v231; // x12
  __int64 v232; // x8
  char *v233; // x9
  char *v234; // x10
  int v235; // t1
  void *v236; // x23
  char *v237; // x24
  int v238; // w20
  int v239; // w20
  __int64 v240; // x8
  __int64 v241; // x9
  signed __int64 v242; // x9
  __int64 v243; // x10
  signed __int64 v244; // x11
  unsigned __int64 v245; // x12
  char *v246; // x10
  char *v247; // x11
  char *v248; // x15
  char *v249; // x14
  __int128 *v250; // x14
  _OWORD *v251; // x15
  unsigned __int64 v252; // x16
  __int128 v253; // q0
  __int128 v254; // q1
  __int64 v255; // x12
  __int64 v256; // x8
  char *v257; // x9
  char *v258; // x10
  int v259; // t1
  void *v260; // x23
  char *v261; // x24
  int v262; // w20
  int v263; // w20
  __int64 v264; // x8
  __int64 v265; // x9
  signed __int64 v266; // x9
  __int64 v267; // x10
  signed __int64 v268; // x11
  unsigned __int64 v269; // x12
  char *v270; // x10
  char *v271; // x11
  char *v272; // x15
  char *v273; // x14
  __int128 *v274; // x14
  _OWORD *v275; // x15
  unsigned __int64 v276; // x16
  __int128 v277; // q0
  __int128 v278; // q1
  __int64 v279; // x12
  __int64 v280; // x8
  char *v281; // x9
  char *v282; // x10
  int v283; // t1
  void *v284; // x23
  char *v285; // x24
  int v286; // w20
  void *v287; // x1
  unsigned int *v288; // x8
  unsigned int v289; // w9
  unsigned int v290; // w9
  _BYTE *v291; // x8
  __int64 v292; // x9
  _QWORD *v293; // x19
  _QWORD *v294; // x8
  _QWORD *v295; // x20
  void *v296; // x0
  void *v297; // t1
  void *v298; // x0
  int v300; // [xsp+14h] [xbp-3CCh]
  unsigned __int64 v301; // [xsp+20h] [xbp-3C0h]
  char **v302; // [xsp+28h] [xbp-3B8h]
  int v303; // [xsp+30h] [xbp-3B0h]
  void *v304; // [xsp+40h] [xbp-3A0h] BYREF
  __int64 v305; // [xsp+48h] [xbp-398h]
  __int128 v306; // [xsp+50h] [xbp-390h] BYREF
  void *v307; // [xsp+60h] [xbp-380h] BYREF
  __int64 v308; // [xsp+68h] [xbp-378h]
  __int128 v309; // [xsp+70h] [xbp-370h] BYREF
  void *v310; // [xsp+80h] [xbp-360h] BYREF
  __int64 v311; // [xsp+88h] [xbp-358h]
  __int128 v312; // [xsp+90h] [xbp-350h] BYREF
  void *v313; // [xsp+A0h] [xbp-340h] BYREF
  _DWORD *v314; // [xsp+A8h] [xbp-338h]
  _DWORD *v315; // [xsp+B0h] [xbp-330h]
  void *v316; // [xsp+B8h] [xbp-328h] BYREF
  __int64 v317; // [xsp+C0h] [xbp-320h]
  __int64 v318; // [xsp+C8h] [xbp-318h]
  void *v319; // [xsp+D0h] [xbp-310h] BYREF
  __int64 v320; // [xsp+D8h] [xbp-308h]
  void *ptr; // [xsp+E0h] [xbp-300h] BYREF
  __int64 v322; // [xsp+E8h] [xbp-2F8h]
  void *v323; // [xsp+F0h] [xbp-2F0h] BYREF
  _DWORD *v324; // [xsp+F8h] [xbp-2E8h]
  unsigned __int64 v325; // [xsp+100h] [xbp-2E0h]
  void *v326; // [xsp+108h] [xbp-2D8h] BYREF
  unsigned __int64 v327; // [xsp+110h] [xbp-2D0h]
  __int64 v328; // [xsp+118h] [xbp-2C8h]
  void *v329; // [xsp+120h] [xbp-2C0h] BYREF
  _QWORD *v330; // [xsp+128h] [xbp-2B8h]
  _QWORD *v331; // [xsp+130h] [xbp-2B0h]
  void *v332[3]; // [xsp+138h] [xbp-2A8h] BYREF
  int v333; // [xsp+150h] [xbp-290h] BYREF
  unsigned __int64 v334; // [xsp+158h] [xbp-288h] BYREF
  size_t v335; // [xsp+160h] [xbp-280h]
  void *v336; // [xsp+168h] [xbp-278h]
  __int128 v337; // [xsp+170h] [xbp-270h] BYREF
  void *v338; // [xsp+180h] [xbp-260h] BYREF
  __int64 v339; // [xsp+188h] [xbp-258h]
  void *v340[2]; // [xsp+190h] [xbp-250h] BYREF
  __int64 v341; // [xsp+1A0h] [xbp-240h]
  __int64 v342; // [xsp+1A8h] [xbp-238h]
  _BYTE v343[64]; // [xsp+1B0h] [xbp-230h] BYREF
  _BYTE *v344; // [xsp+1F0h] [xbp-1F0h]
  cv *v345; // [xsp+1F8h] [xbp-1E8h]
  __int64 v346[35]; // [xsp+200h] [xbp-1E0h] BYREF
  __int128 v347; // [xsp+318h] [xbp-C8h] BYREF
  __int128 v348; // [xsp+328h] [xbp-B8h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = *((_QWORD *)this + 302);
  v3 = *((_DWORD *)this + 69);
  v4 = *((_QWORD *)this + 305);
  *((_QWORD *)this + 300) = *((_QWORD *)this + 299);
  v5 = *((_QWORD *)this + 308);
  *((_QWORD *)this + 303) = v2;
  v6 = *((_QWORD *)this + 311);
  v7 = *((float *)this + 36);
  *((_QWORD *)this + 306) = v4;
  *((_QWORD *)this + 309) = v5;
  *((_QWORD *)this + 312) = v6;
  Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&v338, (unsigned int)(v3 * v3), (unsigned int)(v3 * v3));
  v303 = v3 * v3;
  Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&v338, (unsigned int)(v3 * v3), 1LL);
  v8 = v339;
  v9 = v339 + 3;
  if ( v339 >= 0 )
    v9 = v339;
  v10 = v9 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v339 >= 4 )
  {
    v11 = 0LL;
    v12 = 0LL;
    do
    {
      v12 += 4LL;
      v13 = (char *)v338 + v11;
      v11 += 16LL;
      *v13 = 0LL;
      v13[1] = 0LL;
    }
    while ( v12 < v10 );
  }
  if ( v10 < v8 )
    memset((char *)v338 + 4 * v10, 0, 4 * v8 - 16 * (v9 >> 2));
  v14 = *((_QWORD *)this + 231);
  if ( *((_QWORD *)this + 232) == v14 )
    goto LABEL_126;
  v15 = *(float *)v14;
  v16 = *(float *)(v14 + 4);
  LODWORD(v337) = *(_DWORD *)v14;
  *((float *)&v337 + 1) = v16;
  v17 = *(float *)(v14 + 8);
  v18 = *(_DWORD *)(v14 + 12);
  *((_QWORD *)&v337 + 1) = __PAIR64__(v18, LODWORD(v17));
  if ( *((_BYTE *)this + 2384) )
  {
    v19 = 0;
    *((_DWORD *)this + 452) = v18;
    *((_DWORD *)this + 631) = 0;
    *((float *)this + 449) = v15;
    *((float *)this + 450) = v16;
    *((float *)this + 451) = v17;
    *((_DWORD *)this + 629) = 2;
  }
  else
  {
    v15 = *((float *)this + 449);
    *((_DWORD *)this + 629) = 1;
    *(float *)&v337 = v15;
    v16 = *((float *)this + 450);
    *((float *)&v337 + 1) = v16;
    *((_QWORD *)&v337 + 1) = *(_QWORD *)((char *)this + 1804);
    v20 = *((float *)&v337 + 2);
    v19 = *((_DWORD *)this + 631) + 1;
    *((_DWORD *)this + 631) = v19;
    v17 = v20;
  }
  v21 = *((float *)this + 453);
  v22 = *((float *)this + 454);
  v23 = *((float *)this + 455);
  v24 = sqrtf((float)((float)(v15 * v15) + (float)(v16 * v16)) + (float)(v17 * v17));
  v25 = v15 / v24;
  v26 = v16 / v24;
  v27 = v17 / v24;
  v28 = sqrtf((float)((float)(v21 * v21) + (float)(v22 * v22)) + (float)(v23 * v23));
  v29 = (float)((float)(v23 / v28) * v27)
      + (float)((float)((float)(v21 / v28) * v25) + (float)((float)(v22 / v28) * v26));
  v30 = 0.0;
  if ( fabsf(fabsf(v29) + -1.0) >= 0.0001 )
  {
    v31 = acosf(v29);
    if ( v31 > 1.57079633 )
    {
      v32 = 3.14159265 - v31;
      v31 = v32;
    }
    v30 = fabsf(v31);
  }
  *((float *)this + 630) = v30;
  v33 = (float)(v30 * 180.0) / 3.14159;
  v34 = v33;
  if ( (word_6FDF0 & 1) != 0 )
    v35 = (const char *)qword_6FE00;
  else
    v35 = (char *)&word_6FDF0 + 1;
  v333 = dword_6FDE8;
  v335 = 0LL;
  v336 = 0LL;
  v334 = 0LL;
  v36 = strlen(v35);
  if ( v36 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v37 = v36;
  if ( v36 >= 0x17 )
  {
    v39 = (v36 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v38 = (char *)operator new(v39);
    v335 = v37;
    v336 = v38;
    v334 = v39 | 1;
    goto LABEL_24;
  }
  v38 = (char *)&v334 + 1;
  LOBYTE(v334) = 2 * v36;
  if ( v36 )
LABEL_24:
    memcpy(v38, v35, v37);
  v38[v37] = 0;
  if ( (g3::logLevel(&v333) & 1) == 0 )
  {
    v41 = 0;
    if ( (v334 & 1) != 0 )
      goto LABEL_32;
    goto LABEL_28;
  }
  LOBYTE(v332[0]) = 30;
  BYTE1(v332[2]) = 0;
  WORD1(v332[2]) = 0;
  HIDWORD(v332[2]) = 0;
  strcpy((char *)v332 + 1, "feasibal_region");
  v41 = g3::logTag(v332);
  if ( ((__int64)v332[0] & 1) != 0 )
  {
    operator delete(v332[2]);
    if ( (v334 & 1) != 0 )
      goto LABEL_32;
LABEL_28:
    if ( (v41 & 1) != 0 )
      goto LABEL_29;
LABEL_33:
    if ( v19 > 5 )
      goto LABEL_36;
    goto LABEL_34;
  }
  if ( (v334 & 1) == 0 )
    goto LABEL_28;
LABEL_32:
  operator delete(v336);
  if ( (v41 & 1) == 0 )
    goto LABEL_33;
LABEL_29:
  LogCapture::LogCapture((LogCapture *)v343, "feasibal_region", (const LEVELS *)&dword_6FDE8, "", 6, 0LL);
  LogCapture::capturef((LogCapture *)v343, "ground_process angle:%3f\n", v34);
  LogCapture::~LogCapture((LogCapture *)v343);
  if ( v19 > 5 )
    goto LABEL_36;
LABEL_34:
  if ( fabsf(v34) <= 16.0 )
  {
    v43 = *((float *)&v337 + 1);
    v42 = *(float *)&v337;
    LODWORD(v44) = DWORD2(v337);
    goto LABEL_37;
  }
LABEL_36:
  v45 = *((float *)this + 453);
  *((_DWORD *)this + 629) = 1;
  v46 = *((float *)this + 454);
  v44 = *(_QWORD *)((char *)this + 1820);
  v42 = v45;
  *(_QWORD *)&v337 = __PAIR64__(LODWORD(v46), LODWORD(v45));
  v43 = v46;
  *((_QWORD *)&v337 + 1) = v44;
LABEL_37:
  if ( (float)((float)(fabsf(v42) + fabsf(v43)) + fabsf(*(float *)&v44)) <= 0.0001 )
  {
LABEL_126:
    v132 = *((_DWORD *)this + 631);
    *((_DWORD *)this + 629) = 0;
    *((_DWORD *)this + 631) = v132 + 1;
    v133 = -1;
    goto LABEL_268;
  }
  v329 = 0LL;
  v330 = 0LL;
  v331 = 0LL;
  v326 = 0LL;
  v327 = 0LL;
  v328 = 0LL;
  v324 = 0LL;
  v325 = 0LL;
  v323 = 0LL;
  v47 = *((_DWORD *)this + 500);
  v302 = (char **)((char *)this + 2416);
  v300 = 3 * v3;
  if ( v47 <= 0 )
  {
    v50 = (_DWORD *)((char *)this + 2516);
    goto LABEL_130;
  }
  LODWORD(v48) = *((_DWORD *)this + 501);
  v49 = 0LL;
  v50 = (_DWORD *)((char *)this + 2516);
  v51 = 3 * v3 / 2;
  v52 = v7 * *((float *)this + 14);
  do
  {
    if ( (int)v48 < 1 )
      goto LABEL_124;
    v53 = 0LL;
    do
    {
      v80 = (float *)(*((_QWORD *)this + 263) + **((_QWORD **)this + 270) * v49 + 16 * v53);
      v81 = v80[3];
      if ( v81 < 0.0 || !*(_BYTE *)(*((_QWORD *)this + 147) + **((_QWORD **)this + 154) * v49 + v53) )
        goto LABEL_122;
      v82 = *v80;
      v83 = v80[1];
      v84 = v80[2];
      if ( *(_BYTE *)(*((_QWORD *)this + 251) + **((_QWORD **)this + 258) * v49 + v53) == 1 && *v50 != 1 )
      {
        *(float *)v343 = v82;
        *(float *)&v343[4] = v83;
        *(float *)&v343[8] = v84;
        v85 = *((_QWORD *)this + 300);
        if ( v85 == *((_QWORD *)this + 301) )
          goto LABEL_96;
        goto LABEL_121;
      }
      if ( v81 > 1.5 )
      {
        *(float *)v343 = v82;
        *(float *)&v343[4] = v83;
        *(float *)&v343[8] = v84;
        v85 = *((_QWORD *)this + 300);
        if ( v85 == *((_QWORD *)this + 301) )
          goto LABEL_96;
LABEL_121:
        *(float *)v85 = v82;
        *(_QWORD *)(v85 + 4) = *(_QWORD *)&v343[4];
        *((_QWORD *)this + 300) = v85 + 12;
        goto LABEL_122;
      }
      v86 = fabsf(
              (float)((float)(*(float *)&v337 * v82) + (float)(*((float *)&v337 + 1) * v83))
            + (float)((float)(*((float *)&v337 + 2) * v84) + *((float *)&v337 + 3)));
      if ( v86 > (float)(v7 * 10.0) )
      {
        v348 = v337;
        Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&ptr, v339, v339);
        Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&ptr, v339, 1LL);
        v87 = v322;
        v88 = v322 + 3;
        if ( v322 >= 0 )
          v88 = v322;
        v89 = v88 & 0xFFFFFFFFFFFFFFFCLL;
        if ( v322 >= 4 )
        {
          v90 = 0LL;
          v91 = 0LL;
          do
          {
            v91 += 4LL;
            *(_OWORD *)((char *)ptr + v90) = *(_OWORD *)((char *)v338 + v90);
            v90 += 16LL;
          }
          while ( v91 < v89 );
        }
        v92 = v87 - v89;
        if ( v87 > v89 )
        {
          v93 = (char *)v338;
          v94 = (char *)ptr;
          if ( v92 < 8 )
            goto LABEL_89;
          v95 = (char *)ptr + 4 * v89;
          v96 = (char *)v338 + 4 * v89;
          if ( v95 < (char *)v338 + 4 * v87 && v96 < (char *)ptr + 4 * v87 )
            goto LABEL_89;
          v97 = (__int128 *)(v96 + 16);
          v89 += v92 & 0xFFFFFFFFFFFFFFF8LL;
          v98 = v95 + 16;
          v99 = v92 & 0xFFFFFFFFFFFFFFF8LL;
          do
          {
            v100 = *(v97 - 1);
            v101 = *v97;
            v97 += 2;
            v99 -= 8LL;
            *(v98 - 1) = v100;
            *v98 = v101;
            v98 += 2;
          }
          while ( v99 );
          if ( v92 != (v92 & 0xFFFFFFFFFFFFFFF8LL) )
          {
LABEL_89:
            v102 = 4 * v89;
            v103 = v87 - v89;
            v104 = &v94[4 * v89];
            v105 = &v93[v102];
            do
            {
              v106 = *(_DWORD *)v105;
              v105 += 4;
              --v103;
              *(_DWORD *)v104 = v106;
              v104 += 4;
            }
            while ( v103 );
          }
        }
        feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
          (float *)&v348,
          (__int64 *)&ptr,
          v7,
          (__int64)this,
          v53 + v48 * v49,
          v303,
          1u,
          v51,
          (__int64)v343);
        v107 = *(_OWORD *)v343;
        v108 = v343[24];
        memset(v343, 0, 24);
        free(ptr);
        if ( v108 )
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
            v302,
            *((_DWORD **)this + 303),
            v107,
            *((char **)&v107 + 1));
        if ( (_QWORD)v107 )
          operator delete((void *)v107);
        goto LABEL_122;
      }
      if ( v86 <= v52 )
      {
        *(float *)v343 = v82;
        *(float *)&v343[4] = v83;
        *(float *)&v343[8] = v84;
        v85 = *((_QWORD *)this + 300);
        if ( v85 == *((_QWORD *)this + 301) )
        {
LABEL_96:
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
            (__int64)this + 2392,
            (__int64)v343);
          goto LABEL_122;
        }
        goto LABEL_121;
      }
      v340[0] = 0LL;
      v340[1] = 0LL;
      v341 = 0LL;
      v347 = v337;
      Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&v319, v339, v339);
      Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&v319, v339, 1LL);
      v109 = v320;
      v110 = v320 + 3;
      if ( v320 >= 0 )
        v110 = v320;
      v111 = v110 & 0xFFFFFFFFFFFFFFFCLL;
      if ( v320 >= 4 )
      {
        v112 = 0LL;
        v113 = 0LL;
        do
        {
          v113 += 4LL;
          *(_OWORD *)((char *)v319 + v112) = *(_OWORD *)((char *)v338 + v112);
          v112 += 16LL;
        }
        while ( v113 < v111 );
      }
      v114 = v109 - v111;
      if ( v109 > v111 )
      {
        v115 = (char *)v338;
        v116 = (char *)v319;
        if ( v114 < 8 )
          goto LABEL_110;
        v117 = (char *)v319 + 4 * v111;
        v118 = (char *)v338 + 4 * v111;
        if ( v117 < (char *)v338 + 4 * v109 && v118 < (char *)v319 + 4 * v109 )
          goto LABEL_110;
        v119 = (__int128 *)(v118 + 16);
        v111 += v114 & 0xFFFFFFFFFFFFFFF8LL;
        v120 = v117 + 16;
        v121 = v114 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v122 = *(v119 - 1);
          v123 = *v119;
          v119 += 2;
          v121 -= 8LL;
          *(v120 - 1) = v122;
          *v120 = v123;
          v120 += 2;
        }
        while ( v121 );
        if ( v114 != (v114 & 0xFFFFFFFFFFFFFFF8LL) )
        {
LABEL_110:
          v124 = 4 * v111;
          v125 = v109 - v111;
          v126 = &v116[4 * v111];
          v127 = &v115[v124];
          do
          {
            v128 = *(_DWORD *)v127;
            v127 += 4;
            --v125;
            *(_DWORD *)v126 = v128;
            v126 += 4;
          }
          while ( v125 );
        }
      }
      feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
        (float *)&v347,
        (__int64 *)&v319,
        v7,
        (__int64)this,
        v53 + v48 * v49,
        v303,
        1u,
        v51,
        (__int64)v343);
      if ( v340[0] )
      {
        v340[1] = v340[0];
        operator delete(v340[0]);
        v340[0] = 0LL;
        v340[1] = 0LL;
        v341 = 0LL;
      }
      v129 = *(_OWORD *)v343;
      v130 = *(_QWORD *)&v343[16];
      v131 = v343[24];
      memset(v343, 0, 24);
      *(_OWORD *)v340 = v129;
      v341 = v130;
      free(v319);
      v55 = v327;
      if ( v327 == v328 << 6 )
      {
        if ( (__int64)(v327 + 1) < 0 )
          std::__vector_base_common<true>::__throw_length_error();
        if ( v327 > 0x3FFFFFFFFFFFFFFELL )
        {
          v54 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else if ( v328 << 7 >= ((v327 + 64) & 0xFFFFFFFFFFFFFFC0LL) )
        {
          v54 = v328 << 7;
        }
        else
        {
          v54 = (v327 + 64) & 0xFFFFFFFFFFFFFFC0LL;
        }
        std::vector<bool>::reserve((__int64 *)&v326, v54);
        v55 = v327;
      }
      v327 = v55 + 1;
      v56 = v55 >> 6;
      v57 = 1LL << v55;
      if ( v131 )
        v58 = *((_QWORD *)v326 + v56) | v57;
      else
        v58 = *((_QWORD *)v326 + v56) & ~v57;
      *((_QWORD *)v326 + v56) = v58;
      v59 = v330;
      if ( v330 == v331 )
      {
        std::vector<std::vector<Eigen::Matrix<float,3,1,0,3,1>>>::__push_back_slow_path<std::vector<Eigen::Matrix<float,3,1,0,3,1>> const&>(
          (signed __int64 **)&v329,
          (char **)v340);
        goto LABEL_60;
      }
      v330[1] = 0LL;
      v59[2] = 0LL;
      *v59 = 0LL;
      v60 = (char *)v340[1] - (char *)v340[0];
      if ( v340[1] != v340[0] )
      {
        v61 = 0xAAAAAAAAAAAAAAABLL * (v60 >> 2);
        if ( v61 >= 0x1555555555555556LL )
          std::__vector_base_common<true>::__throw_length_error();
        v62 = (_OWORD *)operator new(v60);
        *v59 = v62;
        v59[1] = v62;
        v59[2] = (char *)v62 + 12 * v61;
        v64 = v340[0];
        v63 = v340[1];
        if ( v340[0] != v340[1] )
        {
          v65 = ((char *)v340[1] - 12 - (char *)v340[0]) / 0xCuLL;
          v66 = v65 + 1;
          if ( v65 + 1 < 8
            || (v67 = 12 * v65, v62 < (_OWORD *)((char *)v340[0] + v67 + 12)) && (char *)v62 + v67 + 12 > v340[0] )
          {
            v68 = v62;
            v69 = v340[0];
            goto LABEL_56;
          }
          v73 = 12 * (v66 & 0x3FFFFFFFFFFFFFF8LL);
          v68 = (_DWORD *)((char *)v62 + v73);
          v69 = (char *)v340[0] + v73;
          v74 = v66 & 0x3FFFFFFFFFFFFFF8LL;
          do
          {
            v75 = v64[1];
            v76 = v64[2];
            v77 = v64[3];
            v78 = v64[4];
            v79 = v64[5];
            v74 -= 8LL;
            *v62 = *v64;
            v62[1] = v75;
            v62[2] = v76;
            v62[3] = v77;
            v62[4] = v78;
            v62[5] = v79;
            v62 += 6;
            v64 += 6;
          }
          while ( v74 );
          if ( v66 != (v66 & 0x3FFFFFFFFFFFFFF8LL) )
          {
            do
            {
LABEL_56:
              *v68 = *v69;
              v68[1] = v69[1];
              v70 = v69[2];
              v69 += 3;
              v68[2] = v70;
              v68 += 3;
            }
            while ( v69 != v63 );
          }
          v59[1] = v68;
        }
      }
      v330 += 3;
LABEL_60:
      v71 = v324;
      *(_DWORD *)v343 = v49;
      *(_DWORD *)&v343[4] = v53;
      if ( (unsigned __int64)v324 >= v325 )
      {
        std::vector<cv::Point_<int>>::__push_back_slow_path<cv::Point_<int>>((__int64)&v323, v343);
        v72 = v340[0];
        if ( !v340[0] )
          goto LABEL_122;
LABEL_64:
        v340[1] = v72;
        operator delete(v72);
        goto LABEL_122;
      }
      *v324 = v49;
      v71[1] = *(_DWORD *)&v343[4];
      v324 = v71 + 2;
      v72 = v340[0];
      if ( v340[0] )
        goto LABEL_64;
LABEL_122:
      v48 = *((int *)this + 501);
      ++v53;
    }
    while ( v53 < v48 );
    v47 = *((_DWORD *)this + 500);
LABEL_124:
    ++v49;
  }
  while ( v49 < v47 );
LABEL_130:
  if ( *v50 == 1 )
  {
    std::vector<Eigen::Matrix<float,4,1,0,4,1>>::insert((unsigned __int64 *)this + 231, *((char **)this + 231), &v337);
    v340[0] = (void *)0x3FF0000000000000LL;
    v340[1] = 0LL;
    v341 = 0LL;
    v342 = 0LL;
    cv::operator+(v343, (char *)this + 1992, v340);
    (*(void (__fastcall **)(_QWORD, _BYTE *, char *, __int64))(**(_QWORD **)v343 + 24LL))(
      *(_QWORD *)v343,
      v343,
      (char *)this + 1992,
      0xFFFFFFFFLL);
    cv::MatExpr::~MatExpr((cv::MatExpr *)v343, v134);
  }
  v135 = *((_QWORD *)this + 232);
  v136 = *((_QWORD *)this + 231);
  v316 = 0LL;
  v317 = 0LL;
  v318 = 0LL;
  v137 = (v135 - v136) >> 4;
  v138 = v137 - 1;
  if ( v137 != 1 )
  {
    if ( v138 >> 62 )
      std::__vector_base_common<true>::__throw_length_error();
    v139 = (float *)operator new(4 * v138);
    v140 = (__int64)&v139[v138];
    v141 = v139;
    v316 = v139;
    v318 = v140;
    memset(v139, 0, 4 * v138);
    v317 = v140;
    if ( v137 >= 2 )
    {
      v142 = sqrtf(
               (float)((float)(*(float *)&v337 * *(float *)&v337)
                     + (float)(*((float *)&v337 + 1) * *((float *)&v337 + 1)))
             + (float)(*((float *)&v337 + 2) * *((float *)&v337 + 2)));
      v143 = *(float *)&v337 / v142;
      v144 = *((float *)&v337 + 1) / v142;
      v145 = *((float *)&v337 + 2) / v142;
      v146 = (float *)(v136 + 24);
      do
      {
        v147 = *(v146 - 2);
        v148 = *(v146 - 1);
        v149 = sqrtf((float)((float)(v147 * v147) + (float)(v148 * v148)) + (float)(*v146 * *v146));
        v150 = (float)((float)(*v146 / v149) * v145)
             + (float)((float)((float)(v147 / v149) * v143) + (float)((float)(v148 / v149) * v144));
        v151 = 0.0;
        if ( fabsf(fabsf(v150) + -1.0) >= 0.0001 )
        {
          v152 = acosf(v150);
          if ( v152 > 1.57079633 )
          {
            v153 = 3.14159265 - v152;
            v152 = v153;
          }
          v151 = fabsf(v152);
        }
        *v141++ = v151;
        --v138;
        v146 += 4;
      }
      while ( v138 );
    }
  }
  *(_DWORD *)v343 = 1124007936;
  memset(&v343[4], 0, 60);
  v344 = &v343[8];
  v345 = (cv *)v346;
  v346[1] = 0LL;
  v346[0] = 0LL;
  v154 = (double)*((int *)this + 500);
  v155 = v154 * 0.25;
  v156 = v154 * 0.8;
  v157 = *((_DWORD *)this + 501);
  v158 = (int)v155;
  v159 = (int)v156;
  v313 = 0LL;
  v314 = 0LL;
  v315 = 0LL;
  if ( (int)v155 < (unsigned int)(int)v156 )
  {
    v301 = v159;
    v160 = v159 - 3;
    v161 = v158;
    v162 = (int)((double)v157 * 0.85);
    v163 = (int)((double)v157 * 0.15);
    do
    {
      if ( (unsigned int)v162 > (unsigned int)v163 )
      {
        v164 = v162;
        do
        {
          v165 = (__int64 *)*((_QWORD *)this + 258);
          v166 = *((_QWORD *)this + 251);
          if ( !*(_BYTE *)(v166 + *v165 * (int)v161 + (int)v164) )
          {
            HIDWORD(v340[1]) = 0;
            *(void **)((char *)v340 + 4) = 0LL;
            LODWORD(v340[0]) = v161;
            v167 = *v165;
            v168 = (int)v161 + 1LL;
            v169 = (int)v164 + (int)v161 * v167;
            v170 = (_BYTE *)(v166 + v169);
            do
            {
              if ( *v170 )
                break;
              --v168;
              v170 -= v167;
            }
            while ( v168 >= 1 );
            v171 = v168 - 1;
            if ( v171 <= v158 )
              v171 = -1;
            v172 = (_BYTE *)(v166 + v169);
            v173 = (int)v161;
            HIDWORD(v340[0]) = v171;
            do
            {
              if ( *v172 )
                break;
              ++v173;
              v172 += v167;
            }
            while ( v173 < *((int *)this + 500) );
            if ( (int)v173 >= v160 )
              v174 = -1;
            else
              v174 = v173;
            v340[1] = (void *)__PAIR64__(v164, v174);
            if ( (v171 & 0x80000000) == 0 && (v174 & 0x80000000) == 0 )
            {
              v175 = v314;
              if ( v314 == v315 )
              {
                std::vector<cv::Vec<int,4>>::__push_back_slow_path<cv::Vec<int,4> const&>((__int64)&v313, v340);
              }
              else
              {
                *v314 = v161;
                v175[1] = HIDWORD(v340[0]);
                *((void **)v175 + 1) = v340[1];
                v314 = v175 + 4;
              }
            }
          }
          --v164;
        }
        while ( v164 > v163 );
      }
      ++v161;
    }
    while ( v161 < v301 );
    v176 = (char *)v313;
    if ( v314 != v313 )
    {
      v177 = 0LL;
      v178 = v300 / 2;
      do
      {
        v179 = (int *)&v176[16 * v177];
        v180 = *((_QWORD *)this + 263);
        v181 = v179[2];
        v182 = v179[3];
        v183 = **((_QWORD **)this + 270);
        v185 = *v179;
        v184 = v179[1];
        v186 = (float *)(v180 + v183 * v185 + 16 * v182);
        v187 = (float *)(v180 + v183 * v184 + 16 * v182);
        v188 = (float *)(v180 + v183 * v181 + 16 * v182);
        v189 = v186[2];
        v190 = v187[2];
        v191 = v188[2];
        v193 = *v186;
        v192 = v186[1];
        v195 = *v187;
        v194 = v187[1];
        v196 = vabds_f32(v189, v190);
        v197 = vabds_f32(v189, v191);
        v198 = vabds_f32(v190, v191);
        v199 = v197 <= v198 || v197 <= v196;
        v200 = (v196 <= v198 || v196 <= v197) << 31 >> 31;
        if ( !v199 )
          v200 = 1;
        v201 = v198 > v196;
        v202 = v198 > v197;
        if ( v201 && v202 )
          v203 = 2;
        else
          v203 = v200;
        if ( v203 )
        {
          v205 = *v188;
          v204 = v188[1];
          if ( v203 != 1 )
          {
            v206 = 0.0;
            v207 = 0.0;
            v208 = 0.0;
            v209 = 0.0;
            v210 = 0.0;
            v189 = 0.0;
            if ( v203 != 2 )
              goto LABEL_183;
            v207 = v205;
            v206 = v204;
LABEL_180:
            v209 = v195;
            v210 = v194;
            v208 = v191;
            v189 = v190;
            goto LABEL_183;
          }
          v207 = v205;
          v206 = v204;
          if ( v201 && v202 )
            goto LABEL_180;
          v209 = v193;
          v210 = v192;
          v208 = v191;
        }
        else
        {
          v209 = v193;
          v210 = v192;
          v207 = v195;
          v206 = v194;
          v208 = v190;
        }
LABEL_183:
        v211 = vabds_f32(v189, v208);
        v212 = sqrtf(
                 (float)((float)(v209 - v207) * (float)(v209 - v207))
               + (float)((float)(v210 - v206) * (float)(v210 - v206)))
             + 0.0000001;
        v213 = atanf(v211 / v212);
        if ( v211 > 35.0 || (v214 = v213 * 57.3, v214 > 8.0) )
        {
          v215 = *((_DWORD *)this + 501);
          v312 = v337;
          Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&v310, v339, v339);
          Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&v310, v339, 1LL);
          v216 = v311;
          v217 = v311 + 3;
          if ( v311 >= 0 )
            v217 = v311;
          v218 = v217 & 0xFFFFFFFFFFFFFFFCLL;
          if ( v311 >= 4 )
          {
            v219 = 0LL;
            v220 = 0LL;
            do
            {
              v220 += 4LL;
              *(_OWORD *)((char *)v310 + v219) = *(_OWORD *)((char *)v338 + v219);
              v219 += 16LL;
            }
            while ( v220 < v218 );
          }
          v221 = v216 - v218;
          if ( v216 > v218 )
          {
            v222 = (char *)v338;
            v223 = (char *)v310;
            if ( v221 < 8 )
              goto LABEL_197;
            v224 = (char *)v310 + 4 * v218;
            v225 = (char *)v338 + 4 * v218;
            if ( v224 < (char *)v338 + 4 * v216 && v225 < (char *)v310 + 4 * v216 )
              goto LABEL_197;
            v226 = (__int128 *)(v225 + 16);
            v218 += v221 & 0xFFFFFFFFFFFFFFF8LL;
            v227 = v224 + 16;
            v228 = v221 & 0xFFFFFFFFFFFFFFF8LL;
            do
            {
              v229 = *(v226 - 1);
              v230 = *v226;
              v226 += 2;
              v228 -= 8LL;
              *(v227 - 1) = v229;
              *v227 = v230;
              v227 += 2;
            }
            while ( v228 );
            if ( v221 != (v221 & 0xFFFFFFFFFFFFFFF8LL) )
            {
LABEL_197:
              v231 = 4 * v218;
              v232 = v216 - v218;
              v233 = &v223[4 * v218];
              v234 = &v222[v231];
              do
              {
                v235 = *(_DWORD *)v234;
                v234 += 4;
                --v232;
                *(_DWORD *)v233 = v235;
                v233 += 4;
              }
              while ( v232 );
            }
          }
          feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
            (float *)&v312,
            (__int64 *)&v310,
            v7,
            (__int64)this,
            v182 + v215 * v184,
            v303,
            1u,
            v178,
            (__int64)v340);
          v236 = v340[0];
          v237 = (char *)v340[1];
          v238 = (unsigned __int8)v342;
          v340[0] = 0LL;
          v340[1] = 0LL;
          v341 = 0LL;
          free(v310);
          if ( v238 )
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
              v302,
              *((_DWORD **)this + 303),
              (unsigned __int64)v236,
              v237);
          if ( v236 )
            operator delete(v236);
          v239 = *((_DWORD *)this + 501);
          v309 = v337;
          Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&v307, v339, v339);
          Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&v307, v339, 1LL);
          v240 = v308;
          v241 = v308 + 3;
          if ( v308 >= 0 )
            v241 = v308;
          v242 = v241 & 0xFFFFFFFFFFFFFFFCLL;
          if ( v308 >= 4 )
          {
            v243 = 0LL;
            v244 = 0LL;
            do
            {
              v244 += 4LL;
              *(_OWORD *)((char *)v307 + v243) = *(_OWORD *)((char *)v338 + v243);
              v243 += 16LL;
            }
            while ( v244 < v242 );
          }
          v245 = v240 - v242;
          if ( v240 > v242 )
          {
            v246 = (char *)v338;
            v247 = (char *)v307;
            if ( v245 < 8 )
              goto LABEL_215;
            v248 = (char *)v307 + 4 * v242;
            v249 = (char *)v338 + 4 * v242;
            if ( v248 < (char *)v338 + 4 * v240 && v249 < (char *)v307 + 4 * v240 )
              goto LABEL_215;
            v250 = (__int128 *)(v249 + 16);
            v242 += v245 & 0xFFFFFFFFFFFFFFF8LL;
            v251 = v248 + 16;
            v252 = v245 & 0xFFFFFFFFFFFFFFF8LL;
            do
            {
              v253 = *(v250 - 1);
              v254 = *v250;
              v250 += 2;
              v252 -= 8LL;
              *(v251 - 1) = v253;
              *v251 = v254;
              v251 += 2;
            }
            while ( v252 );
            if ( v245 != (v245 & 0xFFFFFFFFFFFFFFF8LL) )
            {
LABEL_215:
              v255 = 4 * v242;
              v256 = v240 - v242;
              v257 = &v247[4 * v242];
              v258 = &v246[v255];
              do
              {
                v259 = *(_DWORD *)v258;
                v258 += 4;
                --v256;
                *(_DWORD *)v257 = v259;
                v257 += 4;
              }
              while ( v256 );
            }
          }
          feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
            (float *)&v309,
            (__int64 *)&v307,
            v7,
            (__int64)this,
            v182 + v239 * v185,
            v303,
            1u,
            v178,
            (__int64)v340);
          v260 = v340[0];
          v261 = (char *)v340[1];
          v262 = (unsigned __int8)v342;
          v340[0] = 0LL;
          v340[1] = 0LL;
          v341 = 0LL;
          free(v307);
          if ( v262 )
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
              v302,
              *((_DWORD **)this + 303),
              (unsigned __int64)v260,
              v261);
          if ( v260 )
            operator delete(v260);
          v263 = *((_DWORD *)this + 501);
          v306 = v337;
          Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(&v304, v339, v339);
          Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)&v304, v339, 1LL);
          v264 = v305;
          v265 = v305 + 3;
          if ( v305 >= 0 )
            v265 = v305;
          v266 = v265 & 0xFFFFFFFFFFFFFFFCLL;
          if ( v305 >= 4 )
          {
            v267 = 0LL;
            v268 = 0LL;
            do
            {
              v268 += 4LL;
              *(_OWORD *)((char *)v304 + v267) = *(_OWORD *)((char *)v338 + v267);
              v267 += 16LL;
            }
            while ( v268 < v266 );
          }
          v269 = v264 - v266;
          if ( v264 > v266 )
          {
            v270 = (char *)v338;
            v271 = (char *)v304;
            if ( v269 < 8 )
              goto LABEL_233;
            v272 = (char *)v304 + 4 * v266;
            v273 = (char *)v338 + 4 * v266;
            if ( v272 < (char *)v338 + 4 * v264 && v273 < (char *)v304 + 4 * v264 )
              goto LABEL_233;
            v274 = (__int128 *)(v273 + 16);
            v266 += v269 & 0xFFFFFFFFFFFFFFF8LL;
            v275 = v272 + 16;
            v276 = v269 & 0xFFFFFFFFFFFFFFF8LL;
            do
            {
              v277 = *(v274 - 1);
              v278 = *v274;
              v274 += 2;
              v276 -= 8LL;
              *(v275 - 1) = v277;
              *v275 = v278;
              v275 += 2;
            }
            while ( v276 );
            if ( v269 != (v269 & 0xFFFFFFFFFFFFFFF8LL) )
            {
LABEL_233:
              v279 = 4 * v266;
              v280 = v264 - v266;
              v281 = &v271[4 * v266];
              v282 = &v270[v279];
              do
              {
                v283 = *(_DWORD *)v282;
                v282 += 4;
                --v280;
                *(_DWORD *)v281 = v283;
                v281 += 4;
              }
              while ( v280 );
            }
          }
          feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
            (float *)&v306,
            (__int64 *)&v304,
            v7,
            (__int64)this,
            v182 + v263 * v181,
            v303,
            1u,
            v178,
            (__int64)v340);
          v284 = v340[0];
          v285 = (char *)v340[1];
          v286 = (unsigned __int8)v342;
          v340[0] = 0LL;
          v340[1] = 0LL;
          v341 = 0LL;
          free(v304);
          if ( v286 )
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
              v302,
              *((_DWORD **)this + 303),
              (unsigned __int64)v284,
              v285);
          if ( v284 )
            operator delete(v284);
        }
        v176 = (char *)v313;
        ++v177;
      }
      while ( v177 < ((char *)v314 - (_BYTE *)v313) >> 4 );
    }
  }
  feasibal_region::ground_process::processSlopeBasePlane(
    (__int64)this,
    v40,
    (float *)&v337,
    &v316,
    &v329,
    &v326,
    (__int64 *)&v323);
  if ( v313 )
  {
    v314 = v313;
    operator delete(v313);
  }
  if ( *(_QWORD *)&v343[56] )
  {
    v288 = (unsigned int *)(*(_QWORD *)&v343[56] + 20LL);
    do
    {
      v289 = __ldaxr(v288);
      v290 = v289 - 1;
    }
    while ( __stlxr(v290, v288) );
    if ( !v290 )
      cv::Mat::deallocate((cv::Mat *)v343);
  }
  *(_QWORD *)&v343[56] = 0LL;
  memset(&v343[16], 0, 32);
  if ( *(int *)&v343[4] >= 1 )
  {
    v291 = v344;
    v292 = 0LL;
    do
      *(_DWORD *)&v291[4 * v292++] = 0;
    while ( v292 < *(int *)&v343[4] );
  }
  if ( v345 != (cv *)v346 )
    cv::fastFree(v345, v287);
  if ( v316 )
  {
    v317 = (__int64)v316;
    operator delete(v316);
  }
  if ( v323 )
  {
    v324 = v323;
    operator delete(v323);
  }
  if ( v326 )
    operator delete(v326);
  v293 = v329;
  if ( v329 )
  {
    v294 = v330;
    if ( v330 == v329 )
    {
      v298 = v329;
    }
    else
    {
      v295 = v330;
      do
      {
        v297 = (void *)*(v295 - 3);
        v295 -= 3;
        v296 = v297;
        if ( v297 )
        {
          *(v294 - 2) = v296;
          operator delete(v296);
        }
        v294 = v295;
      }
      while ( v293 != v295 );
      v298 = v329;
    }
    v330 = v293;
    operator delete(v298);
  }
  v133 = 0;
LABEL_268:
  free(v338);
  return v133;
}
// 39028: variable 'v134' is possibly undefined
// 3994C: variable 'v40' is possibly undefined
// 399CC: variable 'v287' is possibly undefined
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 12E10: using guessed type _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 6FDE8: using guessed type int dword_6FDE8;
// 6FDF0: using guessed type __int16 word_6FDF0;
// 6FE00: using guessed type __int64 qword_6FE00;

//----- (0000000000039DA0) ----------------------------------------------------
float __fastcall feasibal_region::ground_process::getVectorAngle(__int64 a1, float *a2, float *a3)
{
  float v3; // s1
  float v4; // s4
  float v5; // s2
  float v6; // s5
  float v7; // s6
  float v8; // s7
  float v9; // s0
  float v11; // s0
  float v12; // s1

  v3 = a2[1];
  v4 = a3[1];
  v5 = a2[2];
  v6 = a3[2];
  v7 = sqrtf((float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v5 * v5));
  v8 = sqrtf((float)((float)(*a3 * *a3) + (float)(v4 * v4)) + (float)(v6 * v6));
  v9 = (float)((float)((float)(*a2 / v7) * (float)(*a3 / v8)) + (float)((float)(v3 / v7) * (float)(v4 / v8)))
     + (float)((float)(v5 / v7) * (float)(v6 / v8));
  if ( fabsf(fabsf(v9) + -1.0) < 0.0001 )
    return 0.0;
  v11 = acosf(v9);
  if ( v11 > 1.57079633 )
  {
    v12 = 3.14159265 - v11;
    v11 = v12;
  }
  return fabsf(v11);
}

//----- (0000000000039E74) ----------------------------------------------------
void __usercall feasibal_region::ground_process::getCellBelongPlaneCloudPoints(
        __int64 a1@<X0>,
        float *a2@<X1>,
        __int64 *a3@<X2>,
        int a4@<W3>,
        int a5@<W4>,
        int a6@<W5>,
        _QWORD *a7@<X8>,
        float a8@<S0>)
{
  __int64 v12; // x28
  float v15; // w22
  float v16; // w25
  float v17; // w23
  float v18; // w26
  float32x4_t v19; // q0
  float32x4_t v20; // q1
  float32x4_t v21; // q2
  float32x4_t v22; // q3
  __int64 v23; // x9
  int v24; // w8
  __int64 v25; // x24
  signed __int64 v26; // x10
  __int64 v27; // x13
  __int64 v28; // x11
  signed __int64 v29; // x12
  unsigned __int64 v30; // x12
  __int64 v31; // x11
  __int64 v32; // x14
  __int64 v33; // x9
  float *v34; // x11
  float *v35; // x10
  float *v36; // x13
  float v37; // t1
  __int64 v38; // x22
  __int64 v39; // x25
  __int64 v40; // x26
  __int64 v41; // x8
  __int64 v42; // x9
  float v43; // s0
  int v44; // w11
  int *v45; // x10
  int *v46; // x13
  int v47; // w8
  unsigned __int64 v48; // x14
  unsigned __int64 v49; // x16
  bool v50; // w0
  _BOOL4 v51; // w13
  _BOOL4 v52; // w15
  _BOOL4 v53; // w14
  _BOOL4 v54; // w16
  float32x4_t *v55; // x17
  float32x4_t *v56; // x14
  float32x4_t *v57; // x16
  float32x4_t v58; // q4
  float32x4_t v59; // q5
  float32x4_t v60; // q6
  float32x4_t v61; // q7
  float32x4_t *v62; // x15
  float32x4_t *v63; // x16
  unsigned __int64 v64; // x0
  float32x4_t v65; // q16
  float32x4_t v66; // q17
  float32x4_t v67; // q18
  float32x4_t v68; // q19
  __int64 v70; // [xsp+10h] [xbp-80h]
  int v71; // [xsp+18h] [xbp-78h] BYREF
  int v72; // [xsp+1Ch] [xbp-74h]
  float v73; // [xsp+20h] [xbp-70h]
  __int64 v74; // [xsp+28h] [xbp-68h]

  v74 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  a7[1] = 0LL;
  a7[2] = 0LL;
  *a7 = 0LL;
  v12 = *(_QWORD *)(a1 + 568);
  v70 = *(_QWORD *)(a1 + 560);
  v15 = *a2;
  v16 = a2[1];
  v17 = a2[2];
  v18 = a2[3];
  Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)a3, a5, 1LL);
  v23 = a3[1];
  v24 = a5 * a4;
  v25 = a5 * a4;
  v26 = v23 & 0xFFFFFFFFFFFFFFFCLL;
  v27 = 2 * v12;
  if ( (__int64)(v23 & 0xFFFFFFFFFFFFFFFCLL) >= 1 )
  {
    v19.n128_f32[0] = v15;
    v20.n128_f32[0] = v16;
    v21.n128_f32[0] = v17;
    v22.n128_f32[0] = v18;
    v28 = 0LL;
    v29 = 0LL;
    v19 = vdupq_lane_s32((int32x2_t)v19.n128_u64[0], 0);
    v20 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v21 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v22 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    do
    {
      v29 += 4LL;
      *(float32x4_t *)(*a3 + v28) = vaddq_f32(
                                      v22,
                                      vaddq_f32(
                                        vaddq_f32(
                                          vmulq_f32(v19, *(float32x4_t *)(v70 + 4LL * v24 + v28)),
                                          vmulq_f32(v20, *(float32x4_t *)(v70 + 4 * (v12 + v24) + v28))),
                                        vmulq_f32(v21, *(float32x4_t *)(v70 + 4 * (v27 + v24) + v28))));
      v28 += 16LL;
    }
    while ( v29 < v26 );
  }
  v30 = v23 - v26;
  if ( v23 > v26 )
  {
    v31 = *a3;
    v19.n128_f32[0] = v15;
    v20.n128_f32[0] = v16;
    v21.n128_f32[0] = v17;
    v22.n128_f32[0] = v18;
    if ( v30 <= 7 )
      goto LABEL_6;
    v48 = v31 + 4 * v26;
    v49 = v31 + 4 * v23;
    v50 = v48 < v70 + 4 * (v23 + v27 + v24) && v70 + 4 * (v26 + v27 + v24) < v49;
    v51 = v48 < v70 + 4 * (v12 + v23 + v24);
    v52 = v70 + 4 * (v12 + v26 + v24) < v49;
    v53 = v48 < v70 + 4 * (v23 + v24);
    v54 = v70 + 4 * (v26 + v24) < v49;
    if ( v50 )
      goto LABEL_6;
    if ( v51 && v52 )
      goto LABEL_6;
    if ( v53 && v54 )
      goto LABEL_6;
    v55 = (float32x4_t *)(v70 + 4 * (v26 + v24));
    v56 = (float32x4_t *)(v31 + 4 * v26 + 16);
    v57 = (float32x4_t *)(v70 + 4 * (v12 + v26 + v24));
    v58 = vdupq_lane_s32((int32x2_t)v19.n128_u64[0], 0);
    v59 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v60 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v61 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    v26 += v30 & 0xFFFFFFFFFFFFFFF8LL;
    v62 = v55 + 1;
    v63 = v57 + 1;
    v64 = v30 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v64 -= 8LL;
      v65 = vaddq_f32(vmulq_f32(v62[-1], v58), vmulq_f32(v63[-1], v59));
      v66 = vaddq_f32(vmulq_f32(*v62, v58), vmulq_f32(*v63, v59));
      v67 = *(float32x4_t *)((char *)&v62[-1] + 8 * v12);
      v68 = *(float32x4_t *)((char *)v62 + 8 * v12);
      v62 += 2;
      v63 += 2;
      v56[-1] = vaddq_f32(vaddq_f32(v65, vmulq_f32(v67, v60)), v61);
      *v56 = vaddq_f32(vaddq_f32(v66, vmulq_f32(v68, v60)), v61);
      v56 += 2;
    }
    while ( v64 );
    if ( v30 != (v30 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_6:
      v32 = v26 + v12;
      v33 = v23 - v26;
      v34 = (float *)(v31 + 4 * v26);
      v35 = (float *)(v70 + 4 * (v26 + v24));
      v36 = (float *)(v70 + 4 * (v32 + v24));
      do
      {
        v37 = *v36++;
        --v33;
        *v34++ = (float)((float)((float)(*v35 * v15) + (float)(v37 * v16)) + (float)(v35[2 * v12] * v17)) + v18;
        ++v35;
      }
      while ( v33 );
    }
  }
  if ( a5 >= 1 )
  {
    v38 = 0LL;
    v39 = v24 + a5;
    v40 = 4 * v25;
    do
    {
      if ( (float)(*(float *)(*a3 + 4 * v38) * *(float *)(*a3 + 4 * v38)) < a8 )
      {
        v41 = *(_QWORD *)(a1 + 560);
        v42 = *(_QWORD *)(a1 + 568);
        v43 = *(float *)(v41 + v40 + 8 * v42 + 4 * v38);
        if ( fabsf(v43) >= 0.0001 )
        {
          v44 = *(_DWORD *)(v41 + v40 + 4 * v38);
          v45 = (int *)a7[1];
          v46 = (int *)a7[2];
          v71 = v44;
          v47 = *(_DWORD *)(v41 + 4 * (v25 + v38 + v42));
          v73 = v43;
          v72 = v47;
          if ( v45 == v46 )
          {
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
              (__int64)a7,
              (__int64)&v71);
          }
          else
          {
            *v45 = v44;
            v45[1] = v72;
            *((float *)v45 + 2) = v73;
            a7[1] = v45 + 3;
          }
        }
      }
      v38 += a6;
    }
    while ( v25 + v38 < v39 );
  }
}
// 39F30: variable 'v19' is possibly undefined
// 39F34: variable 'v20' is possibly undefined
// 39F38: variable 'v21' is possibly undefined
// 39F44: variable 'v22' is possibly undefined

//----- (000000000003A258) ----------------------------------------------------
void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
        __int64 a1@<X0>,
        float *a2@<X1>,
        __int64 *a3@<X2>,
        int a4@<W3>,
        int a5@<W4>,
        unsigned __int8 a6@<W5>,
        int a7@<W6>,
        __int64 a8@<X8>,
        float a9@<S0>)
{
  __int64 v12; // x27
  __int64 v13; // x28
  float v14; // w23
  float v15; // w26
  float v16; // w19
  float v17; // w20
  float32x4_t v20; // q0
  float32x4_t v21; // q1
  float32x4_t v22; // q2
  float32x4_t v23; // q3
  __int64 v24; // x9
  int v25; // w8
  __int64 v26; // x25
  __int64 v27; // x13
  signed __int64 v28; // x10
  __int64 v29; // x11
  signed __int64 v30; // x12
  unsigned __int64 v31; // x12
  __int64 v32; // x11
  __int64 v33; // x14
  __int64 v34; // x9
  float *v35; // x11
  float *v36; // x10
  float *v37; // x13
  float v38; // t1
  float v39; // s0
  __int64 v40; // x27
  __int64 v41; // x19
  __int64 v42; // x20
  float v43; // s9
  char v44; // w24
  float v45; // s1
  __int64 v46; // x8
  __int64 v47; // x9
  float v48; // s0
  int v49; // w11
  int *v50; // x10
  int v51; // w8
  int *v52; // x22
  char *v53; // x20
  bool v54; // zf
  signed __int64 v55; // x21
  char *v56; // x0
  unsigned __int64 v57; // x8
  unsigned __int64 v58; // x10
  __int64 v59; // x8
  char *v60; // x8
  char *v61; // x9
  int v62; // w10
  unsigned __int64 v63; // x14
  unsigned __int64 v64; // x16
  bool v65; // w0
  _BOOL4 v66; // w13
  _BOOL4 v67; // w15
  _BOOL4 v68; // w14
  _BOOL4 v69; // w16
  float32x4_t *v70; // x17
  float32x4_t *v71; // x14
  float32x4_t *v72; // x16
  float32x4_t v73; // q4
  float32x4_t v74; // q5
  float32x4_t v75; // q6
  float32x4_t v76; // q7
  float32x4_t *v77; // x15
  float32x4_t *v78; // x16
  unsigned __int64 v79; // x0
  float32x4_t v80; // q16
  float32x4_t v81; // q17
  float32x4_t v82; // q18
  float32x4_t v83; // q19
  __int64 v84; // x9
  __int64 v85; // x12
  _OWORD *v86; // x13
  __int128 v87; // q1
  __int128 v88; // q2
  __int128 v89; // q3
  __int128 v90; // q4
  __int128 v91; // q5
  void *v95; // [xsp+20h] [xbp-90h] BYREF
  int *v96; // [xsp+28h] [xbp-88h]
  int *v97; // [xsp+30h] [xbp-80h]
  int v98; // [xsp+38h] [xbp-78h] BYREF
  int v99; // [xsp+3Ch] [xbp-74h]
  float v100; // [xsp+40h] [xbp-70h]
  __int64 v101; // [xsp+48h] [xbp-68h]

  v101 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v96 = 0LL;
  v97 = 0LL;
  v95 = 0LL;
  v12 = *(_QWORD *)(a1 + 560);
  v13 = *(_QWORD *)(a1 + 568);
  v14 = *a2;
  v15 = a2[1];
  v16 = a2[2];
  v17 = a2[3];
  Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)a3, a5, 1LL);
  v24 = a3[1];
  v25 = a5 * a4;
  v26 = a5 * a4;
  v27 = 2 * v13;
  v28 = v24 & 0xFFFFFFFFFFFFFFFCLL;
  if ( (__int64)(v24 & 0xFFFFFFFFFFFFFFFCLL) >= 1 )
  {
    v20.n128_f32[0] = v14;
    v21.n128_f32[0] = v15;
    v22.n128_f32[0] = v16;
    v23.n128_f32[0] = v17;
    v29 = 0LL;
    v30 = 0LL;
    v20 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v21 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v22 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    v23 = vdupq_lane_s32((int32x2_t)v23.n128_u64[0], 0);
    do
    {
      v30 += 4LL;
      *(float32x4_t *)(*a3 + v29) = vaddq_f32(
                                      v23,
                                      vaddq_f32(
                                        vaddq_f32(
                                          vmulq_f32(v20, *(float32x4_t *)(v12 + 4LL * v25 + v29)),
                                          vmulq_f32(v21, *(float32x4_t *)(v12 + 4 * (v13 + v25) + v29))),
                                        vmulq_f32(v22, *(float32x4_t *)(v12 + 4 * (v27 + v25) + v29))));
      v29 += 16LL;
    }
    while ( v30 < v28 );
  }
  v31 = v24 - v28;
  if ( v24 > v28 )
  {
    v32 = *a3;
    v20.n128_f32[0] = v14;
    v21.n128_f32[0] = v15;
    v22.n128_f32[0] = v16;
    v23.n128_f32[0] = v17;
    if ( v31 <= 7 )
      goto LABEL_6;
    v63 = v32 + 4 * v28;
    v64 = v32 + 4 * v24;
    v65 = v63 < v12 + 4 * (v24 + v27 + v25) && v12 + 4 * (v28 + v27 + v25) < v64;
    v66 = v63 < v12 + 4 * (v13 + v24 + v25);
    v67 = v12 + 4 * (v13 + v28 + v25) < v64;
    v68 = v63 < v12 + 4 * (v24 + v25);
    v69 = v12 + 4 * (v28 + v25) < v64;
    if ( v65 )
      goto LABEL_6;
    if ( v66 && v67 )
      goto LABEL_6;
    if ( v68 && v69 )
      goto LABEL_6;
    v70 = (float32x4_t *)(v12 + 4 * (v28 + v25));
    v71 = (float32x4_t *)(v32 + 4 * v28 + 16);
    v72 = (float32x4_t *)(v12 + 4 * (v13 + v28 + v25));
    v73 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v74 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v75 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    v76 = vdupq_lane_s32((int32x2_t)v23.n128_u64[0], 0);
    v28 += v31 & 0xFFFFFFFFFFFFFFF8LL;
    v77 = v70 + 1;
    v78 = v72 + 1;
    v79 = v31 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v79 -= 8LL;
      v80 = vaddq_f32(vmulq_f32(v77[-1], v73), vmulq_f32(v78[-1], v74));
      v81 = vaddq_f32(vmulq_f32(*v77, v73), vmulq_f32(*v78, v74));
      v82 = *(float32x4_t *)((char *)&v77[-1] + 8 * v13);
      v83 = *(float32x4_t *)((char *)v77 + 8 * v13);
      v77 += 2;
      v78 += 2;
      v71[-1] = vaddq_f32(vaddq_f32(v80, vmulq_f32(v82, v75)), v76);
      *v71 = vaddq_f32(vaddq_f32(v81, vmulq_f32(v83, v75)), v76);
      v71 += 2;
    }
    while ( v79 );
    if ( v31 != (v31 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_6:
      v33 = v28 + v13;
      v34 = v24 - v28;
      v35 = (float *)(v32 + 4 * v28);
      v36 = (float *)(v12 + 4 * (v28 + v25));
      v37 = (float *)(v12 + 4 * (v33 + v25));
      do
      {
        v38 = *v37++;
        --v34;
        *v35++ = (float)((float)((float)(*v36 * v14) + (float)(v38 * v15)) + (float)(v36[2 * v13] * v16)) + v17;
        ++v36;
      }
      while ( v34 );
    }
  }
  if ( a5 <= 0 )
  {
    v44 = 1;
  }
  else
  {
    v39 = a9 * 0.95;
    v40 = 0LL;
    v41 = 4LL * v25;
    v42 = v25 + a5;
    v43 = v39 * v39;
    v44 = 1;
    do
    {
      v45 = *(float *)(*a3 + 4 * v40);
      if ( v43 < (float)(v45 * v45) )
      {
        v46 = *(_QWORD *)(a1 + 560);
        v47 = *(_QWORD *)(a1 + 568);
        v48 = *(float *)(v46 + v41 + 8 * v47 + 4 * v40);
        if ( fabsf(v48) >= 0.0001 )
        {
          v49 = *(_DWORD *)(v46 + v41 + 4 * v40);
          v50 = v96;
          v98 = v49;
          v51 = *(_DWORD *)(v46 + 4 * (v26 + v40 + v47));
          if ( ((v45 < 0.0) & a6) != 0 )
            v44 = 0;
          v99 = v51;
          v100 = v48;
          if ( v96 == v97 )
          {
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
              (__int64)&v95,
              (__int64)&v98);
          }
          else
          {
            *v96 = v49;
            v50[1] = v99;
            *((float *)v50 + 2) = v100;
            v96 = v50 + 3;
          }
        }
      }
      v40 += a7;
    }
    while ( v26 + v40 < v42 );
  }
  v52 = v96;
  v53 = (char *)v95;
  v55 = (char *)v96 - (_BYTE *)v95;
  v54 = v96 == v95;
  *(_QWORD *)(a8 + 8) = 0LL;
  *(_QWORD *)(a8 + 16) = 0LL;
  *(_QWORD *)a8 = 0LL;
  if ( !v54 )
  {
    if ( 0xAAAAAAAAAAAAAAABLL * (v55 >> 2) >= 0x1555555555555556LL )
      std::__vector_base_common<true>::__throw_length_error();
    v56 = (char *)operator new(v55);
    *(_QWORD *)a8 = v56;
    *(_QWORD *)(a8 + 8) = v56;
    *(_QWORD *)(a8 + 16) = &v56[4 * (v55 >> 2)];
    if ( v53 != (char *)v52 )
    {
      v57 = (v55 - 12) / 0xCuLL;
      v58 = v57 + 1;
      if ( v57 + 1 >= 8 && ((v59 = 12 * v57 + 12, v56 >= &v53[v59]) || &v56[v59] <= v53) )
      {
        v84 = 12 * (v58 & 0x3FFFFFFFFFFFFFF8LL);
        v60 = &v56[v84];
        v61 = &v53[v84];
        v85 = v58 & 0x3FFFFFFFFFFFFFF8LL;
        v86 = v53;
        do
        {
          v87 = v86[1];
          v88 = v86[2];
          v89 = v86[3];
          v90 = v86[4];
          v91 = v86[5];
          v85 -= 8LL;
          *(_OWORD *)v56 = *v86;
          *((_OWORD *)v56 + 1) = v87;
          *((_OWORD *)v56 + 2) = v88;
          *((_OWORD *)v56 + 3) = v89;
          *((_OWORD *)v56 + 4) = v90;
          *((_OWORD *)v56 + 5) = v91;
          v56 += 96;
          v86 += 6;
        }
        while ( v85 );
        if ( v58 == (v58 & 0x3FFFFFFFFFFFFFF8LL) )
          goto LABEL_28;
      }
      else
      {
        v60 = v56;
        v61 = v53;
      }
      do
      {
        *(_DWORD *)v60 = *(_DWORD *)v61;
        *((_DWORD *)v60 + 1) = *((_DWORD *)v61 + 1);
        v62 = *((_DWORD *)v61 + 2);
        v61 += 12;
        *((_DWORD *)v60 + 2) = v62;
        v60 += 12;
      }
      while ( v61 != (char *)v52 );
LABEL_28:
      *(_QWORD *)(a8 + 8) = v60;
    }
  }
  *(_BYTE *)(a8 + 24) = v44;
  if ( v53 )
  {
    v96 = (int *)v53;
    operator delete(v53);
  }
}
// 3A314: variable 'v20' is possibly undefined
// 3A318: variable 'v21' is possibly undefined
// 3A31C: variable 'v22' is possibly undefined
// 3A328: variable 'v23' is possibly undefined

//----- (000000000003A7F8) ----------------------------------------------------
void __usercall feasibal_region::ground_process::getCellNotBelongPlaneCloudPoints(
        __int64 a1@<X0>,
        float *a2@<X1>,
        __int64 *a3@<X2>,
        int a4@<W3>,
        int a5@<W4>,
        int a6@<W5>,
        _QWORD *a7@<X8>,
        float a8@<S0>)
{
  __int64 v12; // x28
  float v15; // w22
  float v16; // w25
  float v17; // w23
  float v18; // w26
  float32x4_t v19; // q0
  float32x4_t v20; // q1
  float32x4_t v21; // q2
  float32x4_t v22; // q3
  __int64 v23; // x9
  int v24; // w8
  __int64 v25; // x24
  signed __int64 v26; // x10
  __int64 v27; // x13
  __int64 v28; // x11
  signed __int64 v29; // x12
  unsigned __int64 v30; // x12
  __int64 v31; // x11
  __int64 v32; // x14
  __int64 v33; // x9
  float *v34; // x11
  float *v35; // x10
  float *v36; // x13
  float v37; // t1
  float v38; // s0
  __int64 v39; // x22
  __int64 v40; // x25
  float v41; // s9
  __int64 v42; // x26
  __int64 v43; // x8
  __int64 v44; // x9
  float v45; // s0
  int v46; // w11
  int *v47; // x10
  int *v48; // x13
  int v49; // w8
  unsigned __int64 v50; // x14
  unsigned __int64 v51; // x16
  bool v52; // w0
  _BOOL4 v53; // w13
  _BOOL4 v54; // w15
  _BOOL4 v55; // w14
  _BOOL4 v56; // w16
  float32x4_t *v57; // x17
  float32x4_t *v58; // x14
  float32x4_t *v59; // x16
  float32x4_t v60; // q4
  float32x4_t v61; // q5
  float32x4_t v62; // q6
  float32x4_t v63; // q7
  float32x4_t *v64; // x15
  float32x4_t *v65; // x16
  unsigned __int64 v66; // x0
  float32x4_t v67; // q16
  float32x4_t v68; // q17
  float32x4_t v69; // q18
  float32x4_t v70; // q19
  __int64 v72; // [xsp+10h] [xbp-80h]
  int v73; // [xsp+18h] [xbp-78h] BYREF
  int v74; // [xsp+1Ch] [xbp-74h]
  float v75; // [xsp+20h] [xbp-70h]
  __int64 v76; // [xsp+28h] [xbp-68h]

  v76 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  a7[1] = 0LL;
  a7[2] = 0LL;
  *a7 = 0LL;
  v12 = *(_QWORD *)(a1 + 568);
  v72 = *(_QWORD *)(a1 + 560);
  v15 = *a2;
  v16 = a2[1];
  v17 = a2[2];
  v18 = a2[3];
  Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)a3, a5, 1LL);
  v23 = a3[1];
  v24 = a5 * a4;
  v25 = a5 * a4;
  v26 = v23 & 0xFFFFFFFFFFFFFFFCLL;
  v27 = 2 * v12;
  if ( (__int64)(v23 & 0xFFFFFFFFFFFFFFFCLL) >= 1 )
  {
    v19.n128_f32[0] = v15;
    v20.n128_f32[0] = v16;
    v21.n128_f32[0] = v17;
    v22.n128_f32[0] = v18;
    v28 = 0LL;
    v29 = 0LL;
    v19 = vdupq_lane_s32((int32x2_t)v19.n128_u64[0], 0);
    v20 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v21 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v22 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    do
    {
      v29 += 4LL;
      *(float32x4_t *)(*a3 + v28) = vaddq_f32(
                                      v22,
                                      vaddq_f32(
                                        vaddq_f32(
                                          vmulq_f32(v19, *(float32x4_t *)(v72 + 4LL * v24 + v28)),
                                          vmulq_f32(v20, *(float32x4_t *)(v72 + 4 * (v12 + v24) + v28))),
                                        vmulq_f32(v21, *(float32x4_t *)(v72 + 4 * (v27 + v24) + v28))));
      v28 += 16LL;
    }
    while ( v29 < v26 );
  }
  v30 = v23 - v26;
  if ( v23 > v26 )
  {
    v31 = *a3;
    v19.n128_f32[0] = v15;
    v20.n128_f32[0] = v16;
    v21.n128_f32[0] = v17;
    v22.n128_f32[0] = v18;
    if ( v30 <= 7 )
      goto LABEL_6;
    v50 = v31 + 4 * v26;
    v51 = v31 + 4 * v23;
    v52 = v50 < v72 + 4 * (v23 + v27 + v24) && v72 + 4 * (v26 + v27 + v24) < v51;
    v53 = v50 < v72 + 4 * (v12 + v23 + v24);
    v54 = v72 + 4 * (v12 + v26 + v24) < v51;
    v55 = v50 < v72 + 4 * (v23 + v24);
    v56 = v72 + 4 * (v26 + v24) < v51;
    if ( v52 )
      goto LABEL_6;
    if ( v53 && v54 )
      goto LABEL_6;
    if ( v55 && v56 )
      goto LABEL_6;
    v57 = (float32x4_t *)(v72 + 4 * (v26 + v24));
    v58 = (float32x4_t *)(v31 + 4 * v26 + 16);
    v59 = (float32x4_t *)(v72 + 4 * (v12 + v26 + v24));
    v60 = vdupq_lane_s32((int32x2_t)v19.n128_u64[0], 0);
    v61 = vdupq_lane_s32((int32x2_t)v20.n128_u64[0], 0);
    v62 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 0);
    v63 = vdupq_lane_s32((int32x2_t)v22.n128_u64[0], 0);
    v26 += v30 & 0xFFFFFFFFFFFFFFF8LL;
    v64 = v57 + 1;
    v65 = v59 + 1;
    v66 = v30 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v66 -= 8LL;
      v67 = vaddq_f32(vmulq_f32(v64[-1], v60), vmulq_f32(v65[-1], v61));
      v68 = vaddq_f32(vmulq_f32(*v64, v60), vmulq_f32(*v65, v61));
      v69 = *(float32x4_t *)((char *)&v64[-1] + 8 * v12);
      v70 = *(float32x4_t *)((char *)v64 + 8 * v12);
      v64 += 2;
      v65 += 2;
      v58[-1] = vaddq_f32(vaddq_f32(v67, vmulq_f32(v69, v62)), v63);
      *v58 = vaddq_f32(vaddq_f32(v68, vmulq_f32(v70, v62)), v63);
      v58 += 2;
    }
    while ( v66 );
    if ( v30 != (v30 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_6:
      v32 = v26 + v12;
      v33 = v23 - v26;
      v34 = (float *)(v31 + 4 * v26);
      v35 = (float *)(v72 + 4 * (v26 + v24));
      v36 = (float *)(v72 + 4 * (v32 + v24));
      do
      {
        v37 = *v36++;
        --v33;
        *v34++ = (float)((float)((float)(*v35 * v15) + (float)(v37 * v16)) + (float)(v35[2 * v12] * v17)) + v18;
        ++v35;
      }
      while ( v33 );
    }
  }
  if ( a5 >= 1 )
  {
    v38 = a8 * 0.95;
    v39 = 0LL;
    v40 = v24 + a5;
    v41 = v38 * v38;
    v42 = 4 * v25;
    do
    {
      if ( v41 < (float)(*(float *)(*a3 + 4 * v39) * *(float *)(*a3 + 4 * v39)) )
      {
        v43 = *(_QWORD *)(a1 + 560);
        v44 = *(_QWORD *)(a1 + 568);
        v45 = *(float *)(v43 + v42 + 8 * v44 + 4 * v39);
        if ( fabsf(v45) >= 0.0001 )
        {
          v46 = *(_DWORD *)(v43 + v42 + 4 * v39);
          v47 = (int *)a7[1];
          v48 = (int *)a7[2];
          v73 = v46;
          v49 = *(_DWORD *)(v43 + 4 * (v25 + v39 + v44));
          v75 = v45;
          v74 = v49;
          if ( v47 == v48 )
          {
            std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
              (__int64)a7,
              (__int64)&v73);
          }
          else
          {
            *v47 = v46;
            v47[1] = v74;
            *((float *)v47 + 2) = v75;
            a7[1] = v47 + 3;
          }
        }
      }
      v39 += a6;
    }
    while ( v25 + v39 < v40 );
  }
}
// 3A8B4: variable 'v19' is possibly undefined
// 3A8B8: variable 'v20' is possibly undefined
// 3A8BC: variable 'v21' is possibly undefined
// 3A8C8: variable 'v22' is possibly undefined

//----- (000000000003ABF4) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::showPtOnImage(float *a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  double *v6; // x10
  double *v7; // x8
  int v8; // w3
  void *v9; // x1
  int v10; // w3
  void *v11; // x1
  int v12; // w3
  void *v13; // x1
  cv *v14; // x0
  __int64 v15; // x0
  __int64 v16; // x28
  unsigned __int64 i; // x19
  float *v18; // x21
  int v19; // w0
  float v20; // s0
  int v21; // w0
  size_t v22; // x0
  size_t v23; // x21
  char *v24; // x22
  unsigned __int64 v25; // x23
  char *v26; // x8
  float *v27; // x21
  int v28; // w0
  float v29; // s0
  int v30; // w0
  int v31; // w1
  void *v32; // x1
  unsigned int *v33; // x8
  unsigned int v34; // w9
  unsigned int v35; // w9
  _QWORD *v36; // x8
  __int64 v37; // x9
  unsigned int *v38; // x8
  unsigned int v39; // w9
  unsigned int v40; // w9
  _QWORD *v41; // x8
  __int64 v42; // x9
  unsigned int *v43; // x8
  unsigned int v44; // w9
  unsigned int v45; // w9
  _QWORD *v46; // x8
  __int64 v47; // x9
  unsigned int *v48; // x8
  unsigned int v49; // w9
  unsigned int v50; // w9
  _QWORD *v51; // x8
  __int64 v52; // x9
  unsigned int *v53; // x8
  unsigned int v54; // w9
  unsigned int v55; // w9
  _QWORD *v56; // x8
  __int64 v57; // x9
  _DWORD v59[2]; // [xsp+68h] [xbp-488h] BYREF
  int v60[2]; // [xsp+70h] [xbp-480h] BYREF
  int v61; // [xsp+78h] [xbp-478h] BYREF
  void **v62; // [xsp+80h] [xbp-470h]
  __int64 v63; // [xsp+88h] [xbp-468h]
  int v64; // [xsp+90h] [xbp-460h] BYREF
  _QWORD *v65; // [xsp+98h] [xbp-458h]
  __int64 v66; // [xsp+A0h] [xbp-450h]
  int v67; // [xsp+A8h] [xbp-448h] BYREF
  _QWORD *v68; // [xsp+B0h] [xbp-440h]
  __int64 v69; // [xsp+B8h] [xbp-438h]
  unsigned __int64 v70; // [xsp+C0h] [xbp-430h] BYREF
  _QWORD *v71; // [xsp+C8h] [xbp-428h]
  void *v72; // [xsp+D0h] [xbp-420h]
  void *v73; // [xsp+D8h] [xbp-418h] BYREF
  _BYTE *v74; // [xsp+E0h] [xbp-410h]
  __int64 v75; // [xsp+E8h] [xbp-408h]
  __int128 v76; // [xsp+F0h] [xbp-400h] BYREF
  __int64 v77; // [xsp+100h] [xbp-3F0h]
  __int64 v78; // [xsp+108h] [xbp-3E8h]
  __int128 v79; // [xsp+110h] [xbp-3E0h] BYREF
  __int128 v80; // [xsp+120h] [xbp-3D0h]
  _QWORD v81[8]; // [xsp+138h] [xbp-3B8h] BYREF
  _QWORD *v82; // [xsp+178h] [xbp-378h]
  cv *v83; // [xsp+180h] [xbp-370h]
  __int64 v84[2]; // [xsp+188h] [xbp-368h] BYREF
  _QWORD v85[8]; // [xsp+198h] [xbp-358h] BYREF
  _QWORD *v86; // [xsp+1D8h] [xbp-318h]
  cv *v87; // [xsp+1E0h] [xbp-310h]
  __int64 v88[2]; // [xsp+1E8h] [xbp-308h] BYREF
  __int128 s; // [xsp+1F8h] [xbp-2F8h] BYREF
  void *v90; // [xsp+208h] [xbp-2E8h]
  _QWORD v91[8]; // [xsp+358h] [xbp-198h] BYREF
  _QWORD *v92; // [xsp+398h] [xbp-158h]
  cv *v93; // [xsp+3A0h] [xbp-150h]
  __int64 v94[2]; // [xsp+3A8h] [xbp-148h] BYREF
  _QWORD v95[8]; // [xsp+3B8h] [xbp-138h] BYREF
  _QWORD *v96; // [xsp+3F8h] [xbp-F8h]
  cv *v97; // [xsp+400h] [xbp-F0h]
  __int64 v98[2]; // [xsp+408h] [xbp-E8h] BYREF
  _QWORD v99[8]; // [xsp+418h] [xbp-D8h] BYREF
  _QWORD *v100; // [xsp+458h] [xbp-98h]
  cv *v101; // [xsp+460h] [xbp-90h]
  __int64 v102[5]; // [xsp+468h] [xbp-88h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  LODWORD(v99[0]) = 1124007936;
  memset((char *)v99 + 4, 0, 60);
  v100 = &v99[1];
  v101 = (cv *)v102;
  v102[0] = 0LL;
  v102[1] = 0LL;
  v90 = 0LL;
  LODWORD(s) = 33619968;
  *((_QWORD *)&s + 1) = v99;
  cv::Mat::copyTo(a1 + 572, &s);
  LODWORD(v95[0]) = 1124007936;
  memset((char *)v95 + 4, 0, 60);
  v96 = &v95[1];
  v97 = (cv *)v98;
  v98[1] = 0LL;
  v98[0] = 0LL;
  *(_QWORD *)&s = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v95, 2, (const int *)&s, 6);
  v4 = v95[2];
  v5 = *(_QWORD *)v97;
  *(double *)v95[2] = a1[25];
  v6 = (double *)(v4 + v5);
  v7 = (double *)(v4 + 2 * v5);
  *(double *)(v4 + 8) = a1[28];
  *(double *)(v4 + 16) = a1[31];
  *v6 = a1[26];
  v6[1] = a1[29];
  v6[2] = a1[32];
  *v7 = a1[27];
  v7[1] = a1[30];
  v7[2] = a1[33];
  cv::Mat::eye(&s, (cv::Mat *)((unsigned int)&dword_0 + 3), 3, 6, v8);
  LODWORD(v91[0]) = 1124007936;
  memset((char *)v91 + 4, 0, 60);
  v92 = &v91[1];
  v93 = (cv *)v94;
  v94[1] = 0LL;
  v94[0] = 0LL;
  (*(void (__fastcall **)(_QWORD, __int128 *, _QWORD *, __int64))(*(_QWORD *)s + 24LL))(s, &s, v91, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&s, v9);
  cv::Mat::zeros(&s, (cv::Mat *)((unsigned int)&dword_0 + 1), 3, 6, v10);
  LODWORD(v85[0]) = 1124007936;
  memset((char *)v85 + 4, 0, 60);
  v86 = &v85[1];
  v87 = (cv *)v88;
  v88[0] = 0LL;
  v88[1] = 0LL;
  (*(void (__fastcall **)(_QWORD, __int128 *, _QWORD *, __int64))(*(_QWORD *)s + 24LL))(s, &s, v85, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&s, v11);
  v73 = 0LL;
  v74 = 0LL;
  v75 = 0LL;
  cv::Mat::zeros(&s, (cv::Mat *)(unsigned int)&byte_5, 1, 6, v12);
  LODWORD(v81[0]) = 1124007936;
  memset((char *)v81 + 4, 0, 60);
  v82 = &v81[1];
  v83 = (cv *)v84;
  v84[0] = 0LL;
  v84[1] = 0LL;
  (*(void (__fastcall **)(_QWORD, __int128 *, _QWORD *, __int64))(*(_QWORD *)s + 24LL))(s, &s, v81, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&s, v13);
  LODWORD(s) = -2130509803;
  *((_QWORD *)&v79 + 1) = v91;
  v71 = v85;
  v68 = v95;
  v90 = 0LL;
  *((_QWORD *)&s + 1) = a2;
  *(_QWORD *)&v80 = 0LL;
  LODWORD(v79) = 16842752;
  v72 = 0LL;
  LODWORD(v70) = 16842752;
  v69 = 0LL;
  v67 = 16842752;
  v66 = 0LL;
  v64 = 16842752;
  v65 = v81;
  v61 = -2113732595;
  v62 = &v73;
  v63 = 0LL;
  v15 = cv::noArray(v14);
  cv::projectPoints(&s, &v79, &v70, &v67, &v64, &v61, v15, 0.0);
  if ( v74 != v73 )
  {
    v16 = 0LL;
    for ( i = 0LL; i < (v74 - (_BYTE *)v73) >> 3; ++i )
    {
      sprintf((char *)&s, "%d", (unsigned int)i);
      v71 = v99;
      v72 = 0LL;
      LODWORD(v70) = 50397184;
      v18 = (float *)((char *)v73 + v16);
      v19 = lrintf(*(float *)((char *)v73 + v16));
      v20 = v18[1];
      LODWORD(v18) = v19;
      v21 = lrintf(v20);
      v60[0] = (int)v18;
      v60[1] = v21;
      v79 = xmmword_547C0;
      v80 = xmmword_547D0;
      cv::circle(&v70, v60, 1LL, &v79, 2LL, 8LL, 0LL);
      *((_QWORD *)&v79 + 1) = v99;
      *(_QWORD *)&v80 = 0LL;
      LODWORD(v79) = 50397184;
      v70 = 0LL;
      v71 = 0LL;
      v72 = 0LL;
      v22 = strlen((const char *)&s);
      if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
        std::__basic_string_common<true>::__throw_length_error();
      v23 = v22;
      if ( v22 >= 0x17 )
      {
        v25 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v24 = (char *)operator new(v25);
        v71 = (_QWORD *)v23;
        v72 = v24;
        v70 = v25 | 1;
      }
      else
      {
        v24 = (char *)&v70 + 1;
        LOBYTE(v70) = 2 * v22;
        if ( !v22 )
          goto LABEL_9;
      }
      memcpy(v24, &s, v23);
LABEL_9:
      v26 = (char *)v73;
      v24[v23] = 0;
      v27 = (float *)&v26[v16];
      v28 = lrintf(*(float *)&v26[v16]);
      v29 = v27[1];
      LODWORD(v27) = v28;
      v30 = lrintf(v29);
      v59[0] = (_DWORD)v27;
      v59[1] = v30;
      v76 = xmmword_547C0;
      v77 = 0LL;
      v78 = 0LL;
      cv::putText(&v79, &v70, v59, 1LL, &v76, 1LL, 8LL, 0LL, 1.0);
      if ( (v70 & 1) != 0 )
        operator delete(v72);
      v16 += 8LL;
    }
  }
  *((_QWORD *)&s + 1) = 0LL;
  LODWORD(v79) = 16842752;
  LOBYTE(s) = 14;
  v90 = 0LL;
  *(_QWORD *)&v80 = 0LL;
  strcpy((char *)&s + 1, "vis_img");
  *((_QWORD *)&v79 + 1) = v99;
  cv::imshow(&s, &v79);
  if ( (s & 1) != 0 )
    operator delete(v90);
  cv::waitKey((cv *)((unsigned int)&dword_0 + 1), v31);
  if ( v81[7] )
  {
    v33 = (unsigned int *)(v81[7] + 20LL);
    do
    {
      v34 = __ldaxr(v33);
      v35 = v34 - 1;
    }
    while ( __stlxr(v35, v33) );
    if ( !v35 )
      cv::Mat::deallocate((cv::Mat *)v81);
  }
  v81[7] = 0LL;
  memset(&v81[2], 0, 32);
  if ( SHIDWORD(v81[0]) >= 1 )
  {
    v36 = v82;
    v37 = 0LL;
    do
      *((_DWORD *)v36 + v37++) = 0;
    while ( v37 < SHIDWORD(v81[0]) );
  }
  if ( v83 != (cv *)v84 )
    cv::fastFree(v83, v32);
  if ( v73 )
  {
    v74 = v73;
    operator delete(v73);
  }
  if ( v85[7] )
  {
    v38 = (unsigned int *)(v85[7] + 20LL);
    do
    {
      v39 = __ldaxr(v38);
      v40 = v39 - 1;
    }
    while ( __stlxr(v40, v38) );
    if ( !v40 )
      cv::Mat::deallocate((cv::Mat *)v85);
  }
  v85[7] = 0LL;
  memset(&v85[2], 0, 32);
  if ( SHIDWORD(v85[0]) >= 1 )
  {
    v41 = v86;
    v42 = 0LL;
    do
      *((_DWORD *)v41 + v42++) = 0;
    while ( v42 < SHIDWORD(v85[0]) );
  }
  if ( v87 != (cv *)v88 )
    cv::fastFree(v87, v32);
  if ( v91[7] )
  {
    v43 = (unsigned int *)(v91[7] + 20LL);
    do
    {
      v44 = __ldaxr(v43);
      v45 = v44 - 1;
    }
    while ( __stlxr(v45, v43) );
    if ( !v45 )
      cv::Mat::deallocate((cv::Mat *)v91);
  }
  v91[7] = 0LL;
  memset(&v91[2], 0, 32);
  if ( SHIDWORD(v91[0]) >= 1 )
  {
    v46 = v92;
    v47 = 0LL;
    do
      *((_DWORD *)v46 + v47++) = 0;
    while ( v47 < SHIDWORD(v91[0]) );
  }
  if ( v93 != (cv *)v94 )
    cv::fastFree(v93, v32);
  if ( v95[7] )
  {
    v48 = (unsigned int *)(v95[7] + 20LL);
    do
    {
      v49 = __ldaxr(v48);
      v50 = v49 - 1;
    }
    while ( __stlxr(v50, v48) );
    if ( !v50 )
      cv::Mat::deallocate((cv::Mat *)v95);
  }
  v95[7] = 0LL;
  memset(&v95[2], 0, 32);
  if ( SHIDWORD(v95[0]) >= 1 )
  {
    v51 = v96;
    v52 = 0LL;
    do
      *((_DWORD *)v51 + v52++) = 0;
    while ( v52 < SHIDWORD(v95[0]) );
  }
  if ( v97 != (cv *)v98 )
    cv::fastFree(v97, v32);
  if ( v99[7] )
  {
    v53 = (unsigned int *)(v99[7] + 20LL);
    do
    {
      v54 = __ldaxr(v53);
      v55 = v54 - 1;
    }
    while ( __stlxr(v55, v53) );
    if ( !v55 )
      cv::Mat::deallocate((cv::Mat *)v99);
  }
  v99[7] = 0LL;
  memset(&v99[2], 0, 32);
  if ( SHIDWORD(v99[0]) >= 1 )
  {
    v56 = v100;
    v57 = 0LL;
    do
      *((_DWORD *)v56 + v57++) = 0;
    while ( v57 < SHIDWORD(v99[0]) );
  }
  if ( v101 != (cv *)v102 )
    cv::fastFree(v101, v32);
  return 0LL;
}
// 3AD74: variable 'v8' is possibly undefined
// 3ADD4: variable 'v9' is possibly undefined
// 3ADE8: variable 'v10' is possibly undefined
// 3AE44: variable 'v11' is possibly undefined
// 3AE60: variable 'v12' is possibly undefined
// 3AEC0: variable 'v13' is possibly undefined
// 3AF2C: variable 'v14' is possibly undefined
// 3B160: variable 'v31' is possibly undefined
// 3B1DC: variable 'v32' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 12C00: using guessed type __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD);
// 12D60: using guessed type __int64 __fastcall cv::projectPoints(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 130C0: using guessed type __int64 __fastcall cv::circle(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 13180: using guessed type __int64 __fastcall cv::imshow(_QWORD, _QWORD);
// 133B0: using guessed type __int64 __fastcall cv::putText(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 547C0: using guessed type __int128 xmmword_547C0;
// 547D0: using guessed type __int128 xmmword_547D0;

//----- (000000000003B98C) ----------------------------------------------------
__int64 __fastcall feasibal_region::get_neighbourhood_plane_idx(__int64 a1, int a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x10
  __int64 v5; // x11
  _QWORD *v6; // x12
  __int64 v7; // x9
  unsigned int v8; // w17
  unsigned __int64 v9; // x16
  int v10; // w15
  unsigned int v11; // w4
  unsigned __int64 v12; // x17
  signed __int64 v13; // x6
  unsigned __int64 v14; // x7
  __int64 result; // x0
  bool v16; // cc

  v3 = *(int *)(a1 + 8);
  v4 = *(int *)(a1 + 12);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 72);
  v7 = 0LL;
  v8 = 0;
  while ( 1 )
  {
    LODWORD(v9) = a2 - v8;
    v10 = v8 + a2;
    if ( a2 - v8 < v8 + a2 )
      break;
LABEL_11:
    v16 = (unsigned int)v7++ > 9;
    v8 = (unsigned int)v7 >> 1;
    if ( v16 )
      return 0xFFFFFFFFLL;
  }
  v11 = v8 + a3;
  v9 = (int)v9;
  v12 = (int)(a3 - v8);
  while ( (unsigned int)v12 >= v11 )
  {
LABEL_10:
    if ( ++v9 >= v10 )
      goto LABEL_11;
  }
  v13 = (a3 << 32) - ((v7 << 31) & 0xFFFFFFFF00000000LL);
  v14 = v12;
  while ( 1 )
  {
    if ( v9 < v3 && v14 < v4 )
    {
      result = *(unsigned __int8 *)(v5 + *v6 * (int)v9 + (v13 >> 32));
      if ( *(_BYTE *)(v5 + *v6 * (int)v9 + (v13 >> 32)) )
        return result;
    }
    ++v14;
    v13 += 0x100000000LL;
    if ( v14 >= (int)v11 )
      goto LABEL_10;
  }
}

//----- (000000000003BA50) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::processSlopeBasePlane(
        __int64 a1,
        __int64 a2,
        float *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        __int64 *a7)
{
  float v10; // s8
  float v11; // s9
  float v12; // s13
  __int64 v13; // x26
  unsigned __int64 v17; // x25
  char *v18; // x0
  char *v19; // x27
  __int64 v20; // x8
  unsigned __int64 v21; // x28
  float v22; // s9
  float v23; // s14
  int *v24; // x8
  __int64 v25; // x11
  __int64 v26; // x12
  __int64 v27; // x13
  __int64 v28; // x14
  int v29; // w6
  __int64 v30; // x9
  float v31; // w8
  float v32; // w10
  float v33; // w9
  __int64 v34; // x15
  signed int v35; // w4
  unsigned __int64 v36; // x2
  unsigned __int64 v37; // x5
  __int64 v38; // x7
  signed __int64 v39; // x26
  unsigned __int64 v40; // x30
  bool v41; // cf
  float v42; // s15
  unsigned __int64 v43; // x26
  float v44; // s13
  float v45; // s0
  char *v46; // x9
  _QWORD *v47; // x9
  _DWORD *v48; // x10
  _DWORD *v49; // t1
  float *v50; // x9
  float v51; // s0
  char *v52; // x0
  unsigned __int64 v53; // x25
  int *v54; // x8
  int v55; // w9
  unsigned int v56; // w10
  _QWORD *v57; // x8
  float v58; // s0
  __int64 *v59; // x10
  __int64 v60; // x9
  __int64 v61; // x10
  unsigned __int64 v62; // x28
  unsigned __int64 v63; // x9
  _QWORD *v64; // x8
  unsigned __int64 v65; // x28
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // x28
  int *v68; // x9
  __int64 v69; // x9
  unsigned __int64 v70; // d0
  float *v71; // x9
  char *v72; // x19
  char *v73; // x8
  char *v74; // x20
  void *v75; // x0
  void *v76; // t1
  void *v77; // x0
  void *v79; // [xsp+20h] [xbp-E0h] BYREF
  char *v80; // [xsp+28h] [xbp-D8h]
  void *v81; // [xsp+38h] [xbp-C8h]
  char *v82; // [xsp+40h] [xbp-C0h]
  char *v83; // [xsp+48h] [xbp-B8h]
  unsigned __int64 v84; // [xsp+50h] [xbp-B0h] BYREF
  float v85; // [xsp+58h] [xbp-A8h]
  __int64 v86; // [xsp+60h] [xbp-A0h]

  v86 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *(float *)(a1 + 144);
  v11 = *(float *)(a1 + 56);
  v12 = *(float *)(a1 + 36);
  v13 = *(_QWORD *)(a1 + 1856) - *(_QWORD *)(a1 + 1848);
  v17 = (v13 >> 4) - 1;
  v81 = 0LL;
  v82 = 0LL;
  v83 = 0LL;
  if ( v13 >> 4 != 1 )
  {
    if ( v17 >> 61 )
      std::__vector_base_common<true>::__throw_length_error();
    v18 = (char *)operator new(8 * v17);
    v19 = &v18[8 * v17];
    v81 = v18;
    v83 = v19;
    memset(v18, 0, (v13 >> 1) - 8);
    v82 = v19;
  }
  std::vector<std::vector<int>>::vector(&v79, (v13 >> 4) - 1);
  v20 = *a7;
  if ( a7[1] != *a7 )
  {
    v21 = 0LL;
    v22 = v10 * v11;
    v23 = fminf(v12, 10.0) * 3.14159265 / 180.0;
    while ( 1 )
    {
      v24 = (int *)(v20 + 8 * v21);
      v25 = *(_QWORD *)(a1 + 2008);
      v26 = *v24;
      v27 = v24[1];
      v28 = **(_QWORD **)(a1 + 2064);
      LOBYTE(v29) = *(_BYTE *)(v25 + v28 * v26 + v27);
      v30 = *(_QWORD *)(a1 + 2104) + **(_QWORD **)(a1 + 2160) * v26 + 16 * v27;
      v31 = *(float *)v30;
      v32 = *(float *)(v30 + 4);
      v33 = *(float *)(v30 + 8);
      if ( !(_BYTE)v29 )
      {
        v34 = 0LL;
        v35 = 0;
        while ( 1 )
        {
          LODWORD(v36) = v26 - v35;
          if ( (int)v26 - v35 < (unsigned int)(v35 + v26) )
            break;
LABEL_17:
          v41 = (unsigned int)v34++ >= 0xA;
          v35 = (unsigned int)v34 >> 1;
          if ( v41 )
            goto LABEL_21;
        }
        v36 = (int)v36;
        v37 = v35 + (int)v27;
        while ( (int)v27 - v35 >= (unsigned int)v37 )
        {
LABEL_16:
          if ( ++v36 >= v35 + (int)v26 )
            goto LABEL_17;
        }
        v38 = v25 + (int)v36 * v28;
        v39 = (v27 << 32) - ((v34 << 31) & 0xFFFFFFFF00000000LL);
        v40 = v27 - v35;
        while ( 1 )
        {
          if ( v36 < *(int *)(a1 + 2000) && v40 < *(int *)(a1 + 2004) )
          {
            v29 = *(unsigned __int8 *)(v38 + (v39 >> 32));
            if ( *(_BYTE *)(v38 + (v39 >> 32)) )
              break;
          }
          ++v40;
          v39 += 0x100000000LL;
          if ( v40 >= v37 )
            goto LABEL_16;
        }
        if ( v29 != 1 )
          goto LABEL_23;
LABEL_21:
        if ( (*(_QWORD *)(*a6 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) & (1LL << v21)) == 0 )
          goto LABEL_43;
LABEL_42:
        std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
          (char **)(a1 + 2416),
          *(_DWORD **)(a1 + 2424),
          *(_QWORD *)(*a5 + 24 * v21),
          *(char **)(*a5 + 24 * v21 + 8));
        goto LABEL_43;
      }
LABEL_23:
      v42 = v32;
      v43 = (unsigned __int8)(v29 - 2);
      v44 = fabsf((float)((float)(*a3 * v31) + (float)(a3[1] * v32)) + (float)((float)(a3[2] * v33) + a3[3]));
      v45 = 15.0;
      if ( v43 < (__int64)(a4[1] - *a4) >> 2 )
      {
        v45 = *(float *)(*a4 + 4 * v43);
        if ( v45 < 0.087266 )
        {
          LODWORD(v84) = v21;
          v46 = (char *)v79 + 24 * v43;
          v49 = (_DWORD *)*((_QWORD *)v46 + 1);
          v47 = v46 + 8;
          v48 = v49;
          if ( (unsigned __int64)v49 >= v47[1] )
          {
            std::vector<int>::__push_back_slow_path<int>((__int64)v79 + 24 * v43, &v84);
          }
          else
          {
            *v48 = v21;
            *v47 = v48 + 1;
          }
          v51 = fabsf(v42) * 0.5 / *(float *)(a1 + 28) + 1.0;
          if ( v44 <= (float)(unsigned int)(float)(v10 * v51) )
            ++*((_DWORD *)v81 + 2 * v43 + 1);
          else
            ++*((_DWORD *)v81 + 2 * v43);
          goto LABEL_43;
        }
      }
      if ( v45 < v23 )
        break;
      if ( v45 < 10.0 )
      {
        if ( (*(_QWORD *)(*a6 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) & (1LL << v21)) != 0 )
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
            (char **)(a1 + 2440),
            *(_DWORD **)(a1 + 2448),
            *(_QWORD *)(*a5 + 24 * v21),
            *(char **)(*a5 + 24 * v21 + 8));
        goto LABEL_43;
      }
      if ( v44 < v22 )
      {
        v84 = __PAIR64__(LODWORD(v32), LODWORD(v31));
        v85 = v33;
        v50 = *(float **)(a1 + 2400);
        if ( v50 == *(float **)(a1 + 2408) )
        {
LABEL_35:
          std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
            a1 + 2392,
            (__int64)&v84);
          goto LABEL_43;
        }
        goto LABEL_29;
      }
      if ( (*(_QWORD *)(*a6 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) & (1LL << v21)) != 0 )
        goto LABEL_42;
LABEL_43:
      v20 = *a7;
      if ( ++v21 >= (a7[1] - *a7) >> 3 )
        goto LABEL_44;
    }
    v84 = __PAIR64__(LODWORD(v32), LODWORD(v31));
    v85 = v33;
    v50 = *(float **)(a1 + 2400);
    if ( v50 == *(float **)(a1 + 2408) )
      goto LABEL_35;
LABEL_29:
    *v50 = v31;
    v50[1] = *((float *)&v84 + 1);
    v50[2] = v85;
    *(_QWORD *)(a1 + 2400) = v50 + 3;
    goto LABEL_43;
  }
LABEL_44:
  v52 = (char *)v81;
  if ( v82 != v81 )
  {
    v53 = 0LL;
    do
    {
      v54 = (int *)&v52[8 * v53];
      v55 = *v54;
      v56 = v54[1] + *v54;
      if ( v56 >= 2 )
      {
        if ( v56 <= 0xA )
        {
          v64 = v79;
          if ( *((_QWORD *)v79 + 3 * v53 + 1) != *((_QWORD *)v79 + 3 * v53) )
          {
            v65 = 0LL;
            do
            {
              v66 = *(unsigned int *)(v64[3 * v53] + 4 * v65);
              if ( ((1LL << v66) & *(_QWORD *)(*a6 + ((v66 >> 3) & 0x1FFFFFF8))) != 0 )
              {
                std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
                  (char **)(a1 + 2464),
                  *(_DWORD **)(a1 + 2472),
                  *(_QWORD *)(*a5 + 24 * v66),
                  *(char **)(*a5 + 24 * v66 + 8));
                v64 = v79;
              }
              ++v65;
            }
            while ( v65 < (__int64)(v64[3 * v53 + 1] - v64[3 * v53]) >> 2 );
          }
        }
        else
        {
          v57 = v79;
          v58 = (float)v55 / (float)v56;
          v59 = (__int64 *)((char *)v79 + 24 * v53);
          v60 = *v59;
          v61 = v59[1];
          if ( v58 <= 0.7 )
          {
            if ( v61 != v60 )
            {
              v67 = 0LL;
              do
              {
                v68 = (int *)(*a7 + 8LL * *(unsigned int *)(v57[3 * v53] + 4 * v67));
                v69 = *(_QWORD *)(a1 + 2104) + **(_QWORD **)(a1 + 2160) * *v68 + 16LL * v68[1];
                v70 = *(_QWORD *)v69;
                LODWORD(v69) = *(_DWORD *)(v69 + 8);
                v84 = v70;
                v85 = *(float *)&v69;
                v71 = *(float **)(a1 + 2400);
                if ( v71 == *(float **)(a1 + 2408) )
                {
                  std::vector<Eigen::Matrix<float,3,1,0,3,1>>::__push_back_slow_path<Eigen::Matrix<float,3,1,0,3,1> const&>(
                    a1 + 2392,
                    (__int64)&v84);
                  v57 = v79;
                }
                else
                {
                  *(_DWORD *)v71 = v70;
                  v71[1] = *((float *)&v84 + 1);
                  v71[2] = v85;
                  *(_QWORD *)(a1 + 2400) = v71 + 3;
                }
                ++v67;
              }
              while ( v67 < (__int64)(v57[3 * v53 + 1] - v57[3 * v53]) >> 2 );
            }
          }
          else if ( v61 != v60 )
          {
            v62 = 0LL;
            do
            {
              v63 = *(unsigned int *)(v57[3 * v53] + 4 * v62);
              if ( ((1LL << v63) & *(_QWORD *)(*a6 + ((v63 >> 3) & 0x1FFFFFF8))) != 0 )
              {
                std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
                  (char **)(a1 + 2464),
                  *(_DWORD **)(a1 + 2472),
                  *(_QWORD *)(*a5 + 24 * v63),
                  *(char **)(*a5 + 24 * v63 + 8));
                v57 = v79;
              }
              ++v62;
            }
            while ( v62 < (__int64)(v57[3 * v53 + 1] - v57[3 * v53]) >> 2 );
          }
        }
      }
      v52 = (char *)v81;
      ++v53;
    }
    while ( v53 < (v82 - (_BYTE *)v81) >> 3 );
  }
  v72 = (char *)v79;
  if ( v79 )
  {
    v73 = v80;
    if ( v80 == v79 )
    {
      v77 = v79;
    }
    else
    {
      v74 = v80;
      do
      {
        v76 = (void *)*((_QWORD *)v74 - 3);
        v74 -= 24;
        v75 = v76;
        if ( v76 )
        {
          *((_QWORD *)v73 - 2) = v75;
          operator delete(v75);
        }
        v73 = v74;
      }
      while ( v72 != v74 );
      v77 = v79;
    }
    v80 = v72;
    operator delete(v77);
    v52 = (char *)v81;
  }
  if ( v52 )
  {
    v82 = v52;
    operator delete(v52);
  }
  return 0LL;
}

//----- (000000000003C22C) ----------------------------------------------------
_QWORD *__fastcall std::vector<std::vector<int>>::vector(_QWORD *result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x20
  _QWORD *v3; // x19
  _QWORD *v4; // x8

  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  if ( a2 )
  {
    v2 = a2;
    v3 = result;
    if ( a2 >= 0xAAAAAAAAAAAAAABLL )
      std::__vector_base_common<true>::__throw_length_error();
    result = (_QWORD *)operator new(24 * a2);
    v4 = result;
    *v3 = result;
    v3[1] = result;
    v3[2] = &result[3 * v2];
    do
    {
      v4[1] = 0LL;
      v4[2] = 0LL;
      *v4 = 0LL;
      --v2;
      v4 = (_QWORD *)(v3[1] + 24LL);
      v3[1] = v4;
    }
    while ( v2 );
  }
  return result;
}

//----- (000000000003C30C) ----------------------------------------------------
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1> const*>>(
        char **a1,
        _DWORD *a2,
        unsigned __int64 a3,
        char *a4)
{
  __int64 v4; // x25
  _DWORD *v5; // x19
  char *v6; // x8
  unsigned __int64 v7; // x26
  char *v8; // x20
  __int64 v9; // x28
  signed __int64 v10; // x10
  char *v12; // x22
  unsigned __int64 v14; // x1
  __int64 v15; // x27
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  unsigned __int64 v20; // x24
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x11
  unsigned __int64 v23; // x10
  __int64 v24; // x13
  __int128 *v25; // x12
  char *v26; // x13
  __int64 v27; // x14
  __int128 v28; // q0
  __int128 v29; // q1
  __int128 v30; // q2
  __int128 v31; // q3
  __int128 v32; // q4
  __int128 v33; // q5
  int v34; // w10
  char *v35; // x10
  __int64 v36; // x10
  char *v37; // x11
  int v38; // w12
  char *v39; // x13
  unsigned __int64 v40; // x12
  char *v41; // x11
  __int64 v42; // x12
  signed __int64 v43; // x11
  unsigned __int64 v44; // x8
  unsigned __int64 v45; // x14
  unsigned __int64 v46; // x13
  char *v47; // x11
  char *v48; // x13
  int v49; // w14
  __int64 v50; // x10
  char *v51; // x12
  bool v52; // cf
  __int64 v53; // x10
  __int64 v54; // x13
  __int64 v55; // x15
  int v56; // w14
  __int64 v57; // x9
  char *v58; // x10
  _DWORD *v59; // x11
  int v60; // w13
  int v61; // w13
  int v62; // w13
  unsigned __int64 v63; // x11
  unsigned __int64 v64; // x9
  _DWORD *v65; // x10
  __int64 v66; // x13
  __int128 *v67; // x12
  char *v68; // x13
  __int64 v69; // x14
  __int128 v70; // q0
  __int128 v71; // q1
  __int128 v72; // q2
  __int128 v73; // q3
  __int128 v74; // q4
  __int128 v75; // q5
  int v76; // w9
  unsigned __int64 v77; // x11
  __int64 v78; // x14
  char *v79; // x14
  __int64 v80; // x15
  __int128 v81; // q1
  __int128 v82; // q2
  __int128 v83; // q3
  __int128 v84; // q4
  __int128 v85; // q5
  int v86; // w8
  __int64 v88; // x13
  __int128 *v89; // x16
  __int64 v90; // x17
  char *v91; // x0
  __int128 v92; // q1
  __int128 v93; // q2
  __int128 v94; // q3
  __int128 v95; // q4
  __int128 v96; // q5

  v4 = (__int64)&a4[-a3];
  v5 = a2;
  if ( (__int64)&a4[-a3] < 1 )
    return v5;
  v7 = (unsigned __int64)a1[1];
  v6 = a1[2];
  v8 = *a1;
  v9 = (char *)a2 - *a1;
  v10 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 2);
  v12 = (char *)a3;
  v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 2);
  if ( v10 <= (__int64)(0xAAAAAAAAAAAAAAABLL * ((__int64)&v6[-v7] >> 2)) )
  {
    v42 = v7 - (_QWORD)v5;
    v43 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 - (_QWORD)v5) >> 2);
    if ( v10 <= v43 )
    {
      v47 = a1[1];
      v44 = (unsigned __int64)a4;
      goto LABEL_35;
    }
    v44 = a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2);
    if ( (char *)v44 == a4 )
    {
      v47 = a1[1];
      if ( v42 < 1 )
        return v5;
      goto LABEL_35;
    }
    v45 = (unsigned __int64)&a4[12 * ~v43 - a3] / 0xC + 1;
    if ( v45 >= 8
      && ((v46 = (unsigned __int64)&a4[12 * ~v43 - a3] / 0xC, v7 >= a3 + 12 * (v43 + v46) + 12)
       || v44 >= v7 + 12 * v46 + 12) )
    {
      v88 = 12 * (v45 & 0x3FFFFFFFFFFFFFF8LL);
      v47 = (char *)(v7 + v88);
      v48 = (char *)(v44 + v88);
      v89 = (__int128 *)(a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2) + 48);
      v90 = v45 & 0x3FFFFFFFFFFFFFF8LL;
      v91 = a1[1];
      do
      {
        v92 = *(v89 - 2);
        v93 = *(v89 - 1);
        v94 = *v89;
        v95 = v89[1];
        v96 = v89[2];
        v90 -= 8LL;
        *(_OWORD *)v91 = *(v89 - 3);
        *((_OWORD *)v91 + 1) = v92;
        *((_OWORD *)v91 + 2) = v93;
        *((_OWORD *)v91 + 3) = v94;
        *((_OWORD *)v91 + 4) = v95;
        *((_OWORD *)v91 + 5) = v96;
        v91 += 96;
        v89 += 6;
      }
      while ( v90 );
      if ( v45 == (v45 & 0x3FFFFFFFFFFFFFF8LL) )
      {
LABEL_32:
        a1[1] = v47;
        if ( v42 < 1 )
          return v5;
LABEL_35:
        v50 = 4 * (v4 >> 2);
        v51 = &v47[-v50];
        v52 = (unsigned __int64)&v47[-v50] >= v7;
        v53 = v47 - (char *)&v5[(unsigned __int64)v50 / 4];
        if ( !v52 )
        {
          v54 = (__int64)v47;
          do
          {
            v55 = *(_QWORD *)v51;
            *(_DWORD *)(v54 + 8) = *((_DWORD *)v51 + 2);
            *(_QWORD *)v54 = v55;
            *(_DWORD *)v54 = *(_DWORD *)v51;
            *(_DWORD *)(v54 + 4) = *((_DWORD *)v51 + 1);
            v56 = *((_DWORD *)v51 + 2);
            v51 += 12;
            *(_DWORD *)(v54 + 8) = v56;
            v54 = (__int64)(a1[1] + 12);
            a1[1] = (char *)v54;
          }
          while ( (unsigned __int64)v51 < v7 );
        }
        if ( v53 )
        {
          v57 = v53 >> 2;
          v58 = v47 - 4;
          do
          {
            v59 = &v5[v57];
            v60 = v5[v57 - 3];
            v57 -= 3LL;
            *(v59 - 3) = *((_DWORD *)v58 - 2);
            *((_DWORD *)v58 - 2) = v60;
            v61 = *(v59 - 2);
            *(v59 - 2) = *((_DWORD *)v58 - 1);
            *((_DWORD *)v58 - 1) = v61;
            v62 = *(v59 - 1);
            *(v59 - 1) = *(_DWORD *)v58;
            *(_DWORD *)v58 = v62;
            v58 -= 12;
          }
          while ( v57 * 4 );
        }
        if ( v44 != a3 )
        {
          v63 = (v44 - a3 - 12) / 0xC;
          v64 = v63 + 1;
          v65 = v5;
          if ( v63 + 1 < 8 )
            goto LABEL_71;
          if ( (unsigned __int64)v5 < a3 + 12 * v63 + 12 )
          {
            v65 = v5;
            if ( a3 < (unsigned __int64)&v8[12 * v14 + 12 + 12 * v63] )
              goto LABEL_71;
          }
          v66 = 3 * (v64 & 0x3FFFFFFFFFFFFFF8LL);
          v67 = (__int128 *)a3;
          v65 = &v5[v66];
          v12 = (char *)(a3 + v66 * 4);
          v68 = &v8[4 * (v9 >> 2) + 48];
          v69 = v64 & 0x3FFFFFFFFFFFFFF8LL;
          do
          {
            v70 = *v67;
            v71 = v67[1];
            v72 = v67[2];
            v73 = v67[3];
            v74 = v67[4];
            v75 = v67[5];
            v67 += 6;
            v69 -= 8LL;
            *((_OWORD *)v68 - 2) = v71;
            *((_OWORD *)v68 - 1) = v72;
            *((_OWORD *)v68 - 3) = v70;
            *((_OWORD *)v68 + 1) = v74;
            *((_OWORD *)v68 + 2) = v75;
            *(_OWORD *)v68 = v73;
            v68 += 96;
          }
          while ( v69 );
          if ( v64 != (v64 & 0x3FFFFFFFFFFFFFF8LL) )
          {
LABEL_71:
            do
            {
              *v65 = *(_DWORD *)v12;
              v65[1] = *((_DWORD *)v12 + 1);
              v76 = *((_DWORD *)v12 + 2);
              v12 += 12;
              v65[2] = v76;
              v65 += 3;
            }
            while ( v12 != (char *)v44 );
          }
        }
        return v5;
      }
    }
    else
    {
      v47 = a1[1];
      v48 = (char *)(a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2));
    }
    do
    {
      *(_DWORD *)v47 = *(_DWORD *)v48;
      *((_DWORD *)v47 + 1) = *((_DWORD *)v48 + 1);
      v49 = *((_DWORD *)v48 + 2);
      v48 += 12;
      *((_DWORD *)v47 + 2) = v49;
      v47 += 12;
    }
    while ( v48 != a4 );
    goto LABEL_32;
  }
  v15 = 0x1555555555555555LL;
  v16 = v10 - 0x5555555555555555LL * ((__int64)(v7 - (_QWORD)v8) >> 2);
  if ( v16 > 0x1555555555555555LL )
    std::__vector_base_common<true>::__throw_length_error();
  v17 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v8) >> 2);
  if ( v17 > 0xAAAAAAAAAAAAAA9LL
    || ((v18 = 2 * v17, v18 >= v16)
      ? (v15 = v18)
      : (v15 = v10 - 0x5555555555555555LL * ((__int64)(v7 - (_QWORD)v8) >> 2)),
        v15) )
  {
    v19 = (char *)operator new(12 * v15);
    v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 2);
  }
  else
  {
    v19 = 0LL;
  }
  v20 = (unsigned __int64)&v19[12 * v14];
  v21 = v20;
  if ( v12 != a4 )
  {
    v22 = (v4 - 12) / 0xCuLL;
    v23 = v22 + 1;
    v21 = (unsigned __int64)&v19[12 * v14];
    if ( v22 + 1 < 8 )
      goto LABEL_72;
    if ( v20 < (unsigned __int64)&v12[12 * v22 + 12] )
    {
      v21 = (unsigned __int64)&v19[12 * v14];
      if ( v12 < &v19[12 * v14 + 12 + 12 * v22] )
        goto LABEL_72;
    }
    v24 = 12 * (v23 & 0x3FFFFFFFFFFFFFF8LL);
    v25 = (__int128 *)v12;
    v21 = v20 + v24;
    v12 += v24;
    v26 = &v19[12 * v14 + 48];
    v27 = v23 & 0x3FFFFFFFFFFFFFF8LL;
    do
    {
      v28 = *v25;
      v29 = v25[1];
      v30 = v25[2];
      v31 = v25[3];
      v32 = v25[4];
      v33 = v25[5];
      v25 += 6;
      v27 -= 8LL;
      *((_OWORD *)v26 - 2) = v29;
      *((_OWORD *)v26 - 1) = v30;
      *((_OWORD *)v26 - 3) = v28;
      *((_OWORD *)v26 + 1) = v32;
      *((_OWORD *)v26 + 2) = v33;
      *(_OWORD *)v26 = v31;
      v26 += 96;
    }
    while ( v27 );
    if ( v23 != (v23 & 0x3FFFFFFFFFFFFFF8LL) )
    {
LABEL_72:
      do
      {
        *(_DWORD *)v21 = *(_DWORD *)v12;
        *(_DWORD *)(v21 + 4) = *((_DWORD *)v12 + 1);
        v34 = *((_DWORD *)v12 + 2);
        v12 += 12;
        *(_DWORD *)(v21 + 8) = v34;
        v21 += 12LL;
      }
      while ( v12 != a4 );
    }
  }
  v35 = &v19[12 * v14];
  if ( v9 )
  {
    v36 = 12 * v14;
    do
    {
      v37 = &v8[v36];
      v38 = *(_DWORD *)&v8[v36 - 12];
      v39 = &v19[v36];
      v36 -= 12LL;
      *((_DWORD *)v39 - 3) = v38;
      *((_DWORD *)v39 - 2) = *((_DWORD *)v37 - 2);
      *((_DWORD *)v39 - 1) = *((_DWORD *)v37 - 1);
    }
    while ( v36 );
    v35 = v19;
  }
  if ( (_DWORD *)v7 == v5 )
  {
    v41 = (char *)v21;
    goto LABEL_61;
  }
  v40 = (v7 + 12 * ~v14 - (unsigned __int64)v8) / 0xC + 1;
  if ( v40 < 8 )
  {
    v41 = (char *)v21;
    goto LABEL_60;
  }
  v77 = (v7 + 12 * ~v14 - (unsigned __int64)v8) / 0xC;
  if ( v21 < (unsigned __int64)&v8[12 * v14 + 12 + 12 * v77] && (unsigned __int64)v5 < v21 + 12 * v77 + 12 )
  {
    v41 = (char *)v21;
    do
    {
LABEL_60:
      *(_DWORD *)v41 = *v5;
      *((_DWORD *)v41 + 1) = v5[1];
      v86 = v5[2];
      v5 += 3;
      *((_DWORD *)v41 + 2) = v86;
      v41 += 12;
    }
    while ( v5 != (_DWORD *)v7 );
    goto LABEL_61;
  }
  v78 = 12 * (v40 & 0x3FFFFFFFFFFFFFF8LL);
  v41 = (char *)(v21 + v78);
  v5 = (_DWORD *)((char *)v5 + v78);
  v79 = &v8[12 * v14 + 48];
  v80 = v40 & 0x3FFFFFFFFFFFFFF8LL;
  do
  {
    v81 = *((_OWORD *)v79 - 2);
    v82 = *((_OWORD *)v79 - 1);
    v83 = *(_OWORD *)v79;
    v84 = *((_OWORD *)v79 + 1);
    v85 = *((_OWORD *)v79 + 2);
    v80 -= 8LL;
    *(_OWORD *)v21 = *((_OWORD *)v79 - 3);
    *(_OWORD *)(v21 + 16) = v81;
    *(_OWORD *)(v21 + 32) = v82;
    *(_OWORD *)(v21 + 48) = v83;
    *(_OWORD *)(v21 + 64) = v84;
    *(_OWORD *)(v21 + 80) = v85;
    v21 += 96LL;
    v79 += 96;
  }
  while ( v80 );
  if ( v40 != (v40 & 0x3FFFFFFFFFFFFFF8LL) )
    goto LABEL_60;
LABEL_61:
  *a1 = v35;
  a1[1] = v41;
  a1[2] = &v19[12 * v15];
  if ( v8 )
    operator delete(v8);
  return (_DWORD *)v20;
}

//----- (000000000003C924) ----------------------------------------------------
void __usercall feasibal_region::ground_process::imageScore(
        const cv::Mat *a1@<X1>,
        const int *a2@<X2>,
        float32x4_t **a3@<X8>)
{
  __int64 v6; // x8
  __int64 v7; // x28
  float32x4_t *v8; // x0
  float32x4_t *v9; // x26
  float32x4_t *v10; // x19
  uint32x4_t *v11; // x0
  char *v12; // x27
  uint32x4_t *v13; // x20
  void *v14; // x21
  uint32x4_t *v15; // x23
  void *v16; // x8
  int v17; // w13
  unsigned __int64 v18; // x9
  int32x2_t v19; // d0
  int v20; // w11
  int v21; // w10
  int v22; // w12
  unsigned __int64 v23; // x14
  int v24; // w2
  __int64 v25; // x2
  unsigned __int64 v26; // x3
  __int64 v27; // x4
  unsigned __int64 v28; // x5
  int v29; // w12
  unsigned __int64 v30; // x9
  int v31; // w10
  unsigned __int64 v32; // x11
  unsigned __int64 v33; // x10
  float32x4_t v34; // q1
  uint32x4_t *v35; // x12
  float32x4_t *v36; // x13
  unsigned __int64 v37; // x14
  uint32x4_t v38; // q2
  uint32x4_t v39; // q3
  __int64 v40; // x11
  unsigned int v41; // s1

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *a2;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v7 = v6 + 1;
  if ( (_DWORD)v6 == -1 )
  {
    v12 = 0LL;
    v15 = 0LL;
    v9 = 0LL;
    v10 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    v16 = 0LL;
  }
  else
  {
    if ( (v7 & 0x80000000) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v8 = (float32x4_t *)operator new(4 * v7);
    v9 = (float32x4_t *)((char *)v8 + 4 * v7);
    v10 = v8;
    *a3 = v8;
    a3[2] = v9;
    memset(v8, 0, 4 * v7);
    a3[1] = v9;
    v11 = (uint32x4_t *)operator new(4 * v7);
    v12 = (char *)v11 + 4 * v7;
    v13 = v11;
    memset(v11, 0, 4 * v7);
    v14 = (void *)operator new(4 * v7);
    memset(v14, 0, 4 * v7);
    v15 = v13;
    v16 = v14;
  }
  v17 = *((_DWORD *)a1 + 3);
  v18 = *((int *)a1 + 2);
  v19.n64_f64[0] = (double)v17 * 0.25;
  v20 = (int)v19.n64_f64[0];
  v21 = (int)((double)v17 * 0.75);
  v22 = (int)((double)(int)v18 * 0.55);
  if ( (_DWORD)v18 )
  {
    v23 = 0LL;
    v24 = *((_DWORD *)a1 + 3);
    do
    {
      if ( v24 )
      {
        v25 = 0LL;
        v26 = 0LL;
        v27 = *((_QWORD *)a1 + 2) + **((_QWORD **)a1 + 9) * (int)v23;
        do
        {
          v28 = *(unsigned __int8 *)(v27 + (v25 >> 32));
          if ( *(_BYTE *)(v27 + (v25 >> 32))
            && v23 < v18
            && v23 > v22
            && v26 < v21
            && v26 > v20
            && (v12 - (char *)v15) >> 2 > v28 )
          {
            ++v15->n128_u32[v28];
          }
          ++v26;
          v25 += 0x100000000LL;
        }
        while ( v26 < v17 );
        v24 = v17;
      }
      ++v23;
    }
    while ( v23 < v18 );
  }
  if ( v9 != v10 )
  {
    v29 = v18 + 1 - v22;
    v30 = ((char *)v9 - (char *)v10) >> 2;
    v31 = (1 - v20 + v21) * v29;
    if ( v30 <= 1 )
      v32 = 1LL;
    else
      v32 = ((char *)v9 - (char *)v10) >> 2;
    v19.n64_f32[0] = (float)v31;
    if ( v32 <= 7 )
    {
      v33 = 0LL;
      do
      {
LABEL_28:
        v40 = v33;
        v41 = v15->n128_u32[v33++];
        v10->n128_f32[v40] = (float)v41 / v19.n64_f32[0];
      }
      while ( v30 > v33 );
      goto LABEL_29;
    }
    v33 = v32 & 0xFFFFFFFFFFFFFFF8LL;
    v34 = vdupq_lane_s32(v19, 0);
    v35 = v15 + 1;
    v36 = v10 + 1;
    v37 = v32 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v38 = v35[-1];
      v39 = *v35;
      v35 += 2;
      v37 -= 8LL;
      v36[-1] = vdivq_f32(vcvtq_f32_u32(v38), v34);
      *v36 = vdivq_f32(vcvtq_f32_u32(v39), v34);
      v36 += 2;
    }
    while ( v37 );
    if ( v32 != v33 )
      goto LABEL_28;
  }
LABEL_29:
  if ( v16 )
    operator delete(v14);
  if ( v15 )
    operator delete(v13);
}

//----- (000000000003CC98) ----------------------------------------------------
_DWORD *__fastcall std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
        char **a1,
        _DWORD *a2,
        unsigned __int64 a3,
        char *a4)
{
  __int64 v4; // x25
  _DWORD *v5; // x19
  char *v6; // x8
  unsigned __int64 v7; // x26
  char *v8; // x20
  __int64 v9; // x28
  signed __int64 v10; // x10
  char *v12; // x22
  unsigned __int64 v14; // x1
  __int64 v15; // x27
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  unsigned __int64 v20; // x24
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x11
  unsigned __int64 v23; // x10
  __int64 v24; // x13
  __int128 *v25; // x12
  char *v26; // x13
  __int64 v27; // x14
  __int128 v28; // q0
  __int128 v29; // q1
  __int128 v30; // q2
  __int128 v31; // q3
  __int128 v32; // q4
  __int128 v33; // q5
  int v34; // w10
  char *v35; // x10
  __int64 v36; // x10
  char *v37; // x11
  int v38; // w12
  char *v39; // x13
  unsigned __int64 v40; // x12
  char *v41; // x11
  __int64 v42; // x12
  signed __int64 v43; // x11
  unsigned __int64 v44; // x8
  unsigned __int64 v45; // x14
  unsigned __int64 v46; // x13
  char *v47; // x11
  char *v48; // x13
  int v49; // w14
  __int64 v50; // x10
  char *v51; // x12
  bool v52; // cf
  __int64 v53; // x10
  __int64 v54; // x13
  __int64 v55; // x15
  int v56; // w14
  __int64 v57; // x9
  char *v58; // x10
  _DWORD *v59; // x11
  int v60; // w13
  int v61; // w13
  int v62; // w13
  unsigned __int64 v63; // x11
  unsigned __int64 v64; // x9
  _DWORD *v65; // x10
  __int64 v66; // x13
  __int128 *v67; // x12
  char *v68; // x13
  __int64 v69; // x14
  __int128 v70; // q0
  __int128 v71; // q1
  __int128 v72; // q2
  __int128 v73; // q3
  __int128 v74; // q4
  __int128 v75; // q5
  int v76; // w9
  unsigned __int64 v77; // x11
  __int64 v78; // x14
  char *v79; // x14
  __int64 v80; // x15
  __int128 v81; // q1
  __int128 v82; // q2
  __int128 v83; // q3
  __int128 v84; // q4
  __int128 v85; // q5
  int v86; // w8
  __int64 v88; // x13
  __int128 *v89; // x16
  __int64 v90; // x17
  char *v91; // x0
  __int128 v92; // q1
  __int128 v93; // q2
  __int128 v94; // q3
  __int128 v95; // q4
  __int128 v96; // q5

  v4 = (__int64)&a4[-a3];
  v5 = a2;
  if ( (__int64)&a4[-a3] < 1 )
    return v5;
  v7 = (unsigned __int64)a1[1];
  v6 = a1[2];
  v8 = *a1;
  v9 = (char *)a2 - *a1;
  v10 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 2);
  v12 = (char *)a3;
  v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 2);
  if ( v10 <= (__int64)(0xAAAAAAAAAAAAAAABLL * ((__int64)&v6[-v7] >> 2)) )
  {
    v42 = v7 - (_QWORD)v5;
    v43 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 - (_QWORD)v5) >> 2);
    if ( v10 <= v43 )
    {
      v47 = a1[1];
      v44 = (unsigned __int64)a4;
      goto LABEL_35;
    }
    v44 = a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2);
    if ( (char *)v44 == a4 )
    {
      v47 = a1[1];
      if ( v42 < 1 )
        return v5;
      goto LABEL_35;
    }
    v45 = (unsigned __int64)&a4[12 * ~v43 - a3] / 0xC + 1;
    if ( v45 >= 8
      && ((v46 = (unsigned __int64)&a4[12 * ~v43 - a3] / 0xC, v7 >= a3 + 12 * (v43 + v46) + 12)
       || v44 >= v7 + 12 * v46 + 12) )
    {
      v88 = 12 * (v45 & 0x3FFFFFFFFFFFFFF8LL);
      v47 = (char *)(v7 + v88);
      v48 = (char *)(v44 + v88);
      v89 = (__int128 *)(a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2) + 48);
      v90 = v45 & 0x3FFFFFFFFFFFFFF8LL;
      v91 = a1[1];
      do
      {
        v92 = *(v89 - 2);
        v93 = *(v89 - 1);
        v94 = *v89;
        v95 = v89[1];
        v96 = v89[2];
        v90 -= 8LL;
        *(_OWORD *)v91 = *(v89 - 3);
        *((_OWORD *)v91 + 1) = v92;
        *((_OWORD *)v91 + 2) = v93;
        *((_OWORD *)v91 + 3) = v94;
        *((_OWORD *)v91 + 4) = v95;
        *((_OWORD *)v91 + 5) = v96;
        v91 += 96;
        v89 += 6;
      }
      while ( v90 );
      if ( v45 == (v45 & 0x3FFFFFFFFFFFFFF8LL) )
      {
LABEL_32:
        a1[1] = v47;
        if ( v42 < 1 )
          return v5;
LABEL_35:
        v50 = 4 * (v4 >> 2);
        v51 = &v47[-v50];
        v52 = (unsigned __int64)&v47[-v50] >= v7;
        v53 = v47 - (char *)&v5[(unsigned __int64)v50 / 4];
        if ( !v52 )
        {
          v54 = (__int64)v47;
          do
          {
            v55 = *(_QWORD *)v51;
            *(_DWORD *)(v54 + 8) = *((_DWORD *)v51 + 2);
            *(_QWORD *)v54 = v55;
            *(_DWORD *)v54 = *(_DWORD *)v51;
            *(_DWORD *)(v54 + 4) = *((_DWORD *)v51 + 1);
            v56 = *((_DWORD *)v51 + 2);
            v51 += 12;
            *(_DWORD *)(v54 + 8) = v56;
            v54 = (__int64)(a1[1] + 12);
            a1[1] = (char *)v54;
          }
          while ( (unsigned __int64)v51 < v7 );
        }
        if ( v53 )
        {
          v57 = v53 >> 2;
          v58 = v47 - 4;
          do
          {
            v59 = &v5[v57];
            v60 = v5[v57 - 3];
            v57 -= 3LL;
            *(v59 - 3) = *((_DWORD *)v58 - 2);
            *((_DWORD *)v58 - 2) = v60;
            v61 = *(v59 - 2);
            *(v59 - 2) = *((_DWORD *)v58 - 1);
            *((_DWORD *)v58 - 1) = v61;
            v62 = *(v59 - 1);
            *(v59 - 1) = *(_DWORD *)v58;
            *(_DWORD *)v58 = v62;
            v58 -= 12;
          }
          while ( v57 * 4 );
        }
        if ( v44 != a3 )
        {
          v63 = (v44 - a3 - 12) / 0xC;
          v64 = v63 + 1;
          v65 = v5;
          if ( v63 + 1 < 8 )
            goto LABEL_71;
          if ( (unsigned __int64)v5 < a3 + 12 * v63 + 12 )
          {
            v65 = v5;
            if ( a3 < (unsigned __int64)&v8[12 * v14 + 12 + 12 * v63] )
              goto LABEL_71;
          }
          v66 = 3 * (v64 & 0x3FFFFFFFFFFFFFF8LL);
          v67 = (__int128 *)a3;
          v65 = &v5[v66];
          v12 = (char *)(a3 + v66 * 4);
          v68 = &v8[4 * (v9 >> 2) + 48];
          v69 = v64 & 0x3FFFFFFFFFFFFFF8LL;
          do
          {
            v70 = *v67;
            v71 = v67[1];
            v72 = v67[2];
            v73 = v67[3];
            v74 = v67[4];
            v75 = v67[5];
            v67 += 6;
            v69 -= 8LL;
            *((_OWORD *)v68 - 2) = v71;
            *((_OWORD *)v68 - 1) = v72;
            *((_OWORD *)v68 - 3) = v70;
            *((_OWORD *)v68 + 1) = v74;
            *((_OWORD *)v68 + 2) = v75;
            *(_OWORD *)v68 = v73;
            v68 += 96;
          }
          while ( v69 );
          if ( v64 != (v64 & 0x3FFFFFFFFFFFFFF8LL) )
          {
LABEL_71:
            do
            {
              *v65 = *(_DWORD *)v12;
              v65[1] = *((_DWORD *)v12 + 1);
              v76 = *((_DWORD *)v12 + 2);
              v12 += 12;
              v65[2] = v76;
              v65 += 3;
            }
            while ( v12 != (char *)v44 );
          }
        }
        return v5;
      }
    }
    else
    {
      v47 = a1[1];
      v48 = (char *)(a3 + 4 * ((__int64)(v7 - (_QWORD)v5) >> 2));
    }
    do
    {
      *(_DWORD *)v47 = *(_DWORD *)v48;
      *((_DWORD *)v47 + 1) = *((_DWORD *)v48 + 1);
      v49 = *((_DWORD *)v48 + 2);
      v48 += 12;
      *((_DWORD *)v47 + 2) = v49;
      v47 += 12;
    }
    while ( v48 != a4 );
    goto LABEL_32;
  }
  v15 = 0x1555555555555555LL;
  v16 = v10 - 0x5555555555555555LL * ((__int64)(v7 - (_QWORD)v8) >> 2);
  if ( v16 > 0x1555555555555555LL )
    std::__vector_base_common<true>::__throw_length_error();
  v17 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v8) >> 2);
  if ( v17 > 0xAAAAAAAAAAAAAA9LL
    || ((v18 = 2 * v17, v18 >= v16)
      ? (v15 = v18)
      : (v15 = v10 - 0x5555555555555555LL * ((__int64)(v7 - (_QWORD)v8) >> 2)),
        v15) )
  {
    v19 = (char *)operator new(12 * v15);
    v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 2);
  }
  else
  {
    v19 = 0LL;
  }
  v20 = (unsigned __int64)&v19[12 * v14];
  v21 = v20;
  if ( v12 != a4 )
  {
    v22 = (v4 - 12) / 0xCuLL;
    v23 = v22 + 1;
    v21 = (unsigned __int64)&v19[12 * v14];
    if ( v22 + 1 < 8 )
      goto LABEL_72;
    if ( v20 < (unsigned __int64)&v12[12 * v22 + 12] )
    {
      v21 = (unsigned __int64)&v19[12 * v14];
      if ( v12 < &v19[12 * v14 + 12 + 12 * v22] )
        goto LABEL_72;
    }
    v24 = 12 * (v23 & 0x3FFFFFFFFFFFFFF8LL);
    v25 = (__int128 *)v12;
    v21 = v20 + v24;
    v12 += v24;
    v26 = &v19[12 * v14 + 48];
    v27 = v23 & 0x3FFFFFFFFFFFFFF8LL;
    do
    {
      v28 = *v25;
      v29 = v25[1];
      v30 = v25[2];
      v31 = v25[3];
      v32 = v25[4];
      v33 = v25[5];
      v25 += 6;
      v27 -= 8LL;
      *((_OWORD *)v26 - 2) = v29;
      *((_OWORD *)v26 - 1) = v30;
      *((_OWORD *)v26 - 3) = v28;
      *((_OWORD *)v26 + 1) = v32;
      *((_OWORD *)v26 + 2) = v33;
      *(_OWORD *)v26 = v31;
      v26 += 96;
    }
    while ( v27 );
    if ( v23 != (v23 & 0x3FFFFFFFFFFFFFF8LL) )
    {
LABEL_72:
      do
      {
        *(_DWORD *)v21 = *(_DWORD *)v12;
        *(_DWORD *)(v21 + 4) = *((_DWORD *)v12 + 1);
        v34 = *((_DWORD *)v12 + 2);
        v12 += 12;
        *(_DWORD *)(v21 + 8) = v34;
        v21 += 12LL;
      }
      while ( v12 != a4 );
    }
  }
  v35 = &v19[12 * v14];
  if ( v9 )
  {
    v36 = 12 * v14;
    do
    {
      v37 = &v8[v36];
      v38 = *(_DWORD *)&v8[v36 - 12];
      v39 = &v19[v36];
      v36 -= 12LL;
      *((_DWORD *)v39 - 3) = v38;
      *((_DWORD *)v39 - 2) = *((_DWORD *)v37 - 2);
      *((_DWORD *)v39 - 1) = *((_DWORD *)v37 - 1);
    }
    while ( v36 );
    v35 = v19;
  }
  if ( (_DWORD *)v7 == v5 )
  {
    v41 = (char *)v21;
    goto LABEL_61;
  }
  v40 = (v7 + 12 * ~v14 - (unsigned __int64)v8) / 0xC + 1;
  if ( v40 < 8 )
  {
    v41 = (char *)v21;
    goto LABEL_60;
  }
  v77 = (v7 + 12 * ~v14 - (unsigned __int64)v8) / 0xC;
  if ( v21 < (unsigned __int64)&v8[12 * v14 + 12 + 12 * v77] && (unsigned __int64)v5 < v21 + 12 * v77 + 12 )
  {
    v41 = (char *)v21;
    do
    {
LABEL_60:
      *(_DWORD *)v41 = *v5;
      *((_DWORD *)v41 + 1) = v5[1];
      v86 = v5[2];
      v5 += 3;
      *((_DWORD *)v41 + 2) = v86;
      v41 += 12;
    }
    while ( v5 != (_DWORD *)v7 );
    goto LABEL_61;
  }
  v78 = 12 * (v40 & 0x3FFFFFFFFFFFFFF8LL);
  v41 = (char *)(v21 + v78);
  v5 = (_DWORD *)((char *)v5 + v78);
  v79 = &v8[12 * v14 + 48];
  v80 = v40 & 0x3FFFFFFFFFFFFFF8LL;
  do
  {
    v81 = *((_OWORD *)v79 - 2);
    v82 = *((_OWORD *)v79 - 1);
    v83 = *(_OWORD *)v79;
    v84 = *((_OWORD *)v79 + 1);
    v85 = *((_OWORD *)v79 + 2);
    v80 -= 8LL;
    *(_OWORD *)v21 = *((_OWORD *)v79 - 3);
    *(_OWORD *)(v21 + 16) = v81;
    *(_OWORD *)(v21 + 32) = v82;
    *(_OWORD *)(v21 + 48) = v83;
    *(_OWORD *)(v21 + 64) = v84;
    *(_OWORD *)(v21 + 80) = v85;
    v21 += 96LL;
    v79 += 96;
  }
  while ( v80 );
  if ( v40 != (v40 & 0x3FFFFFFFFFFFFFF8LL) )
    goto LABEL_60;
LABEL_61:
  *a1 = v35;
  a1[1] = v41;
  a1[2] = &v19[12 * v15];
  if ( v8 )
    operator delete(v8);
  return (_DWORD *)v20;
}

//----- (000000000003D2B0) ----------------------------------------------------
_DWORD *__fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::insert(unsigned __int64 *a1, char *a2, _DWORD *a3)
{
  _DWORD *v4; // x19
  char *v6; // x9
  _BYTE *v7; // x23
  unsigned __int64 v8; // x8
  __int64 v9; // x24
  char *v10; // x11
  __int64 v11; // x10
  unsigned __int64 i; // x8
  int v13; // w12
  __int64 v14; // x10
  char *v15; // x9
  char *v16; // x11
  int v17; // w13
  int v18; // w13
  int v19; // w13
  int v20; // w13
  _DWORD *v21; // x8
  _DWORD *v22; // x10
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x26
  void *v25; // x0
  _BYTE *v26; // x0
  unsigned __int64 v27; // x21
  unsigned __int64 v28; // x9
  _DWORD *v29; // x9
  _DWORD *v30; // x10
  int v31; // t1
  unsigned __int64 v32; // x8
  unsigned __int64 v33; // x10
  unsigned __int64 v34; // x12
  unsigned __int64 v35; // x13
  unsigned __int64 v36; // x11
  _DWORD *v37; // x12
  _DWORD *v38; // x10
  unsigned __int64 v39; // x10
  bool v40; // cf
  __int64 v41; // x17
  _OWORD *v42; // x15
  __int128 *v43; // x16
  __int64 v44; // x17
  __int128 v45; // q0
  __int128 v46; // q1
  __int128 v47; // q3
  __int128 v48; // q4
  __int128 v49; // q5
  __int128 v50; // q6
  __int128 v51; // q7
  int v52; // w13
  __int64 v53; // x10
  void *v55; // [xsp+0h] [xbp-70h] BYREF
  unsigned __int64 v56; // [xsp+8h] [xbp-68h]
  unsigned __int64 v57; // [xsp+10h] [xbp-60h]
  __int64 v58; // [xsp+18h] [xbp-58h]
  _QWORD *v59; // [xsp+20h] [xbp-50h]
  __int64 v60; // [xsp+28h] [xbp-48h]

  v4 = a2;
  v60 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = (_BYTE *)*a1;
  v6 = (char *)a1[1];
  v8 = a1[2];
  v9 = (__int64)&a2[-*a1] >> 4;
  if ( (unsigned __int64)v6 < v8 )
  {
    if ( a2 == v6 )
    {
      v38 = &v7[16 * v9];
      *(_DWORD *)a2 = *a3;
      v38[1] = a3[1];
      v38[2] = a3[2];
      v38[3] = a3[3];
      a1[1] = (unsigned __int64)(a2 + 16);
    }
    else
    {
      v10 = v6 - 16;
      v11 = v6 - (a2 + 16);
      for ( i = a1[1]; v10 < v6; a1[1] = i )
      {
        *(_OWORD *)i = *(_OWORD *)v10;
        *(_DWORD *)i = *(_DWORD *)v10;
        *(_DWORD *)(i + 4) = *((_DWORD *)v10 + 1);
        *(_DWORD *)(i + 8) = *((_DWORD *)v10 + 2);
        v13 = *((_DWORD *)v10 + 3);
        v10 += 16;
        *(_DWORD *)(i + 12) = v13;
        i = a1[1] + 16;
      }
      if ( v11 )
      {
        v14 = 16 * (v11 >> 4);
        v15 = v6 - 8;
        do
        {
          v16 = &a2[v14];
          v17 = *(_DWORD *)&a2[v14 - 16];
          v14 -= 16LL;
          *((_DWORD *)v16 - 4) = *((_DWORD *)v15 - 2);
          *((_DWORD *)v15 - 2) = v17;
          v18 = *((_DWORD *)v16 - 3);
          *((_DWORD *)v16 - 3) = *((_DWORD *)v15 - 1);
          *((_DWORD *)v15 - 1) = v18;
          v19 = *((_DWORD *)v16 - 2);
          *((_DWORD *)v16 - 2) = *(_DWORD *)v15;
          *(_DWORD *)v15 = v19;
          v20 = *((_DWORD *)v16 - 1);
          *((_DWORD *)v16 - 1) = *((_DWORD *)v15 + 1);
          *((_DWORD *)v15 + 1) = v20;
          v15 -= 16;
        }
        while ( v14 );
      }
      if ( i <= (unsigned __int64)a3 )
        v21 = a3;
      else
        v21 = a3 + 4;
      if ( a2 > (char *)a3 )
        v21 = a3;
      v22 = &v7[16 * v9];
      *(_DWORD *)a2 = *v21;
      v22[1] = v21[1];
      v22[2] = v21[2];
      v22[3] = v21[3];
    }
    return v4;
  }
  v23 = ((v6 - v7) >> 4) + 1;
  if ( v23 >> 60 )
    std::__vector_base_common<true>::__throw_length_error();
  if ( (unsigned __int64)((__int64)(v8 - (_QWORD)v7) >> 4) >= 0x7FFFFFFFFFFFFFFLL )
  {
    v58 = 0LL;
    v59 = a1 + 2;
    v24 = 0xFFFFFFFFFFFFFFFLL;
LABEL_23:
    v25 = (void *)operator new(16 * v24);
    goto LABEL_24;
  }
  if ( (__int64)(v8 - (_QWORD)v7) >> 3 >= v23 )
    v24 = (__int64)(v8 - (_QWORD)v7) >> 3;
  else
    v24 = v23;
  v58 = 0LL;
  v59 = a1 + 2;
  if ( v24 )
  {
    if ( v24 >> 60 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_23;
  }
  v25 = 0LL;
LABEL_24:
  v57 = (unsigned __int64)v25 + 16 * v9;
  v58 = (__int64)v25 + 16 * v24;
  v55 = v25;
  v56 = v57;
  sub_406E0((_BYTE **)&v55, a3);
  v26 = (_BYTE *)*a1;
  v27 = v56;
  v28 = v56;
  if ( (_DWORD *)*a1 != v4 )
  {
    v29 = (_DWORD *)(v56 - 8);
    v30 = v4;
    do
    {
      v31 = *(v30 - 4);
      v30 -= 4;
      *(v29 - 2) = v31;
      *(v29 - 1) = v30[1];
      *v29 = v30[2];
      v29[1] = v30[3];
      v29 -= 4;
    }
    while ( v26 != (_BYTE *)v30 );
    v28 = v27 + (~((char *)(v4 - 4) - v26) & 0xFFFFFFFFFFFFFFF0LL);
    v56 = v28;
  }
  v32 = a1[1];
  if ( (_DWORD *)v32 != v4 )
  {
    v33 = v57;
    v34 = (v32 + 16 * ~v9 - (unsigned __int64)v7) >> 4;
    v35 = v34 + 1;
    v36 = v32 - 16 - (_QWORD)v4;
    if ( v34 + 1 >= 8 )
    {
      if ( v57 >= (unsigned __int64)&v7[16 * v9 + 16 + 16 * v34]
        || (v40 = (unsigned __int64)v4 >= v57 + 16 * v34 + 16, v37 = (_DWORD *)v57, v40) )
      {
        v41 = 16 * (v35 & 0x1FFFFFFFFFFFFFF8LL);
        v42 = (_OWORD *)(v57 + 64);
        v37 = (_DWORD *)(v57 + v41);
        v4 = (_DWORD *)((char *)v4 + v41);
        v43 = (__int128 *)&v7[16 * v9 + 64];
        v44 = v35 & 0x1FFFFFFFFFFFFFF8LL;
        do
        {
          v45 = *(v43 - 4);
          v46 = *(v43 - 3);
          v47 = *(v43 - 1);
          v48 = *v43;
          v49 = v43[1];
          v50 = v43[2];
          v51 = v43[3];
          v44 -= 8LL;
          *(v42 - 2) = *(v43 - 2);
          *(v42 - 1) = v47;
          *(v42 - 4) = v45;
          *(v42 - 3) = v46;
          v42[2] = v50;
          v42[3] = v51;
          *v42 = v48;
          v42[1] = v49;
          v42 += 8;
          v43 += 8;
        }
        while ( v44 );
        if ( v35 == (v35 & 0x1FFFFFFFFFFFFFF8LL) )
          goto LABEL_40;
      }
    }
    else
    {
      v37 = (_DWORD *)v57;
    }
    do
    {
      *v37 = *v4;
      v37[1] = v4[1];
      v37[2] = v4[2];
      v52 = v4[3];
      v4 += 4;
      v37[3] = v52;
      v37 += 4;
    }
    while ( v4 != (_DWORD *)v32 );
LABEL_40:
    v39 = v33 + (v36 & 0xFFFFFFFFFFFFFFF0LL) + 16;
    v57 = v39;
    goto LABEL_41;
  }
  v39 = v57;
LABEL_41:
  *a1 = v28;
  a1[1] = v39;
  v56 = (unsigned __int64)v26;
  v57 = v32;
  v53 = a1[2];
  a1[2] = v58;
  v58 = v53;
  v55 = v26;
  if ( (_BYTE *)v32 != v26 )
    v57 = v32 + (~(v32 - 16 - (_QWORD)v26) & 0xFFFFFFFFFFFFFFF0LL);
  if ( v26 )
    operator delete(v26);
  return (_DWORD *)v27;
}

//----- (000000000003D6EC) ----------------------------------------------------
__int64 __fastcall feasibal_region::ground_process::optimizeOrganizePointCloudByCell(
        __int64 a1,
        __int64 a2,
        float a3,
        double a4,
        double a5)
{
  __int64 v5; // x8
  __int64 *v6; // x3
  __int64 *v7; // x4
  __int64 *v8; // x5
  __int64 v9; // x10
  __int64 v10; // x11
  float *v11; // x12
  float *v12; // x13
  _BYTE *v13; // x14
  _WORD *v14; // x15
  unsigned int *v15; // x16
  __int64 v16; // x17
  __int64 v17; // x0
  __int64 v18; // x1
  __int64 v19; // x2
  __int64 v20; // x3
  __int64 v21; // x9
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  _WORD *v25; // x7
  unsigned int *v26; // x19
  _BYTE *v27; // x20
  float *v28; // x21
  float *v29; // x22
  __int64 v30; // x23
  float v31; // s5
  __int64 v32; // x24
  float v33; // s3
  float v34; // s4
  __int64 v35; // x23

  v5 = *(unsigned int *)(a2 + 8);
  if ( (int)v5 >= 1 )
  {
    v6 = *(__int64 **)(a1 + 1136);
    v7 = *(__int64 **)(a2 + 72);
    v8 = *(__int64 **)(a1 + 656);
    v9 = *(unsigned int *)(a2 + 12);
    v10 = *(_QWORD *)(a1 + 560);
    v11 = *(float **)(a1 + 696);
    v12 = *(float **)(a1 + 792);
    v13 = *(_BYTE **)(a1 + 1080);
    v14 = *(_WORD **)(a2 + 16);
    v15 = *(unsigned int **)(a1 + 600);
    v16 = **(_QWORD **)(a1 + 752);
    v17 = **(_QWORD **)(a1 + 848);
    v18 = *v6;
    v19 = *v7;
    v20 = *v8;
    v21 = 0LL;
    v22 = v10 + 4LL * (int)v5 * (int)v9;
    v23 = v10 + 8LL * (int)v5 * (int)v9;
    do
    {
      v24 = v9;
      v25 = v14;
      v26 = v15;
      v27 = v13;
      v28 = v11;
      v29 = v12;
      if ( (int)v9 >= 1 )
      {
        do
        {
          v30 = *v26;
          if ( *v27 )
          {
            LOWORD(a5) = *v25;
            *(_QWORD *)&a5 = vmovl_s16(*(int16x4_t *)&a5).n128_u64[0];
            v31 = (float)SLODWORD(a5);
          }
          else
          {
            v32 = 4 * v30;
            v31 = -1.0;
            *(_DWORD *)(v10 + v32) = 0;
            *(_DWORD *)(v22 + v32) = 0;
            *(_DWORD *)(v23 + v32) = 0;
          }
          LODWORD(a5) = 0;
          v33 = 0.0;
          v34 = 0.0;
          if ( v31 > a3 )
          {
            v34 = v31;
            *(float *)&a5 = v31 * *v28;
            v33 = v31 * *v29;
          }
          v35 = 4 * v30;
          ++v29;
          ++v28;
          ++v27;
          ++v26;
          --v24;
          ++v25;
          *(_DWORD *)(v10 + v35) = LODWORD(a5);
          *(float *)(v22 + v35) = v33;
          *(float *)(v23 + v35) = v34;
        }
        while ( v24 );
      }
      ++v21;
      v12 = (float *)((char *)v12 + v17);
      v11 = (float *)((char *)v11 + v16);
      v13 += v18;
      v15 = (unsigned int *)((char *)v15 + v20);
      v14 = (_WORD *)((char *)v14 + v19);
    }
    while ( v21 != v5 );
  }
  return 0LL;
}

//----- (000000000003D834) ----------------------------------------------------
__int64 __fastcall feasibal_region::createDirectory(unsigned __int8 *a1)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x9
  __int64 v4; // x21
  __int64 v5; // x23
  unsigned __int8 *v6; // x9
  int v7; // w8
  __int64 result; // x0
  __int128 v9[16]; // [xsp+0h] [xbp-150h] BYREF
  __int64 v10; // [xsp+108h] [xbp-48h]

  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *a1;
  if ( (v2 & 1) != 0 )
    v3 = *((_QWORD *)a1 + 1);
  else
    v3 = v2 >> 1;
  memset(v9, 0, sizeof(v9));
  if ( (int)v3 < 1 )
    return 0LL;
  v4 = 0LL;
  v5 = (int)v3;
  v6 = a1 + 1;
  if ( (v2 & 1) == 0 )
    goto LABEL_9;
LABEL_8:
  v6 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
LABEL_9:
  while ( 1 )
  {
    v7 = v6[v4];
    *((_BYTE *)v9 + v4) = v7;
    if ( (v7 == 92 || v7 == 47) && access((const char *)v9, 0) == -1 )
    {
      result = mkdir((const char *)v9, 0x1EDu);
      if ( (_DWORD)result == -1 )
        return result;
    }
    if ( ++v4 >= v5 )
      return 0LL;
    v6 = a1 + 1;
    if ( (*a1 & 1) != 0 )
      goto LABEL_8;
  }
}

//----- (000000000003D94C) ----------------------------------------------------
char *__fastcall std::vector<float>::insert(unsigned __int64 *a1, unsigned __int64 src, char *a3)
{
  char *v3; // x8
  unsigned __int64 v4; // x22
  unsigned __int64 v5; // x9
  char *v6; // x21
  char *v7; // x19
  __int64 v8; // x27
  __int64 v10; // x24
  char *v11; // x10
  signed __int64 v12; // x2
  __int64 v13; // x9
  unsigned __int64 v14; // x12
  char *v15; // x13
  unsigned __int64 v16; // x8
  __int64 v17; // x9
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x26
  char *v20; // x23
  char *v21; // x25
  bool v22; // zf
  char *v23; // x26
  __int64 v24; // x8
  unsigned __int64 v25; // x24
  __int64 v26; // x0
  unsigned __int64 v27; // x13
  bool v28; // cf
  __int64 v29; // x16
  __int128 *v30; // x15
  _OWORD *v31; // x16
  __int64 v32; // x17
  __int128 v33; // q0
  __int128 v34; // q1
  int v35; // t1
  _DWORD *v36; // x21
  char *v37; // x23
  unsigned __int64 v38; // x8
  unsigned __int64 v39; // x22
  void *v40; // x0

  v4 = *a1;
  v3 = (char *)a1[1];
  v5 = a1[2];
  v6 = a3;
  v7 = (char *)src;
  v8 = src - *a1;
  v10 = v8 >> 2;
  if ( (unsigned __int64)v3 < v5 )
  {
    if ( (char *)src == v3 )
    {
      *(_DWORD *)src = *(_DWORD *)a3;
      a1[1] = src + 4;
      return v7;
    }
    v11 = v3 - 4;
    v12 = (signed __int64)&v3[-src - 4];
    v13 = v12 >> 2;
    if ( v3 - 4 >= v3 )
      goto LABEL_39;
    v14 = ((unsigned __int64)&v3[4 * (-v13 - v10) + ~v4] >> 2) + 1;
    if ( v14 > 7 )
    {
      v27 = (unsigned __int64)&v3[4 * (-v13 - v10) + ~v4] >> 2;
      if ( (unsigned __int64)v3 >= v4 + 4 * (v13 + v10 + v27) + 4
        || (v28 = v11 >= &v3[4 * v27 + 4], v15 = (char *)a1[1], v28) )
      {
        v29 = 4 * (v14 & 0x7FFFFFFFFFFFFFF8LL);
        v30 = (__int128 *)(v4 + 4 * (v13 + v10) + 16);
        v15 = &v3[v29];
        v11 += v29;
        v31 = v3 + 16;
        v32 = v14 & 0x7FFFFFFFFFFFFFF8LL;
        do
        {
          v33 = *(v30 - 1);
          v34 = *v30;
          v30 += 2;
          v32 -= 8LL;
          *(v31 - 1) = v33;
          *v31 = v34;
          v31 += 2;
        }
        while ( v32 );
        if ( v14 == (v14 & 0x7FFFFFFFFFFFFFF8LL) )
          goto LABEL_38;
      }
    }
    else
    {
      v15 = (char *)a1[1];
    }
    do
    {
      v35 = *(_DWORD *)v11;
      v11 += 4;
      *(_DWORD *)v15 = v35;
      v15 += 4;
    }
    while ( v11 < v3 );
LABEL_38:
    a1[1] = (unsigned __int64)&v3[4 * ((unsigned __int64)&v3[~src + -4 * v13] >> 2) + 4];
LABEL_39:
    if ( v12 )
      memmove(&v3[-4 * v13], (const void *)src, v12);
    if ( v7 <= v6 && a1[1] > (unsigned __int64)v6 )
      v6 += 4;
    *(_DWORD *)v7 = *(_DWORD *)v6;
    return v7;
  }
  v16 = ((__int64)&v3[-v4] >> 2) + 1;
  if ( v16 >> 62 )
    std::__vector_base_common<true>::__throw_length_error();
  v17 = v5 - v4;
  if ( (unsigned __int64)(v17 >> 2) >= 0x1FFFFFFFFFFFFFFFLL )
  {
    v19 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v18 = v17 >> 1;
    if ( v18 >= v16 )
      v19 = v18;
    else
      v19 = v16;
    if ( !v19 )
    {
      v20 = 0LL;
      goto LABEL_16;
    }
    if ( v19 >> 62 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  }
  v20 = (char *)operator new(4 * v19);
LABEL_16:
  v21 = &v20[4 * v10];
  v22 = v10 == v19;
  v23 = &v20[4 * v19];
  if ( v22 )
  {
    if ( v8 < 1 )
    {
      if ( v8 )
        v25 = v8 >> 1;
      else
        v25 = 1LL;
      if ( v25 )
      {
        if ( v25 >> 62 )
          sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v26 = operator new(4 * v25);
      }
      else
      {
        v26 = 0LL;
      }
      v21 = (char *)(v26 + 4 * (v25 >> 2));
      v23 = (char *)(v26 + 4 * v25);
      if ( v20 )
      {
        operator delete(v20);
        v4 = *a1;
      }
    }
    else
    {
      if ( v10 + 1 >= 0 )
        v24 = v10 + 1;
      else
        v24 = v10 + 2;
      v21 -= (2 * v24) & 0xFFFFFFFFFFFFFFFCLL;
    }
  }
  *(_DWORD *)v21 = *(_DWORD *)v6;
  v36 = v21 + 4;
  v37 = (char *)(v21 - &v7[-v4]);
  if ( (__int64)&v7[-v4] >= 1 )
    memcpy((void *)(v21 - &v7[-v4]), (const void *)v4, (size_t)&v7[-v4]);
  v38 = a1[1];
  v39 = v38 - (_QWORD)v7;
  if ( (__int64)(v38 - (_QWORD)v7) >= 1 )
  {
    memcpy(v21 + 4, v7, v38 - (_QWORD)v7);
    v36 = (_DWORD *)((char *)v36 + v39);
  }
  v40 = (void *)*a1;
  *a1 = (unsigned __int64)v37;
  a1[1] = (unsigned __int64)v36;
  a1[2] = (unsigned __int64)v23;
  if ( v40 )
    operator delete(v40);
  return v21;
}

//----- (000000000003DC58) ----------------------------------------------------
__int64 __fastcall cv::Mat_<unsigned char>::Mat_(__int64 a1, int a2, int a3, _BYTE *a4)
{
  unsigned __int64 v6; // d0
  int v8[2]; // [xsp+8h] [xbp-58h] BYREF
  __int64 v9; // [xsp+10h] [xbp-50h]
  __int64 v10; // [xsp+18h] [xbp-48h]
  __int64 v11; // [xsp+20h] [xbp-40h]
  __int64 v12; // [xsp+28h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_DWORD *)a1 = 1124007936;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 64) = a1 + 8;
  *(_QWORD *)(a1 + 72) = a1 + 80;
  v8[0] = a2;
  v8[1] = a3;
  cv::Mat::create((cv::Mat *)a1, 2, v8, 0);
  LOBYTE(v6) = *a4;
  v10 = 0LL;
  v11 = 0LL;
  v9 = 0LL;
  *(double *)v8 = (double)v6;
  return cv::Mat::operator=(a1, v8);
}
// 3DCDC: variable 'v6' is possibly undefined
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);

//----- (000000000003DD94) ----------------------------------------------------
__int64 feasibal_region::ground_process::viewDreamVis()
{
  return 0LL;
}

//----- (000000000003DD9C) ----------------------------------------------------
cv *__usercall feasibal_region::ground_process::drawResult@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        unsigned int a4@<W3>,
        __int64 a5@<X8>)
{
  __int64 v7; // x8
  int v11; // w9
  __int64 v12; // x14
  __int64 i; // x8
  __int64 v14; // x9
  __int64 v15; // x10
  __int64 v16; // x11
  __int64 v17; // x12
  __int64 v18; // x13
  __int64 v19; // x14
  unsigned int v20; // w15
  int v21; // w14
  int v22; // w1
  void *v23; // x1
  int v24; // v0.s[1]
  __int128 v25; // q1
  __int128 v26; // q2
  __int128 v27; // kr00_16
  unsigned int *v28; // x8
  unsigned int v29; // w9
  cv *v30; // x8
  _QWORD *v31; // x10
  __int64 v32; // x8
  unsigned int *v33; // x8
  unsigned int v34; // w9
  unsigned int v35; // w9
  _BYTE *v36; // x8
  __int64 v37; // x9
  cv *result; // x0
  int v39; // [xsp+8h] [xbp-E8h] BYREF
  _BYTE *v40; // [xsp+10h] [xbp-E0h]
  __int64 v41; // [xsp+18h] [xbp-D8h]
  _BYTE v42[64]; // [xsp+20h] [xbp-D0h] BYREF
  _BYTE *v43; // [xsp+60h] [xbp-90h]
  cv *v44; // [xsp+68h] [xbp-88h]
  __int64 v45[2]; // [xsp+70h] [xbp-80h] BYREF
  int v46[4]; // [xsp+80h] [xbp-70h] BYREF
  __int128 v47; // [xsp+90h] [xbp-60h]
  __int64 v48; // [xsp+A8h] [xbp-48h]

  v48 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = *(_QWORD *)(a1 + 520);
  *(_DWORD *)v42 = 1124007936;
  memset(&v42[4], 0, 60);
  v43 = &v42[8];
  v44 = (cv *)v45;
  v45[0] = 0LL;
  v45[1] = 0LL;
  *(_QWORD *)v46 = v7;
  cv::Mat::create((cv::Mat *)v42, 2, v46, 16);
  *(_OWORD *)v46 = 0u;
  v47 = 0u;
  cv::Mat::operator=(v42, v46);
  v11 = *(_DWORD *)(a1 + 520);
  if ( v11 >= 1 )
  {
    LODWORD(v12) = *(_DWORD *)(a1 + 524);
    for ( i = 0LL; i < v11; ++i )
    {
      if ( (int)v12 >= 1 )
      {
        v14 = 0LL;
        v15 = 0LL;
        v16 = *(_QWORD *)&v42[16] + *(_QWORD *)v44 * i;
        v17 = *(_QWORD *)(a3 + 16) + **(_QWORD **)(a3 + 72) * i;
        v18 = *(_QWORD *)(a2 + 16) + **(_QWORD **)(a2 + 72) * i;
        do
        {
          if ( *(_BYTE *)(v17 + v15) )
          {
            v19 = 3LL * *(unsigned __int8 *)(v17 + v15) - 3;
            *(_BYTE *)(v16 + (unsigned int)v14) = (*(_BYTE *)(v18 + v14) >> 1)
                                                + (*(_BYTE *)(*(_QWORD *)(a1 + 1640) + v19) >> 1);
            *(_BYTE *)(v16 + (unsigned int)(v14 + 1)) = (*(_BYTE *)(v18 + v14 + 1) >> 1)
                                                      + (*(_BYTE *)(*(_QWORD *)(a1 + 1640) + v19 + 1) >> 1);
            v20 = 3 * v15;
            v21 = (*(unsigned __int8 *)(v18 + v14 + 2) >> 1)
                + (*(unsigned __int8 *)(*(_QWORD *)(a1 + 1640) + v19 + 2) >> 1);
          }
          else
          {
            *(_BYTE *)(v16 + (unsigned int)v14) = *(_BYTE *)(v18 + v14);
            *(_BYTE *)(v16 + (unsigned int)(v14 + 1)) = *(_BYTE *)(v18 + v14 + 1);
            LOBYTE(v21) = *(_BYTE *)(v18 + v14 + 2);
            v20 = v14;
          }
          *(_BYTE *)(v16 + v20 + 2) = v21;
          v12 = *(int *)(a1 + 524);
          ++v15;
          v14 += 3LL;
        }
        while ( v15 < v12 );
        v11 = *(_DWORD *)(a1 + 520);
      }
    }
  }
  LOBYTE(v46[0]) = 12;
  strcpy((char *)v46 + 1, "seg_rz");
  v39 = -2130640880;
  *(_QWORD *)&v46[2] = 0LL;
  *(_QWORD *)&v47 = 0LL;
  v41 = 0LL;
  v40 = v42;
  cv::imshow(v46, &v39);
  if ( (v46[0] & 1) != 0 )
    operator delete((void *)v47);
  cv::waitKey((cv *)a4, v22);
  v24 = *(_DWORD *)&v42[4];
  v25 = *(_OWORD *)&v42[16];
  v26 = *(_OWORD *)&v42[32];
  v27 = *(_OWORD *)&v42[48];
  *(_OWORD *)a5 = *(_OWORD *)v42;
  *(_OWORD *)(a5 + 16) = v25;
  *(_OWORD *)(a5 + 32) = v26;
  *(_QWORD *)(a5 + 48) = v27;
  *(_QWORD *)(a5 + 80) = 0LL;
  *(_QWORD *)(a5 + 64) = a5 + 8;
  *(_QWORD *)(a5 + 72) = a5 + 80;
  *(_QWORD *)(a5 + 56) = *((_QWORD *)&v27 + 1);
  *(_QWORD *)(a5 + 88) = 0LL;
  if ( *((_QWORD *)&v27 + 1) )
  {
    v28 = (unsigned int *)(*((_QWORD *)&v27 + 1) + 20LL);
    do
      v29 = __ldaxr(v28);
    while ( __stlxr(v29 + 1, v28) );
    if ( *(int *)&v42[4] <= 2 )
    {
LABEL_17:
      v30 = v44;
      v31 = *(_QWORD **)(a5 + 72);
      *v31 = *(_QWORD *)v44;
      v31[1] = *((_QWORD *)v30 + 1);
      v32 = *(_QWORD *)&v42[56];
      if ( !*(_QWORD *)&v42[56] )
        goto LABEL_25;
      goto LABEL_21;
    }
  }
  else if ( v24 <= 2 )
  {
    goto LABEL_17;
  }
  *(_DWORD *)(a5 + 4) = 0;
  cv::Mat::copySize((cv::Mat *)a5, (const cv::Mat *)v42);
  v32 = *(_QWORD *)&v42[56];
  if ( !*(_QWORD *)&v42[56] )
    goto LABEL_25;
LABEL_21:
  v33 = (unsigned int *)(v32 + 20);
  do
  {
    v34 = __ldaxr(v33);
    v35 = v34 - 1;
  }
  while ( __stlxr(v35, v33) );
  if ( !v35 )
    cv::Mat::deallocate((cv::Mat *)v42);
LABEL_25:
  *(_QWORD *)&v42[56] = 0LL;
  memset(&v42[16], 0, 32);
  if ( *(int *)&v42[4] >= 1 )
  {
    v36 = v43;
    v37 = 0LL;
    do
      *(_DWORD *)&v36[4 * v37++] = 0;
    while ( v37 < *(int *)&v42[4] );
  }
  result = v44;
  if ( v44 != (cv *)v45 )
    return (cv *)cv::fastFree(v44, v23);
  return result;
}
// 3DFA0: variable 'v22' is possibly undefined
// 3E0A4: variable 'v23' is possibly undefined
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);
// 13180: using guessed type __int64 __fastcall cv::imshow(_QWORD, _QWORD);

//----- (000000000003E1F0) ----------------------------------------------------
void __fastcall feasibal_region::ground_process::organizePointCloudByCell(
        __int64 a1,
        __int64 *a2,
        __int64 *a3,
        __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x11
  __int64 v6; // x14
  int *v7; // x12
  __int64 v8; // x13
  __int64 v9; // x15
  int v10; // w9
  __int64 v11; // x10
  __int64 v12; // x16
  __int64 v13; // x0
  __int64 v14; // x1
  _DWORD *v15; // x3
  __int64 v16; // x4
  int *v17; // x5
  __int64 v18; // t1
  __int64 v19; // x6
  int v20; // w7

  v4 = *(unsigned int *)(a4 + 8);
  if ( (int)v4 >= 1 )
  {
    v5 = *(unsigned int *)(a4 + 12);
    v6 = *a3;
    v7 = *(int **)(a4 + 16);
    v8 = *a2;
    v9 = **(_QWORD **)(a4 + 72);
    v10 = 0;
    v11 = 0LL;
    v12 = (int)v4 * (int)v5;
    v13 = *a3 + 4 * v12;
    v14 = *a3 + 8 * v12;
    do
    {
      if ( (int)v5 >= 1 )
      {
        v15 = (_DWORD *)(v8 + 4LL * v10);
        v16 = v5;
        v17 = v7;
        do
        {
          v18 = *v17++;
          --v16;
          v19 = 4 * v18;
          *(_DWORD *)(v6 + v19) = *v15;
          *(_DWORD *)(v13 + v19) = v15[v12];
          v20 = v15[2 * v12];
          ++v15;
          *(_DWORD *)(v14 + v19) = v20;
        }
        while ( v16 );
      }
      ++v11;
      v10 += v5 & ~((int)v5 >> 31);
      v7 = (int *)((char *)v7 + v9);
    }
    while ( v11 != v4 );
  }
}

//----- (000000000003E28C) ----------------------------------------------------
void __fastcall feasibal_region::ground_process::projectPointCloud(
        float a1,
        float a2,
        float a3,
        float a4,
        double a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 *a12)
{
  __int64 v15; // x26
  __int64 v16; // x27
  void *v25; // x1
  void *v26; // x1
  void *v27; // x1
  void *v28; // x1
  __int64 v29; // x14
  __int64 v30; // x15
  _DWORD *v31; // x9
  _DWORD *v32; // x10
  float *v33; // x11
  float *v34; // x12
  float *v35; // x13
  __int64 v36; // x16
  __int64 v37; // x17
  __int64 v38; // x0
  __int64 v39; // x1
  __int64 v40; // x2
  __int64 v41; // x8
  float v42; // s0
  __int64 v43; // x4
  float *v44; // x5
  float *v45; // x6
  float *v46; // x7
  _DWORD *v47; // x19
  _DWORD *v48; // x20
  float v49; // s2
  float v50; // s3
  float v51; // s4
  float v52; // s3
  __int64 v53; // x22
  double v54; // [xsp+10h] [xbp-370h] BYREF
  __int64 v55; // [xsp+18h] [xbp-368h]
  __int64 v56; // [xsp+20h] [xbp-360h]
  __int64 v57; // [xsp+28h] [xbp-358h]
  __int64 v58; // [xsp+30h] [xbp-350h] BYREF
  __int64 v59; // [xsp+38h] [xbp-348h]
  __int64 v60; // [xsp+40h] [xbp-340h]
  __int64 v61; // [xsp+190h] [xbp-1F0h] BYREF
  __int64 v62; // [xsp+198h] [xbp-1E8h]
  __int64 v63; // [xsp+1A0h] [xbp-1E0h]
  __int64 v64; // [xsp+2F0h] [xbp-90h]

  v64 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = *(unsigned int *)(a7 + 8);
  v16 = *(unsigned int *)(a7 + 12);
  v63 = 0LL;
  LODWORD(v61) = 16842752;
  v62 = a7;
  v60 = 0LL;
  LODWORD(v58) = 16842752;
  v59 = a9;
  v55 = a10;
  v56 = 0LL;
  LODWORD(v54) = 33619968;
  cv::divide(&v61, &v58, &v54, 0xFFFFFFFFLL, 1.0);
  v55 = a11;
  v56 = 0LL;
  LODWORD(v54) = 33619968;
  v63 = 0LL;
  LODWORD(v61) = 16842752;
  v62 = a8;
  v60 = 0LL;
  LODWORD(v58) = 16842752;
  v59 = a9;
  cv::divide(&v61, &v58, &v54, 0xFFFFFFFFLL, 1.0);
  cv::operator*(&v58, a10, a1);
  v54 = a3;
  v56 = 0LL;
  v57 = 0LL;
  v55 = 0LL;
  cv::operator+(&v61, &v58, &v54);
  (*(void (__fastcall **)(__int64, __int64 *, __int64, __int64))(*(_QWORD *)v61 + 24LL))(v61, &v61, a10, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v61, v25);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v58, v26);
  cv::operator*(&v58, a11, a2);
  v54 = a4;
  v56 = 0LL;
  v57 = 0LL;
  v55 = 0LL;
  cv::operator+(&v61, &v58, &v54);
  (*(void (__fastcall **)(__int64, __int64 *, __int64, __int64))(*(_QWORD *)v61 + 24LL))(v61, &v61, a11, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v61, v27);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v58, v28);
  if ( (int)v15 >= 1 )
  {
    v29 = *a12;
    v30 = a12[1];
    v31 = *(_DWORD **)(a7 + 16);
    v32 = *(_DWORD **)(a8 + 16);
    v33 = *(float **)(a9 + 16);
    v34 = *(float **)(a10 + 16);
    v35 = *(float **)(a11 + 16);
    v36 = **(_QWORD **)(a7 + 72);
    v37 = **(_QWORD **)(a8 + 72);
    v38 = **(_QWORD **)(a9 + 72);
    v39 = **(_QWORD **)(a10 + 72);
    v40 = **(_QWORD **)(a11 + 72);
    v41 = 0LL;
    v42 = (float)(int)v16;
    do
    {
      v43 = v16;
      v44 = v33;
      v45 = v34;
      v46 = v35;
      v47 = v31;
      v48 = v32;
      if ( (int)v16 >= 1 )
      {
        do
        {
          v49 = *v44;
          if ( *v44 > a5 )
          {
            v50 = *v45;
            if ( *v45 > 0.0 )
            {
              v51 = *v46;
              if ( *v46 > 0.0 && v50 < v42 && v51 < (float)(int)v15 )
              {
                v52 = v50 + (float)(floorf(v51) * v42);
                *(_DWORD *)(v29 + 4LL * (int)v52) = *v47;
                v53 = (int)v52;
                *(_DWORD *)(v29 + 4 * (v30 + v53)) = *v48;
                *(float *)(v29 + 4 * (2 * v30 + v53)) = v49;
              }
            }
          }
          ++v48;
          ++v47;
          ++v46;
          ++v45;
          --v43;
          ++v44;
        }
        while ( v43 );
      }
      ++v41;
      v32 = (_DWORD *)((char *)v32 + v37);
      v31 = (_DWORD *)((char *)v31 + v36);
      v35 = (float *)((char *)v35 + v40);
      v34 = (float *)((char *)v34 + v39);
      v33 = (float *)((char *)v33 + v38);
    }
    while ( v41 != v15 );
  }
}
// 3E3C8: variable 'v25' is possibly undefined
// 3E3D0: variable 'v26' is possibly undefined
// 3E424: variable 'v27' is possibly undefined
// 3E42C: variable 'v28' is possibly undefined
// 12F90: using guessed type __int64 __fastcall cv::divide(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 132F0: using guessed type _QWORD *__fastcall cv::operator+(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13510: using guessed type _QWORD *__fastcall cv::operator*(_QWORD *__return_ptr, _QWORD, double);

//----- (000000000003E5C4) ----------------------------------------------------
void __fastcall feasibal_region::ground_process::fillPointCloud(
        double a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _QWORD *a6)
{
  __int64 v6; // x8
  __int64 v7; // x10
  _DWORD *v8; // x14
  __int64 v9; // x15
  _DWORD *v10; // x11
  _DWORD *v11; // x12
  float *v12; // x13
  __int64 v13; // x16
  __int64 v14; // x17
  __int64 v15; // x0
  __int64 v16; // x9
  __int64 v17; // x1
  __int64 v18; // x4
  _DWORD *v19; // x5
  float *v20; // x6
  _DWORD *v21; // x7
  _DWORD *v22; // x19
  float v23; // s1

  v6 = *(unsigned int *)(a3 + 8);
  if ( (int)v6 >= 1 )
  {
    v7 = *(int *)(a3 + 12);
    v8 = (_DWORD *)*a6;
    v9 = a6[1];
    v10 = *(_DWORD **)(a3 + 16);
    v11 = *(_DWORD **)(a4 + 16);
    v12 = *(float **)(a5 + 16);
    v13 = **(_QWORD **)(a3 + 72);
    v14 = **(_QWORD **)(a4 + 72);
    v15 = **(_QWORD **)(a5 + 72);
    v16 = 0LL;
    v17 = *(unsigned int *)(a3 + 12);
    do
    {
      v18 = v17;
      v19 = v8;
      v20 = v12;
      v21 = v10;
      v22 = v11;
      if ( (int)v7 >= 1 )
      {
        do
        {
          v23 = *v20;
          if ( *v20 > a1 )
          {
            *v19 = *v21;
            v19[v9] = *v22;
            *(float *)&v19[2 * v9] = v23;
          }
          ++v22;
          ++v21;
          ++v20;
          --v18;
          ++v19;
        }
        while ( v18 );
      }
      ++v16;
      v11 = (_DWORD *)((char *)v11 + v14);
      v10 = (_DWORD *)((char *)v10 + v13);
      v12 = (float *)((char *)v12 + v15);
      v8 += v7;
    }
    while ( v16 != v6 );
  }
}

//----- (000000000003E68C) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ofstream::~ofstream(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_6DF38;
  v1[22] = off_6DF60;
  std::filebuf::~filebuf((__int64)(v1 + 1));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 22));
}
// 6DF38: using guessed type __int64 (__fastcall *off_6DF38[2])();
// 6DF60: using guessed type __int64 (__fastcall *off_6DF60[2])();

//----- (000000000003E6D4) ----------------------------------------------------
void __fastcall std::ostream::~ostream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 8));
}

//----- (000000000003E6DC) ----------------------------------------------------
void __fastcall std::ostream::~ostream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 8));
  operator delete((void *)a1);
}

//----- (000000000003E704) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ostream::~ostream(_QWORD *a1)
{
  std::ios_base::~ios_base((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 8));
}

//----- (000000000003E718) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ostream::~ostream(_QWORD *a1)
{
  char *v1; // x19

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  std::ios_base::~ios_base((std::ios_base *)(v1 + 8));
  operator delete(v1);
}

//----- (000000000003E748) ----------------------------------------------------
void __fastcall std::ofstream::~ofstream(_QWORD *a1)
{
  *a1 = off_6DF38;
  a1[22] = off_6DF60;
  std::filebuf::~filebuf((__int64)(a1 + 1));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 22));
  operator delete(a1);
}
// 6DF38: using guessed type __int64 (__fastcall *off_6DF38[2])();
// 6DF60: using guessed type __int64 (__fastcall *off_6DF60[2])();

//----- (000000000003E790) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ofstream::~ofstream(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_6DF38;
  v1[22] = off_6DF60;
  std::filebuf::~filebuf((__int64)(v1 + 1));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 22));
  operator delete(v1);
}
// 6DF38: using guessed type __int64 (__fastcall *off_6DF38[2])();
// 6DF60: using guessed type __int64 (__fastcall *off_6DF60[2])();

//----- (000000000003E7E4) ----------------------------------------------------
void __fastcall std::filebuf::~filebuf(__int64 a1)
{
  FILE *v1; // x20
  void *v3; // x0
  void *v4; // x0

  v1 = *(FILE **)(a1 + 120);
  *(_QWORD *)a1 = off_6E028;
  if ( v1 )
  {
    std::filebuf::sync(a1);
    if ( !fclose(v1) )
      *(_QWORD *)(a1 + 120) = 0LL;
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 24LL))(a1, 0LL, 0LL);
  }
  if ( *(_BYTE *)(a1 + 160) )
  {
    v3 = *(void **)(a1 + 64);
    if ( v3 )
      operator delete[](v3);
  }
  if ( *(_BYTE *)(a1 + 161) )
  {
    v4 = *(void **)(a1 + 104);
    if ( v4 )
      operator delete[](v4);
  }
  *(_QWORD *)a1 = off_6E0D0;
  std::locale::~locale((std::locale *)(a1 + 8));
}
// 6E028: using guessed type __int64 (__fastcall *[3])();
// 6E0D0: using guessed type __int64 (__fastcall *off_6E0D0[8])();

//----- (000000000003E8C4) ----------------------------------------------------
void __fastcall std::filebuf::~filebuf(void *a1)
{
  std::filebuf::~filebuf((__int64)a1);
  operator delete(a1);
}

//----- (000000000003E8E8) ----------------------------------------------------
void __fastcall std::filebuf::imbue(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  char v5; // w0
  int v6; // w8
  void *v7; // x0
  char v8; // w8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x0
  __int64 v12; // x8
  unsigned __int64 v13; // x0

  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1);
  v4 = std::locale::use_facet(a2, &std::codecvt<char,char,mbstate_t>::id);
  *(_QWORD *)(a1 + 128) = v4;
  LODWORD(a2) = *(unsigned __int8 *)(a1 + 162);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 56LL))(v4);
  *(_BYTE *)(a1 + 162) = v5 & 1;
  if ( (_DWORD)a2 != (v5 & 1) )
  {
    v6 = *(unsigned __int8 *)(a1 + 160);
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    if ( (v5 & 1) != 0 )
    {
      if ( v6 )
      {
        v7 = *(void **)(a1 + 64);
        if ( v7 )
          operator delete[](v7);
      }
      v8 = *(_BYTE *)(a1 + 161);
      v9 = *(_QWORD *)(a1 + 104);
      v10 = *(_QWORD *)(a1 + 112);
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 112) = 0LL;
      *(_BYTE *)(a1 + 160) = v8;
      *(_QWORD *)(a1 + 96) = v10;
      *(_QWORD *)(a1 + 104) = 0LL;
      *(_QWORD *)(a1 + 64) = v9;
    }
    else if ( v6 || (v12 = *(_QWORD *)(a1 + 64), v12 == a1 + 88) )
    {
      v11 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 112) = v11;
      *(_QWORD *)(a1 + 104) = operator new[](v11);
      *(_BYTE *)(a1 + 161) = 1;
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 96);
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 104) = v12;
      *(_QWORD *)(a1 + 112) = v13;
      *(_QWORD *)(a1 + 64) = operator new[](v13);
      *(_BYTE *)(a1 + 160) = 1;
    }
  }
}
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);

//----- (000000000003E9D8) ----------------------------------------------------
__int64 __fastcall std::filebuf::setbuf(__int64 a1, __int64 a2, signed __int64 a3)
{
  int v3; // w8
  void *v7; // x0
  void *v8; // x0
  int v9; // w22
  int v10; // w22
  unsigned __int64 v12; // x0

  v3 = *(unsigned __int8 *)(a1 + 160);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if ( v3 )
  {
    v7 = *(void **)(a1 + 64);
    if ( v7 )
      operator delete[](v7);
  }
  if ( *(_BYTE *)(a1 + 161) )
  {
    v8 = *(void **)(a1 + 104);
    if ( v8 )
      operator delete[](v8);
  }
  *(_QWORD *)(a1 + 96) = a3;
  if ( (unsigned __int64)a3 < 9 )
  {
    v10 = *(unsigned __int8 *)(a1 + 162);
    *(_QWORD *)(a1 + 64) = a1 + 88;
    *(_QWORD *)(a1 + 96) = 8LL;
    *(_BYTE *)(a1 + 160) = 0;
    if ( v10 )
      goto LABEL_12;
  }
  else
  {
    v9 = *(unsigned __int8 *)(a1 + 162);
    if ( a2 && *(_BYTE *)(a1 + 162) )
    {
      *(_QWORD *)(a1 + 64) = a2;
      *(_BYTE *)(a1 + 160) = 0;
LABEL_12:
      *(_BYTE *)(a1 + 161) = 0;
      *(_QWORD *)(a1 + 104) = 0LL;
      *(_QWORD *)(a1 + 112) = 0LL;
      return a1;
    }
    *(_QWORD *)(a1 + 64) = operator new[](a3);
    *(_BYTE *)(a1 + 160) = 1;
    if ( v9 )
      goto LABEL_12;
  }
  if ( a3 <= 8 )
    v12 = 8LL;
  else
    v12 = a3;
  *(_QWORD *)(a1 + 112) = v12;
  if ( a2 )
  {
    *(_QWORD *)(a1 + 104) = a2;
    *(_BYTE *)(a1 + 161) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = operator new[](v12);
    *(_BYTE *)(a1 + 161) = 1;
  }
  return a1;
}
// 3EAB4: conditional instruction was optimized away because x0.8>=8

//----- (000000000003EAD8) ----------------------------------------------------
__int64 __fastcall std::filebuf::seekoff(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // x0
  int v7; // w0
  __int64 v8; // x8
  int v9; // w22
  int v10; // w0
  __off_t v11; // x1

  v4 = *(_QWORD *)(a1 + 128);
  if ( !v4 )
    sub_3F59C();
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 48LL))(v4);
  v8 = *(_QWORD *)(a1 + 120);
  if ( v8 )
  {
    v9 = v7;
    if ( a2 && v7 < 1 )
      return 0LL;
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1);
    v8 = 0LL;
    if ( !v10 && a3 <= 2 )
    {
      if ( v9 <= 0 )
        v11 = 0LL;
      else
        v11 = v9 * a2;
      if ( !fseeko(*(FILE **)(a1 + 120), v11, a3) )
      {
        ftello(*(FILE **)(a1 + 120));
        return *(_QWORD *)(a1 + 136);
      }
      return 0LL;
    }
  }
  return v8;
}

//----- (000000000003EB98) ----------------------------------------------------
__int64 __fastcall std::filebuf::seekpos(__int64 a1, __int64 a2, __off_t a3)
{
  if ( !*(_QWORD *)(a1 + 120)
    || (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1)
    || fseeko(*(FILE **)(a1 + 120), a3, 0) )
  {
    return 0LL;
  }
  *(_QWORD *)(a1 + 136) = a2;
  return a2;
}

//----- (000000000003EC08) ----------------------------------------------------
__int64 __fastcall std::filebuf::sync(__int64 a1)
{
  __int64 v2; // x0
  int v3; // w8
  int v4; // w21
  __int64 v5; // x20
  unsigned int v6; // w20
  int v7; // w21
  const void *v8; // x0
  __int64 v9; // x22
  int v10; // w0
  __int64 v11; // x8
  __int64 v13[2]; // [xsp+0h] [xbp-40h] BYREF

  v13[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0;
  v2 = *(_QWORD *)(a1 + 128);
  if ( !v2 )
    sub_3F59C();
  v3 = *(_DWORD *)(a1 + 156);
  if ( (v3 & 0x10) == 0 )
  {
    if ( (v3 & 8) != 0 )
    {
      v13[0] = *(_QWORD *)(a1 + 144);
      if ( *(_BYTE *)(a1 + 162) )
      {
        v4 = 0;
        v5 = *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24);
      }
      else
      {
        v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48LL))(v2);
        v5 = *(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72);
        if ( v10 < 1 )
        {
          if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32) )
          {
            v4 = 0;
          }
          else
          {
            v4 = 1;
            v5 = *(_QWORD *)(a1 + 72)
               + v5
               - (*(int (__fastcall **)(_QWORD, __int64 *, _QWORD))(**(_QWORD **)(a1 + 128) + 64LL))(
                   *(_QWORD *)(a1 + 128),
                   v13,
                   *(_QWORD *)(a1 + 64))
               - *(_QWORD *)(a1 + 64);
          }
        }
        else
        {
          v4 = 0;
          v5 += (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) * v10;
        }
      }
      if ( fseeko(*(FILE **)(a1 + 120), -v5, 1) )
        return (unsigned int)-1;
      if ( v4 )
        *(_QWORD *)(a1 + 136) = v13[0];
      v11 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 156) = 0;
      *(_QWORD *)(a1 + 24) = 0LL;
      *(_QWORD *)(a1 + 32) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
      *(_QWORD *)(a1 + 72) = v11;
      *(_QWORD *)(a1 + 80) = v11;
    }
    return 0;
  }
  if ( *(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 40)
    || (v6 = -1, (*(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 104LL))(a1, 0xFFFFFFFFLL) != -1) )
  {
    while ( 1 )
    {
      v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, __int64 *))(**(_QWORD **)(a1 + 128) + 40LL))(
             *(_QWORD *)(a1 + 128),
             a1 + 136,
             *(_QWORD *)(a1 + 64),
             *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 96),
             v13);
      v8 = *(const void **)(a1 + 64);
      v9 = v13[0] - (_QWORD)v8;
      if ( fwrite(v8, 1uLL, v13[0] - (_QWORD)v8, *(FILE **)(a1 + 120)) != v9 )
        break;
      if ( v7 != 1 )
      {
        if ( v7 == 2 || fflush(*(FILE **)(a1 + 120)) )
          return (unsigned int)-1;
        return 0;
      }
    }
    return (unsigned int)-1;
  }
  return v6;
}

//----- (000000000003EDF8) ----------------------------------------------------
__int64 std::streambuf::showmanyc()
{
  return 0LL;
}

//----- (000000000003EE00) ----------------------------------------------------
__int64 __fastcall std::streambuf::xsgetn(_QWORD *a1, char *dest, __int64 a3)
{
  __int64 i; // x19
  char *v7; // x1
  unsigned __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x23
  int v11; // w0

  if ( a3 < 1 )
    return 0LL;
  for ( i = 0LL; i < a3; i += v10 )
  {
    v7 = (char *)a1[3];
    v8 = a1[4];
    if ( (unsigned __int64)v7 >= v8 )
    {
      v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 80LL))(a1);
      if ( v11 == -1 )
        return i;
      *dest++ = v11;
      v10 = 1LL;
    }
    else
    {
      v9 = v8 - (_QWORD)v7;
      if ( a3 - i < v9 )
        v9 = a3 - i;
      if ( v9 >= 0x7FFFFFFF )
        v10 = 0x7FFFFFFFLL;
      else
        v10 = v9;
      if ( v10 )
      {
        memcpy(dest, v7, v10);
        v7 = (char *)a1[3];
      }
      dest += v10;
      a1[3] = &v7[(int)v10];
    }
  }
  return i;
}

//----- (000000000003EEC4) ----------------------------------------------------
__int64 __fastcall std::filebuf::underflow(__int64 a1)
{
  int v2; // w8
  __int64 v3; // x9
  bool v4; // zf
  __int64 v5; // x8
  __int64 v6; // x10
  __int64 v7; // x8
  int v8; // w9
  unsigned __int8 *v9; // x8
  __int64 v10; // x20
  __int64 result; // x0
  char **v12; // x24
  unsigned __int8 *v13; // x9
  size_t v14; // x0
  unsigned __int8 *v15; // x8
  __int64 v16; // x9
  _BYTE *v17; // x1
  _BYTE *v18; // x9
  __int64 v19; // x8
  void *v20; // x0
  __int64 v21; // x9
  __int64 v22; // x10
  __int64 v23; // x8
  FILE *v24; // x3
  __int64 v25; // x9
  size_t v26; // x2
  size_t v27; // x0
  size_t v28; // x8
  __int64 v29; // x0
  __int64 v30; // x2
  __int64 v31; // x10
  size_t v32; // x3
  unsigned __int8 *v33; // [xsp+8h] [xbp-48h] BYREF
  char v34; // [xsp+14h] [xbp-3Ch] BYREF
  _BYTE v35[11]; // [xsp+15h] [xbp-3Bh] BYREF

  *(_QWORD *)&v35[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  if ( (*(_BYTE *)(a1 + 156) & 8) != 0 )
  {
    v9 = *(unsigned __int8 **)(a1 + 24);
    v8 = 0;
    if ( v9 )
      goto LABEL_8;
  }
  else
  {
    v2 = *(unsigned __int8 *)(a1 + 162);
    v3 = 96LL;
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    v4 = v2 == 0;
    v5 = 64LL;
    if ( v4 )
      v3 = 112LL;
    *(_QWORD *)(a1 + 56) = 0LL;
    if ( v4 )
      v5 = 104LL;
    v6 = *(_QWORD *)(a1 + v5);
    v7 = *(_QWORD *)(a1 + v3);
    *(_DWORD *)(a1 + 156) = 8;
    v8 = 1;
    v9 = (unsigned __int8 *)(v6 + v7);
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = v9;
    *(_QWORD *)(a1 + 32) = v9;
    if ( v9 )
    {
LABEL_8:
      if ( v8 )
        goto LABEL_9;
LABEL_14:
      v13 = *(unsigned __int8 **)(a1 + 32);
      if ( (unsigned __int64)((__int64)&v13[-*(_QWORD *)(a1 + 16)] / 2) >= 4 )
        v10 = 4LL;
      else
        v10 = (__int64)&v13[-*(_QWORD *)(a1 + 16)] / 2;
      if ( v9 != v13 )
        goto LABEL_10;
      goto LABEL_18;
    }
  }
  v9 = v35;
  *(_QWORD *)(a1 + 16) = &v34;
  *(_QWORD *)(a1 + 24) = v35;
  *(_QWORD *)(a1 + 32) = v35;
  if ( !v8 )
    goto LABEL_14;
LABEL_9:
  v10 = 0LL;
  if ( v9 != *(unsigned __int8 **)(a1 + 32) )
  {
LABEL_10:
    result = *v9;
    v12 = (char **)(a1 + 16);
    goto LABEL_36;
  }
LABEL_18:
  v12 = (char **)(a1 + 16);
  memmove(*(void **)(a1 + 16), &v9[-v10], v10);
  if ( *(_BYTE *)(a1 + 162) )
  {
    v14 = fread(
            (void *)(*(_QWORD *)(a1 + 16) + v10),
            1uLL,
            *(_QWORD *)(a1 + 32) - v10 - *(_QWORD *)(a1 + 16),
            *(FILE **)(a1 + 120));
    if ( v14 )
    {
      v15 = (unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v10);
      v16 = (__int64)&v15[v14];
LABEL_34:
      *(_QWORD *)(a1 + 24) = v15;
      *(_QWORD *)(a1 + 32) = v16;
      result = *v15;
      goto LABEL_36;
    }
  }
  else
  {
    v17 = *(_BYTE **)(a1 + 72);
    v18 = *(_BYTE **)(a1 + 80);
    if ( v18 != v17 )
    {
      memmove(*(void **)(a1 + 64), v17, v18 - v17);
      v17 = *(_BYTE **)(a1 + 72);
      v18 = *(_BYTE **)(a1 + 80);
    }
    v19 = *(_QWORD *)(a1 + 64);
    v20 = (void *)(v19 + v18 - v17);
    *(_QWORD *)(a1 + 72) = v20;
    if ( v19 == a1 + 88 )
      v21 = 8LL;
    else
      v21 = *(_QWORD *)(a1 + 96);
    v22 = *(_QWORD *)(a1 + 136);
    v23 = v19 + v21;
    v25 = *(_QWORD *)(a1 + 112);
    v24 = *(FILE **)(a1 + 120);
    *(_QWORD *)(a1 + 80) = v23;
    *(_QWORD *)(a1 + 144) = v22;
    if ( v23 - (__int64)v20 >= (unsigned __int64)(v25 - v10) )
      v26 = v25 - v10;
    else
      v26 = v23 - (_QWORD)v20;
    v27 = fread(v20, 1uLL, v26, v24);
    if ( v27 )
    {
      v28 = v27;
      v29 = *(_QWORD *)(a1 + 128);
      if ( !v29 )
        sub_3F59C();
      v30 = *(_QWORD *)(a1 + 64);
      v31 = *(_QWORD *)(a1 + 112);
      v32 = *(_QWORD *)(a1 + 72) + v28;
      *(_QWORD *)(a1 + 80) = v32;
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, size_t, __int64, __int64, __int64, unsigned __int8 **))(*(_QWORD *)v29 + 32LL))(
             v29,
             a1 + 136,
             v30,
             v32,
             a1 + 72,
             *(_QWORD *)(a1 + 16) + v10,
             *(_QWORD *)(a1 + 16) + v31,
             &v33) == 3 )
      {
        v15 = *(unsigned __int8 **)(a1 + 64);
        v16 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)(a1 + 16) = v15;
        goto LABEL_34;
      }
      v16 = (__int64)v33;
      v15 = (unsigned __int8 *)&(*v12)[v10];
      if ( v33 != v15 )
        goto LABEL_34;
    }
  }
  result = 0xFFFFFFFFLL;
LABEL_36:
  if ( *v12 == &v34 )
  {
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  return result;
}
// 3EEC4: using guessed type unsigned __int8 *var_48;

//----- (000000000003F14C) ----------------------------------------------------
__int64 __fastcall std::streambuf::uflow(_QWORD *a1)
{
  __int64 result; // x0
  unsigned __int8 *v3; // x8

  result = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 72LL))(a1);
  if ( (_DWORD)result != -1 )
  {
    v3 = (unsigned __int8 *)a1[3];
    a1[3] = v3 + 1;
    return *v3;
  }
  return result;
}

//----- (000000000003F18C) ----------------------------------------------------
__int64 __fastcall std::filebuf::pbackfail(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x9
  __int64 result; // x0
  _BYTE *v5; // x9
  int v6; // t1

  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) >= v2 )
    return 0xFFFFFFFFLL;
  result = a2;
  if ( a2 == -1 )
  {
    result = 0LL;
    *(_QWORD *)(a1 + 24) = v2 - 1;
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 152) & 0x10) != 0 )
    {
      v5 = (_BYTE *)(v2 - 1);
    }
    else
    {
      v6 = *(unsigned __int8 *)(v2 - 1);
      v5 = (_BYTE *)(v2 - 1);
      if ( v6 != (unsigned __int8)a2 )
        return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 24) = v5;
    *v5 = a2;
  }
  return result;
}

//----- (000000000003F1EC) ----------------------------------------------------
__int64 __fastcall std::streambuf::xsputn(_QWORD *a1, unsigned __int8 *src, __int64 a3)
{
  __int64 v6; // x21
  char *v7; // x0
  unsigned __int64 v8; // x8
  signed __int64 v9; // x8
  size_t v10; // x23

  if ( a3 < 1 )
    return 0LL;
  v6 = 0LL;
  do
  {
    while ( 1 )
    {
      v7 = (char *)a1[6];
      v8 = a1[7];
      if ( (unsigned __int64)v7 < v8 )
        break;
      if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(*a1 + 104LL))(a1, *src) != -1 )
      {
        ++src;
        if ( ++v6 < a3 )
          continue;
      }
      return v6;
    }
    v9 = v8 - (_QWORD)v7;
    if ( a3 - v6 >= v9 )
      v10 = v9;
    else
      v10 = a3 - v6;
    if ( v10 )
    {
      memcpy(v7, src, v10);
      v7 = (char *)a1[6];
    }
    src += v10;
    v6 += v10;
    a1[6] = &v7[v10];
  }
  while ( v6 < a3 );
  return v6;
}

//----- (000000000003F2B0) ----------------------------------------------------
__int64 __fastcall std::filebuf::overflow(__int64 a1, unsigned int a2)
{
  unsigned __int64 v4; // x8
  char *v5; // x2
  char **v6; // x25
  __int64 v7; // x26
  __int64 *v8; // x27
  char *v9; // x3
  char *v10; // x28
  size_t v11; // x21
  FILE *v12; // x3
  char *v13; // x0
  __int64 v15; // x0
  unsigned int v16; // w0
  char *v17; // x8
  unsigned int v18; // w22
  const void *v19; // x0
  __int64 v20; // x3
  __int64 v21; // x0
  unsigned int v22; // w0
  char *v23; // [xsp+0h] [xbp-70h]
  __int64 v24; // [xsp+8h] [xbp-68h]
  char v25; // [xsp+14h] [xbp-5Ch] BYREF
  _BYTE v26[11]; // [xsp+15h] [xbp-5Bh] BYREF

  *(_QWORD *)&v26[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*(_QWORD *)(a1 + 120) )
    return 0xFFFFFFFFLL;
  if ( (*(_BYTE *)(a1 + 156) & 0x10) != 0 )
  {
    v6 = (char **)(a1 + 40);
    v5 = *(char **)(a1 + 40);
    v8 = (__int64 *)(a1 + 56);
    v7 = *(_QWORD *)(a1 + 56);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    if ( v4 < 9 )
    {
      *(_QWORD *)(a1 + 40) = 0LL;
      v6 = (char **)(a1 + 40);
      v5 = 0LL;
      v7 = 0LL;
      *(_QWORD *)(a1 + 56) = 0LL;
      v8 = (__int64 *)(a1 + 56);
      *(_QWORD *)(a1 + 48) = 0LL;
    }
    else
    {
      if ( *(_BYTE *)(a1 + 162) )
      {
        v5 = *(char **)(a1 + 64);
      }
      else
      {
        v5 = *(char **)(a1 + 104);
        v4 = *(_QWORD *)(a1 + 112);
      }
      v7 = (__int64)&v5[v4 - 1];
      v6 = (char **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v5;
      *(_QWORD *)(a1 + 48) = v5;
      v8 = (__int64 *)(a1 + 56);
      *(_QWORD *)(a1 + 56) = v7;
    }
    *(_DWORD *)(a1 + 156) = 16;
  }
  v9 = *(char **)(a1 + 48);
  v10 = v5;
  if ( a2 != -1 )
  {
    if ( !v9 )
    {
      v9 = &v25;
      *(_QWORD *)(a1 + 40) = &v25;
      *(_QWORD *)(a1 + 48) = &v25;
      *(_QWORD *)(a1 + 56) = v26;
    }
    *v9 = a2;
    v5 = *(char **)(a1 + 40);
    v9 = (char *)(*(_QWORD *)(a1 + 48) + 1LL);
    *(_QWORD *)(a1 + 48) = v9;
  }
  v11 = v9 - v5;
  if ( v9 == v5 )
    goto LABEL_20;
  if ( *(_BYTE *)(a1 + 162) )
  {
    v12 = *(FILE **)(a1 + 120);
    v13 = v5;
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 64);
    v15 = *(_QWORD *)(a1 + 128);
    if ( !v15 )
LABEL_35:
      sub_3F59C();
    v16 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 24LL))(v15, a1 + 136);
    v17 = *(char **)(a1 + 40);
    if ( v23 == v17 )
      return 0xFFFFFFFFLL;
    v18 = v16;
    while ( v18 != 3 )
    {
      if ( v18 > 1 )
        return 0xFFFFFFFFLL;
      v19 = *(const void **)(a1 + 64);
      if ( fwrite(v19, 1uLL, v24 - (_QWORD)v19, *(FILE **)(a1 + 120)) != v24 - (_QWORD)v19 )
        return 0xFFFFFFFFLL;
      if ( v18 != 1 )
        goto LABEL_19;
      v20 = *(_QWORD *)(a1 + 48);
      *v6 = v23;
      *v8 = v20;
      v21 = *(_QWORD *)(a1 + 128);
      *(_QWORD *)(a1 + 48) = v20;
      if ( !v21 )
        goto LABEL_35;
      v22 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v21 + 24LL))(v21, a1 + 136);
      v17 = *(char **)(a1 + 40);
      v18 = v22;
      if ( v23 == v17 )
        return 0xFFFFFFFFLL;
    }
    v12 = *(FILE **)(a1 + 120);
    v13 = v17;
    v11 = *(_QWORD *)(a1 + 48) - (_QWORD)v17;
  }
  if ( fwrite(v13, 1uLL, v11, v12) != v11 )
    return 0xFFFFFFFFLL;
LABEL_19:
  *(_QWORD *)(a1 + 48) = v10;
  *v6 = v10;
  *v8 = v7;
LABEL_20:
  if ( a2 == -1 )
    return 0LL;
  else
    return a2;
}
// 3F428: variable 'v23' is possibly undefined

//----- (000000000003F514) ----------------------------------------------------
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  *a1 = off_6E0D0;
  std::locale::~locale((std::locale *)(a1 + 1));
}
// 6E0D0: using guessed type __int64 (__fastcall *[8])();

//----- (000000000003F528) ----------------------------------------------------
void __fastcall std::streambuf::~streambuf(_QWORD *a1)
{
  *a1 = off_6E0D0;
  std::locale::~locale((std::locale *)(a1 + 1));
  operator delete(a1);
}
// 6E0D0: using guessed type __int64 (__fastcall *off_6E0D0[8])();

//----- (000000000003F564) ----------------------------------------------------
__int64 std::streambuf::seekoff()
{
  return 0LL;
}

//----- (000000000003F570) ----------------------------------------------------
__int64 std::streambuf::seekpos()
{
  return 0LL;
}

//----- (000000000003F57C) ----------------------------------------------------
__int64 std::streambuf::sync()
{
  return 0LL;
}

//----- (000000000003F584) ----------------------------------------------------
__int64 std::streambuf::underflow()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000003F58C) ----------------------------------------------------
__int64 std::streambuf::pbackfail()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000003F594) ----------------------------------------------------
__int64 std::streambuf::overflow()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000003F59C) ----------------------------------------------------
void __noreturn sub_3F59C()
{
  std::bad_cast *exception; // x19

  exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
  std::bad_cast::bad_cast(exception);
  __cxa_throw(
    exception,
    (struct type_info *)&`typeinfo for'std::bad_cast,
    (void (__fastcall *)(void *))&std::bad_cast::~bad_cast);
}

//----- (000000000003F5D0) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ifstream::~ifstream(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_6E158;
  v1[23] = off_6E180;
  std::filebuf::~filebuf((__int64)(v1 + 2));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 23));
}
// 6E158: using guessed type __int64 (__fastcall *off_6E158[2])();
// 6E180: using guessed type __int64 (__fastcall *off_6E180[2])();

//----- (000000000003F618) ----------------------------------------------------
void __fastcall std::istream::~istream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 16));
}

//----- (000000000003F620) ----------------------------------------------------
void __fastcall std::istream::~istream(__int64 a1)
{
  std::ios_base::~ios_base((std::ios_base *)(a1 + 16));
  operator delete((void *)a1);
}

//----- (000000000003F648) ----------------------------------------------------
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1)
{
  std::ios_base::~ios_base((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 16));
}

//----- (000000000003F65C) ----------------------------------------------------
void __fastcall `virtual thunk to'std::istream::~istream(_QWORD *a1)
{
  char *v1; // x19

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  std::ios_base::~ios_base((std::ios_base *)(v1 + 16));
  operator delete(v1);
}

//----- (000000000003F68C) ----------------------------------------------------
void __fastcall std::ifstream::~ifstream(_QWORD *a1)
{
  *a1 = off_6E158;
  a1[23] = off_6E180;
  std::filebuf::~filebuf((__int64)(a1 + 2));
  std::ios_base::~ios_base((std::ios_base *)(a1 + 23));
  operator delete(a1);
}
// 6E158: using guessed type __int64 (__fastcall *off_6E158[2])();
// 6E180: using guessed type __int64 (__fastcall *off_6E180[2])();

//----- (000000000003F6D4) ----------------------------------------------------
void __fastcall `virtual thunk to'std::ifstream::~ifstream(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL));
  *v1 = off_6E158;
  v1[23] = off_6E180;
  std::filebuf::~filebuf((__int64)(v1 + 2));
  std::ios_base::~ios_base((std::ios_base *)(v1 + 23));
  operator delete(v1);
}
// 6E158: using guessed type __int64 (__fastcall *off_6E158[2])();
// 6E180: using guessed type __int64 (__fastcall *off_6E180[2])();

//----- (000000000003F728) ----------------------------------------------------
__int64 __fastcall std::filebuf::basic_filebuf(__int64 a1)
{
  const std::locale *v1; // x20
  char has_facet; // w21
  _QWORD v5[2]; // [xsp+0h] [xbp-40h] BYREF

  v1 = (const std::locale *)(a1 + 8);
  v5[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)a1 = off_6E0D0;
  std::locale::locale((std::locale *)(a1 + 8));
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_BYTE *)(a1 + 162) = 0;
  *(_WORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_QWORD *)a1 = off_6E028;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  std::locale::locale((std::locale *)v5, v1);
  has_facet = std::locale::has_facet(v5, &std::codecvt<char,char,mbstate_t>::id);
  std::locale::~locale((std::locale *)v5);
  if ( (has_facet & 1) != 0 )
  {
    std::locale::locale((std::locale *)v5, v1);
    *(_QWORD *)(a1 + 128) = std::locale::use_facet(v5, &std::codecvt<char,char,mbstate_t>::id);
    std::locale::~locale((std::locale *)v5);
    *(_BYTE *)(a1 + 162) = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 128) + 56LL))(*(_QWORD *)(a1 + 128)) & 1;
  }
  return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0LL, 4096LL);
}
// 127E0: using guessed type __int64 __fastcall std::locale::has_facet(_QWORD, _QWORD);
// 12A70: using guessed type __int64 __fastcall std::locale::use_facet(_QWORD, _QWORD);
// 6E028: using guessed type __int64 (__fastcall *off_6E028[3])();
// 6E0D0: using guessed type __int64 (__fastcall *off_6E0D0[8])();

//----- (000000000003F880) ----------------------------------------------------
__int64 *__fastcall std::getline<char,std::char_traits<char>,std::allocator<char>>(__int64 *a1, __int64 a2, char a3)
{
  __int64 v3; // x8
  char *v5; // x0
  int v6; // w9
  _QWORD *v7; // x0
  __int64 i; // x22
  _QWORD *v11; // x0
  char *v12; // x8
  char v13; // w8
  int v14; // w0
  int v15; // w8

  v3 = *a1;
  v5 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  v6 = *((_DWORD *)v5 + 8);
  if ( v6 )
  {
    std::ios_base::clear((std::ios_base *)v5, v6 | 4);
    return a1;
  }
  v7 = (_QWORD *)*((_QWORD *)v5 + 17);
  if ( !v7 || (std::ostream::flush(v7), v3 = *a1, !*(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32)) )
  {
    if ( (*(_BYTE *)a2 & 1) != 0 )
    {
      **(_BYTE **)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 8) = 0LL;
    }
    else
    {
      *(_WORD *)a2 = 0;
    }
    for ( i = 0LL; ; --i )
    {
      v11 = *(_QWORD **)((char *)a1 + *(_QWORD *)(v3 - 24) + 40);
      v12 = (char *)v11[3];
      if ( v12 == (char *)v11[4] )
      {
        v14 = (*(__int64 (__fastcall **)(_QWORD *))(*v11 + 80LL))(v11);
        v13 = v14;
        if ( v14 == -1 )
        {
          if ( i )
            v15 = 2;
          else
            v15 = 6;
LABEL_21:
          std::ios_base::clear(
            (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)),
            *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v15);
          return a1;
        }
      }
      else
      {
        v11[3] = v12 + 1;
        v13 = *v12;
      }
      if ( v13 == a3 )
      {
        v15 = 0;
        goto LABEL_21;
      }
      std::string::push_back((__int64 *)a2, v13);
      if ( (*(_BYTE *)a2 & 1) != 0 && *(_QWORD *)(a2 + 8) == -17LL )
      {
        v15 = 4;
        goto LABEL_21;
      }
      v3 = *a1;
    }
  }
  return a1;
}

//----- (000000000003FA04) ----------------------------------------------------
void __fastcall std::string::push_back(__int64 *a1, char a2)
{
  unsigned __int64 v2; // x8
  __int64 v5; // x25
  size_t v6; // x21
  char *v7; // x23
  void *v8; // x22
  unsigned __int64 v9; // x8
  __int64 v10; // x24
  char *v11; // x8

  v2 = *(unsigned __int8 *)a1;
  if ( (v2 & 1) != 0 )
  {
    v5 = a1[1];
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v5 != v6 )
      goto LABEL_3;
LABEL_6:
    if ( v6 == -17LL )
      std::__basic_string_common<true>::__throw_length_error();
    if ( (v2 & 1) != 0 )
      v8 = (void *)a1[2];
    else
      v8 = (char *)a1 + 1;
    if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v10 = -17LL;
    }
    else
    {
      if ( v6 + 1 >= 2 * v6 )
        v9 = v6 + 1;
      else
        v9 = 2 * v6;
      if ( v9 >= 0x17 )
        v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v10 = 23LL;
    }
    v7 = (char *)operator new(v10);
    memcpy(v7, v8, v6);
    if ( v6 != 22 )
      operator delete(v8);
    a1[2] = (__int64)v7;
    *a1 = v10 | 1;
    goto LABEL_22;
  }
  v5 = v2 >> 1;
  v6 = 22LL;
  if ( v2 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v2 & 1) != 0 )
  {
    v7 = (char *)a1[2];
LABEL_22:
    a1[1] = v5 + 1;
    goto LABEL_23;
  }
  *(_BYTE *)a1 = 2 * v5 + 2;
  v7 = (char *)a1 + 1;
LABEL_23:
  v11 = &v7[v5];
  *v11 = a2;
  v11[1] = 0;
}

//----- (000000000003FB30) ----------------------------------------------------
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // x22
  size_t v7; // x22
  void *v8; // x8
  _BOOL4 v9; // w9
  std::bad_alloc *exception; // x19
  void *v11[2]; // [xsp+0h] [xbp-40h] BYREF

  v11[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 && a3 && 0x7FFFFFFFFFFFFFFFLL / a3 < a2 )
  {
LABEL_10:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  v6 = a3 * a2;
  if ( *(_QWORD *)(a1 + 16) * *(_QWORD *)(a1 + 8) != a3 * a2 )
  {
    free(*(void **)a1);
    if ( v6 )
    {
      if ( v6 >> 62 )
        goto LABEL_10;
      v7 = 4 * v6;
      if ( posix_memalign(v11, 0x10uLL, v7) )
      {
        v8 = 0LL;
        v9 = 1;
        v11[0] = 0LL;
        if ( v7 )
          goto LABEL_9;
      }
      else
      {
        v8 = v11[0];
        v9 = v11[0] == 0LL;
        if ( v7 )
        {
LABEL_9:
          if ( v9 )
            goto LABEL_10;
        }
      }
    }
    else
    {
      v8 = 0LL;
    }
    *(_QWORD *)a1 = v8;
  }
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
}

//----- (000000000003FC40) ----------------------------------------------------
void __fastcall std::vector<cv::Vec<unsigned char,3>>::__push_back_slow_path<cv::Vec<unsigned char,3> const&>(
        __int64 a1,
        _BYTE *a2)
{
  _BYTE *v2; // x20
  _BYTE *v3; // x22
  unsigned __int64 v4; // x23
  __int64 v7; // x24
  __int64 v8; // x0
  _BYTE *v9; // x8
  _BYTE *v10; // x10
  char v11; // t1

  v2 = *(_BYTE **)a1;
  v3 = *(_BYTE **)(a1 + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * (_QWORD)&v3[-*(_QWORD *)a1];
  if ( v4 + 1 >= 0x5555555555555556LL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * (*(_QWORD *)(a1 + 16) - (_QWORD)v2) > 0x2AAAAAAAAAAAAAA9LL )
  {
    v7 = 0x5555555555555555LL;
  }
  else
  {
    if ( 0x5555555555555556LL * (*(_QWORD *)(a1 + 16) - (_QWORD)v2) >= v4 + 1 )
      v7 = 0x5555555555555556LL * (*(_QWORD *)(a1 + 16) - (_QWORD)v2);
    else
      v7 = v4 + 1;
    if ( !v7 )
    {
      v8 = 0LL;
      goto LABEL_10;
    }
  }
  v8 = operator new(3 * v7);
LABEL_10:
  v9 = (_BYTE *)(v8 + 3 * v4);
  *v9 = *a2;
  v9[1] = a2[1];
  v9[2] = a2[2];
  v10 = v9 + 3;
  if ( v3 != v2 )
  {
    do
    {
      v11 = *(v3 - 3);
      v3 -= 3;
      *(v9 - 3) = v11;
      v9 -= 3;
      v9[1] = v3[1];
      v9[2] = v3[2];
    }
    while ( v2 != v3 );
    v2 = *(_BYTE **)a1;
  }
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v8 + 3 * v7;
  if ( v2 )
    operator delete(v2);
}

//----- (000000000003FD60) ----------------------------------------------------
void __fastcall Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21
  size_t v6; // x21
  void *v7; // x8
  _BOOL4 v8; // w9
  std::bad_alloc *exception; // x19
  void *v10[2]; // [xsp+0h] [xbp-30h] BYREF

  v10[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 && a3 && 0x7FFFFFFFFFFFFFFFLL / a3 < a2 )
  {
LABEL_10:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  v5 = a3 * a2;
  if ( *(_QWORD *)(a1 + 8) != a3 * a2 )
  {
    free(*(void **)a1);
    if ( v5 )
    {
      if ( v5 >> 62 )
        goto LABEL_10;
      v6 = 4 * v5;
      if ( posix_memalign(v10, 0x10uLL, v6) )
      {
        v7 = 0LL;
        v8 = 1;
        v10[0] = 0LL;
        if ( v6 )
          goto LABEL_9;
      }
      else
      {
        v7 = v10[0];
        v8 = v10[0] == 0LL;
        if ( v6 )
        {
LABEL_9:
          if ( v8 )
            goto LABEL_10;
        }
      }
    }
    else
    {
      v7 = 0LL;
    }
    *(_QWORD *)a1 = v7;
  }
  *(_QWORD *)(a1 + 8) = a2;
}

//----- (000000000003FE60) ----------------------------------------------------
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,1,0>::DenseStorage(_QWORD *result, unsigned __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x21
  void *v6; // x8
  _BOOL4 v7; // w9
  std::bad_alloc *exception; // x19
  void *v9[2]; // [xsp+0h] [xbp-30h] BYREF

  v4 = result;
  v9[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v6 = 0LL;
    goto LABEL_9;
  }
  if ( a2 >> 62 )
    goto LABEL_6;
  v5 = 4 * a2;
  result = (_QWORD *)posix_memalign(v9, 0x10uLL, 4 * a2);
  if ( (_DWORD)result )
  {
    v6 = 0LL;
    v7 = 1;
    v9[0] = 0LL;
    if ( !v5 )
      goto LABEL_9;
  }
  else
  {
    v6 = v9[0];
    v7 = v9[0] == 0LL;
    if ( !v5 )
      goto LABEL_9;
  }
  if ( v7 )
  {
LABEL_6:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
LABEL_9:
  *v4 = v6;
  v4[1] = a3;
  return result;
}

//----- (000000000003FF2C) ----------------------------------------------------
void __fastcall std::vector<bool>::reserve(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x21
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int128 v6; // q1
  __int64 v7; // x9
  void *v8[2]; // [xsp+0h] [xbp-60h] BYREF
  unsigned __int64 v9; // [xsp+10h] [xbp-50h]
  unsigned __int64 v10; // [xsp+18h] [xbp-48h] BYREF
  int v11; // [xsp+20h] [xbp-40h]
  __int64 v12; // [xsp+28h] [xbp-38h] BYREF
  int v13; // [xsp+30h] [xbp-30h]
  __int64 v14; // [xsp+38h] [xbp-28h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 > a1[2] << 6 )
  {
    v8[0] = 0LL;
    v8[1] = 0LL;
    v9 = 0LL;
    if ( (a2 & 0x8000000000000000LL) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v2 = ((a2 - 1) >> 6) + 1;
    v8[0] = (void *)operator new(8 * v2);
    v8[1] = 0LL;
    v4 = *a1;
    v5 = a1[1];
    v13 = 0;
    v12 = v4;
    v9 = v2;
    v10 = v4 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8LL);
    v11 = v5 & 0x3F;
    std::vector<bool>::__construct_at_end<std::__bit_iterator<std::vector<bool>,false,0ul>>(
      v8,
      (__int64)&v12,
      (__int64)&v10);
    v6 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)v8;
    *(_OWORD *)v8 = v6;
    v7 = a1[2];
    a1[2] = v9;
    v9 = v7;
    if ( (_QWORD)v6 )
      operator delete((void *)v6);
  }
}

//----- (000000000004002C) ----------------------------------------------------
_QWORD *__fastcall std::vector<bool>::__construct_at_end<std::__bit_iterator<std::vector<bool>,false,0ul>>(
        _QWORD *result,
        __int64 a2,
        __int64 a3)
{
  __int64 *v3; // x19
  __int64 v4; // x23
  __int64 v5; // x8
  __int64 v6; // x9
  unsigned __int64 v7; // x10
  __int64 v8; // x24
  unsigned __int64 v9; // x12
  _QWORD *v10; // x11
  unsigned __int64 v11; // x12
  int v12; // w10
  unsigned __int64 *v13; // x20
  __int64 v14; // x11
  __int64 v15; // t1
  unsigned __int64 v16; // x8
  __int64 v17; // x11
  __int64 v18; // x26
  unsigned __int64 *v19; // [xsp+8h] [xbp-88h] BYREF
  int v20; // [xsp+10h] [xbp-80h]
  __int64 v21; // [xsp+18h] [xbp-78h] BYREF
  int v22; // [xsp+20h] [xbp-70h]
  __int64 v23; // [xsp+28h] [xbp-68h] BYREF
  int v24; // [xsp+30h] [xbp-60h]
  __int64 *v25; // [xsp+38h] [xbp-58h] BYREF
  int v26; // [xsp+40h] [xbp-50h]
  __int64 v27; // [xsp+48h] [xbp-48h]

  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(__int64 **)a2;
  v4 = *(unsigned int *)(a2 + 8);
  v5 = *(_QWORD *)a3;
  v6 = *(unsigned int *)(a3 + 8);
  v7 = result[1];
  v8 = v6 - v4 + 8LL * (*(_QWORD *)a3 - *(_QWORD *)a2);
  v9 = v8 + v7;
  result[1] = v8 + v7;
  if ( v7 && ((v9 - 1) ^ (v7 - 1)) <= 0x3F )
  {
    v10 = (_QWORD *)*result;
  }
  else
  {
    v10 = (_QWORD *)*result;
    if ( v9 > 0x40 )
      *(_QWORD *)((char *)v10 + (((v9 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) = 0LL;
    else
      *v10 = 0LL;
  }
  v11 = v7 >> 3;
  v12 = v7 & 0x3F;
  v13 = (_QWORD *)((char *)v10 + (v11 & 0x1FFFFFFFFFFFFFF8LL));
  if ( (_DWORD)v4 == v12 )
  {
    if ( v8 >= 1 )
    {
      if ( (_DWORD)v4 )
      {
        if ( v8 >= (unsigned int)(64 - v4) )
          v14 = (unsigned int)(64 - v4);
        else
          v14 = v8;
        v15 = *v3++;
        v16 = 0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v4 - (unsigned __int8)v14);
        v8 -= v14;
        v17 = v14 + v4;
        *v13 = *v13 & ~(v16 & (-1LL << v4)) | v15 & v16 & (-1LL << v4);
        v13 += v17 / 64;
        LODWORD(v4) = v17 % 64;
      }
      if ( v8 >= 0 )
        v18 = v8;
      else
        v18 = v8 + 63;
      result = memmove(v13, v3, 8 * (v18 >> 6));
      v13 += v18 >> 6;
      if ( (__int64)(v8 - (v18 & 0xFFFFFFFFFFFFFFC0LL)) >= 1 )
      {
        LODWORD(v4) = v8 - (v18 & 0xFFFFFFC0);
        *v13 = *v13 & ~(0xFFFFFFFFFFFFFFFFLL >> (((unsigned __int8)v18 & 0xC0u) - (unsigned __int8)v8)) | v3[v18 >> 6] & (0xFFFFFFFFFFFFFFFFLL >> (((unsigned __int8)v18 & 0xC0u) - (unsigned __int8)v8));
      }
    }
    v19 = v13;
    v20 = v4;
  }
  else
  {
    v23 = v5;
    v25 = v3;
    v26 = v4;
    v24 = v6;
    v21 = (__int64)v10 + (v11 & 0x1FFFFFFFFFFFFFF8LL);
    v22 = v12;
    return (_QWORD *)std::__copy_unaligned<std::vector<bool>,false>(
                       (unsigned __int64)&v25,
                       (__int64)&v23,
                       (__int64)&v21,
                       (__int64)&v19);
  }
  return result;
}

//----- (0000000000040208) ----------------------------------------------------
unsigned __int64 __usercall std::__copy_unaligned<std::vector<bool>,false>@<X0>(
        unsigned __int64 result@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X8>)
{
  unsigned __int64 *v4; // x12
  __int64 v5; // x11
  __int64 v6; // x9
  unsigned __int64 v7; // x12
  unsigned int *v8; // x10
  __int64 v9; // x17
  unsigned __int64 v10; // x3
  unsigned __int64 *v11; // x1
  char v12; // w15
  unsigned __int64 v13; // x12
  unsigned __int64 v14; // x14
  bool v15; // cf
  bool v16; // cc
  int v17; // w11
  unsigned __int64 v18; // x15
  unsigned __int64 v19; // x11
  unsigned __int64 v20; // x6
  unsigned int v21; // w11
  unsigned __int64 *v22; // x16
  __int64 v23; // x13
  unsigned int v24; // w15
  __int64 v25; // x14
  __int64 v26; // x1
  __int64 *v27; // x3
  unsigned __int64 v28; // x12
  unsigned __int64 *v29; // x3
  unsigned __int64 v30; // x0
  char v31; // w1
  __int64 v32; // x12
  unsigned __int64 v33; // x15
  __int64 v34; // x9
  unsigned __int64 *v35; // x13
  unsigned __int64 *v36; // x9

  v4 = *(unsigned __int64 **)result;
  v5 = *(unsigned int *)(result + 8);
  v6 = *(unsigned int *)(a2 + 8) + 8LL * (*(_QWORD *)a2 - *(_QWORD *)result) - v5;
  if ( v6 <= 0 )
  {
    v21 = *(_DWORD *)(a3 + 8);
  }
  else
  {
    if ( (_DWORD)v5 )
    {
      v7 = *v4;
      v8 = (unsigned int *)(a3 + 8);
      v9 = *(unsigned int *)(a3 + 8);
      if ( v6 >= (unsigned int)(64 - v5) )
        v10 = (unsigned int)(64 - v5);
      else
        v10 = *(unsigned int *)(a2 + 8) + 8LL * (*(_QWORD *)a2 - *(_QWORD *)result) - v5;
      v11 = *(unsigned __int64 **)a3;
      v12 = v5 - v9;
      v13 = (0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v5 - (unsigned __int8)v10)) & (-1LL << v5) & v7;
      if ( v10 <= (unsigned int)(64 - v9) )
        v14 = v10;
      else
        v14 = (unsigned int)(64 - v9);
      v15 = (unsigned int)v9 >= (unsigned int)v5;
      v17 = v9 - v5;
      v16 = v17 != 0 && v15;
      v18 = v13 >> v12;
      v19 = v13 << v17;
      if ( v16 )
        v20 = v19;
      else
        v20 = v18;
      v21 = ((_BYTE)v9 + (_BYTE)v14) & 0x3F;
      v6 -= v10;
      v22 = (unsigned __int64 *)((char *)v11 + (((v14 + v9) >> 3) & 0x1FFFFFFFFFFFFFF8LL));
      *v11 = *v11 & ~((0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v9 - (unsigned __int8)v14)) & (-1LL << v9)) | v20;
      *(_QWORD *)a3 = v22;
      *v8 = v21;
      if ( (__int64)(v10 - v14) >= 1 )
      {
        *v22 = (v13 >> ((unsigned __int8)v14 + (unsigned __int8)*(_DWORD *)(result + 8))) | *v22 & ~(0xFFFFFFFFFFFFFFFFLL >> ((unsigned __int8)v14 - (unsigned __int8)v10));
        v21 = v10 - v14;
        *v8 = v10 - v14;
      }
      v4 = (unsigned __int64 *)(*(_QWORD *)result + 8LL);
      *(_QWORD *)result = v4;
    }
    else
    {
      v8 = (unsigned int *)(a3 + 8);
      v21 = *(_DWORD *)(a3 + 8);
    }
    v23 = v21;
    v24 = 64 - v21;
    v25 = -1LL << v21;
    if ( v6 >= 64 )
    {
      v26 = v6;
      do
      {
        v27 = *(__int64 **)a3;
        v28 = *v4;
        v26 -= 64LL;
        *v27++ = **(_QWORD **)a3 & ~v25 | (v28 << v21);
        *(_QWORD *)a3 = v27;
        *v27 = *v27 & v25 | (v28 >> v24);
        v4 = (unsigned __int64 *)(*(_QWORD *)result + 8LL);
        *(_QWORD *)result = v4;
      }
      while ( v26 > 63 );
      v6 &= 0x3Fu;
    }
    if ( v6 >= 1 )
    {
      v29 = *(unsigned __int64 **)a3;
      v30 = *v4;
      v31 = 64 - v21;
      if ( v6 <= v24 )
        v32 = v6;
      else
        v32 = v24;
      v33 = v30 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v6);
      v34 = v6 - v32;
      result = v33 << v21;
      v21 = (v21 + v32) & 0x3F;
      v35 = (unsigned __int64 *)((char *)v29 + (((unsigned __int64)(v32 + v23) >> 3) & 0x1FFFFFFFFFFFFFF8LL));
      *v29 = *v29 & ~((0xFFFFFFFFFFFFFFFFLL >> (v31 - (unsigned __int8)v32)) & v25) | result;
      *(_QWORD *)a3 = v35;
      *(_DWORD *)(a3 + 8) = v21;
      if ( v34 >= 1 )
      {
        *v35 = *v35 & ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v34) | (v33 >> v32);
        v21 = v34;
        *v8 = v34;
      }
    }
  }
  v36 = *(unsigned __int64 **)a3;
  *(_DWORD *)(a4 + 8) = v21;
  *(_QWORD *)a4 = v36;
  return result;
}

//----- (0000000000040448) ----------------------------------------------------
void __fastcall std::vector<std::vector<Eigen::Matrix<float,3,1,0,3,1>>>::__push_back_slow_path<std::vector<Eigen::Matrix<float,3,1,0,3,1>> const&>(
        signed __int64 **a1,
        char **a2)
{
  unsigned __int64 v2; // x20
  __int64 v3; // x23
  __int64 v6; // x22
  signed __int64 *v7; // x20
  signed __int64 *v8; // x10
  signed __int64 *v9; // x12
  signed __int64 *v10; // x9
  char *v11; // x11
  char *v12; // x10
  signed __int64 *v13; // x13
  signed __int64 *v14; // x14
  __int128 v15; // q0
  signed __int64 *v16; // x21
  signed __int64 *v17; // x19
  void *v18; // x0
  void *v19; // t1

  v2 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  v3 = 0xAAAAAAAAAAAAAAALL;
  if ( v2 + 1 > 0xAAAAAAAAAAAAAAALL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) > 0x555555555555554LL
    || (0x5555555555555556LL * (a1[2] - *a1) >= v2 + 1 ? (v3 = 0x5555555555555556LL * (a1[2] - *a1)) : (v3 = v2 + 1), v3) )
  {
    v6 = operator new(24 * v3);
  }
  else
  {
    v6 = 0LL;
  }
  v7 = (signed __int64 *)(v6 + 24 * v2);
  std::vector<Eigen::Matrix<float,3,1,0,3,1>>::vector(v7, a2);
  v8 = *a1;
  v9 = a1[1];
  v10 = v7 + 3;
  if ( v9 == *a1 )
  {
    v16 = *a1;
  }
  else
  {
    v11 = 0LL;
    v12 = (char *)((char *)v8 - (char *)v9);
    do
    {
      v13 = (signed __int64 *)&v11[(_QWORD)v7];
      v14 = (signed __int64 *)&v11[(_QWORD)v9];
      *(v13 - 2) = 0LL;
      *(v13 - 1) = 0LL;
      *(v13 - 3) = 0LL;
      v15 = *(_OWORD *)&v11[(_QWORD)v9 - 24];
      v11 -= 24;
      *(_OWORD *)(v13 - 3) = v15;
      *(v13 - 1) = *(v14 - 1);
      *(v14 - 3) = 0LL;
      *(v14 - 2) = 0LL;
      *(v14 - 1) = 0LL;
    }
    while ( v12 != v11 );
    v16 = *a1;
    v8 = a1[1];
    v7 = (signed __int64 *)&v11[(_QWORD)v7];
  }
  *a1 = v7;
  a1[1] = v10;
  a1[2] = (signed __int64 *)(v6 + 24 * v3);
  if ( v8 != v16 )
  {
    v17 = v8;
    do
    {
      v19 = (void *)*(v17 - 3);
      v17 -= 3;
      v18 = v19;
      if ( v19 )
      {
        *(v8 - 2) = (signed __int64)v18;
        operator delete(v18);
      }
      v8 = v17;
    }
    while ( v16 != v17 );
  }
  if ( v16 )
    operator delete(v16);
}

//----- (00000000000405D4) ----------------------------------------------------
void __fastcall std::vector<cv::Point_<int>>::__push_back_slow_path<cv::Point_<int>>(__int64 a1, _QWORD *a2)
{
  char *v2; // x20
  char *v3; // x22
  __int64 v5; // x23
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x24
  __int64 v10; // x0
  _QWORD *v11; // x10
  _QWORD *v12; // x9
  __int64 v13; // x11
  _DWORD *v14; // x12
  int v15; // t1

  v2 = *(char **)a1;
  v3 = *(char **)(a1 + 8);
  v5 = (__int64)&v3[-*(_QWORD *)a1] >> 3;
  if ( (unsigned __int64)(v5 + 1) >> 61 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 3) > 0xFFFFFFFFFFFFFFELL )
  {
    v9 = 0x1FFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = operator new(8 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 2;
  if ( v8 >= v5 + 1 )
    v9 = v8;
  else
    v9 = v5 + 1;
  if ( v9 )
  {
    if ( v9 >> 61 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = (_QWORD *)(v10 + 8 * v5);
  *v11 = *a2;
  v12 = v11 + 1;
  if ( v3 != v2 )
  {
    v13 = v3 - 8 - v2;
    v14 = (_DWORD *)v11 - 1;
    do
    {
      v15 = *((_DWORD *)v3 - 2);
      v3 -= 8;
      *(v14 - 1) = v15;
      *v14 = *((_DWORD *)v3 + 1);
      v14 -= 2;
    }
    while ( v2 != v3 );
    v11 = (_QWORD *)((char *)v11 + (~v13 & 0xFFFFFFFFFFFFFFF8LL));
  }
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = v10 + 8 * v9;
  if ( v2 )
    operator delete(v2);
}

//----- (00000000000406E0) ----------------------------------------------------
void __fastcall sub_406E0(_BYTE **a1, _DWORD *a2)
{
  char *v2; // x8
  char *v3; // x22
  char *v6; // x10
  _BYTE *v7; // x21
  char *v8; // x23
  __int64 v9; // x9
  __int64 v10; // x8
  __int64 v11; // x8
  __int64 v12; // x9
  char *v13; // x8
  __int64 v14; // x10
  signed __int64 v15; // x9
  __int64 v16; // x10
  char *v17; // x11
  int v18; // w13
  int v19; // w12
  int v20; // w13
  int v21; // w12
  int v22; // w13
  int v23; // w12
  int v24; // w13
  bool v25; // zf
  __int64 v26; // x8
  __int64 v27; // x8
  unsigned __int64 v28; // x24
  _BYTE *v29; // x0
  unsigned __int64 v30; // x10
  _BYTE *v31; // x11
  int v32; // w12

  v3 = a1[2];
  v2 = a1[3];
  v6 = v3;
  if ( v3 == v2 )
  {
    v7 = *a1;
    v8 = a1[1];
    v9 = v8 - *a1;
    if ( v8 <= *a1 )
    {
      v26 = v2 - v7;
      v25 = v26 == 0;
      v27 = v26 >> 3;
      if ( v25 )
        v28 = 1LL;
      else
        v28 = v27;
      if ( v28 )
      {
        if ( v28 >> 60 )
          sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v29 = (_BYTE *)operator new(16 * v28);
      }
      else
      {
        v29 = 0LL;
      }
      if ( v8 == v3 )
      {
        v6 = &v29[16 * (v28 >> 2)];
      }
      else
      {
        v30 = (v28 >> 2) + ((unsigned __int64)(v3 - 16 - v8) >> 4) + 1;
        v31 = &v29[16 * (v28 >> 2)];
        do
        {
          *(_OWORD *)v31 = *(_OWORD *)v8;
          *(_DWORD *)v31 = *(_DWORD *)v8;
          *((_DWORD *)v31 + 1) = *((_DWORD *)v8 + 1);
          *((_DWORD *)v31 + 2) = *((_DWORD *)v8 + 2);
          v32 = *((_DWORD *)v8 + 3);
          v8 += 16;
          *((_DWORD *)v31 + 3) = v32;
          v31 += 16;
        }
        while ( v8 != v3 );
        v7 = *a1;
        v6 = &v29[16 * v30];
      }
      *a1 = v29;
      a1[1] = &v29[16 * (v28 >> 2)];
      a1[2] = v6;
      a1[3] = &v29[16 * v28];
      if ( v7 )
      {
        operator delete(v7);
        v6 = a1[2];
      }
    }
    else
    {
      v10 = v9 >> 4;
      if ( (v9 >> 4) + 1 >= 0 )
        v11 = v10 + 1;
      else
        v11 = v10 + 2;
      v12 = v11 >> 1;
      v13 = &v8[-16 * (v11 >> 1)];
      v6 = v13;
      if ( v8 != v3 )
      {
        v14 = -v12;
        v15 = v3 - 16 - v8;
        v16 = 16 * v14;
        do
        {
          v17 = &v8[v16];
          v18 = *(_DWORD *)v8;
          *(_DWORD *)v8 = *(_DWORD *)&v8[v16];
          v19 = *(_DWORD *)&v8[v16 + 4];
          *(_DWORD *)v17 = v18;
          v20 = *((_DWORD *)v8 + 1);
          *((_DWORD *)v8 + 1) = v19;
          v21 = *(_DWORD *)&v8[v16 + 8];
          *((_DWORD *)v17 + 1) = v20;
          v22 = *((_DWORD *)v8 + 2);
          *((_DWORD *)v8 + 2) = v21;
          v23 = *(_DWORD *)&v8[v16 + 12];
          *((_DWORD *)v17 + 2) = v22;
          v24 = *((_DWORD *)v8 + 3);
          *((_DWORD *)v8 + 3) = v23;
          v8 += 16;
          *((_DWORD *)v17 + 3) = v24;
        }
        while ( v3 != v8 );
        v6 = &v13[(v15 & 0xFFFFFFFFFFFFFFF0LL) + 16];
      }
      a1[1] = v13;
      a1[2] = v6;
    }
  }
  *(_DWORD *)v6 = *a2;
  *((_DWORD *)v6 + 1) = a2[1];
  *((_DWORD *)v6 + 2) = a2[2];
  *((_DWORD *)v6 + 3) = a2[3];
  a1[2] = v6 + 16;
}

//----- (00000000000408AC) ----------------------------------------------------
void __fastcall std::vector<cv::Vec<int,4>>::__push_back_slow_path<cv::Vec<int,4> const&>(__int64 a1, _OWORD *a2)
{
  char *v2; // x20
  char *v3; // x22
  __int64 v5; // x23
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x24
  __int64 v10; // x0
  _OWORD *v11; // x10
  _OWORD *v12; // x9
  signed __int64 v13; // x11
  _DWORD *v14; // x12
  int v15; // t1

  v2 = *(char **)a1;
  v3 = *(char **)(a1 + 8);
  v5 = (__int64)&v3[-*(_QWORD *)a1] >> 4;
  if ( (unsigned __int64)(v5 + 1) >> 60 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 4) > 0x7FFFFFFFFFFFFFELL )
  {
    v9 = 0xFFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = operator new(16 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 3;
  if ( v8 >= v5 + 1 )
    v9 = v8;
  else
    v9 = v5 + 1;
  if ( v9 )
  {
    if ( v9 >> 60 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = (_OWORD *)(v10 + 16 * v5);
  *v11 = *a2;
  v12 = v11 + 1;
  if ( v3 != v2 )
  {
    v13 = v3 - 16 - v2;
    v14 = (_DWORD *)v11 - 2;
    do
    {
      v15 = *((_DWORD *)v3 - 4);
      v3 -= 16;
      *(v14 - 2) = v15;
      *(v14 - 1) = *((_DWORD *)v3 + 1);
      *v14 = *((_DWORD *)v3 + 2);
      v14[1] = *((_DWORD *)v3 + 3);
      v14 -= 4;
    }
    while ( v2 != v3 );
    v11 = (_OWORD *)((char *)v11 + (~v13 & 0xFFFFFFFFFFFFFFF0LL));
  }
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = v10 + 16 * v9;
  if ( v2 )
    operator delete(v2);
}

//----- (00000000000409CC) ----------------------------------------------------
void __fastcall std::vector<Eigen::Matrix<float,4,1,0,4,1>>::__push_back_slow_path<Eigen::Matrix<float,4,1,0,4,1>>(
        __int64 a1,
        _OWORD *a2)
{
  char *v2; // x20
  char *v3; // x22
  __int64 v5; // x23
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x24
  __int64 v10; // x0
  _OWORD *v11; // x9
  _OWORD *v12; // x10
  signed __int64 v13; // x11
  _DWORD *v14; // x12
  int v15; // t1

  v2 = *(char **)a1;
  v3 = *(char **)(a1 + 8);
  v5 = (__int64)&v3[-*(_QWORD *)a1] >> 4;
  if ( (unsigned __int64)(v5 + 1) >> 60 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 4) > 0x7FFFFFFFFFFFFFELL )
  {
    v9 = 0xFFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = operator new(16 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 3;
  if ( v8 >= v5 + 1 )
    v9 = v8;
  else
    v9 = v5 + 1;
  if ( v9 )
  {
    if ( v9 >> 60 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = (_OWORD *)(v10 + 16 * v5);
  *v11 = *a2;
  *v11 = *a2;
  v12 = v11 + 1;
  if ( v3 != v2 )
  {
    v13 = v3 - 16 - v2;
    v14 = (_DWORD *)v11 - 2;
    do
    {
      v15 = *((_DWORD *)v3 - 4);
      v3 -= 16;
      *(v14 - 2) = v15;
      *(v14 - 1) = *((_DWORD *)v3 + 1);
      *v14 = *((_DWORD *)v3 + 2);
      v14[1] = *((_DWORD *)v3 + 3);
      v14 -= 4;
    }
    while ( v2 != v3 );
    v11 = (_OWORD *)((char *)v11 + (~v13 & 0xFFFFFFFFFFFFFFF0LL));
  }
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = v10 + 16 * v9;
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000040AF4) ----------------------------------------------------
feasibal_region *__fastcall feasibal_region::feasibal_region::feasibal_region(feasibal_region::feasibal_region *this)
{
  feasibal_region *result; // x0

  *((_QWORD *)this + 2) = 0LL;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 5) = 0x3FECBC6A7EF9DB23LL;
  *(_OWORD *)this = xmmword_54DC0;
  feasibal_region::PreParamInfo::PreParamInfo((feasibal_region::feasibal_region *)((char *)this + 48));
  *((_QWORD *)this + 77) = 0LL;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((_WORD *)this + 296) = 0;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 34) = 0u;
  result = (feasibal_region *)operator new(0x30uLL);
  *((_QWORD *)this + 77) = result;
  *(_OWORD *)((char *)this + 600) = xmmword_54DD0;
  strcpy((char *)result, "/sdcard/pudu/config/PreParamInfo.config");
  *((_QWORD *)this + 78) = 0LL;
  return result;
}
// 54DC0: using guessed type __int128 xmmword_54DC0;
// 54DD0: using guessed type __int128 xmmword_54DD0;

//----- (0000000000040BB8) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::WriteCameraParam(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v4; // x20
  unsigned int v5; // w19
  const char *v6; // x20
  size_t v7; // x0
  size_t v8; // x19
  char *v9; // x21
  unsigned __int64 v10; // x22
  char v11; // w19
  struct _Unwind_Exception *v13; // x19
  char v14; // [xsp+0h] [xbp-1F0h] BYREF
  char v15[15]; // [xsp+1h] [xbp-1EFh] BYREF
  void *v16; // [xsp+10h] [xbp-1E0h]
  int v17; // [xsp+18h] [xbp-1D8h] BYREF
  unsigned __int64 v18; // [xsp+20h] [xbp-1D0h] BYREF
  size_t v19; // [xsp+28h] [xbp-1C8h]
  void *v20; // [xsp+30h] [xbp-1C0h]
  char v21[56]; // [xsp+38h] [xbp-1B8h] BYREF
  __int128 v22; // [xsp+70h] [xbp-180h] BYREF
  void *v23; // [xsp+80h] [xbp-170h]
  __int64 v24; // [xsp+1B8h] [xbp-38h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v22 = 0uLL;
  v23 = 0LL;
  cv::FileStorage::FileStorage(v21, a2, 1LL, &v22);
  if ( (v22 & 1) != 0 )
    operator delete(v23);
  if ( (cv::FileStorage::isOpened((cv::FileStorage *)v21) & 1) == 0 )
  {
    if ( (word_6FFC0 & 1) != 0 )
      v6 = (const char *)qword_6FFD0;
    else
      v6 = (char *)&word_6FFC0 + 1;
    v17 = dword_6FFB8;
    v19 = 0LL;
    v20 = 0LL;
    v18 = 0LL;
    v7 = strlen(v6);
    if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v8 = v7;
    if ( v7 >= 0x17 )
    {
      v10 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v9 = (char *)operator new(v10);
      v19 = v8;
      v20 = v9;
      v18 = v10 | 1;
    }
    else
    {
      v9 = (char *)&v18 + 1;
      LOBYTE(v18) = 2 * v7;
      if ( !v7 )
      {
LABEL_19:
        v9[v8] = 0;
        if ( (g3::logLevel(&v17) & 1) != 0 )
        {
          *(_QWORD *)&v15[7] = 0LL;
          v16 = 0LL;
          v14 = 12;
          strcpy(v15, "region");
          v11 = g3::logTag(&v14);
          if ( (v14 & 1) == 0 )
          {
            if ( (v18 & 1) == 0 )
              goto LABEL_22;
LABEL_25:
            operator delete(v20);
            if ( (v11 & 1) != 0 )
              goto LABEL_23;
            goto LABEL_26;
          }
          operator delete(v16);
          if ( (v18 & 1) != 0 )
            goto LABEL_25;
        }
        else
        {
          v11 = 0;
          if ( (v18 & 1) != 0 )
            goto LABEL_25;
        }
LABEL_22:
        if ( (v11 & 1) != 0 )
        {
LABEL_23:
          LogCapture::LogCapture((LogCapture *)&v22, "region", (const LEVELS *)&dword_6FFB8, "", 6, 0LL);
          LogCapture::capturef((LogCapture *)&v22, "write could not open file\n");
          LogCapture::~LogCapture((LogCapture *)&v22);
          v5 = -1;
          goto LABEL_30;
        }
LABEL_26:
        v5 = -1;
        goto LABEL_30;
      }
    }
    memcpy(v9, v6, v8);
    goto LABEL_19;
  }
  v23 = 0LL;
  LOBYTE(v22) = 26;
  *(_QWORD *)((char *)&v22 + 6) = *(_QWORD *)"a_matrix";
  *(_QWORD *)((char *)&v22 + 1) = *(_QWORD *)"camera_matrix";
  HIWORD(v22) = 0;
  v4 = (_DWORD *)cv::operator<<(v21, &v22);
  if ( (v22 & 1) != 0 )
    operator delete(v23);
  if ( ((*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v4 + 24LL))(v4) & 1) == 0 )
    goto LABEL_9;
  if ( v4[2] == 6 )
  {
    v23 = (void *)operator new(0x20uLL);
    v22 = xmmword_53EB0;
    strcpy((char *)v23, "No element name has been given");
    v13 = (struct _Unwind_Exception *)cv::error(
                                        4294967294LL,
                                        &v22,
                                        "operator<<",
                                        "D:/project/MirRGBDApp/RGBDLib/src/main/jni/cppbase/include/opencv\\opencv2/core/persistence.hpp",
                                        1207LL);
    if ( (v22 & 1) != 0 )
      operator delete(v23);
    cv::FileStorage::~FileStorage((cv::FileStorage *)v21);
    _Unwind_Resume(v13);
  }
  cv::write(v4, v4 + 4, a3);
  if ( (v4[2] & 4) != 0 )
  {
    v5 = 0;
    v4[2] = 6;
  }
  else
  {
LABEL_9:
    v5 = 0;
  }
LABEL_30:
  cv::FileStorage::~FileStorage((cv::FileStorage *)v21);
  return v5;
}
// 12630: using guessed type __int64 __fastcall cv::FileStorage::FileStorage(_QWORD, _QWORD, _QWORD, _QWORD);
// 127A0: using guessed type __int64 __fastcall cv::write(_QWORD, _QWORD, _QWORD);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 12FD0: using guessed type __int64 __fastcall cv::operator<<(_QWORD, _QWORD);
// 13350: using guessed type __int64 __fastcall cv::error(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 53EB0: using guessed type __int128 xmmword_53EB0;
// 6FFB8: using guessed type int dword_6FFB8;
// 6FFC0: using guessed type __int16 word_6FFC0;
// 6FFD0: using guessed type __int64 qword_6FFD0;

//----- (0000000000040F3C) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::readParam(float32x2_t *a1, __int64 a2)
{
  int v3; // w3
  int v4; // w3
  int v5; // w3
  float *v6; // x2
  float *v7; // x2
  float *v8; // x2
  float *v9; // x2
  float *v10; // x2
  int v11; // w3
  int v12; // w3
  int v13; // w3
  int v14; // w3
  int v15; // w3
  int v16; // w3
  float v17; // s1
  double *v18; // x8
  cv *v19; // x11
  float v20; // s0
  double v21; // d8
  double v22; // d2
  signed __int32 v23; // s1
  __int64 v24; // x9
  char *v25; // x11
  float v26; // s0
  double *v27; // x10
  cv *v28; // x12
  double v29; // d1
  __int64 v30; // x12
  double *v31; // x13
  double v32; // d1
  double v33; // d0
  float v34; // s1
  float v35; // s0
  float v36; // s2
  float v37; // s2
  float v38; // s2
  float v39; // s2
  float v40; // s2
  float v41; // s2
  double v42; // d2
  double *v43; // x8
  double *v44; // x9
  double v45; // d2
  float v46; // s1
  double v47; // d1
  float v48; // s0
  float v49; // s0
  float v50; // s0
  float v51; // s0
  float v52; // s0
  float v53; // s0
  float v54; // s0
  double *v55; // x8
  __int64 v56; // x9
  float v57; // s0
  float v58; // s0
  float v59; // s0
  float v60; // s0
  float v61; // s0
  float v62; // s0
  float v63; // s0
  double *v64; // x11
  float v65; // s0
  double *v66; // x8
  float v67; // s0
  float v68; // s0
  float v69; // s0
  float v70; // s0
  float v71; // s0
  float v72; // s0
  float v73; // s0
  float v74; // s0
  double *v75; // x8
  __int64 v76; // x9
  float v77; // s0
  float v78; // s0
  float v79; // s0
  float v80; // s0
  float v81; // s0
  float v82; // s0
  float v83; // s0
  double *v84; // x11
  float v85; // s0
  double *v86; // x8
  float v87; // s0
  float v88; // s0
  float v89; // s0
  float v90; // s0
  float v91; // s0
  float v92; // s0
  float v93; // s0
  float v94; // s0
  const char *v95; // x21
  size_t v96; // x0
  size_t v97; // x19
  char *v98; // x22
  const char *v99; // x20
  size_t v100; // x0
  size_t v101; // x19
  char *v102; // x21
  unsigned __int64 v103; // x22
  char v104; // w19
  unsigned int v105; // w19
  char v106; // w19
  double v107; // d11
  __int64 v108; // x8
  double v109; // d10
  double v110; // d12
  double v111; // d9
  const char *v112; // x20
  size_t v113; // x0
  size_t v114; // x19
  char *v115; // x21
  unsigned __int64 v116; // x22
  void *v117; // x1
  char v118; // w19
  float v119; // s0
  float v120; // s4
  float v121; // s1
  float v122; // s3
  __int64 v123; // x8
  unsigned int *v124; // x8
  unsigned int v125; // w9
  unsigned int v126; // w9
  _DWORD *v127; // x8
  __int64 v128; // x9
  unsigned int *v129; // x8
  unsigned int v130; // w9
  unsigned int v131; // w9
  _DWORD *v132; // x8
  __int64 v133; // x9
  unsigned int *v134; // x8
  unsigned int v135; // w9
  unsigned int v136; // w9
  _QWORD *v137; // x8
  __int64 v138; // x9
  unsigned int *v139; // x8
  unsigned int v140; // w9
  unsigned int v141; // w9
  _DWORD *v142; // x8
  __int64 v143; // x9
  unsigned int *v144; // x8
  unsigned int v145; // w9
  unsigned int v146; // w9
  _DWORD *v147; // x8
  __int64 v148; // x9
  double v150; // [xsp+10h] [xbp-4E0h]
  float *v151; // [xsp+28h] [xbp-4C8h]
  char v152; // [xsp+48h] [xbp-4A8h] BYREF
  char v153[15]; // [xsp+49h] [xbp-4A7h] BYREF
  void *v154; // [xsp+58h] [xbp-498h]
  int v155; // [xsp+60h] [xbp-490h] BYREF
  unsigned __int64 v156; // [xsp+68h] [xbp-488h] BYREF
  size_t v157; // [xsp+70h] [xbp-480h]
  void *v158; // [xsp+78h] [xbp-478h]
  char v159; // [xsp+80h] [xbp-470h] BYREF
  char v160[15]; // [xsp+81h] [xbp-46Fh] BYREF
  void *v161; // [xsp+90h] [xbp-460h]
  int v162; // [xsp+98h] [xbp-458h] BYREF
  unsigned __int64 v163; // [xsp+A0h] [xbp-450h] BYREF
  size_t v164; // [xsp+A8h] [xbp-448h]
  void *v165; // [xsp+B0h] [xbp-440h]
  char v166; // [xsp+B8h] [xbp-438h] BYREF
  char v167[15]; // [xsp+B9h] [xbp-437h] BYREF
  void *v168; // [xsp+C8h] [xbp-428h]
  int v169; // [xsp+D0h] [xbp-420h] BYREF
  unsigned __int64 v170; // [xsp+D8h] [xbp-418h] BYREF
  size_t v171; // [xsp+E0h] [xbp-410h]
  void *v172; // [xsp+E8h] [xbp-408h]
  char v173[56]; // [xsp+F0h] [xbp-400h] BYREF
  int v174[2]; // [xsp+128h] [xbp-3C8h] BYREF
  _QWORD v175[8]; // [xsp+130h] [xbp-3C0h] BYREF
  _DWORD *v176; // [xsp+170h] [xbp-380h]
  cv *v177; // [xsp+178h] [xbp-378h]
  __int64 v178[2]; // [xsp+180h] [xbp-370h] BYREF
  _QWORD v179[8]; // [xsp+190h] [xbp-360h] BYREF
  _DWORD *v180; // [xsp+1D0h] [xbp-320h]
  cv *v181; // [xsp+1D8h] [xbp-318h]
  __int64 v182[2]; // [xsp+1E0h] [xbp-310h] BYREF
  _QWORD v183[8]; // [xsp+1F0h] [xbp-300h] BYREF
  _QWORD *v184; // [xsp+230h] [xbp-2C0h]
  cv *v185; // [xsp+238h] [xbp-2B8h]
  __int64 v186[2]; // [xsp+240h] [xbp-2B0h] BYREF
  _QWORD v187[8]; // [xsp+250h] [xbp-2A0h] BYREF
  _DWORD *v188; // [xsp+290h] [xbp-260h]
  cv *v189; // [xsp+298h] [xbp-258h]
  __int64 v190[2]; // [xsp+2A0h] [xbp-250h] BYREF
  _BYTE v191[64]; // [xsp+2B0h] [xbp-240h] BYREF
  _DWORD *v192; // [xsp+2F0h] [xbp-200h]
  cv *v193; // [xsp+2F8h] [xbp-1F8h]
  __int64 v194[2]; // [xsp+300h] [xbp-1F0h] BYREF
  _QWORD v195[44]; // [xsp+310h] [xbp-1E0h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  memset(v195, 0, 24);
  cv::FileStorage::FileStorage(v173, a2, 0LL, v195);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  if ( (cv::FileStorage::isOpened((cv::FileStorage *)v173) & 1) == 0 )
  {
    if ( (word_6FFC0 & 1) != 0 )
      v99 = (const char *)qword_6FFD0;
    else
      v99 = (char *)&word_6FFC0 + 1;
    v169 = dword_6FFB8;
    v171 = 0LL;
    v172 = 0LL;
    v170 = 0LL;
    v100 = strlen(v99);
    if ( v100 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v101 = v100;
    if ( v100 >= 0x17 )
    {
      v103 = (v100 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v102 = (char *)operator new(v103);
      v171 = v101;
      v172 = v102;
      v170 = v103 | 1;
    }
    else
    {
      v102 = (char *)&v170 + 1;
      LOBYTE(v170) = 2 * v100;
      if ( !v100 )
      {
LABEL_100:
        v102[v101] = 0;
        if ( (g3::logLevel(&v169) & 1) != 0 )
        {
          *(_QWORD *)&v167[7] = 0LL;
          v168 = 0LL;
          v166 = 12;
          strcpy(v167, "region");
          v104 = g3::logTag(&v166);
          if ( (v166 & 1) == 0 )
          {
            if ( (v170 & 1) == 0 )
              goto LABEL_103;
LABEL_106:
            operator delete(v172);
            if ( (v104 & 1) == 0 )
            {
LABEL_108:
              v105 = -1;
              goto LABEL_187;
            }
LABEL_107:
            LogCapture::LogCapture((LogCapture *)v195, "region", (const LEVELS *)&dword_6FFB8, "", 6, 0LL);
            LogCapture::capturef((LogCapture *)v195, "read could not open file\n");
            LogCapture::~LogCapture((LogCapture *)v195);
            goto LABEL_108;
          }
          operator delete(v168);
          if ( (v170 & 1) != 0 )
            goto LABEL_106;
        }
        else
        {
          v104 = 0;
          if ( (v170 & 1) != 0 )
            goto LABEL_106;
        }
LABEL_103:
        if ( (v104 & 1) == 0 )
          goto LABEL_108;
        goto LABEL_107;
      }
    }
    memcpy(v102, v99, v101);
    goto LABEL_100;
  }
  strcpy(&v191[17], "nsic");
  *(_WORD *)&v191[22] = 0;
  strcpy(v191, "(use_static_extr");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)v187, 0LL, v3);
    a1[6].n64_u8[0] = LODWORD(v187[0]) != 0;
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  memset(v191, 0, 24);
  *(_QWORD *)&v191[16] = operator new(0x20uLL);
  *(_OWORD *)v191 = xmmword_54DE0;
  strcpy(*(char **)&v191[16], "use_static_camera_matrix");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)v187, 0LL, v4);
    a1[74].n64_u8[1] = LODWORD(v187[0]) != 0;
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  BYTE1(v195[1]) = 101;
  WORD1(v195[1]) = 0;
  HIDWORD(v195[1]) = 0;
  v195[2] = 0LL;
  LOBYTE(v195[0]) = 18;
  strcpy((char *)v195 + 1, "mask_fi");
  feasibal_region::feasibal_region::attemtpRead<std::string>(
    (__int64)a1,
    (__int64)v195,
    (__int64)&a1[64],
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v191[0] = 18;
  v191[9] = 101;
  *(_WORD *)&v191[10] = 0;
  *(_DWORD *)&v191[12] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  strcpy(&v191[1], "near_ed");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)((char *)&a1[67] + 4), 0LL, v5);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  *(_QWORD *)&v191[8] = 0LL;
  *(_QWORD *)&v191[16] = 0LL;
  *(_QWORD *)v191 = 0x61646D616C0ALL;
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)&a1[11], v6, 0.0);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  *(_QWORD *)&v191[8] = 0LL;
  *(_QWORD *)&v191[16] = 0LL;
  *(_QWORD *)v191 = 8020996LL;
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)&a1[9], v7, 0.0);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[9] = 0;
  *(_WORD *)&v191[10] = 0;
  *(_DWORD *)&v191[12] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  v191[0] = 16;
  strcpy(&v191[1], "region_");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)&a1[7], v8, 0.0);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[9] = 0;
  *(_WORD *)&v191[10] = 0;
  *(_DWORD *)&v191[12] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  v191[0] = 16;
  strcpy(&v191[1], "region_");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)((char *)&a1[7] + 4), v9, 0.0);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  strcpy(&v191[17], "on");
  *(_DWORD *)&v191[20] = 0;
  strcpy(v191, "$angular_resolut");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)((char *)&a1[8] + 4), v10, 0.0);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[0] = 22;
  strcpy(&v191[9], "dth");
  v191[13] = 0;
  *(_WORD *)&v191[14] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  strcpy(&v191[1], "image_w");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)((char *)&a1[39] + 4), 0LL, v11);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[0] = 22;
  strcpy(&v191[9], "ght");
  v191[13] = 0;
  *(_WORD *)&v191[14] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  strcpy(&v191[1], "image_h");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)&a1[39], 0LL, v12);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  strcpy(&v191[9], "ze");
  *(_DWORD *)&v191[12] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  v191[0] = 20;
  strcpy(&v191[1], "patch_s");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)((char *)&a1[38] + 4), 0LL, v13);
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[0] = 18;
  v191[9] = 100;
  *(_WORD *)&v191[10] = 0;
  *(_DWORD *)&v191[12] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  strcpy(&v191[1], "hand_ho");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)v187, 0LL, v14);
    a1[11].n64_u8[4] = LODWORD(v187[0]) != 0;
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  v191[17] = 0;
  *(_WORD *)&v191[18] = 0;
  *(_DWORD *)&v191[20] = 0;
  v191[0] = 30;
  strcpy(&v191[1], "invaild_discard");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)v187, 0LL, v15);
    a1[67].n64_u8[0] = LODWORD(v187[0]) != 0;
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  strcpy(&v191[9], "data");
  *(_WORD *)&v191[14] = 0;
  *(_QWORD *)&v191[16] = 0LL;
  v191[0] = 24;
  strcpy(&v191[1], "record_");
  cv::FileStorage::operator[](v195, v173);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v195) )
  {
    cv::FileStorage::operator[](v195, v173);
    cv::read((cv *)v195, (const cv::FileNode *)v187, 0LL, v16);
    a1[67].n64_u8[1] = LODWORD(v187[0]) != 0;
  }
  if ( (v191[0] & 1) != 0 )
    operator delete(*(void **)&v191[16]);
  *(_DWORD *)v191 = 1124007936;
  memset(&v191[4], 0, 60);
  memset(v195, 0, 32);
  LODWORD(v187[0]) = 1124007936;
  memset((char *)v187 + 4, 0, 60);
  v192 = &v191[8];
  v193 = (cv *)v194;
  v194[1] = 0LL;
  v194[0] = 0LL;
  v188 = &v187[1];
  v189 = (cv *)v190;
  v190[1] = 0LL;
  v190[0] = 0LL;
  *(_QWORD *)v174 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v187, 2, v174, 6);
  cv::Mat::operator=(v187, v195);
  LODWORD(v183[0]) = 1124007936;
  memset(v195, 0, 32);
  memset((char *)v183 + 4, 0, 60);
  v184 = &v183[1];
  v185 = (cv *)v186;
  v186[1] = 0LL;
  v186[0] = 0LL;
  *(_QWORD *)v174 = 0x300000003LL;
  cv::Mat::create((cv::Mat *)v183, 2, v174, 6);
  cv::Mat::operator=(v183, v195);
  v151 = (float *)&a1[9];
  LODWORD(v179[0]) = 1124007936;
  memset(v195, 0, 32);
  memset((char *)v179 + 4, 0, 60);
  v180 = &v179[1];
  v181 = (cv *)v182;
  v182[0] = 0LL;
  v182[1] = 0LL;
  *(_QWORD *)v174 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v179, 2, v174, 6);
  cv::Mat::operator=(v179, v195);
  LODWORD(v175[0]) = 1124007936;
  memset(v195, 0, 32);
  memset((char *)v175 + 4, 0, 60);
  v176 = &v175[1];
  v177 = (cv *)v178;
  v178[0] = 0LL;
  v178[1] = 0LL;
  *(_QWORD *)v174 = 0x400000004LL;
  cv::Mat::create((cv::Mat *)v175, 2, v174, 6);
  cv::Mat::operator=(v175, v195);
  v195[2] = 0LL;
  LOBYTE(v195[0]) = 26;
  strcpy((char *)v195 + 1, "obstacle_size");
  HIBYTE(v195[1]) = 0;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)v191,
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v195[2] = 0LL;
  LOBYTE(v195[0]) = 26;
  strcpy((char *)v195 + 1, "camera_matrix");
  HIBYTE(v195[1]) = 0;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)v187,
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  BYTE1(v195[2]) = 98;
  WORD1(v195[2]) = 0;
  HIDWORD(v195[2]) = 0;
  strcpy((char *)v195, "\"camera_matrix_r");
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)v183,
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v195[1] = 0LL;
  v195[2] = 0LL;
  v195[0] = 20994LL;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)&a1[40],
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v195[1] = 0LL;
  v195[2] = 0LL;
  v195[0] = 21506LL;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)&a1[52],
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v195[1] = 0LL;
  v195[2] = 0LL;
  v195[0] = 1668436998LL;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)v179,
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  v195[1] = 0LL;
  v195[2] = 0LL;
  v195[0] = 1919374342LL;
  feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
    (__int64)a1,
    (__int64)v195,
    (const cv::FileNode *)v175,
    (__int64)v173);
  if ( (v195[0] & 1) != 0 )
    operator delete((void *)v195[2]);
  if ( *v192 * v192[1] == 3 )
  {
    v17 = *(double *)(*(_QWORD *)&v191[16] + 16LL);
    a1[21].n64_u64[0] = vcvt_f32_f64(**(float64x2_t **)&v191[16]).n64_u64[0];
    a1[22].n64_f32[0] = v17;
  }
  v18 = (double *)v187[2];
  v19 = v189;
  v20 = (double)a1[39].n64_i32[1] / 640.0;
  v21 = v20;
  v22 = *(double *)(v187[2] + 16LL) * v20;
  v23 = a1[39].n64_i32[0];
  *(double *)v187[2] = *(double *)v187[2] * v20;
  v18[2] = v22;
  v24 = *(_QWORD *)v19;
  v25 = (char *)v18 + *(_QWORD *)v19;
  v26 = (double)v23 / 480.0;
  *(float64x2_t *)(v25 + 8) = vmulq_n_f64(*(float64x2_t *)(v25 + 8), v26);
  v27 = (double *)v183[2];
  v28 = v185;
  v29 = *(double *)(v183[2] + 16LL) * v21;
  *(double *)v183[2] = *(double *)v183[2] * v21;
  v27[2] = v29;
  v30 = *(_QWORD *)v28;
  v31 = (double *)((char *)v27 + v30);
  v150 = v26;
  v32 = *(double *)((char *)v27 + v30 + 8) * v26;
  v33 = *(double *)((char *)v27 + v30 + 16) * v26;
  v31[1] = v32;
  v31[2] = v33;
  if ( *v188 * v188[1] == 9 )
  {
    v34 = v32;
    v35 = v33;
    v36 = *v18;
    a1[12].n64_f32[0] = v36;
    v37 = *v27;
    a1[16].n64_f32[1] = v37;
    v38 = v18[1];
    a1[13].n64_f32[1] = v38;
    v39 = v27[1];
    a1[18].n64_f32[0] = v39;
    v40 = v18[2];
    a1[15].n64_f32[0] = v40;
    v41 = v27[2];
    a1[19].n64_f32[1] = v41;
    v42 = *(double *)((char *)v18 + v24);
    v43 = (double *)((char *)v18 + 2 * v24);
    v44 = (double *)((char *)v27 + 2 * v30);
    *(float *)&v42 = v42;
    a1[12].n64_u32[1] = LODWORD(v42);
    *(float *)&v42 = *(double *)((char *)v27 + v30);
    a1[17].n64_u32[0] = LODWORD(v42);
    v45 = *((double *)v25 + 1);
    a1[18].n64_f32[1] = v34;
    v46 = v45;
    a1[14].n64_f32[0] = v46;
    v47 = *((double *)v25 + 2);
    a1[20].n64_f32[0] = v35;
    v48 = v47;
    a1[15].n64_f32[1] = v48;
    v49 = *v43;
    a1[13].n64_f32[0] = v49;
    v50 = *v44;
    a1[17].n64_f32[1] = v50;
    v51 = v43[1];
    a1[14].n64_f32[1] = v51;
    v52 = v44[1];
    a1[19].n64_f32[0] = v52;
    v53 = v43[2];
    a1[16].n64_f32[0] = v53;
    v54 = v44[2];
    a1[20].n64_f32[1] = v54;
  }
  if ( *v180 * v180[1] == 16 )
  {
    v55 = (double *)v179[2];
    v56 = *(_QWORD *)v181;
    v57 = *(double *)v179[2];
    a1[22].n64_f32[1] = v57;
    v58 = v55[1];
    a1[24].n64_f32[1] = v58;
    v59 = v55[2];
    a1[26].n64_f32[1] = v59;
    v60 = v55[3];
    a1[28].n64_f32[1] = v60;
    v61 = *(double *)((char *)v55 + v56);
    a1[23].n64_f32[0] = v61;
    v62 = *(double *)((char *)v55 + v56 + 8);
    a1[25].n64_f32[0] = v62;
    v63 = *(double *)((char *)v55 + v56 + 16);
    a1[27].n64_f32[0] = v63;
    v64 = (double *)((char *)v55 + 2 * v56);
    v65 = *(double *)((char *)v55 + v56 + 24);
    a1[29].n64_f32[0] = v65;
    v66 = (double *)((char *)v55 + 3 * v56);
    v67 = *v64;
    a1[23].n64_f32[1] = v67;
    v68 = v64[1];
    a1[25].n64_f32[1] = v68;
    v69 = v64[2];
    a1[27].n64_f32[1] = v69;
    v70 = v64[3];
    a1[29].n64_f32[1] = v70;
    v71 = *v66;
    a1[24].n64_f32[0] = v71;
    v72 = v66[1];
    a1[26].n64_f32[0] = v72;
    v73 = v66[2];
    a1[28].n64_f32[0] = v73;
    v74 = v66[3];
    a1[30].n64_f32[0] = v74;
  }
  if ( *v176 * v176[1] == 16 )
  {
    v75 = (double *)v175[2];
    v76 = *(_QWORD *)v177;
    v77 = *(double *)v175[2];
    a1[30].n64_f32[1] = v77;
    v78 = v75[1];
    a1[32].n64_f32[1] = v78;
    v79 = v75[2];
    a1[34].n64_f32[1] = v79;
    v80 = v75[3];
    a1[36].n64_f32[1] = v80;
    v81 = *(double *)((char *)v75 + v76);
    a1[31].n64_f32[0] = v81;
    v82 = *(double *)((char *)v75 + v76 + 8);
    a1[33].n64_f32[0] = v82;
    v83 = *(double *)((char *)v75 + v76 + 16);
    a1[35].n64_f32[0] = v83;
    v84 = (double *)((char *)v75 + 2 * v76);
    v85 = *(double *)((char *)v75 + v76 + 24);
    a1[37].n64_f32[0] = v85;
    v86 = (double *)((char *)v75 + 3 * v76);
    v87 = *v84;
    a1[31].n64_f32[1] = v87;
    v88 = v84[1];
    a1[33].n64_f32[1] = v88;
    v89 = v84[2];
    a1[35].n64_f32[1] = v89;
    v90 = v84[3];
    a1[37].n64_f32[1] = v90;
    v91 = *v86;
    a1[32].n64_f32[0] = v91;
    v92 = v86[1];
    a1[34].n64_f32[0] = v92;
    v93 = v86[2];
    a1[36].n64_f32[0] = v93;
    v94 = v86[3];
    a1[38].n64_f32[0] = v94;
  }
  if ( (word_6FF40 & 1) != 0 )
    v95 = (const char *)qword_6FF50;
  else
    v95 = (char *)&word_6FF40 + 1;
  v162 = dword_6FF38;
  v164 = 0LL;
  v165 = 0LL;
  v163 = 0LL;
  v96 = strlen(v95);
  if ( v96 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v97 = v96;
  if ( v96 >= 0x17 )
  {
    v98 = (char *)operator new((v96 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    v164 = v97;
    v165 = v98;
    v163 = (v97 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    goto LABEL_110;
  }
  v98 = (char *)&v163 + 1;
  LOBYTE(v163) = 2 * v96;
  if ( v96 )
LABEL_110:
    memcpy(v98, v95, v97);
  v98[v97] = 0;
  if ( (g3::logLevel(&v162) & 1) != 0 )
  {
    *(_QWORD *)&v160[7] = 0LL;
    v161 = 0LL;
    v159 = 12;
    strcpy(v160, "region");
    v106 = g3::logTag(&v159);
    if ( (v159 & 1) == 0 )
    {
      if ( (v163 & 1) == 0 )
        goto LABEL_114;
LABEL_117:
      operator delete(v165);
      if ( (v106 & 1) == 0 )
        goto LABEL_119;
      goto LABEL_118;
    }
    operator delete(v161);
    if ( (v163 & 1) != 0 )
      goto LABEL_117;
  }
  else
  {
    v106 = 0;
    if ( (v163 & 1) != 0 )
      goto LABEL_117;
  }
LABEL_114:
  if ( (v106 & 1) != 0 )
  {
LABEL_118:
    LogCapture::LogCapture((LogCapture *)v195, "region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v195, "init param: dz:%f", *v151);
    LogCapture::~LogCapture((LogCapture *)v195);
  }
LABEL_119:
  v107 = *(double *)v187[2];
  v108 = v187[2] + *(_QWORD *)v189;
  v110 = *(double *)(v108 + 8);
  v109 = *(double *)(v108 + 16);
  v111 = *(double *)(v187[2] + 16LL);
  if ( (word_6FF40 & 1) != 0 )
    v112 = (const char *)qword_6FF50;
  else
    v112 = (char *)&word_6FF40 + 1;
  v155 = dword_6FF38;
  v157 = 0LL;
  v158 = 0LL;
  v156 = 0LL;
  v113 = strlen(v112);
  if ( v113 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v114 = v113;
  if ( v113 >= 0x17 )
  {
    v116 = (v113 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v115 = (char *)operator new(v116);
    v157 = v114;
    v158 = v115;
    v156 = v116 | 1;
    goto LABEL_127;
  }
  v115 = (char *)&v156 + 1;
  LOBYTE(v156) = 2 * v113;
  if ( v113 )
LABEL_127:
    memcpy(v115, v112, v114);
  v115[v114] = 0;
  if ( (g3::logLevel(&v155) & 1) == 0 )
  {
    v118 = 0;
    if ( (v156 & 1) != 0 )
      goto LABEL_135;
    goto LABEL_131;
  }
  *(_QWORD *)&v153[7] = 0LL;
  v154 = 0LL;
  v152 = 12;
  strcpy(v153, "region");
  v118 = g3::logTag(&v152);
  if ( (v152 & 1) != 0 )
  {
    operator delete(v154);
    if ( (v156 & 1) != 0 )
      goto LABEL_135;
LABEL_131:
    if ( (v118 & 1) != 0 )
      goto LABEL_132;
    goto LABEL_136;
  }
  if ( (v156 & 1) == 0 )
    goto LABEL_131;
LABEL_135:
  operator delete(v158);
  if ( (v118 & 1) != 0 )
  {
LABEL_132:
    LogCapture::LogCapture((LogCapture *)v195, "region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
    v119 = v107 / v21;
    v120 = v110 / v21;
    v121 = v111 / v150;
    v122 = v109 / v150;
    LogCapture::capturef((LogCapture *)v195, "init param: 640x480:fx:%f,fy:%f,cx:%f,cy:%f ", v119, v121, v120, v122);
    LogCapture::~LogCapture((LogCapture *)v195);
    v123 = v175[7];
    if ( !v175[7] )
      goto LABEL_141;
LABEL_137:
    v124 = (unsigned int *)(v123 + 20);
    do
    {
      v125 = __ldaxr(v124);
      v126 = v125 - 1;
    }
    while ( __stlxr(v126, v124) );
    if ( !v126 )
      cv::Mat::deallocate((cv::Mat *)v175);
    goto LABEL_141;
  }
LABEL_136:
  v123 = v175[7];
  if ( v175[7] )
    goto LABEL_137;
LABEL_141:
  v175[7] = 0LL;
  memset(&v175[2], 0, 32);
  if ( SHIDWORD(v175[0]) >= 1 )
  {
    v127 = v176;
    v128 = 0LL;
    do
      v127[v128++] = 0;
    while ( v128 < SHIDWORD(v175[0]) );
  }
  if ( v177 != (cv *)v178 )
    cv::fastFree(v177, v117);
  if ( v179[7] )
  {
    v129 = (unsigned int *)(v179[7] + 20LL);
    do
    {
      v130 = __ldaxr(v129);
      v131 = v130 - 1;
    }
    while ( __stlxr(v131, v129) );
    if ( !v131 )
      cv::Mat::deallocate((cv::Mat *)v179);
  }
  v179[7] = 0LL;
  memset(&v179[2], 0, 32);
  if ( SHIDWORD(v179[0]) >= 1 )
  {
    v132 = v180;
    v133 = 0LL;
    do
      v132[v133++] = 0;
    while ( v133 < SHIDWORD(v179[0]) );
  }
  if ( v181 != (cv *)v182 )
    cv::fastFree(v181, v117);
  if ( v183[7] )
  {
    v134 = (unsigned int *)(v183[7] + 20LL);
    do
    {
      v135 = __ldaxr(v134);
      v136 = v135 - 1;
    }
    while ( __stlxr(v136, v134) );
    if ( !v136 )
      cv::Mat::deallocate((cv::Mat *)v183);
  }
  v183[7] = 0LL;
  memset(&v183[2], 0, 32);
  if ( SHIDWORD(v183[0]) >= 1 )
  {
    v137 = v184;
    v138 = 0LL;
    do
      *((_DWORD *)v137 + v138++) = 0;
    while ( v138 < SHIDWORD(v183[0]) );
  }
  if ( v185 != (cv *)v186 )
    cv::fastFree(v185, v117);
  if ( v187[7] )
  {
    v139 = (unsigned int *)(v187[7] + 20LL);
    do
    {
      v140 = __ldaxr(v139);
      v141 = v140 - 1;
    }
    while ( __stlxr(v141, v139) );
    if ( !v141 )
      cv::Mat::deallocate((cv::Mat *)v187);
  }
  v187[7] = 0LL;
  memset(&v187[2], 0, 32);
  if ( SHIDWORD(v187[0]) >= 1 )
  {
    v142 = v188;
    v143 = 0LL;
    do
      v142[v143++] = 0;
    while ( v143 < SHIDWORD(v187[0]) );
  }
  if ( v189 != (cv *)v190 )
    cv::fastFree(v189, v117);
  if ( *(_QWORD *)&v191[56] )
  {
    v144 = (unsigned int *)(*(_QWORD *)&v191[56] + 20LL);
    do
    {
      v145 = __ldaxr(v144);
      v146 = v145 - 1;
    }
    while ( __stlxr(v146, v144) );
    if ( !v146 )
      cv::Mat::deallocate((cv::Mat *)v191);
  }
  *(_QWORD *)&v191[56] = 0LL;
  memset(&v191[16], 0, 32);
  if ( *(int *)&v191[4] >= 1 )
  {
    v147 = v192;
    v148 = 0LL;
    do
      v147[v148++] = 0;
    while ( v148 < *(int *)&v191[4] );
  }
  if ( v193 != (cv *)v194 )
    cv::fastFree(v193, v117);
  v105 = 0;
LABEL_187:
  cv::FileStorage::~FileStorage((cv::FileStorage *)v173);
  return v105;
}
// 41020: variable 'v3' is possibly undefined
// 410BC: variable 'v4' is possibly undefined
// 41194: variable 'v5' is possibly undefined
// 41208: variable 'v6' is possibly undefined
// 41278: variable 'v7' is possibly undefined
// 412F0: variable 'v8' is possibly undefined
// 41368: variable 'v9' is possibly undefined
// 413E4: variable 'v10' is possibly undefined
// 41464: variable 'v11' is possibly undefined
// 414E4: variable 'v12' is possibly undefined
// 41560: variable 'v13' is possibly undefined
// 415D8: variable 'v14' is possibly undefined
// 41664: variable 'v15' is possibly undefined
// 416F4: variable 'v16' is possibly undefined
// 42318: variable 'v117' is possibly undefined
// 12630: using guessed type __int64 __fastcall cv::FileStorage::FileStorage(_QWORD, _QWORD, _QWORD, _QWORD);
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 133F0: using guessed type _QWORD *__fastcall cv::FileStorage::operator[](_QWORD *__return_ptr, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 54DE0: using guessed type __int128 xmmword_54DE0;
// 6FF38: using guessed type int dword_6FF38;
// 6FF40: using guessed type __int16 word_6FF40;
// 6FF50: using guessed type __int64 qword_6FF50;
// 6FFB8: using guessed type int dword_6FFB8;
// 6FFC0: using guessed type __int16 word_6FFC0;
// 6FFD0: using guessed type __int64 qword_6FFD0;

//----- (00000000000429F8) ----------------------------------------------------
void __fastcall feasibal_region::feasibal_region::attemtpRead<std::string>(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  _QWORD v6[3]; // [xsp+8h] [xbp-58h] BYREF
  __int64 v7[2]; // [xsp+20h] [xbp-40h] BYREF
  void *v8; // [xsp+30h] [xbp-30h]
  __int64 v9; // [xsp+38h] [xbp-28h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  cv::FileStorage::operator[](v7, a4);
  if ( (unsigned int)cv::FileNode::type((cv::FileNode *)v7) )
  {
    cv::FileStorage::operator[](v6, a4);
    v7[0] = 0LL;
    v7[1] = 0LL;
    v8 = 0LL;
    cv::read(v6, a3, v7);
    if ( (v7[0] & 1) != 0 )
      operator delete(v8);
  }
}
// 13120: using guessed type __int64 __fastcall cv::read(_QWORD, _QWORD, _QWORD);
// 133F0: using guessed type _QWORD *__fastcall cv::FileStorage::operator[](_QWORD *__return_ptr, _QWORD);
// 429F8: using guessed type _QWORD var_58[3];

//----- (0000000000042AB8) ----------------------------------------------------
cv *__fastcall feasibal_region::feasibal_region::attemtpRead<cv::Mat>(
        __int64 a1,
        __int64 a2,
        const cv::FileNode *a3,
        __int64 a4)
{
  cv *result; // x0
  const cv::Mat *v7; // x3
  void *v8; // x1
  unsigned int *v9; // x8
  unsigned int v10; // w9
  unsigned int v11; // w9
  _QWORD *v12; // x8
  __int64 v13; // x9
  _QWORD v14[3]; // [xsp+0h] [xbp-B0h] BYREF
  _QWORD v15[8]; // [xsp+18h] [xbp-98h] BYREF
  _QWORD *v16; // [xsp+58h] [xbp-58h]
  cv *v17; // [xsp+60h] [xbp-50h]
  __int64 v18[3]; // [xsp+68h] [xbp-48h] BYREF

  v18[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  cv::FileStorage::operator[](v15, a4);
  result = (cv *)cv::FileNode::type((cv::FileNode *)v15);
  if ( (_DWORD)result )
  {
    cv::FileStorage::operator[](v14, a4);
    LODWORD(v15[0]) = 1124007936;
    memset((char *)v15 + 4, 0, 60);
    v16 = &v15[1];
    v17 = (cv *)v18;
    v18[0] = 0LL;
    v18[1] = 0LL;
    cv::read((cv *)v14, a3, (cv::Mat *)v15, v7);
    if ( v15[7] )
    {
      v9 = (unsigned int *)(v15[7] + 20LL);
      do
      {
        v10 = __ldaxr(v9);
        v11 = v10 - 1;
      }
      while ( __stlxr(v11, v9) );
      if ( !v11 )
        cv::Mat::deallocate((cv::Mat *)v15);
    }
    v15[7] = 0LL;
    memset(&v15[2], 0, 32);
    if ( SHIDWORD(v15[0]) >= 1 )
    {
      v12 = v16;
      v13 = 0LL;
      do
        *((_DWORD *)v12 + v13++) = 0;
      while ( v13 < SHIDWORD(v15[0]) );
    }
    result = v17;
    if ( v17 != (cv *)v18 )
      return (cv *)cv::fastFree(v17, v8);
  }
  return result;
}
// 42B4C: variable 'v7' is possibly undefined
// 42BBC: variable 'v8' is possibly undefined
// 133F0: using guessed type _QWORD *__fastcall cv::FileStorage::operator[](_QWORD *__return_ptr, _QWORD);

//----- (0000000000042C70) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int64 *a2)
{
  __int64 *v3; // x0
  unsigned __int64 v5; // x8
  void *v6; // x1
  size_t v7; // x2
  feasibal_region::ground_process *v8; // x20
  feasibal_region::ground_process *v9; // x21
  void *v10; // x1
  void *v12[62]; // [xsp+0h] [xbp-230h] BYREF
  __int16 v13; // [xsp+1F0h] [xbp-40h]
  int v14; // [xsp+1F4h] [xbp-3Ch]
  __int64 v15; // [xsp+1F8h] [xbp-38h]

  v3 = (__int64 *)(a1 + 600);
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( v3 != a2 )
  {
    v5 = *(unsigned __int8 *)a2;
    if ( (v5 & 1) != 0 )
      v6 = (void *)a2[2];
    else
      v6 = (char *)a2 + 1;
    if ( (v5 & 1) != 0 )
      v7 = a2[1];
    else
      v7 = v5 >> 1;
    std::string::assign(v3, v6, v7);
  }
  feasibal_region::feasibal_region::readParam((float32x2_t *)a1, (__int64)a2);
  v8 = (feasibal_region::ground_process *)operator new(0xC18uLL);
  feasibal_region::ground_process::ground_process(v8);
  v9 = *(feasibal_region::ground_process **)(a1 + 624);
  *(_QWORD *)(a1 + 624) = v8;
  if ( v9 )
  {
    feasibal_region::ground_process::~ground_process(v9);
    operator delete(v9);
  }
  feasibal_region::PreParamInfo::PreParamInfo((feasibal_region::PreParamInfo *)v12);
  v13 = 0;
  v14 = 1084227584;
  feasibal_region::PreParamInfo::operator=((__int64)v12, (__int128 *)(a1 + 48));
  feasibal_region::ground_process::init(*(_QWORD *)(a1 + 624), (__int64)v12);
  feasibal_region::PreParamInfo::~PreParamInfo(v12, v10);
  return 0LL;
}
// 42D2C: variable 'v10' is possibly undefined

//----- (0000000000042D88) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::readParam(__int64 a1, __int64 a2, _DWORD *a3, int a4, double a5)
{
  int v8; // s1
  float v9; // s9
  float v10; // s10
  float v11; // s12
  float v12; // s11
  __int64 v15; // d2
  __int64 v16; // d4
  int v17; // s3
  int v18; // w8
  __int64 v19; // x8
  __int64 v20; // x13
  __int64 v21; // x12
  int64x2_t v22; // q1
  _QWORD *v23; // x13
  __int64 v24; // x14
  int64x2_t v25; // q0
  __int64 v26; // d2
  __int64 v27; // x10
  int *v28; // x11
  __int64 v29; // t1
  _QWORD *v30; // x8
  cv::Mat *v31; // x1
  __int64 v32; // x9
  unsigned __int64 v33; // x10
  _QWORD *v34; // x9
  _QWORD *v35; // x8
  _QWORD *v36; // x9
  _QWORD *v37; // x8
  _QWORD *v38; // x9
  _QWORD *v39; // x8
  _QWORD *v40; // x9
  void *v41; // x1
  unsigned int *v42; // x8
  unsigned int v43; // w9
  unsigned int v44; // w9
  cv *v45; // x8
  __int64 v46; // x9
  int v47; // w9
  __int128 v48; // q0
  cv *v49; // x0
  unsigned int *v50; // x8
  unsigned int v51; // w9
  unsigned int v52; // w9
  int *v53; // x8
  __int64 v54; // x9
  float v55; // s0
  int v56; // w8
  __int64 v57; // x8
  __int64 v58; // x13
  __int64 v59; // x12
  int64x2_t v60; // q1
  _QWORD *v61; // x13
  __int64 v62; // x14
  int64x2_t v63; // q0
  __int64 v64; // d2
  __int64 v65; // x10
  int *v66; // x11
  __int64 v67; // t1
  _QWORD *v68; // x8
  cv::Mat *v69; // x1
  __int64 v70; // x9
  unsigned __int64 v71; // x10
  _QWORD *v72; // x9
  void *v73; // x1
  unsigned int *v74; // x8
  unsigned int v75; // w9
  unsigned int v76; // w9
  __int64 v77; // x8
  __int64 v78; // x9
  int v79; // w9
  __int128 v80; // q0
  cv *v81; // x0
  unsigned int *v82; // x8
  unsigned int v83; // w9
  unsigned int v84; // w9
  int *v85; // x8
  __int64 v86; // x9
  void *v87; // x1
  unsigned int *v88; // x8
  unsigned int v89; // w9
  unsigned int v90; // w9
  cv *v91; // x8
  __int64 v92; // x9
  int v93; // w9
  __int128 v94; // q0
  cv *v95; // x0
  __int64 v96; // x8
  __int64 v97; // x13
  __int64 v98; // x12
  int64x2_t v99; // q1
  _QWORD *v100; // x13
  __int64 v101; // x14
  int64x2_t v102; // q0
  __int64 v103; // d2
  __int64 v104; // x10
  int *v105; // x11
  __int64 v106; // t1
  _QWORD *v107; // x8
  cv::Mat *v108; // x1
  __int64 v109; // x9
  unsigned __int64 v110; // x10
  _QWORD *v111; // x9
  _QWORD *v112; // x8
  _QWORD *v113; // x9
  _QWORD *v114; // x8
  _QWORD *v115; // x9
  _QWORD *v116; // x8
  _QWORD *v117; // x9
  void *v118; // x1
  __int64 v119; // x8
  unsigned int *v120; // x8
  unsigned int v121; // w9
  unsigned int v122; // w9
  int v123; // w8
  __int64 v124; // x8
  __int64 v125; // x9
  int v126; // v0.s[1]
  __int128 v127; // q1
  cv *v128; // x0
  int v129; // w8
  unsigned int *v130; // x8
  unsigned int v131; // w9
  unsigned int v132; // w9
  cv *v133; // x9
  cv *v134; // x8
  __int64 v135; // x9
  unsigned int *v136; // x8
  unsigned int v137; // w9
  unsigned int v138; // w9
  int *v139; // x8
  __int64 v140; // x9
  __int64 v141; // x8
  __int64 v142; // x13
  __int64 v143; // x12
  int64x2_t v144; // q1
  _QWORD *v145; // x13
  __int64 v146; // x14
  int64x2_t v147; // q0
  __int64 v148; // d2
  __int64 v149; // x10
  int *v150; // x11
  __int64 v151; // t1
  _QWORD *v152; // x8
  cv::Mat *v153; // x1
  __int64 v154; // x9
  unsigned __int64 v155; // x10
  _QWORD *v156; // x9
  void *v157; // x1
  __int64 v158; // x8
  unsigned int *v159; // x8
  unsigned int v160; // w9
  unsigned int v161; // w9
  int v162; // w8
  __int64 v163; // x8
  __int64 v164; // x9
  int v165; // v0.s[1]
  __int128 v166; // q1
  cv *v167; // x0
  int v168; // w8
  unsigned int *v169; // x8
  unsigned int v170; // w9
  unsigned int v171; // w9
  cv *v172; // x9
  cv *v173; // x8
  __int64 v174; // x9
  unsigned int *v175; // x8
  unsigned int v176; // w9
  unsigned int v177; // w9
  int *v178; // x8
  __int64 v179; // x9
  __int64 v180; // x8
  __int64 v181; // x13
  __int64 v182; // x12
  int64x2_t v183; // q1
  _QWORD *v184; // x13
  __int64 v185; // x14
  int64x2_t v186; // q0
  __int64 v187; // d2
  __int64 v188; // x10
  int *v189; // x11
  __int64 v190; // t1
  _QWORD *v191; // x8
  cv::Mat *v192; // x1
  __int64 v193; // x9
  unsigned __int64 v194; // x10
  _QWORD *v195; // x9
  _QWORD *v196; // x8
  _QWORD *v197; // x9
  _QWORD *v198; // x8
  _QWORD *v199; // x9
  _QWORD *v200; // x8
  _QWORD *v201; // x9
  _QWORD *v202; // x8
  _QWORD *v203; // x9
  _QWORD *v204; // x8
  _QWORD *v205; // x9
  _QWORD *v206; // x10
  _QWORD *v207; // x8
  _QWORD *v208; // x9
  void *v209; // x1
  unsigned int *v210; // x8
  unsigned int v211; // w9
  unsigned int v212; // w9
  cv *v213; // x8
  __int64 v214; // x9
  int v215; // w9
  __int128 v216; // q0
  cv *v217; // x0
  unsigned int *v218; // x8
  unsigned int v219; // w9
  unsigned int v220; // w9
  int *v221; // x8
  __int64 v222; // x9
  __int64 v223; // x8
  __int64 v224; // x13
  __int64 v225; // x12
  int64x2_t v226; // q1
  _QWORD *v227; // x13
  __int64 v228; // x14
  int64x2_t v229; // q0
  __int64 v230; // d2
  __int64 v231; // x10
  int *v232; // x11
  __int64 v233; // t1
  _QWORD *v234; // x8
  cv::Mat *v235; // x1
  __int64 v236; // x9
  unsigned __int64 v237; // x10
  _QWORD *v238; // x9
  _QWORD *v239; // x8
  _QWORD *v240; // x9
  _QWORD *v241; // x8
  _QWORD *v242; // x9
  _QWORD *v243; // x8
  _QWORD *v244; // x9
  _QWORD *v245; // x8
  _QWORD *v246; // x9
  _QWORD *v247; // x8
  _QWORD *v248; // x9
  _QWORD *v249; // x8
  _QWORD *v250; // x9
  _QWORD *v251; // x8
  void *v252; // x1
  unsigned int *v253; // x8
  unsigned int v254; // w9
  unsigned int v255; // w9
  cv *v256; // x8
  __int64 v257; // x9
  int v258; // w9
  __int128 v259; // q0
  cv *v260; // x0
  unsigned int *v261; // x8
  unsigned int v262; // w9
  unsigned int v263; // w9
  int *v264; // x8
  __int64 v265; // x9
  float v266; // s1
  float v267; // s0
  float v268; // s3
  double *v269; // x8
  cv *v270; // x9
  double v271; // d8
  double v272; // d2
  __int64 v273; // x9
  double *v274; // x11
  double *v275; // x10
  cv *v276; // x12
  double v277; // d1
  __int64 v278; // x12
  double *v279; // x13
  double v280; // d1
  double v281; // d0
  float v282; // s1
  float v283; // s0
  float v284; // s2
  float v285; // s2
  float v286; // s2
  float v287; // s2
  float v288; // s2
  float v289; // s2
  double v290; // d2
  double *v291; // x8
  double *v292; // x9
  double v293; // d2
  float v294; // s1
  double v295; // d1
  float v296; // s0
  float v297; // s0
  float v298; // s0
  float v299; // s0
  float v300; // s0
  float v301; // s0
  float v302; // s0
  double *v303; // x8
  __int64 v304; // x9
  float v305; // s0
  float v306; // s0
  float v307; // s0
  float v308; // s0
  float v309; // s0
  float v310; // s0
  float v311; // s0
  double *v312; // x11
  float v313; // s0
  double *v314; // x8
  float v315; // s0
  float v316; // s0
  float v317; // s0
  float v318; // s0
  float v319; // s0
  float v320; // s0
  float v321; // s0
  float v322; // s0
  double *v323; // x8
  __int64 v324; // x9
  float v325; // s0
  float v326; // s0
  float v327; // s0
  float v328; // s0
  float v329; // s0
  float v330; // s0
  float v331; // s0
  double *v332; // x11
  float v333; // s0
  double *v334; // x8
  float v335; // s0
  float v336; // s0
  float v337; // s0
  float v338; // s0
  float v339; // s0
  float v340; // s0
  float v341; // s0
  float v342; // s0
  const char *v343; // x21
  size_t v344; // x0
  size_t v345; // x20
  char *v346; // x22
  unsigned __int64 v347; // x23
  char v348; // w20
  double v349; // d11
  __int64 v350; // x8
  double v351; // d10
  double v352; // d12
  double v353; // d9
  const char *v354; // x20
  size_t v355; // x0
  size_t v356; // x19
  char *v357; // x21
  unsigned __int64 v358; // x22
  void *v359; // x1
  char v360; // w19
  float v361; // s0
  float v362; // s4
  float v363; // s1
  float v364; // s3
  __int64 v365; // x8
  unsigned int *v366; // x8
  unsigned int v367; // w9
  unsigned int v368; // w9
  cv *v369; // x8
  __int64 v370; // x9
  unsigned int *v371; // x8
  unsigned int v372; // w9
  unsigned int v373; // w9
  cv *v374; // x8
  __int64 v375; // x9
  unsigned int *v376; // x8
  unsigned int v377; // w9
  unsigned int v378; // w9
  cv *v379; // x8
  __int64 v380; // x9
  unsigned int *v381; // x8
  unsigned int v382; // w9
  unsigned int v383; // w9
  cv *v384; // x8
  __int64 v385; // x9
  unsigned int *v386; // x8
  unsigned int v387; // w9
  unsigned int v388; // w9
  __int64 v389; // x8
  __int64 v390; // x9
  double v392; // [xsp+30h] [xbp-530h]
  void *v393[3]; // [xsp+70h] [xbp-4F0h] BYREF
  int v394; // [xsp+88h] [xbp-4D8h] BYREF
  unsigned __int64 v395; // [xsp+90h] [xbp-4D0h] BYREF
  size_t v396; // [xsp+98h] [xbp-4C8h]
  void *v397; // [xsp+A0h] [xbp-4C0h]
  void *v398[3]; // [xsp+A8h] [xbp-4B8h] BYREF
  int v399; // [xsp+C0h] [xbp-4A0h] BYREF
  unsigned __int64 v400; // [xsp+C8h] [xbp-498h] BYREF
  size_t v401; // [xsp+D0h] [xbp-490h]
  void *v402; // [xsp+D8h] [xbp-488h]
  cv::Mat *v403; // [xsp+E0h] [xbp-480h] BYREF
  __int64 v404; // [xsp+E8h] [xbp-478h]
  _QWORD *v405; // [xsp+F0h] [xbp-470h]
  __int64 v406; // [xsp+F8h] [xbp-468h]
  unsigned __int64 v407; // [xsp+100h] [xbp-460h]
  cv::Mat *v408; // [xsp+108h] [xbp-458h] BYREF
  __int64 v409; // [xsp+110h] [xbp-450h]
  _QWORD *v410; // [xsp+118h] [xbp-448h]
  __int64 v411; // [xsp+120h] [xbp-440h]
  unsigned __int64 v412; // [xsp+128h] [xbp-438h]
  _BYTE v413[64]; // [xsp+130h] [xbp-430h] BYREF
  cv *v414[2]; // [xsp+170h] [xbp-3F0h]
  __int64 v415; // [xsp+180h] [xbp-3E0h] BYREF
  __int64 v416; // [xsp+188h] [xbp-3D8h]
  int v417; // [xsp+280h] [xbp-2E0h] BYREF
  int v418[15]; // [xsp+284h] [xbp-2DCh] BYREF
  int *v419; // [xsp+2C0h] [xbp-2A0h]
  cv *v420; // [xsp+2C8h] [xbp-298h]
  __int64 v421; // [xsp+2D0h] [xbp-290h] BYREF
  __int64 v422; // [xsp+2D8h] [xbp-288h]
  _BYTE v423[64]; // [xsp+2E0h] [xbp-280h] BYREF
  cv *v424[2]; // [xsp+320h] [xbp-240h]
  __int64 v425; // [xsp+330h] [xbp-230h] BYREF
  __int64 v426; // [xsp+338h] [xbp-228h]
  _BYTE v427[64]; // [xsp+340h] [xbp-220h] BYREF
  cv *v428[2]; // [xsp+380h] [xbp-1E0h]
  __int64 v429; // [xsp+390h] [xbp-1D0h] BYREF
  __int64 v430; // [xsp+398h] [xbp-1C8h]
  _BYTE v431[64]; // [xsp+3A0h] [xbp-1C0h] BYREF
  cv *v432[2]; // [xsp+3E0h] [xbp-180h]
  __int64 v433; // [xsp+3F0h] [xbp-170h] BYREF
  __int64 v434; // [xsp+3F8h] [xbp-168h]
  _BYTE v435[64]; // [xsp+400h] [xbp-160h] BYREF
  cv *v436[2]; // [xsp+440h] [xbp-120h]
  __int64 v437; // [xsp+450h] [xbp-110h] BYREF
  __int64 v438; // [xsp+458h] [xbp-108h]
  _BYTE v439[64]; // [xsp+460h] [xbp-100h] BYREF
  __int128 v440; // [xsp+4A0h] [xbp-C0h]
  __int64 v441; // [xsp+4B0h] [xbp-B0h] BYREF
  __int64 v442; // [xsp+4B8h] [xbp-A8h]

  v8 = 1146355712;
  v9 = 480.0;
  v10 = 240.0;
  v11 = 640.0;
  v12 = 320.0;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  *(_DWORD *)v439 = 1124007936;
  memset(&v439[4], 0, 60);
  *(_DWORD *)v435 = 1124007936;
  memset(&v435[4], 0, 60);
  *(_DWORD *)v431 = 1124007936;
  memset(&v431[4], 0, 60);
  *(_QWORD *)&v440 = &v439[8];
  *((_QWORD *)&v440 + 1) = &v441;
  v441 = 0LL;
  v442 = 0LL;
  v436[0] = (cv *)&v435[8];
  v436[1] = (cv *)&v437;
  v438 = 0LL;
  v437 = 0LL;
  v432[0] = (cv *)&v431[8];
  v432[1] = (cv *)&v433;
  v434 = 0LL;
  v433 = 0LL;
  *(_DWORD *)v427 = 1124007936;
  memset(&v427[4], 0, 60);
  v428[0] = (cv *)&v427[8];
  v428[1] = (cv *)&v429;
  v430 = 0LL;
  v429 = 0LL;
  *(_DWORD *)v423 = 1124007936;
  memset(&v423[4], 0, 60);
  v424[0] = (cv *)&v423[8];
  v424[1] = (cv *)&v425;
  v426 = 0LL;
  v425 = 0LL;
  *(_DWORD *)(a1 + 632) = a4;
  *(_DWORD *)(a1 + 316) = 320;
  *(_QWORD *)(a1 + 308) = 0xF000000004LL;
  v15 = 0x1A8000000F0LL;
  v16 = 0x140000000F0LL;
  v17 = 1137967104;
  v18 = 10;
  switch ( a4 )
  {
    case 0:
      goto LABEL_6;
    case 1:
      goto LABEL_5;
    case 2:
      v9 = 640.0;
      v15 = 0xC800000140LL;
      v8 = 1137180672;
      v17 = 1128792064;
      v10 = 320.0;
      goto LABEL_4;
    case 3:
      v8 = 1142947840;
      v17 = 1134559232;
      v15 = 0x140000000C8LL;
      v9 = 400.0;
      v10 = 200.0;
LABEL_4:
      v18 = 8;
LABEL_5:
      v12 = *(float *)&v17;
      v11 = *(float *)&v8;
      v16 = v15;
      *(_DWORD *)(a1 + 308) = v18;
LABEL_6:
      *(_QWORD *)(a1 + 312) = v16;
      break;
    default:
      break;
  }
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x300000003LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v19 = 0LL;
  else
    v19 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v19;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v21 = 0LL;
        v20 = 1LL;
      }
      else
      {
        v21 = v418[0] & 0xFFFFFFFC;
        v22 = vdupq_n_s64(1uLL);
        v23 = v419 + 2;
        v24 = v21;
        v25 = v22;
        do
        {
          v26 = *(v23 - 1);
          v22.n128_u64[0] *= (int)v26;
          v25.n128_u64[0] *= (int)*v23;
          v24 -= 4LL;
          v22.n128_u64[1] *= SHIDWORD(v26);
          v25.n128_u64[1] *= (int)HIDWORD(*v23);
          v23 += 2;
        }
        while ( v24 );
        v20 = v25.n128_u64[0] * v22.n128_u64[0] * v25.n128_u64[1] * v22.n128_u64[1];
        if ( v21 == v418[0] )
          goto LABEL_20;
      }
      v27 = (unsigned int)v418[0] - v21;
      v28 = &v419[v21];
      do
      {
        v29 = *v28++;
        --v27;
        v20 *= v29;
      }
      while ( v27 );
    }
    else
    {
      v20 = v418[2] * (__int64)v418[1];
    }
LABEL_20:
    v412 = *(_QWORD *)&v418[3] + v20 * v19;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v30 = v410;
  *v410 = 0x40803149BA5E353FLL;
  v31 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v30 + v409);
    if ( (unsigned __int64)v30 + v409 >= v412 )
    {
      v410 = v30;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v31 = v408;
      v30 = v410;
    }
    else
    {
      v30 = (_QWORD *)((char *)v30 + v409);
    }
  }
  v32 = v409;
  v33 = v412;
  v403 = v31;
  v404 = v409;
  v405 = v30;
  v406 = v411;
  v407 = v412;
  *v30 = 0LL;
  if ( !v31 )
  {
    *v30 = 0x3FF0000000000000LL;
    goto LABEL_56;
  }
  v34 = (_QWORD *)((char *)v30 + v32);
  v405 = v34;
  if ( (unsigned __int64)v34 >= v33 )
  {
    v405 = v30;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v34 = v405;
    v31 = v403;
  }
  *v34 = 0x407499C6A7EF9DB2LL;
  if ( !v31 )
  {
    v35 = v34;
    *v34 = 0LL;
LABEL_36:
    v36 = v35;
    goto LABEL_37;
  }
  v35 = (_QWORD *)((char *)v34 + v404);
  v405 = (_QWORD *)((char *)v34 + v404);
  if ( (unsigned __int64)v34 + v404 >= v407 )
  {
    v405 = v34;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v35 = v405;
    v31 = v403;
  }
  *v35 = 0LL;
  if ( !v31 )
    goto LABEL_36;
  v36 = (_QWORD *)((char *)v35 + v404);
  v405 = (_QWORD *)((char *)v35 + v404);
  if ( (unsigned __int64)v35 + v404 >= v407 )
  {
    v405 = v35;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v36 = v405;
    v31 = v403;
  }
LABEL_37:
  *v36 = 0x40803149BA5E353FLL;
  if ( v31 )
  {
    v37 = (_QWORD *)((char *)v36 + v404);
    v405 = (_QWORD *)((char *)v36 + v404);
    if ( (unsigned __int64)v36 + v404 >= v407 )
    {
      v405 = v36;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v37 = v405;
      v31 = v403;
    }
  }
  else
  {
    v37 = v36;
  }
  *v37 = 0x406E065604189375LL;
  if ( !v31 )
  {
    v38 = v37;
    *v37 = 0LL;
LABEL_51:
    v39 = v38;
    *v38 = 0LL;
    goto LABEL_52;
  }
  v38 = (_QWORD *)((char *)v37 + v404);
  v405 = (_QWORD *)((char *)v37 + v404);
  if ( (unsigned __int64)v37 + v404 >= v407 )
  {
    v405 = v37;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v38 = v405;
    v31 = v403;
  }
  *v38 = 0LL;
  if ( !v31 )
    goto LABEL_51;
  v39 = (_QWORD *)((char *)v38 + v404);
  v405 = (_QWORD *)((char *)v38 + v404);
  if ( (unsigned __int64)v38 + v404 >= v407 )
  {
    v405 = v38;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v39 = v405;
    v31 = v403;
  }
  *v39 = 0LL;
  if ( v31 )
  {
    v40 = (_QWORD *)((char *)v39 + v404);
    v405 = (_QWORD *)((char *)v39 + v404);
    if ( (unsigned __int64)v39 + v404 >= v407 )
    {
      v405 = v39;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v40 = v405;
      v31 = v403;
    }
    goto LABEL_53;
  }
LABEL_52:
  v40 = v39;
LABEL_53:
  *v40 = 0x3FF0000000000000LL;
  if ( v31 )
  {
    v405 = (_QWORD *)((char *)v40 + v404);
    if ( (unsigned __int64)v40 + v404 >= v407 )
    {
      v405 = v40;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v31 = v403;
    }
  }
LABEL_56:
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v31);
  if ( *(_QWORD *)&v431[56] )
  {
    v42 = (unsigned int *)(*(_QWORD *)&v431[56] + 20LL);
    do
    {
      v43 = __ldaxr(v42);
      v44 = v43 - 1;
    }
    while ( __stlxr(v44, v42) );
    if ( !v44 )
      cv::Mat::deallocate((cv::Mat *)v431);
  }
  *(_QWORD *)&v431[56] = 0LL;
  memset(&v431[16], 0, 32);
  if ( *(int *)&v431[4] >= 1 )
  {
    v45 = v432[0];
    v46 = 0LL;
    do
      *((_DWORD *)v45 + v46++) = 0;
    while ( v46 < *(int *)&v431[4] );
  }
  *(_OWORD *)v431 = *(_OWORD *)v413;
  *(_OWORD *)&v431[16] = *(_OWORD *)&v413[16];
  *(_OWORD *)&v431[32] = *(_OWORD *)&v413[32];
  *(_OWORD *)&v431[48] = *(_OWORD *)&v413[48];
  if ( (__int64 *)v432[1] == &v433 )
  {
    v47 = *(_DWORD *)&v413[4];
  }
  else
  {
    cv::fastFree(v432[1], v41);
    v47 = *(_DWORD *)&v413[4];
    v432[0] = (cv *)&v431[8];
    v432[1] = (cv *)&v433;
  }
  if ( v47 <= 2 )
  {
    v49 = v414[1];
    v433 = *(_QWORD *)v414[1];
    v434 = *((_QWORD *)v414[1] + 1);
  }
  else
  {
    v48 = *(_OWORD *)v414;
    v49 = (cv *)&v415;
    v414[0] = (cv *)&v413[8];
    v414[1] = (cv *)&v415;
    *(_OWORD *)v432 = v48;
  }
  *(_DWORD *)v413 = 1124007936;
  memset(&v413[4], 0, 60);
  if ( v49 != (cv *)&v415 )
    cv::fastFree(v49, v41);
  if ( *(_QWORD *)&v418[13] )
  {
    v50 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v51 = __ldaxr(v50);
      v52 = v51 - 1;
    }
    while ( __stlxr(v52, v50) );
    if ( !v52 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v53 = v419;
    v54 = 0LL;
    do
      v53[v54++] = 0;
    while ( v54 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v41);
  v55 = a5;
  *(_DWORD *)(a1 + 52) = a4;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 593) = 1;
  *(_DWORD *)(a1 + 88) = 1061997773;
  *(float *)(a1 + 72) = v55;
  *(_DWORD *)(a1 + 76) = *a3;
  *(_DWORD *)(a1 + 80) = a3[1];
  v56 = a3[2];
  *(_QWORD *)(a1 + 56) = 0x44BB8000447A0000LL;
  *(_DWORD *)(a1 + 68) = 1097859072;
  *(_DWORD *)(a1 + 84) = v56;
  *(_BYTE *)(a1 + 92) = 0;
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x300000001LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v57 = 0LL;
  else
    v57 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v57;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v59 = 0LL;
        v58 = 1LL;
      }
      else
      {
        v59 = v418[0] & 0xFFFFFFFC;
        v60 = vdupq_n_s64(1uLL);
        v61 = v419 + 2;
        v62 = v59;
        v63 = v60;
        do
        {
          v64 = *(v61 - 1);
          v60.n128_u64[0] *= (int)v64;
          v63.n128_u64[0] *= (int)*v61;
          v62 -= 4LL;
          v60.n128_u64[1] *= SHIDWORD(v64);
          v63.n128_u64[1] *= (int)HIDWORD(*v61);
          v61 += 2;
        }
        while ( v62 );
        v58 = v63.n128_u64[0] * v60.n128_u64[0] * v63.n128_u64[1] * v60.n128_u64[1];
        if ( v59 == v418[0] )
          goto LABEL_95;
      }
      v65 = (unsigned int)v418[0] - v59;
      v66 = &v419[v59];
      do
      {
        v67 = *v66++;
        --v65;
        v58 *= v67;
      }
      while ( v65 );
    }
    else
    {
      v58 = v418[2] * (__int64)v418[1];
    }
LABEL_95:
    v412 = *(_QWORD *)&v418[3] + v58 * v57;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v68 = v410;
  *v410 = 0x4049000000000000LL;
  v69 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v68 + v409);
    if ( (unsigned __int64)v68 + v409 >= v412 )
    {
      v410 = v68;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v69 = v408;
      v68 = v410;
    }
    else
    {
      v68 = (_QWORD *)((char *)v68 + v409);
    }
  }
  v70 = v409;
  v71 = v412;
  v403 = v69;
  v404 = v409;
  v405 = v68;
  v406 = v411;
  v407 = v412;
  *v68 = 0x4049000000000000LL;
  if ( v69 )
  {
    v72 = (_QWORD *)((char *)v68 + v70);
    v405 = v72;
    if ( (unsigned __int64)v72 >= v71 )
    {
      v405 = v68;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v72 = v405;
      v69 = v403;
    }
    *v72 = 0x4034000000000000LL;
    if ( v69 )
    {
      v405 = (_QWORD *)((char *)v72 + v404);
      if ( (unsigned __int64)v72 + v404 >= v407 )
      {
        v405 = v72;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v69 = v403;
      }
    }
  }
  else
  {
    *v68 = 0x4034000000000000LL;
  }
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v69);
  if ( *(_QWORD *)&v439[56] )
  {
    v74 = (unsigned int *)(*(_QWORD *)&v439[56] + 20LL);
    do
    {
      v75 = __ldaxr(v74);
      v76 = v75 - 1;
    }
    while ( __stlxr(v76, v74) );
    if ( !v76 )
      cv::Mat::deallocate((cv::Mat *)v439);
  }
  *(_QWORD *)&v439[56] = 0LL;
  memset(&v439[16], 0, 32);
  if ( *(int *)&v439[4] >= 1 )
  {
    v77 = v440;
    v78 = 0LL;
    do
      *(_DWORD *)(v77 + 4 * v78++) = 0;
    while ( v78 < *(int *)&v439[4] );
  }
  *(_OWORD *)v439 = *(_OWORD *)v413;
  *(_OWORD *)&v439[16] = *(_OWORD *)&v413[16];
  *(_OWORD *)&v439[32] = *(_OWORD *)&v413[32];
  *(_OWORD *)&v439[48] = *(_OWORD *)&v413[48];
  if ( *((__int64 **)&v440 + 1) == &v441 )
  {
    v79 = *(_DWORD *)&v413[4];
  }
  else
  {
    cv::fastFree(*((cv **)&v440 + 1), v73);
    v79 = *(_DWORD *)&v413[4];
    *(_QWORD *)&v440 = &v439[8];
    *((_QWORD *)&v440 + 1) = &v441;
  }
  if ( v79 <= 2 )
  {
    v81 = v414[1];
    v441 = *(_QWORD *)v414[1];
    v442 = *((_QWORD *)v414[1] + 1);
  }
  else
  {
    v80 = *(_OWORD *)v414;
    v81 = (cv *)&v415;
    v414[0] = (cv *)&v413[8];
    v414[1] = (cv *)&v415;
    v440 = v80;
  }
  *(_DWORD *)v413 = 1124007936;
  memset(&v413[4], 0, 60);
  if ( v81 != (cv *)&v415 )
    cv::fastFree(v81, v73);
  if ( *(_QWORD *)&v418[13] )
  {
    v82 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v83 = __ldaxr(v82);
      v84 = v83 - 1;
    }
    while ( __stlxr(v84, v82) );
    if ( !v84 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v85 = v419;
    v86 = 0LL;
    do
      v85[v86++] = 0;
    while ( v86 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v73);
  *(_DWORD *)v413 = 1124007936;
  *(_QWORD *)&v418[3] = 0LL;
  memset(&v413[4], 0, 60);
  v417 = 33619968;
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_QWORD *)&v418[1] = v413;
  cv::Mat::copyTo(a2, &v417);
  if ( *(_QWORD *)&v435[56] )
  {
    v88 = (unsigned int *)(*(_QWORD *)&v435[56] + 20LL);
    do
    {
      v89 = __ldaxr(v88);
      v90 = v89 - 1;
    }
    while ( __stlxr(v90, v88) );
    if ( !v90 )
      cv::Mat::deallocate((cv::Mat *)v435);
  }
  *(_QWORD *)&v435[56] = 0LL;
  memset(&v435[16], 0, 32);
  if ( *(int *)&v435[4] >= 1 )
  {
    v91 = v436[0];
    v92 = 0LL;
    do
      *((_DWORD *)v91 + v92++) = 0;
    while ( v92 < *(int *)&v435[4] );
  }
  *(_OWORD *)v435 = *(_OWORD *)v413;
  *(_OWORD *)&v435[16] = *(_OWORD *)&v413[16];
  *(_OWORD *)&v435[32] = *(_OWORD *)&v413[32];
  *(_OWORD *)&v435[48] = *(_OWORD *)&v413[48];
  if ( (__int64 *)v436[1] == &v437 )
  {
    v93 = *(_DWORD *)&v413[4];
  }
  else
  {
    cv::fastFree(v436[1], v87);
    v93 = *(_DWORD *)&v413[4];
    v436[1] = (cv *)&v437;
    v436[0] = (cv *)&v435[8];
  }
  if ( v93 <= 2 )
  {
    v95 = v414[1];
    v437 = *(_QWORD *)v414[1];
    v438 = *((_QWORD *)v414[1] + 1);
  }
  else
  {
    v94 = *(_OWORD *)v414;
    v95 = (cv *)&v415;
    v414[0] = (cv *)&v413[8];
    v414[1] = (cv *)&v415;
    *(_OWORD *)v436 = v94;
  }
  *(_DWORD *)v413 = 1124007936;
  memset(&v413[4], 0, 60);
  if ( v95 != (cv *)&v415 )
    cv::fastFree(v95, v87);
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x300000003LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v96 = 0LL;
  else
    v96 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v96;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v98 = 0LL;
        v97 = 1LL;
      }
      else
      {
        v98 = v418[0] & 0xFFFFFFFC;
        v99 = vdupq_n_s64(1uLL);
        v100 = v419 + 2;
        v101 = v98;
        v102 = v99;
        do
        {
          v103 = *(v100 - 1);
          v99.n128_u64[0] *= (int)v103;
          v102.n128_u64[0] *= (int)*v100;
          v101 -= 4LL;
          v99.n128_u64[1] *= SHIDWORD(v103);
          v102.n128_u64[1] *= (int)HIDWORD(*v100);
          v100 += 2;
        }
        while ( v101 );
        v97 = v102.n128_u64[0] * v99.n128_u64[0] * v102.n128_u64[1] * v99.n128_u64[1];
        if ( v98 == v418[0] )
          goto LABEL_162;
      }
      v104 = (unsigned int)v418[0] - v98;
      v105 = &v419[v98];
      do
      {
        v106 = *v105++;
        --v104;
        v97 *= v106;
      }
      while ( v104 );
    }
    else
    {
      v97 = v418[2] * (__int64)v418[1];
    }
LABEL_162:
    v412 = *(_QWORD *)&v418[3] + v97 * v96;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v107 = v410;
  *v410 = 0x3FEFFFA3B9AE0C17LL;
  v108 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v107 + v409);
    if ( (unsigned __int64)v107 + v409 >= v412 )
    {
      v410 = v107;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v108 = v408;
      v107 = v410;
    }
    else
    {
      v107 = (_QWORD *)((char *)v107 + v409);
    }
  }
  v109 = v409;
  v110 = v412;
  v403 = v108;
  v404 = v409;
  v405 = v107;
  v406 = v411;
  v407 = v412;
  *v107 = 0x3F831FDA90DAAE37LL;
  if ( v108 )
  {
    v111 = (_QWORD *)((char *)v107 + v109);
    v405 = v111;
    if ( (unsigned __int64)v111 >= v110 )
    {
      v405 = v107;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v111 = v405;
      v108 = v403;
    }
    *v111 = 0x3F4C317B9A77876DLL;
    if ( v108 )
    {
      v112 = (_QWORD *)((char *)v111 + v404);
      v405 = (_QWORD *)((char *)v111 + v404);
      if ( (unsigned __int64)v111 + v404 >= v407 )
      {
        v405 = v111;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v112 = v405;
        v108 = v403;
      }
    }
    else
    {
      v112 = v111;
    }
    *v112 = 0xBF831E06255E0874LL;
    if ( v108 )
    {
      v113 = (_QWORD *)((char *)v112 + v404);
      v405 = (_QWORD *)((char *)v112 + v404);
      if ( (unsigned __int64)v112 + v404 >= v407 )
      {
        v405 = v112;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v113 = v405;
        v108 = v403;
      }
    }
    else
    {
      v113 = v112;
    }
    *v113 = 0x3FEFFF950B955F78LL;
    if ( v108 )
    {
      v114 = (_QWORD *)((char *)v113 + v404);
      v405 = (_QWORD *)((char *)v113 + v404);
      if ( (unsigned __int64)v113 + v404 >= v407 )
      {
        v405 = v113;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v114 = v405;
        v108 = v403;
      }
    }
    else
    {
      v114 = v113;
    }
    *v114 = 0xBF70465EB41570D6LL;
    if ( v108 )
    {
      v115 = (_QWORD *)((char *)v114 + v404);
      v405 = (_QWORD *)((char *)v114 + v404);
      if ( (unsigned __int64)v114 + v404 >= v407 )
      {
        v405 = v114;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v115 = v405;
        v108 = v403;
      }
    }
    else
    {
      v115 = v114;
    }
    *v115 = 0xBF4D685D58EDFA3BLL;
    if ( v108 )
    {
      v116 = (_QWORD *)((char *)v115 + v404);
      v405 = (_QWORD *)((char *)v115 + v404);
      if ( (unsigned __int64)v115 + v404 >= v407 )
      {
        v405 = v115;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v116 = v405;
        v108 = v403;
      }
    }
    else
    {
      v116 = v115;
    }
    *v116 = 0x3F703DC2D92E041FLL;
    if ( v108 )
    {
      v117 = (_QWORD *)((char *)v116 + v404);
      v405 = (_QWORD *)((char *)v116 + v404);
      if ( (unsigned __int64)v116 + v404 >= v407 )
      {
        v405 = v116;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v117 = v405;
        v108 = v403;
      }
    }
    else
    {
      v117 = v116;
    }
    *v117 = 0x3FEFFFEF39085F4ALL;
    if ( v108 )
    {
      v405 = (_QWORD *)((char *)v117 + v404);
      if ( (unsigned __int64)v117 + v404 >= v407 )
      {
        v405 = v117;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v108 = v403;
      }
    }
  }
  else
  {
    *v107 = 0x3FEFFFEF39085F4ALL;
  }
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v108);
  if ( (_BYTE *)(a1 + 320) == v413 )
  {
    if ( *(_QWORD *)&v413[56] )
    {
      v130 = (unsigned int *)(*(_QWORD *)&v413[56] + 20LL);
      do
      {
        v131 = __ldaxr(v130);
        v132 = v131 - 1;
      }
      while ( __stlxr(v132, v130) );
      if ( !v132 )
        cv::Mat::deallocate((cv::Mat *)v413);
    }
  }
  else
  {
    v119 = *(_QWORD *)(a1 + 376);
    if ( v119 )
    {
      v120 = (unsigned int *)(v119 + 20);
      do
      {
        v121 = __ldaxr(v120);
        v122 = v121 - 1;
      }
      while ( __stlxr(v122, v120) );
      if ( !v122 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 320));
    }
    v123 = *(_DWORD *)(a1 + 324);
    *(_QWORD *)(a1 + 376) = 0LL;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    if ( v123 >= 1 )
    {
      v124 = *(_QWORD *)(a1 + 384);
      v125 = 0LL;
      do
        *(_DWORD *)(v124 + 4 * v125++) = 0;
      while ( v125 < *(int *)(a1 + 324) );
    }
    v126 = *(_DWORD *)&v413[4];
    v127 = *(_OWORD *)&v413[16];
    v128 = *(cv **)(a1 + 392);
    *(_OWORD *)(a1 + 320) = *(_OWORD *)v413;
    *(_OWORD *)(a1 + 336) = v127;
    *(_OWORD *)(a1 + 352) = *(_OWORD *)&v413[32];
    *(_OWORD *)(a1 + 368) = *(_OWORD *)&v413[48];
    if ( v128 == (cv *)(a1 + 400) )
    {
      v129 = v126;
    }
    else
    {
      cv::fastFree(v128, v118);
      *(_QWORD *)(a1 + 384) = a1 + 328;
      *(_QWORD *)(a1 + 392) = a1 + 400;
      v129 = *(_DWORD *)&v413[4];
      v128 = (cv *)(a1 + 400);
    }
    if ( v129 <= 2 )
    {
      v133 = v414[1];
      *(_QWORD *)v128 = *(_QWORD *)v414[1];
      *((_QWORD *)v128 + 1) = *((_QWORD *)v133 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 384) = *(_OWORD *)v414;
      v414[0] = (cv *)&v413[8];
      v414[1] = (cv *)&v415;
    }
    *(_DWORD *)v413 = 1124007936;
    memset(&v413[4], 0, 60);
  }
  *(_QWORD *)&v413[56] = 0LL;
  memset(&v413[16], 0, 32);
  if ( *(int *)&v413[4] >= 1 )
  {
    v134 = v414[0];
    v135 = 0LL;
    do
      *((_DWORD *)v134 + v135++) = 0;
    while ( v135 < *(int *)&v413[4] );
  }
  if ( (__int64 *)v414[1] != &v415 )
    cv::fastFree(v414[1], v118);
  if ( *(_QWORD *)&v418[13] )
  {
    v136 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v137 = __ldaxr(v136);
      v138 = v137 - 1;
    }
    while ( __stlxr(v138, v136) );
    if ( !v138 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v139 = v419;
    v140 = 0LL;
    do
      v139[v140++] = 0;
    while ( v140 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v118);
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x100000003LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v141 = 0LL;
  else
    v141 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v141;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v143 = 0LL;
        v142 = 1LL;
      }
      else
      {
        v143 = v418[0] & 0xFFFFFFFC;
        v144 = vdupq_n_s64(1uLL);
        v145 = v419 + 2;
        v146 = v143;
        v147 = v144;
        do
        {
          v148 = *(v145 - 1);
          v144.n128_u64[0] *= (int)v148;
          v147.n128_u64[0] *= (int)*v145;
          v146 -= 4LL;
          v144.n128_u64[1] *= SHIDWORD(v148);
          v147.n128_u64[1] *= (int)HIDWORD(*v145);
          v145 += 2;
        }
        while ( v146 );
        v142 = v147.n128_u64[0] * v144.n128_u64[0] * v147.n128_u64[1] * v144.n128_u64[1];
        if ( v143 == v418[0] )
          goto LABEL_247;
      }
      v149 = (unsigned int)v418[0] - v143;
      v150 = &v419[v143];
      do
      {
        v151 = *v150++;
        --v149;
        v142 *= v151;
      }
      while ( v149 );
    }
    else
    {
      v142 = v418[2] * (__int64)v418[1];
    }
LABEL_247:
    v412 = *(_QWORD *)&v418[3] + v142 * v141;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v152 = v410;
  *v410 = 0xC038E34D6A161E4FLL;
  v153 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v152 + v409);
    if ( (unsigned __int64)v152 + v409 >= v412 )
    {
      v410 = v152;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v153 = v408;
      v152 = v410;
    }
    else
    {
      v152 = (_QWORD *)((char *)v152 + v409);
    }
  }
  v154 = v409;
  v155 = v412;
  v403 = v153;
  v404 = v409;
  v405 = v152;
  v406 = v411;
  v407 = v412;
  *v152 = 0x3FC679CC74B838C1LL;
  if ( v153 )
  {
    v156 = (_QWORD *)((char *)v152 + v154);
    v405 = v156;
    if ( (unsigned __int64)v156 >= v155 )
    {
      v405 = v152;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v156 = v405;
      v153 = v403;
    }
    *v156 = 0x3FE6FA3DB3BFB58DLL;
    if ( v153 )
    {
      v405 = (_QWORD *)((char *)v156 + v404);
      if ( (unsigned __int64)v156 + v404 >= v407 )
      {
        v405 = v156;
        cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
        v153 = v403;
      }
    }
  }
  else
  {
    *v152 = 0x3FE6FA3DB3BFB58DLL;
  }
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v153);
  if ( (_BYTE *)(a1 + 416) == v413 )
  {
    if ( *(_QWORD *)&v413[56] )
    {
      v169 = (unsigned int *)(*(_QWORD *)&v413[56] + 20LL);
      do
      {
        v170 = __ldaxr(v169);
        v171 = v170 - 1;
      }
      while ( __stlxr(v171, v169) );
      if ( !v171 )
        cv::Mat::deallocate((cv::Mat *)v413);
    }
  }
  else
  {
    v158 = *(_QWORD *)(a1 + 472);
    if ( v158 )
    {
      v159 = (unsigned int *)(v158 + 20);
      do
      {
        v160 = __ldaxr(v159);
        v161 = v160 - 1;
      }
      while ( __stlxr(v161, v159) );
      if ( !v161 )
        cv::Mat::deallocate((cv::Mat *)(a1 + 416));
    }
    v162 = *(_DWORD *)(a1 + 420);
    *(_QWORD *)(a1 + 472) = 0LL;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    if ( v162 >= 1 )
    {
      v163 = *(_QWORD *)(a1 + 480);
      v164 = 0LL;
      do
        *(_DWORD *)(v163 + 4 * v164++) = 0;
      while ( v164 < *(int *)(a1 + 420) );
    }
    v165 = *(_DWORD *)&v413[4];
    v166 = *(_OWORD *)&v413[16];
    v167 = *(cv **)(a1 + 488);
    *(_OWORD *)(a1 + 416) = *(_OWORD *)v413;
    *(_OWORD *)(a1 + 432) = v166;
    *(_OWORD *)(a1 + 448) = *(_OWORD *)&v413[32];
    *(_OWORD *)(a1 + 464) = *(_OWORD *)&v413[48];
    if ( v167 == (cv *)(a1 + 496) )
    {
      v168 = v165;
    }
    else
    {
      cv::fastFree(v167, v157);
      *(_QWORD *)(a1 + 480) = a1 + 424;
      *(_QWORD *)(a1 + 488) = a1 + 496;
      v168 = *(_DWORD *)&v413[4];
      v167 = (cv *)(a1 + 496);
    }
    if ( v168 <= 2 )
    {
      v172 = v414[1];
      *(_QWORD *)v167 = *(_QWORD *)v414[1];
      *((_QWORD *)v167 + 1) = *((_QWORD *)v172 + 1);
    }
    else
    {
      *(_OWORD *)(a1 + 480) = *(_OWORD *)v414;
      v414[0] = (cv *)&v413[8];
      v414[1] = (cv *)&v415;
    }
    *(_DWORD *)v413 = 1124007936;
    memset(&v413[4], 0, 60);
  }
  *(_QWORD *)&v413[56] = 0LL;
  memset(&v413[16], 0, 32);
  if ( *(int *)&v413[4] >= 1 )
  {
    v173 = v414[0];
    v174 = 0LL;
    do
      *((_DWORD *)v173 + v174++) = 0;
    while ( v174 < *(int *)&v413[4] );
  }
  if ( (__int64 *)v414[1] != &v415 )
    cv::fastFree(v414[1], v157);
  if ( *(_QWORD *)&v418[13] )
  {
    v175 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v176 = __ldaxr(v175);
      v177 = v176 - 1;
    }
    while ( __stlxr(v177, v175) );
    if ( !v177 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v178 = v419;
    v179 = 0LL;
    do
      v178[v179++] = 0;
    while ( v179 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v157);
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x400000004LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v180 = 0LL;
  else
    v180 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v180;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v182 = 0LL;
        v181 = 1LL;
      }
      else
      {
        v182 = v418[0] & 0xFFFFFFFC;
        v183 = vdupq_n_s64(1uLL);
        v184 = v419 + 2;
        v185 = v182;
        v186 = v183;
        do
        {
          v187 = *(v184 - 1);
          v183.n128_u64[0] *= (int)v187;
          v186.n128_u64[0] *= (int)*v184;
          v185 -= 4LL;
          v183.n128_u64[1] *= SHIDWORD(v187);
          v186.n128_u64[1] *= (int)HIDWORD(*v184);
          v184 += 2;
        }
        while ( v185 );
        v181 = v186.n128_u64[0] * v183.n128_u64[0] * v186.n128_u64[1] * v183.n128_u64[1];
        if ( v182 == v418[0] )
          goto LABEL_308;
      }
      v188 = (unsigned int)v418[0] - v182;
      v189 = &v419[v182];
      do
      {
        v190 = *v189++;
        --v188;
        v181 *= v190;
      }
      while ( v188 );
    }
    else
    {
      v181 = v418[2] * (__int64)v418[1];
    }
LABEL_308:
    v412 = *(_QWORD *)&v418[3] + v181 * v180;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v191 = v410;
  *v410 = 0x3E4A99B5E3F53BACLL;
  v192 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v191 + v409);
    if ( (unsigned __int64)v191 + v409 >= v412 )
    {
      v410 = v191;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v192 = v408;
      v191 = v410;
    }
    else
    {
      v191 = (_QWORD *)((char *)v191 + v409);
    }
  }
  v193 = v409;
  v194 = v412;
  v403 = v192;
  v404 = v409;
  v405 = v191;
  v406 = v411;
  v407 = v412;
  *v191 = 0xBFED23F9E816BDBDLL;
  if ( !v192 )
  {
    *v191 = 0x3FF0000000000000LL;
    goto LABEL_372;
  }
  v195 = (_QWORD *)((char *)v191 + v193);
  v405 = v195;
  if ( (unsigned __int64)v195 >= v194 )
  {
    v405 = v191;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v195 = v405;
    v192 = v403;
  }
  *v195 = 0x3FDA71D22DC888B2LL;
  if ( !v192 )
  {
    v196 = v195;
    *v195 = 0LL;
LABEL_324:
    v197 = v196;
    goto LABEL_325;
  }
  v196 = (_QWORD *)((char *)v195 + v404);
  v405 = (_QWORD *)((char *)v195 + v404);
  if ( (unsigned __int64)v195 + v404 >= v407 )
  {
    v405 = v195;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v196 = v405;
    v192 = v403;
  }
  *v196 = 0LL;
  if ( !v192 )
    goto LABEL_324;
  v197 = (_QWORD *)((char *)v196 + v404);
  v405 = (_QWORD *)((char *)v196 + v404);
  if ( (unsigned __int64)v196 + v404 >= v407 )
  {
    v405 = v196;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v197 = v405;
    v192 = v403;
  }
LABEL_325:
  *v197 = 0xBFEFFFCBDE1599BDLL;
  if ( v192 )
  {
    v198 = (_QWORD *)((char *)v197 + v404);
    v405 = (_QWORD *)((char *)v197 + v404);
    if ( (unsigned __int64)v197 + v404 >= v407 )
    {
      v405 = v197;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v198 = v405;
      v192 = v403;
    }
  }
  else
  {
    v198 = v197;
  }
  *v198 = 0xBF67DDFD0889E4E0LL;
  if ( v192 )
  {
    v199 = (_QWORD *)((char *)v198 + v404);
    v405 = (_QWORD *)((char *)v198 + v404);
    if ( (unsigned __int64)v198 + v404 >= v407 )
    {
      v405 = v198;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v199 = v405;
      v192 = v403;
    }
  }
  else
  {
    v199 = v198;
  }
  *v199 = 0xBF7A4CD84FBC4603LL;
  if ( !v192 )
  {
    v200 = v199;
    *v199 = 0LL;
LABEL_340:
    v201 = v200;
    goto LABEL_341;
  }
  v200 = (_QWORD *)((char *)v199 + v404);
  v405 = (_QWORD *)((char *)v199 + v404);
  if ( (unsigned __int64)v199 + v404 >= v407 )
  {
    v405 = v199;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v200 = v405;
    v192 = v403;
  }
  *v200 = 0LL;
  if ( !v192 )
    goto LABEL_340;
  v201 = (_QWORD *)((char *)v200 + v404);
  v405 = (_QWORD *)((char *)v200 + v404);
  if ( (unsigned __int64)v200 + v404 >= v407 )
  {
    v405 = v200;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v201 = v405;
    v192 = v403;
  }
LABEL_341:
  *v201 = 0x3F7CE1860966F061LL;
  if ( v192 )
  {
    v202 = (_QWORD *)((char *)v201 + v404);
    v405 = (_QWORD *)((char *)v201 + v404);
    if ( (unsigned __int64)v201 + v404 >= v407 )
    {
      v405 = v201;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v202 = v405;
      v192 = v403;
    }
  }
  else
  {
    v202 = v201;
  }
  *v202 = 0xBFDA71A718B60BF6LL;
  if ( v192 )
  {
    v203 = (_QWORD *)((char *)v202 + v404);
    v405 = (_QWORD *)((char *)v202 + v404);
    if ( (unsigned __int64)v202 + v404 >= v407 )
    {
      v405 = v202;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v203 = v405;
      v192 = v403;
    }
  }
  else
  {
    v203 = v202;
  }
  *v203 = 0xBFED23CA6EC30C6ELL;
  if ( v192 )
  {
    v204 = (_QWORD *)((char *)v203 + v404);
    v405 = (_QWORD *)((char *)v203 + v404);
    if ( (unsigned __int64)v203 + v404 >= v407 )
    {
      v405 = v203;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v204 = v405;
      v192 = v403;
    }
  }
  else
  {
    v204 = v203;
  }
  *v204 = 0x408D4A1140000000LL;
  if ( !v192 )
  {
    v205 = v204;
    *v204 = 0LL;
LABEL_363:
    v206 = v205;
    *v205 = 0LL;
    goto LABEL_364;
  }
  v205 = (_QWORD *)((char *)v204 + v404);
  v405 = (_QWORD *)((char *)v204 + v404);
  if ( (unsigned __int64)v204 + v404 >= v407 )
  {
    v405 = v204;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v205 = v405;
    v192 = v403;
  }
  *v205 = 0LL;
  if ( !v192 )
    goto LABEL_363;
  v206 = (_QWORD *)((char *)v205 + v404);
  v405 = (_QWORD *)((char *)v205 + v404);
  if ( (unsigned __int64)v205 + v404 >= v407 )
  {
    v405 = v205;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v206 = v405;
    v192 = v403;
  }
  *v206 = 0LL;
  if ( v192 )
  {
    v207 = (_QWORD *)((char *)v206 + v404);
    v405 = (_QWORD *)((char *)v206 + v404);
    if ( (unsigned __int64)v206 + v404 >= v407 )
    {
      v405 = v206;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v207 = v405;
      v192 = v403;
    }
    goto LABEL_365;
  }
LABEL_364:
  v207 = v206;
LABEL_365:
  *v207 = 40924280LL;
  if ( v192 )
  {
    v208 = (_QWORD *)((char *)v207 + v404);
    v405 = (_QWORD *)((char *)v207 + v404);
    if ( (unsigned __int64)v207 + v404 >= v407 )
    {
      v405 = v207;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v208 = v405;
      v192 = v403;
    }
  }
  else
  {
    v208 = v207;
  }
  *v208 = 0x3FF0000000000000LL;
  if ( v192 )
  {
    v405 = (_QWORD *)((char *)v208 + v404);
    if ( (unsigned __int64)v208 + v404 >= v407 )
    {
      v405 = v208;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v192 = v403;
    }
  }
LABEL_372:
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v192);
  if ( *(_QWORD *)&v427[56] )
  {
    v210 = (unsigned int *)(*(_QWORD *)&v427[56] + 20LL);
    do
    {
      v211 = __ldaxr(v210);
      v212 = v211 - 1;
    }
    while ( __stlxr(v212, v210) );
    if ( !v212 )
      cv::Mat::deallocate((cv::Mat *)v427);
  }
  *(_QWORD *)&v427[56] = 0LL;
  memset(&v427[16], 0, 32);
  if ( *(int *)&v427[4] >= 1 )
  {
    v213 = v428[0];
    v214 = 0LL;
    do
      *((_DWORD *)v213 + v214++) = 0;
    while ( v214 < *(int *)&v427[4] );
  }
  *(_OWORD *)v427 = *(_OWORD *)v413;
  *(_OWORD *)&v427[16] = *(_OWORD *)&v413[16];
  *(_OWORD *)&v427[32] = *(_OWORD *)&v413[32];
  *(_OWORD *)&v427[48] = *(_OWORD *)&v413[48];
  if ( (__int64 *)v428[1] == &v429 )
  {
    v215 = *(_DWORD *)&v413[4];
  }
  else
  {
    cv::fastFree(v428[1], v209);
    v215 = *(_DWORD *)&v413[4];
    v428[1] = (cv *)&v429;
    v428[0] = (cv *)&v427[8];
  }
  if ( v215 <= 2 )
  {
    v217 = v414[1];
    v429 = *(_QWORD *)v414[1];
    v430 = *((_QWORD *)v414[1] + 1);
  }
  else
  {
    v216 = *(_OWORD *)v414;
    v217 = (cv *)&v415;
    v414[0] = (cv *)&v413[8];
    v414[1] = (cv *)&v415;
    *(_OWORD *)v428 = v216;
  }
  *(_DWORD *)v413 = 1124007936;
  memset(&v413[4], 0, 60);
  if ( v217 != (cv *)&v415 )
    cv::fastFree(v217, v209);
  if ( *(_QWORD *)&v418[13] )
  {
    v218 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v219 = __ldaxr(v218);
      v220 = v219 - 1;
    }
    while ( __stlxr(v220, v218) );
    if ( !v220 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v221 = v419;
    v222 = 0LL;
    do
      v221[v222++] = 0;
    while ( v222 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v209);
  v417 = 1124007936;
  memset(v418, 0, sizeof(v418));
  v419 = &v418[1];
  v420 = (cv *)&v421;
  v422 = 0LL;
  v421 = 0LL;
  v408 = (cv::Mat *)0x400000004LL;
  cv::Mat::create((cv::Mat *)&v417, 2, (const int *)&v408, 6);
  v408 = (cv::Mat *)&v417;
  if ( v418[0] < 1 )
    v223 = 0LL;
  else
    v223 = *((_QWORD *)v420 + v418[0] - 1);
  v409 = v223;
  v410 = 0LL;
  v411 = 0LL;
  v412 = 0LL;
  if ( (v417 & 0x4000) != 0 )
  {
    v411 = *(_QWORD *)&v418[3];
    if ( v418[0] >= 3 )
    {
      if ( v418[0] == 3 )
      {
        v225 = 0LL;
        v224 = 1LL;
      }
      else
      {
        v225 = v418[0] & 0xFFFFFFFC;
        v226 = vdupq_n_s64(1uLL);
        v227 = v419 + 2;
        v228 = v225;
        v229 = v226;
        do
        {
          v230 = *(v227 - 1);
          v226.n128_u64[0] *= (int)v230;
          v229.n128_u64[0] *= (int)*v227;
          v228 -= 4LL;
          v226.n128_u64[1] *= SHIDWORD(v230);
          v229.n128_u64[1] *= (int)HIDWORD(*v227);
          v227 += 2;
        }
        while ( v228 );
        v224 = v229.n128_u64[0] * v226.n128_u64[0] * v229.n128_u64[1] * v226.n128_u64[1];
        if ( v225 == v418[0] )
          goto LABEL_411;
      }
      v231 = (unsigned int)v418[0] - v225;
      v232 = &v419[v225];
      do
      {
        v233 = *v232++;
        --v231;
        v224 *= v233;
      }
      while ( v231 );
    }
    else
    {
      v224 = v418[2] * (__int64)v418[1];
    }
LABEL_411:
    v412 = *(_QWORD *)&v418[3] + v224 * v223;
  }
  cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 0LL, 0);
  v234 = v410;
  *v410 = 0x3FF0000000000000LL;
  v235 = v408;
  if ( v408 )
  {
    v410 = (_QWORD *)((char *)v234 + v409);
    if ( (unsigned __int64)v234 + v409 >= v412 )
    {
      v410 = v234;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v408, 1LL, 1);
      v235 = v408;
      v234 = v410;
    }
    else
    {
      v234 = (_QWORD *)((char *)v234 + v409);
    }
  }
  v236 = v409;
  v237 = v412;
  v403 = v235;
  v404 = v409;
  v405 = v234;
  v406 = v411;
  v407 = v412;
  *v234 = 0LL;
  if ( !v235 )
  {
    *v234 = 0x3FF0000000000000LL;
    goto LABEL_475;
  }
  v238 = (_QWORD *)((char *)v234 + v236);
  v405 = v238;
  if ( (unsigned __int64)v238 >= v237 )
  {
    v405 = v234;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v238 = v405;
    v235 = v403;
  }
  *v238 = 0LL;
  if ( !v235 )
  {
    v239 = v238;
    *v238 = 0LL;
LABEL_430:
    v240 = v239;
    *v239 = 0LL;
LABEL_431:
    v241 = v240;
    goto LABEL_432;
  }
  v239 = (_QWORD *)((char *)v238 + v404);
  v405 = (_QWORD *)((char *)v238 + v404);
  if ( (unsigned __int64)v238 + v404 >= v407 )
  {
    v405 = v238;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v239 = v405;
    v235 = v403;
  }
  *v239 = 0LL;
  if ( !v235 )
    goto LABEL_430;
  v240 = (_QWORD *)((char *)v239 + v404);
  v405 = (_QWORD *)((char *)v239 + v404);
  if ( (unsigned __int64)v239 + v404 >= v407 )
  {
    v405 = v239;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v240 = v405;
    v235 = v403;
  }
  *v240 = 0LL;
  if ( !v235 )
    goto LABEL_431;
  v241 = (_QWORD *)((char *)v240 + v404);
  v405 = (_QWORD *)((char *)v240 + v404);
  if ( (unsigned __int64)v240 + v404 >= v407 )
  {
    v405 = v240;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v241 = v405;
    v235 = v403;
  }
LABEL_432:
  *v241 = 0x3FF0000000000000LL;
  if ( !v235 )
  {
    v242 = v241;
    *v241 = 0LL;
LABEL_448:
    v243 = v242;
    *v242 = 0LL;
LABEL_449:
    v244 = v243;
    *v243 = 0LL;
LABEL_450:
    v245 = v244;
    *v244 = 0LL;
LABEL_451:
    v246 = v245;
    goto LABEL_452;
  }
  v242 = (_QWORD *)((char *)v241 + v404);
  v405 = (_QWORD *)((char *)v241 + v404);
  if ( (unsigned __int64)v241 + v404 >= v407 )
  {
    v405 = v241;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v242 = v405;
    v235 = v403;
  }
  *v242 = 0LL;
  if ( !v235 )
    goto LABEL_448;
  v243 = (_QWORD *)((char *)v242 + v404);
  v405 = (_QWORD *)((char *)v242 + v404);
  if ( (unsigned __int64)v242 + v404 >= v407 )
  {
    v405 = v242;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v243 = v405;
    v235 = v403;
  }
  *v243 = 0LL;
  if ( !v235 )
    goto LABEL_449;
  v244 = (_QWORD *)((char *)v243 + v404);
  v405 = (_QWORD *)((char *)v243 + v404);
  if ( (unsigned __int64)v243 + v404 >= v407 )
  {
    v405 = v243;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v244 = v405;
    v235 = v403;
  }
  *v244 = 0LL;
  if ( !v235 )
    goto LABEL_450;
  v245 = (_QWORD *)((char *)v244 + v404);
  v405 = (_QWORD *)((char *)v244 + v404);
  if ( (unsigned __int64)v244 + v404 >= v407 )
  {
    v405 = v244;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v245 = v405;
    v235 = v403;
  }
  *v245 = 0LL;
  if ( !v235 )
    goto LABEL_451;
  v246 = (_QWORD *)((char *)v245 + v404);
  v405 = (_QWORD *)((char *)v245 + v404);
  if ( (unsigned __int64)v245 + v404 >= v407 )
  {
    v405 = v245;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v246 = v405;
    v235 = v403;
  }
LABEL_452:
  *v246 = 0x3FF0000000000000LL;
  if ( !v235 )
  {
    v247 = v246;
    *v246 = 0LL;
LABEL_468:
    v248 = v247;
    *v247 = 0LL;
LABEL_469:
    v249 = v248;
    *v248 = 0LL;
LABEL_470:
    v250 = v249;
    *v249 = 0LL;
    goto LABEL_471;
  }
  v247 = (_QWORD *)((char *)v246 + v404);
  v405 = (_QWORD *)((char *)v246 + v404);
  if ( (unsigned __int64)v246 + v404 >= v407 )
  {
    v405 = v246;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v247 = v405;
    v235 = v403;
  }
  *v247 = 0LL;
  if ( !v235 )
    goto LABEL_468;
  v248 = (_QWORD *)((char *)v247 + v404);
  v405 = (_QWORD *)((char *)v247 + v404);
  if ( (unsigned __int64)v247 + v404 >= v407 )
  {
    v405 = v247;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v248 = v405;
    v235 = v403;
  }
  *v248 = 0LL;
  if ( !v235 )
    goto LABEL_469;
  v249 = (_QWORD *)((char *)v248 + v404);
  v405 = (_QWORD *)((char *)v248 + v404);
  if ( (unsigned __int64)v248 + v404 >= v407 )
  {
    v405 = v248;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v249 = v405;
    v235 = v403;
  }
  *v249 = 0LL;
  if ( !v235 )
    goto LABEL_470;
  v250 = (_QWORD *)((char *)v249 + v404);
  v405 = (_QWORD *)((char *)v249 + v404);
  if ( (unsigned __int64)v249 + v404 >= v407 )
  {
    v405 = v249;
    cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
    v250 = v405;
    v235 = v403;
  }
  *v250 = 0LL;
  if ( v235 )
  {
    v251 = (_QWORD *)((char *)v250 + v404);
    v405 = (_QWORD *)((char *)v250 + v404);
    if ( (unsigned __int64)v250 + v404 >= v407 )
    {
      v405 = v250;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v251 = v405;
      v235 = v403;
    }
    goto LABEL_472;
  }
LABEL_471:
  v251 = v250;
LABEL_472:
  *v251 = 0x3FF0000000000000LL;
  if ( v235 )
  {
    v405 = (_QWORD *)((char *)v251 + v404);
    if ( (unsigned __int64)v251 + v404 >= v407 )
    {
      v405 = v251;
      cv::MatConstIterator::seek((cv::MatConstIterator *)&v403, 1LL, 1);
      v235 = v403;
    }
  }
LABEL_475:
  memset(&v413[4], 0, 60);
  v414[0] = (cv *)&v413[8];
  v414[1] = (cv *)&v415;
  v415 = 0LL;
  v416 = 0LL;
  *(_DWORD *)v413 = 1124007942;
  cv::Mat_<double>::operator=((cv::Mat *)v413, v235);
  if ( *(_QWORD *)&v423[56] )
  {
    v253 = (unsigned int *)(*(_QWORD *)&v423[56] + 20LL);
    do
    {
      v254 = __ldaxr(v253);
      v255 = v254 - 1;
    }
    while ( __stlxr(v255, v253) );
    if ( !v255 )
      cv::Mat::deallocate((cv::Mat *)v423);
  }
  *(_QWORD *)&v423[56] = 0LL;
  memset(&v423[16], 0, 32);
  if ( *(int *)&v423[4] >= 1 )
  {
    v256 = v424[0];
    v257 = 0LL;
    do
      *((_DWORD *)v256 + v257++) = 0;
    while ( v257 < *(int *)&v423[4] );
  }
  *(_OWORD *)v423 = *(_OWORD *)v413;
  *(_OWORD *)&v423[16] = *(_OWORD *)&v413[16];
  *(_OWORD *)&v423[32] = *(_OWORD *)&v413[32];
  *(_OWORD *)&v423[48] = *(_OWORD *)&v413[48];
  if ( (__int64 *)v424[1] == &v425 )
  {
    v258 = *(_DWORD *)&v413[4];
  }
  else
  {
    cv::fastFree(v424[1], v252);
    v258 = *(_DWORD *)&v413[4];
    v424[1] = (cv *)&v425;
    v424[0] = (cv *)&v423[8];
  }
  if ( v258 <= 2 )
  {
    v260 = v414[1];
    v425 = *(_QWORD *)v414[1];
    v426 = *((_QWORD *)v414[1] + 1);
  }
  else
  {
    v259 = *(_OWORD *)v414;
    v260 = (cv *)&v415;
    v414[0] = (cv *)&v413[8];
    v414[1] = (cv *)&v415;
    *(_OWORD *)v424 = v259;
  }
  *(_DWORD *)v413 = 1124007936;
  memset(&v413[4], 0, 60);
  if ( v260 != (cv *)&v415 )
    cv::fastFree(v260, v252);
  if ( *(_QWORD *)&v418[13] )
  {
    v261 = (unsigned int *)(*(_QWORD *)&v418[13] + 20LL);
    do
    {
      v262 = __ldaxr(v261);
      v263 = v262 - 1;
    }
    while ( __stlxr(v263, v261) );
    if ( !v263 )
      cv::Mat::deallocate((cv::Mat *)&v417);
  }
  *(_QWORD *)&v418[13] = 0LL;
  memset(&v418[3], 0, 32);
  if ( v418[0] >= 1 )
  {
    v264 = v419;
    v265 = 0LL;
    do
      v264[v265++] = 0;
    while ( v265 < v418[0] );
  }
  if ( v420 != (cv *)&v421 )
    cv::fastFree(v420, v252);
  v266 = v12 / v11;
  v267 = v10 / v9;
  if ( *(_DWORD *)v440 * *(_DWORD *)(v440 + 4) == 3 )
  {
    v268 = *(double *)(*(_QWORD *)&v439[16] + 16LL);
    *(float32x2_t *)(a1 + 168) = vcvt_f32_f64(**(float64x2_t **)&v439[16]);
    *(float *)(a1 + 176) = v268;
  }
  v269 = *(double **)&v435[16];
  v270 = v436[1];
  v271 = v266;
  v272 = *(double *)(*(_QWORD *)&v435[16] + 16LL) * v266;
  **(double **)&v435[16] = **(double **)&v435[16] * v266;
  v269[2] = v272;
  v273 = *(_QWORD *)v270;
  v274 = (double *)((char *)v269 + v273);
  *(float64x2_t *)((char *)v269 + v273 + 8) = vmulq_n_f64(*(float64x2_t *)((char *)v269 + v273 + 8), v267);
  v275 = *(double **)&v431[16];
  v276 = v432[1];
  v277 = *(double *)(*(_QWORD *)&v431[16] + 16LL) * v266;
  **(double **)&v431[16] = **(double **)&v431[16] * v271;
  v275[2] = v277;
  v278 = *(_QWORD *)v276;
  v279 = (double *)((char *)v275 + v278);
  v392 = v267;
  v280 = *(double *)((char *)v275 + v278 + 8) * v267;
  v281 = *(double *)((char *)v275 + v278 + 16) * v267;
  v279[1] = v280;
  v279[2] = v281;
  if ( *(_DWORD *)v436[0] * *((_DWORD *)v436[0] + 1) == 9 )
  {
    v282 = v280;
    v283 = v281;
    v284 = *v269;
    *(float *)(a1 + 96) = v284;
    v285 = *v275;
    *(float *)(a1 + 132) = v285;
    v286 = v269[1];
    *(float *)(a1 + 108) = v286;
    v287 = v275[1];
    *(float *)(a1 + 144) = v287;
    v288 = v269[2];
    *(float *)(a1 + 120) = v288;
    v289 = v275[2];
    *(float *)(a1 + 156) = v289;
    v290 = *(double *)((char *)v269 + v273);
    v291 = (double *)((char *)v269 + 2 * v273);
    v292 = (double *)((char *)v275 + 2 * v278);
    *(float *)&v290 = v290;
    *(_DWORD *)(a1 + 100) = LODWORD(v290);
    *(float *)&v290 = *(double *)((char *)v275 + v278);
    *(_DWORD *)(a1 + 136) = LODWORD(v290);
    v293 = v274[1];
    *(float *)(a1 + 148) = v282;
    v294 = v293;
    *(float *)(a1 + 112) = v294;
    v295 = v274[2];
    *(float *)(a1 + 160) = v283;
    v296 = v295;
    *(float *)(a1 + 124) = v296;
    v297 = *v291;
    *(float *)(a1 + 104) = v297;
    v298 = *v292;
    *(float *)(a1 + 140) = v298;
    v299 = v291[1];
    *(float *)(a1 + 116) = v299;
    v300 = v292[1];
    *(float *)(a1 + 152) = v300;
    v301 = v291[2];
    *(float *)(a1 + 128) = v301;
    v302 = v292[2];
    *(float *)(a1 + 164) = v302;
  }
  if ( *(_DWORD *)v428[0] * *((_DWORD *)v428[0] + 1) == 16 )
  {
    v303 = *(double **)&v427[16];
    v304 = *(_QWORD *)v428[1];
    v305 = **(double **)&v427[16];
    *(float *)(a1 + 180) = v305;
    v306 = v303[1];
    *(float *)(a1 + 196) = v306;
    v307 = v303[2];
    *(float *)(a1 + 212) = v307;
    v308 = v303[3];
    *(float *)(a1 + 228) = v308;
    v309 = *(double *)((char *)v303 + v304);
    *(float *)(a1 + 184) = v309;
    v310 = *(double *)((char *)v303 + v304 + 8);
    *(float *)(a1 + 200) = v310;
    v311 = *(double *)((char *)v303 + v304 + 16);
    *(float *)(a1 + 216) = v311;
    v312 = (double *)((char *)v303 + 2 * v304);
    v313 = *(double *)((char *)v303 + v304 + 24);
    *(float *)(a1 + 232) = v313;
    v314 = (double *)((char *)v303 + 3 * v304);
    v315 = *v312;
    *(float *)(a1 + 188) = v315;
    v316 = v312[1];
    *(float *)(a1 + 204) = v316;
    v317 = v312[2];
    *(float *)(a1 + 220) = v317;
    v318 = v312[3];
    *(float *)(a1 + 236) = v318;
    v319 = *v314;
    *(float *)(a1 + 192) = v319;
    v320 = v314[1];
    *(float *)(a1 + 208) = v320;
    v321 = v314[2];
    *(float *)(a1 + 224) = v321;
    v322 = v314[3];
    *(float *)(a1 + 240) = v322;
  }
  if ( *(_DWORD *)v424[0] * *((_DWORD *)v424[0] + 1) == 16 )
  {
    v323 = *(double **)&v423[16];
    v324 = *(_QWORD *)v424[1];
    v325 = **(double **)&v423[16];
    *(float *)(a1 + 244) = v325;
    v326 = v323[1];
    *(float *)(a1 + 260) = v326;
    v327 = v323[2];
    *(float *)(a1 + 276) = v327;
    v328 = v323[3];
    *(float *)(a1 + 292) = v328;
    v329 = *(double *)((char *)v323 + v324);
    *(float *)(a1 + 248) = v329;
    v330 = *(double *)((char *)v323 + v324 + 8);
    *(float *)(a1 + 264) = v330;
    v331 = *(double *)((char *)v323 + v324 + 16);
    *(float *)(a1 + 280) = v331;
    v332 = (double *)((char *)v323 + 2 * v324);
    v333 = *(double *)((char *)v323 + v324 + 24);
    *(float *)(a1 + 296) = v333;
    v334 = (double *)((char *)v323 + 3 * v324);
    v335 = *v332;
    *(float *)(a1 + 252) = v335;
    v336 = v332[1];
    *(float *)(a1 + 268) = v336;
    v337 = v332[2];
    *(float *)(a1 + 284) = v337;
    v338 = v332[3];
    *(float *)(a1 + 300) = v338;
    v339 = *v334;
    *(float *)(a1 + 256) = v339;
    v340 = v334[1];
    *(float *)(a1 + 272) = v340;
    v341 = v334[2];
    *(float *)(a1 + 288) = v341;
    v342 = v334[3];
    *(float *)(a1 + 304) = v342;
  }
  if ( (word_6FF40 & 1) != 0 )
    v343 = (const char *)qword_6FF50;
  else
    v343 = (char *)&word_6FF40 + 1;
  v399 = dword_6FF38;
  v401 = 0LL;
  v402 = 0LL;
  v400 = 0LL;
  v344 = strlen(v343);
  if ( v344 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v345 = v344;
  if ( v344 >= 0x17 )
  {
    v347 = (v344 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v346 = (char *)operator new(v347);
    v401 = v345;
    v402 = v346;
    v400 = v347 | 1;
    goto LABEL_517;
  }
  v346 = (char *)&v400 + 1;
  LOBYTE(v400) = 2 * v344;
  if ( v344 )
LABEL_517:
    memcpy(v346, v343, v345);
  v346[v345] = 0;
  if ( (g3::logLevel(&v399) & 1) != 0 )
  {
    LOBYTE(v398[0]) = 30;
    strcpy((char *)v398 + 1, "feasibal_region");
    BYTE1(v398[2]) = 0;
    WORD1(v398[2]) = 0;
    HIDWORD(v398[2]) = 0;
    v348 = g3::logTag(v398);
    if ( ((__int64)v398[0] & 1) == 0 )
    {
      if ( (v400 & 1) == 0 )
        goto LABEL_521;
LABEL_524:
      operator delete(v402);
      if ( (v348 & 1) == 0 )
        goto LABEL_526;
      goto LABEL_525;
    }
    operator delete(v398[2]);
    if ( (v400 & 1) != 0 )
      goto LABEL_524;
  }
  else
  {
    v348 = 0;
    if ( (v400 & 1) != 0 )
      goto LABEL_524;
  }
LABEL_521:
  if ( (v348 & 1) != 0 )
  {
LABEL_525:
    LogCapture::LogCapture((LogCapture *)v413, "feasibal_region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)v413, "init param: dz:%f", *(float *)(a1 + 72));
    LogCapture::~LogCapture((LogCapture *)v413);
  }
LABEL_526:
  v349 = **(double **)&v435[16];
  v350 = *(_QWORD *)&v435[16] + *(_QWORD *)v436[1];
  v352 = *(double *)(v350 + 8);
  v351 = *(double *)(v350 + 16);
  v353 = *(double *)(*(_QWORD *)&v435[16] + 16LL);
  if ( (word_6FF40 & 1) != 0 )
    v354 = (const char *)qword_6FF50;
  else
    v354 = (char *)&word_6FF40 + 1;
  v394 = dword_6FF38;
  v396 = 0LL;
  v397 = 0LL;
  v395 = 0LL;
  v355 = strlen(v354);
  if ( v355 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v356 = v355;
  if ( v355 >= 0x17 )
  {
    v358 = (v355 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v357 = (char *)operator new(v358);
    v396 = v356;
    v397 = v357;
    v395 = v358 | 1;
    goto LABEL_534;
  }
  v357 = (char *)&v395 + 1;
  LOBYTE(v395) = 2 * v355;
  if ( v355 )
LABEL_534:
    memcpy(v357, v354, v356);
  v357[v356] = 0;
  if ( (g3::logLevel(&v394) & 1) == 0 )
  {
    v360 = 0;
    if ( (v395 & 1) != 0 )
      goto LABEL_542;
    goto LABEL_538;
  }
  LOBYTE(v393[0]) = 30;
  strcpy((char *)v393 + 1, "feasibal_region");
  BYTE1(v393[2]) = 0;
  WORD1(v393[2]) = 0;
  HIDWORD(v393[2]) = 0;
  v360 = g3::logTag(v393);
  if ( ((__int64)v393[0] & 1) != 0 )
  {
    operator delete(v393[2]);
    if ( (v395 & 1) != 0 )
      goto LABEL_542;
LABEL_538:
    if ( (v360 & 1) != 0 )
      goto LABEL_539;
    goto LABEL_543;
  }
  if ( (v395 & 1) == 0 )
    goto LABEL_538;
LABEL_542:
  operator delete(v397);
  if ( (v360 & 1) != 0 )
  {
LABEL_539:
    LogCapture::LogCapture((LogCapture *)v413, "feasibal_region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
    v361 = v349 / v271;
    v362 = v352 / v271;
    v363 = v353 / v392;
    v364 = v351 / v392;
    LogCapture::capturef((LogCapture *)v413, "init param: 640x480:fx:%f,fy:%f,cx:%f,cy:%f ", v361, v363, v362, v364);
    LogCapture::~LogCapture((LogCapture *)v413);
    v365 = *(_QWORD *)&v423[56];
    if ( !*(_QWORD *)&v423[56] )
      goto LABEL_548;
    goto LABEL_544;
  }
LABEL_543:
  v365 = *(_QWORD *)&v423[56];
  if ( !*(_QWORD *)&v423[56] )
    goto LABEL_548;
LABEL_544:
  v366 = (unsigned int *)(v365 + 20);
  do
  {
    v367 = __ldaxr(v366);
    v368 = v367 - 1;
  }
  while ( __stlxr(v368, v366) );
  if ( !v368 )
    cv::Mat::deallocate((cv::Mat *)v423);
LABEL_548:
  *(_QWORD *)&v423[56] = 0LL;
  memset(&v423[16], 0, 32);
  if ( *(int *)&v423[4] >= 1 )
  {
    v369 = v424[0];
    v370 = 0LL;
    do
      *((_DWORD *)v369 + v370++) = 0;
    while ( v370 < *(int *)&v423[4] );
  }
  if ( (__int64 *)v424[1] != &v425 )
    cv::fastFree(v424[1], v359);
  if ( *(_QWORD *)&v427[56] )
  {
    v371 = (unsigned int *)(*(_QWORD *)&v427[56] + 20LL);
    do
    {
      v372 = __ldaxr(v371);
      v373 = v372 - 1;
    }
    while ( __stlxr(v373, v371) );
    if ( !v373 )
      cv::Mat::deallocate((cv::Mat *)v427);
  }
  *(_QWORD *)&v427[56] = 0LL;
  memset(&v427[16], 0, 32);
  if ( *(int *)&v427[4] >= 1 )
  {
    v374 = v428[0];
    v375 = 0LL;
    do
      *((_DWORD *)v374 + v375++) = 0;
    while ( v375 < *(int *)&v427[4] );
  }
  if ( (__int64 *)v428[1] != &v429 )
    cv::fastFree(v428[1], v359);
  if ( *(_QWORD *)&v431[56] )
  {
    v376 = (unsigned int *)(*(_QWORD *)&v431[56] + 20LL);
    do
    {
      v377 = __ldaxr(v376);
      v378 = v377 - 1;
    }
    while ( __stlxr(v378, v376) );
    if ( !v378 )
      cv::Mat::deallocate((cv::Mat *)v431);
  }
  *(_QWORD *)&v431[56] = 0LL;
  memset(&v431[16], 0, 32);
  if ( *(int *)&v431[4] >= 1 )
  {
    v379 = v432[0];
    v380 = 0LL;
    do
      *((_DWORD *)v379 + v380++) = 0;
    while ( v380 < *(int *)&v431[4] );
  }
  if ( (__int64 *)v432[1] != &v433 )
    cv::fastFree(v432[1], v359);
  if ( *(_QWORD *)&v435[56] )
  {
    v381 = (unsigned int *)(*(_QWORD *)&v435[56] + 20LL);
    do
    {
      v382 = __ldaxr(v381);
      v383 = v382 - 1;
    }
    while ( __stlxr(v383, v381) );
    if ( !v383 )
      cv::Mat::deallocate((cv::Mat *)v435);
  }
  *(_QWORD *)&v435[56] = 0LL;
  memset(&v435[16], 0, 32);
  if ( *(int *)&v435[4] >= 1 )
  {
    v384 = v436[0];
    v385 = 0LL;
    do
      *((_DWORD *)v384 + v385++) = 0;
    while ( v385 < *(int *)&v435[4] );
  }
  if ( (__int64 *)v436[1] != &v437 )
    cv::fastFree(v436[1], v359);
  if ( *(_QWORD *)&v439[56] )
  {
    v386 = (unsigned int *)(*(_QWORD *)&v439[56] + 20LL);
    do
    {
      v387 = __ldaxr(v386);
      v388 = v387 - 1;
    }
    while ( __stlxr(v388, v386) );
    if ( !v388 )
      cv::Mat::deallocate((cv::Mat *)v439);
  }
  *(_QWORD *)&v439[56] = 0LL;
  memset(&v439[16], 0, 32);
  if ( *(int *)&v439[4] >= 1 )
  {
    v389 = v440;
    v390 = 0LL;
    do
      *(_DWORD *)(v389 + 4 * v390++) = 0;
    while ( v390 < *(int *)&v439[4] );
  }
  if ( *((__int64 **)&v440 + 1) != &v441 )
    cv::fastFree(*((cv **)&v440 + 1), v359);
  return 0LL;
}
// 433B8: conditional instruction was optimized away because x1.8==0
// 44CA8: conditional instruction was optimized away because x1.8==0
// 451D4: conditional instruction was optimized away because x1.8==0
// 45324: conditional instruction was optimized away because x1.8==0
// 45330: conditional instruction was optimized away because x1.8==0
// 4533C: conditional instruction was optimized away because x1.8==0
// 4548C: conditional instruction was optimized away because x1.8==0
// 45498: conditional instruction was optimized away because x1.8==0
// 454A4: conditional instruction was optimized away because x1.8==0
// 434C4: variable 'v41' is possibly undefined
// 4392C: variable 'v73' is possibly undefined
// 43AE8: variable 'v87' is possibly undefined
// 440C4: variable 'v118' is possibly undefined
// 44568: variable 'v157' is possibly undefined
// 44DEC: variable 'v209' is possibly undefined
// 4559C: variable 'v252' is possibly undefined
// 45D64: variable 'v359' is possibly undefined
// 28: using guessed type __int64;
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 12C00: using guessed type __int64 __fastcall cv::Mat::copyTo(_QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 6FF38: using guessed type int dword_6FF38;
// 6FF40: using guessed type __int16 word_6FF40;
// 6FF50: using guessed type __int64 qword_6FF50;

//----- (0000000000046C64) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::init(__int64 a1, __int128 *a2, __int64 a3, int a4, double a5)
{
  __int128 v7; // q0
  __int128 v8; // q1
  __int64 v11; // x8
  unsigned int *v12; // x8
  unsigned int v13; // w9
  _QWORD *v14; // x8
  cv *v15; // x10
  void *v16; // x1
  unsigned int *v17; // x8
  unsigned int v18; // w9
  unsigned int v19; // w9
  __int64 v20; // x8
  __int64 v21; // x9
  feasibal_region::ground_process *v22; // x20
  feasibal_region::ground_process *v23; // x21
  void *v24; // x1
  void *v26[62]; // [xsp+8h] [xbp-2B8h] BYREF
  __int16 v27; // [xsp+1F8h] [xbp-C8h]
  int v28; // [xsp+1FCh] [xbp-C4h]
  __int64 v29; // [xsp+200h] [xbp-C0h] BYREF
  int v30; // [xsp+208h] [xbp-B8h]
  __int128 v31; // [xsp+210h] [xbp-B0h] BYREF
  __int128 v32; // [xsp+220h] [xbp-A0h]
  __int128 v33; // [xsp+230h] [xbp-90h]
  __int64 v34; // [xsp+240h] [xbp-80h]
  __int64 v35; // [xsp+248h] [xbp-78h]
  __int64 v36; // [xsp+250h] [xbp-70h]
  cv *v37; // [xsp+258h] [xbp-68h]
  __int64 v38[4]; // [xsp+260h] [xbp-60h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v7 = *a2;
  v8 = a2[1];
  v31 = *a2;
  v32 = v8;
  v33 = a2[2];
  v34 = *((_QWORD *)a2 + 6);
  v11 = *((_QWORD *)a2 + 7);
  v37 = (cv *)v38;
  v38[0] = 0LL;
  v38[1] = 0LL;
  v35 = v11;
  v36 = (__int64)&v31 + 8;
  if ( v11 )
  {
    v12 = (unsigned int *)(v11 + 20);
    do
      v13 = __ldaxr(v12);
    while ( __stlxr(v13 + 1, v12) );
    if ( *((int *)a2 + 1) <= 2 )
      goto LABEL_5;
LABEL_7:
    DWORD1(v31) = 0;
    cv::Mat::copySize((cv::Mat *)&v31, (const cv::Mat *)a2);
    goto LABEL_8;
  }
  if ( SDWORD1(v7) > 2 )
    goto LABEL_7;
LABEL_5:
  v14 = (_QWORD *)*((_QWORD *)a2 + 9);
  v15 = v37;
  *(_QWORD *)v37 = *v14;
  *((_QWORD *)v15 + 1) = v14[1];
LABEL_8:
  v29 = *(_QWORD *)a3;
  v30 = *(_DWORD *)(a3 + 8);
  feasibal_region::feasibal_region::readParam(a1, (__int64)&v31, &v29, a4, a5);
  if ( v35 )
  {
    v17 = (unsigned int *)(v35 + 20);
    do
    {
      v18 = __ldaxr(v17);
      v19 = v18 - 1;
    }
    while ( __stlxr(v19, v17) );
    if ( !v19 )
      cv::Mat::deallocate((cv::Mat *)&v31);
  }
  v35 = 0LL;
  v32 = 0u;
  v33 = 0u;
  if ( SDWORD1(v31) >= 1 )
  {
    v20 = v36;
    v21 = 0LL;
    do
      *(_DWORD *)(v20 + 4 * v21++) = 0;
    while ( v21 < SDWORD1(v31) );
  }
  if ( v37 != (cv *)v38 )
    cv::fastFree(v37, v16);
  v22 = (feasibal_region::ground_process *)operator new(0xC18uLL);
  feasibal_region::ground_process::ground_process(v22);
  v23 = *(feasibal_region::ground_process **)(a1 + 624);
  *(_QWORD *)(a1 + 624) = v22;
  if ( v23 )
  {
    feasibal_region::ground_process::~ground_process(v23);
    operator delete(v23);
  }
  feasibal_region::PreParamInfo::PreParamInfo((feasibal_region::PreParamInfo *)v26);
  v27 = 0;
  v28 = 1084227584;
  feasibal_region::PreParamInfo::operator=((__int64)v26, (__int128 *)(a1 + 48));
  feasibal_region::ground_process::init(*(_QWORD *)(a1 + 624), (__int64)v26);
  feasibal_region::PreParamInfo::~PreParamInfo(v26, v24);
  return 0LL;
}
// 46DC0: variable 'v16' is possibly undefined
// 46E20: variable 'v24' is possibly undefined

//----- (0000000000046F00) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::setIRCameraMatrix(__int64 a1, __int64 a2)
{
  __int64 *v2; // x20
  unsigned int v4; // w21

  v2 = (__int64 *)(a1 + 600);
  v4 = 1;
  if ( !(unsigned int)feasibal_region::feasibal_region::WriteCameraParam(a1, a1 + 600, a2) )
  {
    feasibal_region::feasibal_region::init(a1, v2);
    *(_BYTE *)(a1 + 592) = 1;
    return 0;
  }
  return v4;
}

//----- (0000000000046F54) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::run(
        feasibal_region::feasibal_region *this,
        const feasibal_region::RunInputParam *a2,
        feasibal_region::RunOutputParam *a3)
{
  __int64 v6; // x8
  __int64 v7; // x11
  __int64 v8; // x9
  __int64 v9; // x10
  int64x2_t v10; // q1
  _QWORD *v11; // x11
  __int64 v12; // x12
  int64x2_t v13; // q0
  __int64 v14; // d2
  __int64 v15; // x12
  int *v16; // x9
  __int64 v17; // t1
  __int64 v18; // x8
  unsigned int *v19; // x8
  unsigned int v20; // w9
  unsigned int *v21; // x8
  unsigned int v22; // w9
  unsigned int v23; // w9
  const char *v24; // x20
  size_t v25; // x0
  size_t v26; // x19
  char *v27; // x21
  unsigned __int64 v28; // x22
  void *v29; // x1
  char v30; // w19
  unsigned int v31; // w19
  _DWORD *v32; // x8
  __int64 v33; // x9
  __int64 v34; // x10
  __int64 *v35; // x8
  __int64 v36; // x8
  unsigned int *v37; // x8
  unsigned int v38; // w9
  unsigned int *v39; // x8
  unsigned int v40; // w9
  unsigned int v41; // w9
  const cv::Mat *v42; // x1
  _BYTE *v43; // x8
  __int64 v44; // x9
  __int64 v45; // x10
  __int64 *v46; // x8
  int v47; // w8
  int v48; // w9
  const char *v49; // x22
  size_t v50; // x0
  size_t v51; // x21
  char *v52; // x23
  unsigned __int64 v53; // x24
  char v54; // w21
  _DWORD *v55; // x21
  unsigned int *v56; // x8
  unsigned int v57; // w9
  __int64 v58; // x8
  unsigned int *v59; // x8
  unsigned int v60; // w9
  unsigned int v61; // w9
  int v62; // w8
  __int64 v63; // x8
  __int64 v64; // x9
  __int64 v65; // x10
  __int64 *v66; // x10
  __int64 v67; // x8
  _DWORD *v68; // x21
  unsigned int *v69; // x8
  unsigned int v70; // w9
  __int64 v71; // x8
  unsigned int *v72; // x8
  unsigned int v73; // w9
  unsigned int v74; // w9
  __int64 v75; // x8
  __int64 v76; // x9
  __int64 v77; // x10
  __int64 *v78; // x10
  __int64 v79; // x8
  char *v80; // x1
  char *v81; // x2
  float v82; // s0
  double v83; // d8
  const char *v84; // x20
  size_t v85; // x0
  size_t v86; // x19
  char *v87; // x21
  unsigned __int64 v88; // x22
  char v89; // w19
  __suseconds_t tv_usec; // x24
  __time_t tv_sec; // x26
  __suseconds_t v92; // x27
  __time_t v93; // x28
  const char *v94; // x20
  size_t v95; // x0
  size_t v96; // x19
  char *v97; // x21
  unsigned __int64 v98; // x22
  char v99; // w19
  float v100; // s0
  void *v101; // x1
  void *v103[3]; // [xsp+10h] [xbp-580h] BYREF
  int v104; // [xsp+28h] [xbp-568h] BYREF
  unsigned __int64 v105; // [xsp+30h] [xbp-560h] BYREF
  size_t v106; // [xsp+38h] [xbp-558h]
  void *v107; // [xsp+40h] [xbp-550h]
  char v108; // [xsp+48h] [xbp-548h] BYREF
  char v109[15]; // [xsp+49h] [xbp-547h] BYREF
  void *v110; // [xsp+58h] [xbp-538h]
  int v111; // [xsp+60h] [xbp-530h] BYREF
  unsigned __int64 v112; // [xsp+68h] [xbp-528h] BYREF
  size_t v113; // [xsp+70h] [xbp-520h]
  void *v114; // [xsp+78h] [xbp-518h]
  char v115; // [xsp+80h] [xbp-510h] BYREF
  char v116[15]; // [xsp+81h] [xbp-50Fh] BYREF
  void *v117; // [xsp+90h] [xbp-500h]
  int v118; // [xsp+98h] [xbp-4F8h] BYREF
  unsigned __int64 v119; // [xsp+A0h] [xbp-4F0h] BYREF
  size_t v120; // [xsp+A8h] [xbp-4E8h]
  void *v121; // [xsp+B0h] [xbp-4E0h]
  int v122[2]; // [xsp+B8h] [xbp-4D8h] BYREF
  char v123; // [xsp+C0h] [xbp-4D0h] BYREF
  char v124[15]; // [xsp+C1h] [xbp-4CFh] BYREF
  void *v125; // [xsp+D0h] [xbp-4C0h]
  int v126; // [xsp+D8h] [xbp-4B8h] BYREF
  unsigned __int64 v127; // [xsp+E0h] [xbp-4B0h] BYREF
  size_t v128; // [xsp+E8h] [xbp-4A8h]
  void *v129; // [xsp+F0h] [xbp-4A0h]
  struct timeval v130; // [xsp+F8h] [xbp-498h] BYREF
  struct timeval tv; // [xsp+108h] [xbp-488h] BYREF
  int v132; // [xsp+118h] [xbp-478h] BYREF
  _BYTE *v133; // [xsp+120h] [xbp-470h]
  __int64 v134; // [xsp+128h] [xbp-468h]
  __int128 v135; // [xsp+260h] [xbp-330h] BYREF
  __int128 v136; // [xsp+270h] [xbp-320h]
  __int128 v137; // [xsp+280h] [xbp-310h]
  __int128 v138; // [xsp+290h] [xbp-300h]
  __int128 v139; // [xsp+2A0h] [xbp-2F0h] BYREF
  __int128 v140; // [xsp+2B0h] [xbp-2E0h] BYREF
  __int128 v141; // [xsp+2C0h] [xbp-2D0h]
  __int128 v142; // [xsp+2D0h] [xbp-2C0h] BYREF
  __int128 v143; // [xsp+2E0h] [xbp-2B0h] BYREF
  __int128 v144; // [xsp+2F0h] [xbp-2A0h]
  _BYTE v145[40]; // [xsp+300h] [xbp-290h] BYREF
  char v146; // [xsp+328h] [xbp-268h]
  __int64 v147; // [xsp+32Ch] [xbp-264h]
  _OWORD v148[4]; // [xsp+378h] [xbp-218h] BYREF
  __int64 v149; // [xsp+3B8h] [xbp-1D8h]
  __int64 *v150; // [xsp+3C0h] [xbp-1D0h]
  __int64 v151[2]; // [xsp+3C8h] [xbp-1C8h] BYREF
  int v152; // [xsp+3D8h] [xbp-1B8h]
  _OWORD v153[4]; // [xsp+3E0h] [xbp-1B0h] BYREF
  __int64 v154; // [xsp+420h] [xbp-170h]
  __int64 *v155; // [xsp+428h] [xbp-168h]
  __int64 v156[3]; // [xsp+430h] [xbp-160h] BYREF
  _BYTE v157[64]; // [xsp+448h] [xbp-148h] BYREF
  _DWORD *v158; // [xsp+488h] [xbp-108h]
  __int64 *v159; // [xsp+490h] [xbp-100h]
  __int64 v160[2]; // [xsp+498h] [xbp-F8h] BYREF
  _BYTE v161[64]; // [xsp+4A8h] [xbp-E8h] BYREF
  _BYTE *v162; // [xsp+4E8h] [xbp-A8h]
  __int64 *v163; // [xsp+4F0h] [xbp-A0h]
  __int64 v164[3]; // [xsp+4F8h] [xbp-98h] BYREF
  int v165; // [xsp+510h] [xbp-80h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  gettimeofday(&tv, 0LL);
  *(_DWORD *)v157 = 1124007936;
  memset(&v157[4], 0, 60);
  v159 = v160;
  v158 = &v157[8];
  v160[1] = 0LL;
  v160[0] = 0LL;
  *(_DWORD *)v161 = 1124007936;
  memset(&v161[4], 0, 60);
  v163 = v164;
  v162 = &v161[8];
  memset(v145, 0, sizeof(v145));
  v143 = 0u;
  v144 = 0u;
  v141 = 0u;
  v142 = 0u;
  v139 = 0u;
  v140 = 0u;
  LODWORD(v148[0]) = 1124007936;
  memset((char *)v148 + 4, 0, 60);
  LODWORD(v153[0]) = 1124007936;
  v149 = (__int64)v148 + 8;
  v150 = v151;
  v151[1] = 0LL;
  v151[0] = 0LL;
  memset((char *)v153 + 4, 0, 60);
  v164[0] = 0LL;
  v164[1] = 0LL;
  v154 = (__int64)v153 + 8;
  v155 = v156;
  v156[0] = 0LL;
  v156[1] = 0LL;
  v147 = 0xFFFFFFFFLL;
  v146 = 0;
  if ( !*((_QWORD *)a2 + 2) )
    goto LABEL_22;
  v6 = *((unsigned int *)a2 + 1);
  if ( (int)v6 >= 3 )
  {
    v8 = *((_QWORD *)a2 + 8);
    if ( (_DWORD)v6 == 3 )
    {
      v9 = 0LL;
      v7 = 1LL;
    }
    else
    {
      v9 = v6 & 0x7FFFFFFC;
      v10 = vdupq_n_s64(1uLL);
      v11 = (_QWORD *)(v8 + 8);
      v12 = (unsigned int)v6 & 0xFFFFFFFC;
      v13 = v10;
      do
      {
        v14 = *(v11 - 1);
        v10.n128_u64[0] *= (int)v14;
        v13.n128_u64[0] *= (int)*v11;
        v12 -= 4LL;
        v10.n128_u64[1] *= SHIDWORD(v14);
        v13.n128_u64[1] *= (int)HIDWORD(*v11);
        v11 += 2;
      }
      while ( v12 );
      v7 = v13.n128_u64[0] * v10.n128_u64[0] * v13.n128_u64[1] * v10.n128_u64[1];
      if ( v9 == v6 )
      {
LABEL_12:
        if ( !v7 )
          goto LABEL_22;
        if ( v157 == (_BYTE *)a2 )
        {
LABEL_51:
          if ( v157 == (_BYTE *)a2 )
            goto LABEL_70;
          v36 = *((_QWORD *)a2 + 19);
          if ( v36 )
          {
            v37 = (unsigned int *)(v36 + 20);
            do
              v38 = __ldaxr(v37);
            while ( __stlxr(v38 + 1, v37) );
          }
          if ( *(_QWORD *)&v161[56] )
          {
            v39 = (unsigned int *)(*(_QWORD *)&v161[56] + 20LL);
            do
            {
              v40 = __ldaxr(v39);
              v41 = v40 - 1;
            }
            while ( __stlxr(v41, v39) );
            if ( !v41 )
              cv::Mat::deallocate((cv::Mat *)v161);
          }
          *(_QWORD *)&v161[56] = 0LL;
          memset(&v161[16], 0, 32);
          v42 = (const feasibal_region::RunInputParam *)((char *)a2 + 96);
          if ( *(__int64 *)v161 <= 0 )
          {
            *(_DWORD *)v161 = *(_DWORD *)v42;
          }
          else
          {
            v43 = v162;
            v44 = 0LL;
            do
              *(_DWORD *)&v43[4 * v44++] = 0;
            while ( v44 < *(int *)&v161[4] );
            *(_DWORD *)v161 = *(_DWORD *)v42;
            if ( *(int *)&v161[4] > 2 )
              goto LABEL_68;
          }
          if ( *((int *)a2 + 25) <= 2 )
          {
            *(_DWORD *)&v161[4] = *((_DWORD *)a2 + 25);
            v45 = (__int64)v163;
            *(_QWORD *)&v161[8] = *((_QWORD *)a2 + 13);
            v46 = (__int64 *)*((_QWORD *)a2 + 21);
            *v163 = *v46;
            *(_QWORD *)(v45 + 8) = v46[1];
LABEL_69:
            *(_OWORD *)&v161[16] = *((_OWORD *)a2 + 7);
            *(_OWORD *)&v161[32] = *((_OWORD *)a2 + 8);
            *(_OWORD *)&v161[48] = *((_OWORD *)a2 + 9);
LABEL_70:
            v164[2] = *((_QWORD *)a2 + 36);
            v165 = *((_DWORD *)a2 + 74);
            v47 = *((_DWORD *)this + 78);
            if ( *v158 == v47 )
            {
              v48 = *((_DWORD *)this + 79);
              if ( v158[1] == v48 )
                goto LABEL_93;
            }
            else
            {
              v48 = *((_DWORD *)this + 79);
            }
            v132 = 16842752;
            *(_QWORD *)&v136 = 0LL;
            LODWORD(v135) = 33619968;
            v122[0] = v48;
            v122[1] = v47;
            v133 = v157;
            v134 = 0LL;
            *((_QWORD *)&v135 + 1) = v157;
            cv::resize(&v132, &v135, v122, 0LL, 1.0, 1.0);
            if ( (word_6FF40 & 1) != 0 )
              v49 = (const char *)qword_6FF50;
            else
              v49 = (char *)&word_6FF40 + 1;
            v118 = dword_6FF38;
            v120 = 0LL;
            v121 = 0LL;
            v119 = 0LL;
            v50 = strlen(v49);
            if ( v50 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v51 = v50;
            if ( v50 >= 0x17 )
            {
              v53 = (v50 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v52 = (char *)operator new(v53);
              v120 = v51;
              v121 = v52;
              v119 = v53 | 1;
            }
            else
            {
              v52 = (char *)&v119 + 1;
              LOBYTE(v119) = 2 * v50;
              if ( !v50 )
              {
LABEL_83:
                v52[v51] = 0;
                if ( (g3::logLevel(&v118) & 1) != 0 )
                {
                  *(_QWORD *)&v116[7] = 0LL;
                  v117 = 0LL;
                  v115 = 12;
                  strcpy(v116, "region");
                  v54 = g3::logTag(&v115);
                  if ( (v115 & 1) == 0 )
                  {
                    if ( (v119 & 1) == 0 )
                      goto LABEL_86;
LABEL_91:
                    operator delete(v121);
                    if ( (v54 & 1) == 0 )
                      goto LABEL_93;
                    goto LABEL_92;
                  }
                  operator delete(v117);
                  if ( (v119 & 1) != 0 )
                    goto LABEL_91;
                }
                else
                {
                  v54 = 0;
                  if ( (v119 & 1) != 0 )
                    goto LABEL_91;
                }
LABEL_86:
                if ( (v54 & 1) == 0 )
                {
LABEL_93:
                  if ( *((_DWORD *)this + 158) == 1 )
                  {
                    v132 = 16842752;
                    *(_QWORD *)&v136 = 0LL;
                    LODWORD(v135) = 33619968;
                    v133 = v157;
                    v134 = 0LL;
                    *((_QWORD *)&v135 + 1) = v157;
                    cv::medianBlur(&v132, &v135, 5LL);
                  }
                  feasibal_region::ground_process::run(
                    *((feasibal_region::ground_process **)this + 78),
                    (const feasibal_region::GroundProcessRunInData *)v157,
                    (feasibal_region::GroundProcessRunOutData *)&v139);
                  feasibal_region::ground_process::getExtrinsic(
                    *((feasibal_region::ground_process **)this + 78),
                    (__int64)&v135);
                  if ( (char *)a3 + 88 != (char *)&v140 + 8 )
                    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                      (__int64)a3 + 88,
                      *((char **)&v140 + 1),
                      (char *)v141);
                  if ( (__int128 *)((char *)a3 + 112) != &v142 )
                    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                      (__int64)a3 + 112,
                      (char *)v142,
                      *((char **)&v142 + 1));
                  if ( (char *)a3 + 136 != (char *)&v143 + 8 )
                    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                      (__int64)a3 + 136,
                      *((char **)&v143 + 1),
                      (char *)v144);
                  if ( (char *)a3 + 160 != v145 )
                    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                      (__int64)a3 + 160,
                      *(char **)v145,
                      *(char **)&v145[8]);
                  *(_OWORD *)a3 = v135;
                  *((_OWORD *)a3 + 1) = v136;
                  *((_OWORD *)a3 + 2) = v137;
                  *((_OWORD *)a3 + 3) = v138;
                  if ( (__int128 *)((char *)a3 + 64) != &v139 )
                    std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                      (__int64)a3 + 64,
                      (char *)v139,
                      *((char **)&v139 + 1));
                  v55 = (_DWORD *)((char *)a3 + 232);
                  *((_DWORD *)a3 + 112) = v147;
                  if ( (_OWORD *)((char *)a3 + 232) == v148 )
                  {
LABEL_124:
                    v68 = (_DWORD *)((char *)a3 + 328);
                    *((_DWORD *)a3 + 106) = v152;
                    if ( (_OWORD *)((char *)a3 + 328) == v153 )
                      goto LABEL_143;
                    if ( *((_QWORD *)&v153[3] + 1) )
                    {
                      v69 = (unsigned int *)(*((_QWORD *)&v153[3] + 1) + 20LL);
                      do
                        v70 = __ldaxr(v69);
                      while ( __stlxr(v70 + 1, v69) );
                    }
                    v71 = *((_QWORD *)a3 + 48);
                    if ( v71 )
                    {
                      v72 = (unsigned int *)(v71 + 20);
                      do
                      {
                        v73 = __ldaxr(v72);
                        v74 = v73 - 1;
                      }
                      while ( __stlxr(v74, v72) );
                      if ( !v74 )
                        cv::Mat::deallocate((feasibal_region::RunOutputParam *)((char *)a3 + 328));
                    }
                    *((_QWORD *)a3 + 48) = 0LL;
                    *(_OWORD *)((char *)a3 + 360) = 0u;
                    *(_OWORD *)((char *)a3 + 344) = 0u;
                    if ( *((int *)a3 + 83) <= 0 )
                    {
                      *v68 = v153[0];
                    }
                    else
                    {
                      v75 = *((_QWORD *)a3 + 49);
                      v76 = 0LL;
                      do
                      {
                        *(_DWORD *)(v75 + 4 * v76) = 0;
                        v77 = *((int *)a3 + 83);
                        ++v76;
                      }
                      while ( v76 < v77 );
                      *v68 = v153[0];
                      if ( (int)v77 > 2 )
                        goto LABEL_141;
                    }
                    if ( SDWORD1(v153[0]) <= 2 )
                    {
                      *((_DWORD *)a3 + 83) = DWORD1(v153[0]);
                      v78 = (__int64 *)*((_QWORD *)a3 + 50);
                      *((_QWORD *)a3 + 42) = *((_QWORD *)&v153[0] + 1);
                      v79 = (__int64)v155;
                      *v78 = *v155;
                      v78[1] = *(_QWORD *)(v79 + 8);
LABEL_142:
                      *(_OWORD *)((char *)a3 + 344) = v153[1];
                      *(_OWORD *)((char *)a3 + 360) = v153[2];
                      *(_OWORD *)((char *)a3 + 376) = v153[3];
LABEL_143:
                      *(_OWORD *)((char *)a3 + 428) = *(_OWORD *)&v145[24];
                      v80 = (char *)*((_QWORD *)a3 + 8);
                      v81 = (char *)*((_QWORD *)a3 + 9);
                      *((_BYTE *)a3 + 444) = v146;
                      *((_DWORD *)a3 + 113) = HIDWORD(v147);
                      std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                        (__int64)a3 + 184,
                        v80,
                        v81);
                      std::vector<Eigen::Matrix<float,3,1,0,3,1>>::assign<Eigen::Matrix<float,3,1,0,3,1>*>(
                        (__int64)a3 + 208,
                        *((char **)a3 + 11),
                        *((char **)a3 + 12));
                      std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
                        (char **)a3 + 26,
                        *((_DWORD **)a3 + 27),
                        *((_QWORD *)a3 + 14),
                        *((char **)a3 + 15));
                      std::vector<Eigen::Matrix<float,3,1,0,3,1>>::insert<std::__wrap_iter<Eigen::Matrix<float,3,1,0,3,1>*>>(
                        (char **)a3 + 26,
                        *((_DWORD **)a3 + 27),
                        *((_QWORD *)a3 + 17),
                        *((char **)a3 + 18));
                      v82 = (float)(*((float *)a3 + 113) * 180.0) / 3.14159;
                      v83 = v82;
                      *((_BYTE *)a3 + 456) = v82 < 9.0 && v82 > 4.2;
                      v111 = dword_6FF38;
                      v113 = 0LL;
                      v114 = 0LL;
                      if ( (word_6FF40 & 1) != 0 )
                        v84 = (const char *)qword_6FF50;
                      else
                        v84 = (char *)&word_6FF40 + 1;
                      v112 = 0LL;
                      v85 = strlen(v84);
                      if ( v85 >= 0xFFFFFFFFFFFFFFF0LL )
                        std::__basic_string_common<true>::__throw_length_error();
                      v86 = v85;
                      if ( v85 >= 0x17 )
                      {
                        v88 = (v85 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                        v87 = (char *)operator new(v88);
                        v113 = v86;
                        v114 = v87;
                        v112 = v88 | 1;
                      }
                      else
                      {
                        v87 = (char *)&v112 + 1;
                        LOBYTE(v112) = 2 * v85;
                        if ( !v85 )
                        {
LABEL_152:
                          v87[v86] = 0;
                          if ( (g3::logLevel(&v111) & 1) != 0 )
                          {
                            *(_QWORD *)&v109[7] = 0LL;
                            v110 = 0LL;
                            v108 = 12;
                            strcpy(v109, "region");
                            v89 = g3::logTag(&v108);
                            if ( (v108 & 1) == 0 )
                            {
                              if ( (v112 & 1) == 0 )
                                goto LABEL_155;
LABEL_160:
                              operator delete(v114);
                              if ( (v89 & 1) == 0 )
                                goto LABEL_162;
                              goto LABEL_161;
                            }
                            operator delete(v110);
                            if ( (v112 & 1) != 0 )
                              goto LABEL_160;
                          }
                          else
                          {
                            v89 = 0;
                            if ( (v112 & 1) != 0 )
                              goto LABEL_160;
                          }
LABEL_155:
                          if ( (v89 & 1) == 0 )
                          {
LABEL_162:
                            gettimeofday(&v130, 0LL);
                            tv_sec = v130.tv_sec;
                            tv_usec = v130.tv_usec;
                            v93 = tv.tv_sec;
                            v92 = tv.tv_usec;
                            v104 = dword_6FF38;
                            if ( (word_6FF40 & 1) != 0 )
                              v94 = (const char *)qword_6FF50;
                            else
                              v94 = (char *)&word_6FF40 + 1;
                            v106 = 0LL;
                            v107 = 0LL;
                            v105 = 0LL;
                            v95 = strlen(v94);
                            if ( v95 >= 0xFFFFFFFFFFFFFFF0LL )
                              std::__basic_string_common<true>::__throw_length_error();
                            v96 = v95;
                            if ( v95 >= 0x17 )
                            {
                              v98 = (v95 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                              v97 = (char *)operator new(v98);
                              v106 = v96;
                              v107 = v97;
                              v105 = v98 | 1;
                            }
                            else
                            {
                              v97 = (char *)&v105 + 1;
                              LOBYTE(v105) = 2 * v95;
                              if ( !v95 )
                              {
LABEL_171:
                                v97[v96] = 0;
                                if ( (g3::logLevel(&v104) & 1) != 0 )
                                {
                                  LOBYTE(v103[0]) = 30;
                                  strcpy((char *)v103 + 1, "feasibal_region");
                                  BYTE1(v103[2]) = 0;
                                  WORD1(v103[2]) = 0;
                                  HIDWORD(v103[2]) = 0;
                                  v99 = g3::logTag(v103);
                                  if ( ((__int64)v103[0] & 1) == 0 )
                                  {
                                    if ( (v105 & 1) == 0 )
                                      goto LABEL_174;
LABEL_179:
                                    operator delete(v107);
                                    if ( (v99 & 1) == 0 )
                                    {
LABEL_181:
                                      v31 = 0;
                                      goto LABEL_182;
                                    }
LABEL_180:
                                    LogCapture::LogCapture(
                                      (LogCapture *)&v132,
                                      "feasibal_region",
                                      (const LEVELS *)&dword_6FF38,
                                      "",
                                      6,
                                      0LL);
                                    v100 = (double)(tv_sec - v93) * 1000.0 + (double)(tv_usec - v92) / 1000.0;
                                    LogCapture::capturef(
                                      (LogCapture *)&v132,
                                      "%s:%3fms\n",
                                      "region process time:",
                                      v100);
                                    LogCapture::~LogCapture((LogCapture *)&v132);
                                    goto LABEL_181;
                                  }
                                  operator delete(v103[2]);
                                  if ( (v105 & 1) != 0 )
                                    goto LABEL_179;
                                }
                                else
                                {
                                  v99 = 0;
                                  if ( (v105 & 1) != 0 )
                                    goto LABEL_179;
                                }
LABEL_174:
                                if ( (v99 & 1) == 0 )
                                  goto LABEL_181;
                                goto LABEL_180;
                              }
                            }
                            memcpy(v97, v94, v96);
                            goto LABEL_171;
                          }
LABEL_161:
                          LogCapture::LogCapture(
                            (LogCapture *)&v132,
                            "region",
                            (const LEVELS *)&dword_6FF38,
                            "",
                            6,
                            0LL);
                          LogCapture::capturef((LogCapture *)&v132, "base angle:%3f", v83);
                          LogCapture::~LogCapture((LogCapture *)&v132);
                          goto LABEL_162;
                        }
                      }
                      memcpy(v87, v84, v86);
                      goto LABEL_152;
                    }
LABEL_141:
                    cv::Mat::copySize((feasibal_region::RunOutputParam *)((char *)a3 + 328), (const cv::Mat *)v153);
                    goto LABEL_142;
                  }
                  if ( *((_QWORD *)&v148[3] + 1) )
                  {
                    v56 = (unsigned int *)(*((_QWORD *)&v148[3] + 1) + 20LL);
                    do
                      v57 = __ldaxr(v56);
                    while ( __stlxr(v57 + 1, v56) );
                  }
                  v58 = *((_QWORD *)a3 + 36);
                  if ( v58 )
                  {
                    v59 = (unsigned int *)(v58 + 20);
                    do
                    {
                      v60 = __ldaxr(v59);
                      v61 = v60 - 1;
                    }
                    while ( __stlxr(v61, v59) );
                    if ( !v61 )
                      cv::Mat::deallocate((feasibal_region::RunOutputParam *)((char *)a3 + 232));
                  }
                  *((_QWORD *)a3 + 36) = 0LL;
                  *(_OWORD *)((char *)a3 + 264) = 0u;
                  v62 = *((_DWORD *)a3 + 59);
                  *(_OWORD *)((char *)a3 + 248) = 0u;
                  if ( v62 <= 0 )
                  {
                    *v55 = v148[0];
                  }
                  else
                  {
                    v63 = *((_QWORD *)a3 + 37);
                    v64 = 0LL;
                    do
                    {
                      *(_DWORD *)(v63 + 4 * v64) = 0;
                      v65 = *((int *)a3 + 59);
                      ++v64;
                    }
                    while ( v64 < v65 );
                    *v55 = v148[0];
                    if ( (int)v65 > 2 )
                      goto LABEL_122;
                  }
                  if ( SDWORD1(v148[0]) <= 2 )
                  {
                    *((_DWORD *)a3 + 59) = DWORD1(v148[0]);
                    v66 = (__int64 *)*((_QWORD *)a3 + 38);
                    *((_QWORD *)a3 + 30) = *((_QWORD *)&v148[0] + 1);
                    v67 = (__int64)v150;
                    *v66 = *v150;
                    v66[1] = *(_QWORD *)(v67 + 8);
LABEL_123:
                    *(_OWORD *)((char *)a3 + 248) = v148[1];
                    *(_OWORD *)((char *)a3 + 264) = v148[2];
                    *(_OWORD *)((char *)a3 + 280) = v148[3];
                    goto LABEL_124;
                  }
LABEL_122:
                  cv::Mat::copySize((feasibal_region::RunOutputParam *)((char *)a3 + 232), (const cv::Mat *)v148);
                  goto LABEL_123;
                }
LABEL_92:
                LogCapture::LogCapture((LogCapture *)&v132, "region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
                LogCapture::capturef((LogCapture *)&v132, "image need resize!!!");
                LogCapture::~LogCapture((LogCapture *)&v132);
                goto LABEL_93;
              }
            }
            memcpy(v52, v49, v51);
            goto LABEL_83;
          }
LABEL_68:
          cv::Mat::copySize((cv::Mat *)v161, v42);
          goto LABEL_69;
        }
        v18 = *((_QWORD *)a2 + 7);
        if ( v18 )
        {
          v19 = (unsigned int *)(v18 + 20);
          do
            v20 = __ldaxr(v19);
          while ( __stlxr(v20 + 1, v19) );
          if ( *(_QWORD *)&v157[56] )
          {
            v21 = (unsigned int *)(*(_QWORD *)&v157[56] + 20LL);
            do
            {
              v22 = __ldaxr(v21);
              v23 = v22 - 1;
            }
            while ( __stlxr(v23, v21) );
            if ( !v23 )
              cv::Mat::deallocate((cv::Mat *)v157);
          }
        }
        *(_QWORD *)&v157[56] = 0LL;
        memset(&v157[16], 0, 32);
        if ( *(__int64 *)v157 <= 0 )
        {
          *(_DWORD *)v157 = *(_DWORD *)a2;
        }
        else
        {
          v32 = v158;
          v33 = 0LL;
          do
            v32[v33++] = 0;
          while ( v33 < *(int *)&v157[4] );
          *(_DWORD *)v157 = *(_DWORD *)a2;
          if ( *(int *)&v157[4] > 2 )
            goto LABEL_49;
        }
        if ( *((int *)a2 + 1) <= 2 )
        {
          *(_DWORD *)&v157[4] = *((_DWORD *)a2 + 1);
          v34 = (__int64)v159;
          *(_QWORD *)&v157[8] = *((_QWORD *)a2 + 1);
          v35 = (__int64 *)*((_QWORD *)a2 + 9);
          *v159 = *v35;
          *(_QWORD *)(v34 + 8) = v35[1];
LABEL_50:
          *(_OWORD *)&v157[16] = *((_OWORD *)a2 + 1);
          *(_OWORD *)&v157[32] = *((_OWORD *)a2 + 2);
          *(_OWORD *)&v157[48] = *((_OWORD *)a2 + 3);
          goto LABEL_51;
        }
LABEL_49:
        cv::Mat::copySize((cv::Mat *)v157, a2);
        goto LABEL_50;
      }
    }
    v15 = v6 - v9;
    v16 = (int *)(v8 + 4 * v9);
    do
    {
      v17 = *v16++;
      --v15;
      v7 *= v17;
    }
    while ( v15 );
    goto LABEL_12;
  }
  v7 = *((int *)a2 + 3) * (__int64)*((int *)a2 + 2);
  if ( (_DWORD)v6 )
    goto LABEL_12;
LABEL_22:
  if ( (word_6FF40 & 1) != 0 )
    v24 = (const char *)qword_6FF50;
  else
    v24 = (char *)&word_6FF40 + 1;
  v126 = dword_6FF38;
  v128 = 0LL;
  v129 = 0LL;
  v127 = 0LL;
  v25 = strlen(v24);
  if ( v25 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v26 = v25;
  if ( v25 >= 0x17 )
  {
    v28 = (v25 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v27 = (char *)operator new(v28);
    v128 = v26;
    v129 = v27;
    v127 = v28 | 1;
    goto LABEL_30;
  }
  v27 = (char *)&v127 + 1;
  LOBYTE(v127) = 2 * v25;
  if ( v25 )
LABEL_30:
    memcpy(v27, v24, v26);
  v27[v26] = 0;
  if ( (g3::logLevel(&v126) & 1) != 0 )
  {
    *(_QWORD *)&v124[7] = 0LL;
    v125 = 0LL;
    v123 = 12;
    strcpy(v124, "region");
    v30 = g3::logTag(&v123);
    if ( (v123 & 1) == 0 )
    {
      if ( (v127 & 1) == 0 )
        goto LABEL_34;
LABEL_39:
      operator delete(v129);
      if ( (v30 & 1) != 0 )
        goto LABEL_35;
LABEL_40:
      v31 = 1;
      goto LABEL_182;
    }
    operator delete(v125);
    if ( (v127 & 1) != 0 )
      goto LABEL_39;
  }
  else
  {
    v30 = 0;
    if ( (v127 & 1) != 0 )
      goto LABEL_39;
  }
LABEL_34:
  if ( (v30 & 1) == 0 )
    goto LABEL_40;
LABEL_35:
  LogCapture::LogCapture((LogCapture *)&v132, "region", (const LEVELS *)&dword_6FF38, "", 6, 0LL);
  LogCapture::capturef((LogCapture *)&v132, "input error\n");
  LogCapture::~LogCapture((LogCapture *)&v132);
  v31 = 1;
LABEL_182:
  feasibal_region::GroundProcessRunOutData::~GroundProcessRunOutData(
    (feasibal_region::GroundProcessRunOutData *)&v139,
    v29);
  feasibal_region::GroundProcessRunInData::~GroundProcessRunInData(
    (feasibal_region::GroundProcessRunInData *)v157,
    v101);
  return v31;
}
// 47174: conditional instruction was optimized away because w8.4>=3
// 470CC: mask 0xFFFFFFFC is shortened because x8.8 <= 0x7FFFFFFF
// 47DB0: variable 'v29' is possibly undefined
// 47DB8: variable 'v101' is possibly undefined
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 137D0: using guessed type __int64 __fastcall cv::medianBlur(_QWORD, _QWORD, _QWORD);
// 13940: using guessed type __int64 __fastcall cv::resize(_QWORD, _QWORD, _QWORD, _QWORD, double, double);
// 6FF38: using guessed type int dword_6FF38;
// 6FF40: using guessed type __int16 word_6FF40;
// 6FF50: using guessed type __int64 qword_6FF50;

//----- (0000000000047F58) ----------------------------------------------------
void __fastcall feasibal_region::GroundProcessRunOutData::~GroundProcessRunOutData(
        feasibal_region::GroundProcessRunOutData *this,
        void *a2)
{
  __int64 v2; // x8
  cv::Mat *v4; // x0
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  __int64 v12; // x8
  unsigned int *v13; // x8
  unsigned int v14; // w9
  unsigned int v15; // w9
  int v16; // w8
  __int64 v17; // x8
  __int64 v18; // x9
  cv *v19; // x0
  void *v20; // x0
  void *v21; // x0
  void *v22; // x0
  void *v23; // x0
  void *v24; // x0

  v2 = *((_QWORD *)this + 47);
  if ( v2 )
  {
    v4 = (feasibal_region::GroundProcessRunOutData *)((char *)this + 320);
    v5 = (unsigned int *)(v2 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate(v4);
  }
  v8 = *((_DWORD *)this + 81);
  *((_QWORD *)this + 47) = 0LL;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  if ( v8 >= 1 )
  {
    v9 = *((_QWORD *)this + 48);
    v10 = 0LL;
    do
      *(_DWORD *)(v9 + 4 * v10++) = 0;
    while ( v10 < *((int *)this + 81) );
  }
  v11 = (cv *)*((_QWORD *)this + 49);
  if ( v11 != (feasibal_region::GroundProcessRunOutData *)((char *)this + 400) )
    cv::fastFree(v11, a2);
  v12 = *((_QWORD *)this + 34);
  if ( v12 )
  {
    v13 = (unsigned int *)(v12 + 20);
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while ( __stlxr(v15, v13) );
    if ( !v15 )
      cv::Mat::deallocate((feasibal_region::GroundProcessRunOutData *)((char *)this + 216));
  }
  v16 = *((_DWORD *)this + 55);
  *((_QWORD *)this + 34) = 0LL;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  if ( v16 >= 1 )
  {
    v17 = *((_QWORD *)this + 35);
    v18 = 0LL;
    do
      *(_DWORD *)(v17 + 4 * v18++) = 0;
    while ( v18 < *((int *)this + 55) );
  }
  v19 = (cv *)*((_QWORD *)this + 36);
  if ( v19 != (feasibal_region::GroundProcessRunOutData *)((char *)this + 296) )
    cv::fastFree(v19, a2);
  v20 = (void *)*((_QWORD *)this + 12);
  if ( v20 )
  {
    *((_QWORD *)this + 13) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 9);
  if ( v21 )
  {
    *((_QWORD *)this + 10) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 6);
  if ( v22 )
  {
    *((_QWORD *)this + 7) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 3);
  if ( v23 )
  {
    *((_QWORD *)this + 4) = v23;
    operator delete(v23);
  }
  v24 = *(void **)this;
  if ( *(_QWORD *)this )
  {
    *((_QWORD *)this + 1) = v24;
    operator delete(v24);
  }
}
// 47FD4: variable 'a2' is possibly undefined

//----- (00000000000480B8) ----------------------------------------------------
void __fastcall feasibal_region::GroundProcessRunInData::~GroundProcessRunInData(
        feasibal_region::GroundProcessRunInData *this,
        void *a2)
{
  __int64 v2; // x8
  cv::Mat *v4; // x0
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  __int64 v12; // x8
  unsigned int *v13; // x8
  unsigned int v14; // w9
  unsigned int v15; // w9
  int v16; // w8
  __int64 v17; // x8
  __int64 v18; // x9
  cv *v19; // x0

  v2 = *((_QWORD *)this + 19);
  if ( v2 )
  {
    v4 = (feasibal_region::GroundProcessRunInData *)((char *)this + 96);
    v5 = (unsigned int *)(v2 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate(v4);
  }
  v8 = *((_DWORD *)this + 25);
  *((_QWORD *)this + 19) = 0LL;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  if ( v8 >= 1 )
  {
    v9 = *((_QWORD *)this + 20);
    v10 = 0LL;
    do
      *(_DWORD *)(v9 + 4 * v10++) = 0;
    while ( v10 < *((int *)this + 25) );
  }
  v11 = (cv *)*((_QWORD *)this + 21);
  if ( v11 != (feasibal_region::GroundProcessRunInData *)((char *)this + 176) )
    cv::fastFree(v11, a2);
  v12 = *((_QWORD *)this + 7);
  if ( v12 )
  {
    v13 = (unsigned int *)(v12 + 20);
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while ( __stlxr(v15, v13) );
    if ( !v15 )
      cv::Mat::deallocate(this);
  }
  v16 = *((_DWORD *)this + 1);
  *((_QWORD *)this + 7) = 0LL;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  if ( v16 >= 1 )
  {
    v17 = *((_QWORD *)this + 8);
    v18 = 0LL;
    do
      *(_DWORD *)(v17 + 4 * v18++) = 0;
    while ( v18 < *((int *)this + 1) );
  }
  v19 = (cv *)*((_QWORD *)this + 9);
  if ( v19 != (feasibal_region::GroundProcessRunInData *)((char *)this + 80) )
    cv::fastFree(v19, a2);
}
// 48134: variable 'a2' is possibly undefined

//----- (00000000000481BC) ----------------------------------------------------
__int64 __fastcall feasibal_region::feasibal_region::release(feasibal_region::feasibal_region *this)
{
  return 0LL;
}

//----- (00000000000481C4) ----------------------------------------------------
float64x2_t __usercall feasibal_region::feasibal_region::getTFMatrix@<Q0>(
        double *a1@<X1>,
        float64x2_t *a2@<X2>,
        float64x2_t *a3@<X8>)
{
  double v3; // d9
  double v4; // d13
  double v7; // d10
  double v8; // d11
  double v9; // d12
  double v10; // d7
  double v11; // d16
  double v12; // d2
  double v13; // d1
  double v14; // d3
  double v15; // d5
  double v16; // d11
  double v17; // d2
  double v18; // d12
  double v19; // d9
  double v20; // d10
  double v21; // d7
  double v22; // d17
  double v23; // d18
  double v24; // d3
  double v25; // d0
  double v26; // d6
  double v27; // d3
  double v28; // d0
  double v29; // d4
  double v30; // d16
  double v31; // d1
  double v32; // d17
  double v33; // d4
  double v34; // d18
  double v35; // d6
  double v36; // d5
  double v37; // d3
  double v38; // d0
  double v39; // d7
  double v40; // d19
  double v41; // d20
  double v42; // d4
  double v43; // d18
  double v44; // d6
  double v45; // d3
  double v46; // d0
  double v47; // d1
  double v48; // d5
  float64x2_t result; // q0
  double v50; // d1
  double v51; // [xsp+8h] [xbp-78h] BYREF
  double v52; // [xsp+10h] [xbp-70h] BYREF
  double cosx; // [xsp+18h] [xbp-68h] BYREF
  double sinx; // [xsp+20h] [xbp-60h] BYREF
  double v55; // [xsp+28h] [xbp-58h] BYREF
  double v56; // [xsp+38h] [xbp-48h] BYREF

  v3 = a1[1];
  v4 = *a1;
  sincos(a1[2] * 0.5, &sinx, &cosx);
  v8 = cosx;
  v7 = sinx;
  v9 = sinx * 0.0;
  sincos(v3 * 0.5, &v52, &v51);
  v10 = v52 * 0.0 * v9;
  v11 = v7 * (v52 * 0.0);
  v12 = v8 * (v52 * 0.0);
  v13 = v51 * v7 + v12;
  v14 = v51 * v8 - v10;
  v15 = v12 + v51 * v9;
  v16 = v11 + v52 * v8 + v51 * v9 - v10;
  v17 = v14 - v52 * v9;
  v18 = v52 * v9 + v13 - v10;
  v19 = v17 - v11;
  v20 = v10 + v15 - v52 * v7;
  sincos(v4 * 0.5, &v56, &v55);
  v21 = v56 * 0.0 * v19;
  v22 = v56 * 0.0 * v16;
  v23 = v56 * 0.0 * v18;
  v24 = v56 * 0.0 * v20;
  v25 = v24 + v55 * v18 + v21;
  v26 = v22 + v56 * v19 + v55 * v20 - v23;
  v27 = v56 * v18 + v21 + v55 * v16 - v24;
  v28 = v25 - v56 * v16;
  v29 = v55 * v19 - v56 * v20 - v22 - v23;
  v30 = v29 * (v26 + v26);
  v31 = v26 * (v26 + v26);
  v32 = v29 * (v27 + v27);
  v33 = v29 * (v28 + v28);
  v34 = v26 * (v27 + v27);
  v35 = v26 * (v28 + v28);
  v36 = v27 * (v27 + v27);
  v37 = v27 * (v28 + v28);
  v38 = v28 * (v28 + v28);
  v39 = v36 + v38;
  v40 = v34 - v33;
  v41 = v35 + v32;
  v42 = v34 + v33;
  v43 = v37 - v30;
  v44 = v35 - v32;
  v45 = v37 + v30;
  v46 = 1.0 - (v31 + v38);
  v47 = 1.0 - (v31 + v36);
  v48 = (1.0 - v39) * 0.0;
  a3[1].n128_u64[1] = 0LL;
  a3[3].n128_u64[1] = 0LL;
  a3[5].n128_u64[1] = 0LL;
  a3[7].n128_u64[1] = 0x3FF0000000000000LL;
  a3[4].n128_f64[0] = v41 + v43 * 0.0 + v47 * 0.0;
  a3[4].n128_f64[1] = v43 + v41 * 0.0 + v47 * 0.0;
  a3[5].n128_f64[0] = v47 + v41 * 0.0 + v43 * 0.0;
  a3->n128_f64[0] = v44 * 0.0 + 1.0 - v39 + v42 * 0.0;
  a3->n128_f64[1] = v44 * 0.0 + v42 + v48;
  a3[1].n128_f64[0] = v44 + v42 * 0.0 + v48;
  a3[2].n128_f64[0] = v45 * 0.0 + v40 + v46 * 0.0;
  a3[2].n128_f64[1] = v45 * 0.0 + v40 * 0.0 + v46;
  a3[3].n128_f64[0] = v45 + v40 * 0.0 + v46 * 0.0;
  result = vaddq_f64(*a2, (float64x2_t)0);
  v50 = a2[1].n128_f64[0] + 0.0;
  a3[6] = result;
  a3[7].n128_f64[0] = v50;
  return result;
}

//----- (0000000000048434) ----------------------------------------------------
void __fastcall feasibal_region::ground_process::~ground_process(feasibal_region::ground_process *this)
{
  std::ios_base *v2; // x20
  void *v3; // x1
  __int64 v4; // x8
  unsigned int *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w9
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x9
  cv *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  void *v18; // x0
  __int64 v19; // x8
  unsigned int *v20; // x8
  unsigned int v21; // w9
  unsigned int v22; // w9
  int v23; // w8
  __int64 v24; // x8
  __int64 v25; // x9
  cv *v26; // x0
  __int64 v27; // x8
  unsigned int *v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w9
  int v31; // w8
  __int64 v32; // x8
  __int64 v33; // x9
  cv *v34; // x0
  __int64 v35; // x8
  unsigned int *v36; // x8
  unsigned int v37; // w9
  unsigned int v38; // w9
  __int64 v39; // x8
  __int64 v40; // x9
  cv *v41; // x0
  __int64 v42; // x8
  unsigned int *v43; // x8
  unsigned int v44; // w9
  unsigned int v45; // w9
  __int64 v46; // x8
  __int64 v47; // x9
  cv *v48; // x0
  __int64 v49; // x8
  unsigned int *v50; // x8
  unsigned int v51; // w9
  unsigned int v52; // w9
  __int64 v53; // x8
  __int64 v54; // x9
  cv *v55; // x0
  void *v56; // x0
  void *v57; // x0
  void *v58; // x0
  __int64 v59; // x8
  unsigned int *v60; // x8
  unsigned int v61; // w9
  unsigned int v62; // w9
  __int64 v63; // x8
  __int64 v64; // x9
  cv *v65; // x0
  __int64 v66; // x8
  unsigned int *v67; // x8
  unsigned int v68; // w9
  unsigned int v69; // w9
  __int64 v70; // x8
  __int64 v71; // x9
  cv *v72; // x0
  __int64 v73; // x8
  unsigned int *v74; // x8
  unsigned int v75; // w9
  unsigned int v76; // w9
  __int64 v77; // x8
  __int64 v78; // x9
  cv *v79; // x0
  __int64 v80; // x8
  unsigned int *v81; // x8
  unsigned int v82; // w9
  unsigned int v83; // w9
  __int64 v84; // x8
  __int64 v85; // x9
  cv *v86; // x0
  __int64 v87; // x8
  unsigned int *v88; // x8
  unsigned int v89; // w9
  unsigned int v90; // w9
  __int64 v91; // x8
  __int64 v92; // x9
  cv *v93; // x0
  __int64 v94; // x8
  unsigned int *v95; // x8
  unsigned int v96; // w9
  unsigned int v97; // w9
  __int64 v98; // x8
  __int64 v99; // x9
  cv *v100; // x0
  __int64 v101; // x8
  unsigned int *v102; // x8
  unsigned int v103; // w9
  unsigned int v104; // w9
  __int64 v105; // x8
  __int64 v106; // x9
  cv *v107; // x0
  __int64 v108; // x8
  unsigned int *v109; // x8
  unsigned int v110; // w9
  unsigned int v111; // w9
  __int64 v112; // x8
  __int64 v113; // x9
  cv *v114; // x0
  __int64 v115; // x8
  unsigned int *v116; // x8
  unsigned int v117; // w9
  unsigned int v118; // w9
  __int64 v119; // x8
  __int64 v120; // x9
  cv *v121; // x0
  __int64 v122; // x8
  unsigned int *v123; // x8
  unsigned int v124; // w9
  unsigned int v125; // w9
  __int64 v126; // x8
  __int64 v127; // x9
  cv *v128; // x0
  __int64 v129; // x8
  unsigned int *v130; // x8
  unsigned int v131; // w9
  unsigned int v132; // w9
  __int64 v133; // x8
  __int64 v134; // x9
  cv *v135; // x0
  void *v136; // x1
  CAPE *v137; // x20

  v2 = (feasibal_region::ground_process *)((char *)this + 2912);
  *((_QWORD *)this + 342) = off_6DF38;
  *((_QWORD *)this + 364) = off_6DF60;
  std::filebuf::~filebuf((__int64)this + 2744);
  std::ios_base::~ios_base(v2);
  v4 = *((_QWORD *)this + 333);
  if ( v4 )
  {
    v5 = (unsigned int *)(v4 + 20);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while ( __stlxr(v7, v5) );
    if ( !v7 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2608));
  }
  v8 = *((_DWORD *)this + 653);
  *((_QWORD *)this + 333) = 0LL;
  *((_OWORD *)this + 165) = 0u;
  *((_OWORD *)this + 164) = 0u;
  if ( v8 >= 1 )
  {
    v9 = *((_QWORD *)this + 334);
    v10 = 0LL;
    do
      *(_DWORD *)(v9 + 4 * v10++) = 0;
    while ( v10 < *((int *)this + 653) );
  }
  v11 = (cv *)*((_QWORD *)this + 335);
  if ( v11 != (feasibal_region::ground_process *)((char *)this + 2688) )
    cv::fastFree(v11, v3);
  v12 = (void *)*((_QWORD *)this + 322);
  if ( v12 )
  {
    *((_QWORD *)this + 323) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 317);
  if ( v13 )
  {
    *((_QWORD *)this + 318) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 311);
  if ( v14 )
  {
    *((_QWORD *)this + 312) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 308);
  if ( v15 )
  {
    *((_QWORD *)this + 309) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 305);
  if ( v16 )
  {
    *((_QWORD *)this + 306) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 302);
  if ( v17 )
  {
    *((_QWORD *)this + 303) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 299);
  if ( v18 )
  {
    *((_QWORD *)this + 300) = v18;
    operator delete(v18);
  }
  v19 = *((_QWORD *)this + 293);
  if ( v19 )
  {
    v20 = (unsigned int *)(v19 + 20);
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while ( __stlxr(v22, v20) );
    if ( !v22 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2288));
  }
  v23 = *((_DWORD *)this + 573);
  *((_QWORD *)this + 293) = 0LL;
  *((_OWORD *)this + 145) = 0u;
  *((_OWORD *)this + 144) = 0u;
  if ( v23 >= 1 )
  {
    v24 = *((_QWORD *)this + 294);
    v25 = 0LL;
    do
      *(_DWORD *)(v24 + 4 * v25++) = 0;
    while ( v25 < *((int *)this + 573) );
  }
  v26 = (cv *)*((_QWORD *)this + 295);
  if ( v26 != (feasibal_region::ground_process *)((char *)this + 2368) )
    cv::fastFree(v26, v3);
  v27 = *((_QWORD *)this + 281);
  if ( v27 )
  {
    v28 = (unsigned int *)(v27 + 20);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while ( __stlxr(v30, v28) );
    if ( !v30 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2192));
  }
  v31 = *((_DWORD *)this + 549);
  *((_QWORD *)this + 281) = 0LL;
  *((_OWORD *)this + 139) = 0u;
  *((_OWORD *)this + 138) = 0u;
  if ( v31 >= 1 )
  {
    v32 = *((_QWORD *)this + 282);
    v33 = 0LL;
    do
      *(_DWORD *)(v32 + 4 * v33++) = 0;
    while ( v33 < *((int *)this + 549) );
  }
  v34 = (cv *)*((_QWORD *)this + 283);
  if ( v34 != (feasibal_region::ground_process *)((char *)this + 2272) )
    cv::fastFree(v34, v3);
  v35 = *((_QWORD *)this + 268);
  if ( v35 )
  {
    v36 = (unsigned int *)(v35 + 20);
    do
    {
      v37 = __ldaxr(v36);
      v38 = v37 - 1;
    }
    while ( __stlxr(v38, v36) );
    if ( !v38 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 2088));
  }
  *((_QWORD *)this + 268) = 0LL;
  *(_OWORD *)((char *)this + 2120) = 0u;
  *(_OWORD *)((char *)this + 2104) = 0u;
  if ( *((int *)this + 523) >= 1 )
  {
    v39 = *((_QWORD *)this + 269);
    v40 = 0LL;
    do
      *(_DWORD *)(v39 + 4 * v40++) = 0;
    while ( v40 < *((int *)this + 523) );
  }
  v41 = (cv *)*((_QWORD *)this + 270);
  if ( v41 != (feasibal_region::ground_process *)((char *)this + 2168) )
    cv::fastFree(v41, v3);
  v42 = *((_QWORD *)this + 256);
  if ( v42 )
  {
    v43 = (unsigned int *)(v42 + 20);
    do
    {
      v44 = __ldaxr(v43);
      v45 = v44 - 1;
    }
    while ( __stlxr(v45, v43) );
    if ( !v45 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1992));
  }
  *((_QWORD *)this + 256) = 0LL;
  *(_OWORD *)((char *)this + 2024) = 0u;
  *(_OWORD *)((char *)this + 2008) = 0u;
  if ( *((int *)this + 499) >= 1 )
  {
    v46 = *((_QWORD *)this + 257);
    v47 = 0LL;
    do
      *(_DWORD *)(v46 + 4 * v47++) = 0;
    while ( v47 < *((int *)this + 499) );
  }
  v48 = (cv *)*((_QWORD *)this + 258);
  if ( v48 != (feasibal_region::ground_process *)((char *)this + 2072) )
    cv::fastFree(v48, v3);
  v49 = *((_QWORD *)this + 244);
  if ( v49 )
  {
    v50 = (unsigned int *)(v49 + 20);
    do
    {
      v51 = __ldaxr(v50);
      v52 = v51 - 1;
    }
    while ( __stlxr(v52, v50) );
    if ( !v52 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1896));
  }
  *((_QWORD *)this + 244) = 0LL;
  *(_OWORD *)((char *)this + 1928) = 0u;
  *(_OWORD *)((char *)this + 1912) = 0u;
  if ( *((int *)this + 475) >= 1 )
  {
    v53 = *((_QWORD *)this + 245);
    v54 = 0LL;
    do
      *(_DWORD *)(v53 + 4 * v54++) = 0;
    while ( v54 < *((int *)this + 475) );
  }
  v55 = (cv *)*((_QWORD *)this + 246);
  if ( v55 != (feasibal_region::ground_process *)((char *)this + 1976) )
    cv::fastFree(v55, v3);
  v56 = (void *)*((_QWORD *)this + 234);
  if ( v56 )
  {
    *((_QWORD *)this + 235) = v56;
    operator delete(v56);
  }
  v57 = (void *)*((_QWORD *)this + 231);
  if ( v57 )
  {
    *((_QWORD *)this + 232) = v57;
    operator delete(v57);
  }
  v58 = (void *)*((_QWORD *)this + 205);
  if ( v58 )
  {
    *((_QWORD *)this + 206) = v58;
    operator delete(v58);
  }
  v59 = *((_QWORD *)this + 200);
  if ( v59 )
  {
    v60 = (unsigned int *)(v59 + 20);
    do
    {
      v61 = __ldaxr(v60);
      v62 = v61 - 1;
    }
    while ( __stlxr(v62, v60) );
    if ( !v62 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1544));
  }
  *((_QWORD *)this + 200) = 0LL;
  *(_OWORD *)((char *)this + 1576) = 0u;
  *(_OWORD *)((char *)this + 1560) = 0u;
  if ( *((int *)this + 387) >= 1 )
  {
    v63 = *((_QWORD *)this + 201);
    v64 = 0LL;
    do
      *(_DWORD *)(v63 + 4 * v64++) = 0;
    while ( v64 < *((int *)this + 387) );
  }
  v65 = (cv *)*((_QWORD *)this + 202);
  if ( v65 != (feasibal_region::ground_process *)((char *)this + 1624) )
    cv::fastFree(v65, v3);
  v66 = *((_QWORD *)this + 188);
  if ( v66 )
  {
    v67 = (unsigned int *)(v66 + 20);
    do
    {
      v68 = __ldaxr(v67);
      v69 = v68 - 1;
    }
    while ( __stlxr(v69, v67) );
    if ( !v69 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1448));
  }
  *((_QWORD *)this + 188) = 0LL;
  *(_OWORD *)((char *)this + 1480) = 0u;
  *(_OWORD *)((char *)this + 1464) = 0u;
  if ( *((int *)this + 363) >= 1 )
  {
    v70 = *((_QWORD *)this + 189);
    v71 = 0LL;
    do
      *(_DWORD *)(v70 + 4 * v71++) = 0;
    while ( v71 < *((int *)this + 363) );
  }
  v72 = (cv *)*((_QWORD *)this + 190);
  if ( v72 != (feasibal_region::ground_process *)((char *)this + 1528) )
    cv::fastFree(v72, v3);
  v73 = *((_QWORD *)this + 176);
  if ( v73 )
  {
    v74 = (unsigned int *)(v73 + 20);
    do
    {
      v75 = __ldaxr(v74);
      v76 = v75 - 1;
    }
    while ( __stlxr(v76, v74) );
    if ( !v76 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1352));
  }
  *((_QWORD *)this + 176) = 0LL;
  *(_OWORD *)((char *)this + 1384) = 0u;
  *(_OWORD *)((char *)this + 1368) = 0u;
  if ( *((int *)this + 339) >= 1 )
  {
    v77 = *((_QWORD *)this + 177);
    v78 = 0LL;
    do
      *(_DWORD *)(v77 + 4 * v78++) = 0;
    while ( v78 < *((int *)this + 339) );
  }
  v79 = (cv *)*((_QWORD *)this + 178);
  if ( v79 != (feasibal_region::ground_process *)((char *)this + 1432) )
    cv::fastFree(v79, v3);
  v80 = *((_QWORD *)this + 164);
  if ( v80 )
  {
    v81 = (unsigned int *)(v80 + 20);
    do
    {
      v82 = __ldaxr(v81);
      v83 = v82 - 1;
    }
    while ( __stlxr(v83, v81) );
    if ( !v83 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1256));
  }
  *((_QWORD *)this + 164) = 0LL;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *(_OWORD *)((char *)this + 1272) = 0u;
  if ( *((int *)this + 315) >= 1 )
  {
    v84 = *((_QWORD *)this + 165);
    v85 = 0LL;
    do
      *(_DWORD *)(v84 + 4 * v85++) = 0;
    while ( v85 < *((int *)this + 315) );
  }
  v86 = (cv *)*((_QWORD *)this + 166);
  if ( v86 != (feasibal_region::ground_process *)((char *)this + 1336) )
    cv::fastFree(v86, v3);
  v87 = *((_QWORD *)this + 152);
  if ( v87 )
  {
    v88 = (unsigned int *)(v87 + 20);
    do
    {
      v89 = __ldaxr(v88);
      v90 = v89 - 1;
    }
    while ( __stlxr(v90, v88) );
    if ( !v90 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1160));
  }
  *((_QWORD *)this + 152) = 0LL;
  *(_OWORD *)((char *)this + 1192) = 0u;
  *(_OWORD *)((char *)this + 1176) = 0u;
  if ( *((int *)this + 291) >= 1 )
  {
    v91 = *((_QWORD *)this + 153);
    v92 = 0LL;
    do
      *(_DWORD *)(v91 + 4 * v92++) = 0;
    while ( v92 < *((int *)this + 291) );
  }
  v93 = (cv *)*((_QWORD *)this + 154);
  if ( v93 != (feasibal_region::ground_process *)((char *)this + 1240) )
    cv::fastFree(v93, v3);
  v94 = *((_QWORD *)this + 140);
  if ( v94 )
  {
    v95 = (unsigned int *)(v94 + 20);
    do
    {
      v96 = __ldaxr(v95);
      v97 = v96 - 1;
    }
    while ( __stlxr(v97, v95) );
    if ( !v97 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 1064));
  }
  *((_QWORD *)this + 140) = 0LL;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  if ( *((int *)this + 267) >= 1 )
  {
    v98 = *((_QWORD *)this + 141);
    v99 = 0LL;
    do
      *(_DWORD *)(v98 + 4 * v99++) = 0;
    while ( v99 < *((int *)this + 267) );
  }
  v100 = (cv *)*((_QWORD *)this + 142);
  if ( v100 != (feasibal_region::ground_process *)((char *)this + 1144) )
    cv::fastFree(v100, v3);
  v101 = *((_QWORD *)this + 128);
  if ( v101 )
  {
    v102 = (unsigned int *)(v101 + 20);
    do
    {
      v103 = __ldaxr(v102);
      v104 = v103 - 1;
    }
    while ( __stlxr(v104, v102) );
    if ( !v104 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 968));
  }
  *((_QWORD *)this + 128) = 0LL;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  if ( *((int *)this + 243) >= 1 )
  {
    v105 = *((_QWORD *)this + 129);
    v106 = 0LL;
    do
      *(_DWORD *)(v105 + 4 * v106++) = 0;
    while ( v106 < *((int *)this + 243) );
  }
  v107 = (cv *)*((_QWORD *)this + 130);
  if ( v107 != (feasibal_region::ground_process *)((char *)this + 1048) )
    cv::fastFree(v107, v3);
  v108 = *((_QWORD *)this + 116);
  if ( v108 )
  {
    v109 = (unsigned int *)(v108 + 20);
    do
    {
      v110 = __ldaxr(v109);
      v111 = v110 - 1;
    }
    while ( __stlxr(v111, v109) );
    if ( !v111 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 872));
  }
  *((_QWORD *)this + 116) = 0LL;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 888) = 0u;
  if ( *((int *)this + 219) >= 1 )
  {
    v112 = *((_QWORD *)this + 117);
    v113 = 0LL;
    do
      *(_DWORD *)(v112 + 4 * v113++) = 0;
    while ( v113 < *((int *)this + 219) );
  }
  v114 = (cv *)*((_QWORD *)this + 118);
  if ( v114 != (feasibal_region::ground_process *)((char *)this + 952) )
    cv::fastFree(v114, v3);
  v115 = *((_QWORD *)this + 104);
  if ( v115 )
  {
    v116 = (unsigned int *)(v115 + 20);
    do
    {
      v117 = __ldaxr(v116);
      v118 = v117 - 1;
    }
    while ( __stlxr(v118, v116) );
    if ( !v118 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 776));
  }
  *((_QWORD *)this + 104) = 0LL;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  if ( *((int *)this + 195) >= 1 )
  {
    v119 = *((_QWORD *)this + 105);
    v120 = 0LL;
    do
      *(_DWORD *)(v119 + 4 * v120++) = 0;
    while ( v120 < *((int *)this + 195) );
  }
  v121 = (cv *)*((_QWORD *)this + 106);
  if ( v121 != (feasibal_region::ground_process *)((char *)this + 856) )
    cv::fastFree(v121, v3);
  v122 = *((_QWORD *)this + 92);
  if ( v122 )
  {
    v123 = (unsigned int *)(v122 + 20);
    do
    {
      v124 = __ldaxr(v123);
      v125 = v124 - 1;
    }
    while ( __stlxr(v125, v123) );
    if ( !v125 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 680));
  }
  *((_QWORD *)this + 92) = 0LL;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  if ( *((int *)this + 171) >= 1 )
  {
    v126 = *((_QWORD *)this + 93);
    v127 = 0LL;
    do
      *(_DWORD *)(v126 + 4 * v127++) = 0;
    while ( v127 < *((int *)this + 171) );
  }
  v128 = (cv *)*((_QWORD *)this + 94);
  if ( v128 != (feasibal_region::ground_process *)((char *)this + 760) )
    cv::fastFree(v128, v3);
  v129 = *((_QWORD *)this + 80);
  if ( v129 )
  {
    v130 = (unsigned int *)(v129 + 20);
    do
    {
      v131 = __ldaxr(v130);
      v132 = v131 - 1;
    }
    while ( __stlxr(v132, v130) );
    if ( !v132 )
      cv::Mat::deallocate((feasibal_region::ground_process *)((char *)this + 584));
  }
  *((_QWORD *)this + 80) = 0LL;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  if ( *((int *)this + 147) >= 1 )
  {
    v133 = *((_QWORD *)this + 81);
    v134 = 0LL;
    do
      *(_DWORD *)(v133 + 4 * v134++) = 0;
    while ( v134 < *((int *)this + 147) );
  }
  v135 = (cv *)*((_QWORD *)this + 82);
  if ( v135 != (feasibal_region::ground_process *)((char *)this + 664) )
    cv::fastFree(v135, v3);
  free(*((void **)this + 70));
  free(*((void **)this + 67));
  v137 = (CAPE *)*((_QWORD *)this + 64);
  *((_QWORD *)this + 64) = 0LL;
  if ( v137 )
  {
    CAPE::~CAPE(v137);
    operator delete(v137);
  }
  feasibal_region::PreParamInfo::~PreParamInfo((void **)this + 2, v136);
}
// 484E0: variable 'v3' is possibly undefined
// 48D6C: variable 'v136' is possibly undefined
// 6DF38: using guessed type __int64 (__fastcall *off_6DF38[2])();
// 6DF60: using guessed type __int64 (__fastcall *off_6DF60[2])();

//----- (0000000000048DB4) ----------------------------------------------------
void __fastcall CAPE::CAPE(CAPE *this, int a2, int a3, int a4, int a5, char a6, float a7, float a8, float a9)
{
  _BYTE *v9; // x25
  char *v10; // x24
  int *v12; // x22
  int *v13; // x21
  int v14; // w23
  unsigned int v15; // w26
  void *v16; // x1
  __int64 v17; // x8
  int *v18; // x25
  unsigned int *v19; // x8
  unsigned int v20; // w9
  unsigned int v21; // w9
  int v22; // w8
  __int64 v23; // x8
  __int64 v24; // x9
  int v25; // v0.s[1]
  __int128 v26; // q1
  cv *v27; // x0
  int v28; // w8
  unsigned int *v29; // x8
  unsigned int v30; // w9
  unsigned int v31; // w9
  cv *v32; // x9
  cv *v33; // x8
  __int64 v34; // x9
  void *v35; // x1
  __int64 v36; // x8
  unsigned int *v37; // x8
  unsigned int v38; // w9
  unsigned int v39; // w9
  int v40; // w8
  __int64 v41; // x8
  __int64 v42; // x9
  int v43; // v0.s[1]
  __int128 v44; // q1
  cv *v45; // x0
  int v46; // w8
  char **v47; // x25
  unsigned int *v48; // x8
  unsigned int v49; // w9
  unsigned int v50; // w9
  cv *v51; // x9
  cv *v52; // x8
  __int64 v53; // x9
  void *v54; // x1
  __int64 v55; // x8
  unsigned int *v56; // x8
  unsigned int v57; // w9
  unsigned int v58; // w9
  int v59; // w8
  __int64 v60; // x8
  __int64 v61; // x9
  int v62; // v0.s[1]
  __int128 v63; // q1
  cv *v64; // x0
  int v65; // w8
  unsigned int *v66; // x8
  unsigned int v67; // w9
  unsigned int v68; // w9
  cv *v69; // x9
  cv *v70; // x8
  __int64 v71; // x9
  void *v72; // x1
  __int64 v73; // x8
  unsigned int *v74; // x8
  unsigned int v75; // w9
  unsigned int v76; // w9
  int v77; // w8
  __int64 v78; // x8
  __int64 v79; // x9
  int v80; // v0.s[1]
  __int128 v81; // q1
  cv *v82; // x0
  int v83; // w8
  unsigned int *v84; // x8
  unsigned int v85; // w9
  unsigned int v86; // w9
  cv *v87; // x9
  cv *v88; // x8
  __int64 v89; // x9
  void *v90; // x1
  __int64 v91; // x8
  unsigned int *v92; // x8
  unsigned int v93; // w9
  unsigned int v94; // w9
  int v95; // w8
  __int64 v96; // x8
  __int64 v97; // x9
  int v98; // v0.s[1]
  __int128 v99; // q1
  cv *v100; // x0
  int v101; // w8
  unsigned int *v102; // x8
  unsigned int v103; // w9
  unsigned int v104; // w9
  cv *v105; // x9
  cv *v106; // x8
  __int64 v107; // x9
  void *v108; // x1
  __int64 v109; // x8
  unsigned int *v110; // x8
  unsigned int v111; // w9
  unsigned int v112; // w9
  int v113; // w8
  __int64 v114; // x8
  __int64 v115; // x9
  int v116; // v0.s[1]
  __int128 v117; // q1
  cv *v118; // x0
  int v119; // w8
  unsigned int *v120; // x8
  unsigned int v121; // w9
  unsigned int v122; // w9
  cv *v123; // x9
  cv *v124; // x8
  __int64 v125; // x9
  int v126; // w24
  int v127; // w27
  __int64 v128; // x0
  _QWORD *v129; // x8
  std::__shared_weak_count *v130; // x20
  unsigned __int64 *v131; // x8
  unsigned __int64 v132; // x9
  _QWORD *v133; // x20
  __int64 v134; // x8
  __int64 v135; // x9
  signed __int64 v136; // x10
  __int64 v137; // x11
  signed __int64 v138; // x12
  _QWORD *v139; // x13
  int v140; // w3
  void *v141; // x1
  int v142; // w3
  void *v143; // x1
  Histogram *v144; // x20
  int v145; // w3
  Histogram *v146; // x24
  void *v147; // x1
  cv::Mat *v148; // [xsp+80h] [xbp-2B0h]
  char *v149; // [xsp+88h] [xbp-2A8h]
  char *v150; // [xsp+90h] [xbp-2A0h]
  char *v151; // [xsp+98h] [xbp-298h]
  char *v152; // [xsp+A0h] [xbp-290h]
  char *v153; // [xsp+A8h] [xbp-288h]
  int *v154; // [xsp+B0h] [xbp-280h]
  int *v155; // [xsp+B8h] [xbp-278h]
  int *v156; // [xsp+C0h] [xbp-270h]
  cv::Mat *v161; // [xsp+E0h] [xbp-250h]
  cv::Mat *v162; // [xsp+E8h] [xbp-248h]
  cv::Mat *v163; // [xsp+F0h] [xbp-240h]
  char *v164; // [xsp+F8h] [xbp-238h]
  char **v165; // [xsp+100h] [xbp-230h]
  cv *v166; // [xsp+108h] [xbp-228h]
  cv *v167; // [xsp+110h] [xbp-220h]
  cv *v168; // [xsp+118h] [xbp-218h]
  cv *v169; // [xsp+120h] [xbp-210h]
  cv *v170; // [xsp+128h] [xbp-208h]
  cv *v171; // [xsp+130h] [xbp-200h]
  cv::Mat *v172; // [xsp+138h] [xbp-1F8h]
  cv::Mat *v173; // [xsp+140h] [xbp-1F0h]
  cv::Mat *v174; // [xsp+148h] [xbp-1E8h]
  cv::Mat *v175; // [xsp+150h] [xbp-1E0h]
  cv::Mat *v176; // [xsp+158h] [xbp-1D8h]
  _BYTE v177[64]; // [xsp+160h] [xbp-1D0h] BYREF
  cv *v178[2]; // [xsp+1A0h] [xbp-190h]
  __int64 v179; // [xsp+1B0h] [xbp-180h] BYREF
  __int64 v180; // [xsp+1B8h] [xbp-178h]
  int v181; // [xsp+2C8h] [xbp-68h] BYREF
  int v182; // [xsp+2CCh] [xbp-64h]
  __int64 v183; // [xsp+2D0h] [xbp-60h]

  v183 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 20) = 1124007940;
  v9 = (char *)this + 80;
  *(_OWORD *)((char *)this + 84) = 0u;
  v10 = (char *)this + 88;
  v156 = (int *)((char *)this + 84);
  *((_OWORD *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 196) = 0u;
  v171 = (CAPE *)((char *)this + 160);
  *((_QWORD *)this + 18) = (char *)this + 88;
  *((_QWORD *)this + 19) = (char *)this + 160;
  *(_OWORD *)((char *)this + 180) = 0u;
  v164 = (char *)this + 180;
  v153 = (char *)this + 184;
  *((_QWORD *)this + 30) = (char *)this + 184;
  *((_QWORD *)this + 31) = (char *)this + 256;
  *((_DWORD *)this + 44) = 1124007936;
  *((_OWORD *)this + 16) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  v170 = (CAPE *)((char *)this + 256);
  v176 = (CAPE *)((char *)this + 176);
  *((_OWORD *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 308) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *((_DWORD *)this + 68) = 1124007940;
  *((_QWORD *)this + 42) = (char *)this + 280;
  *((_QWORD *)this + 43) = (char *)this + 352;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *(_OWORD *)((char *)this + 404) = 0u;
  *(_OWORD *)((char *)this + 388) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *((_QWORD *)this + 54) = (char *)this + 376;
  *((_QWORD *)this + 55) = (char *)this + 448;
  *((_OWORD *)this + 28) = 0u;
  *((_DWORD *)this + 92) = 1124007936;
  *((_DWORD *)this + 116) = 1124007936;
  *(_OWORD *)((char *)this + 484) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *(_OWORD *)((char *)this + 500) = 0u;
  v154 = (int *)((char *)this + 564);
  v155 = (int *)((char *)this + 468);
  *(_OWORD *)((char *)this + 468) = 0u;
  v151 = (char *)this + 568;
  v152 = (char *)this + 472;
  *((_QWORD *)this + 66) = (char *)this + 472;
  v168 = (CAPE *)((char *)this + 640);
  v169 = (CAPE *)((char *)this + 544);
  *((_QWORD *)this + 67) = (char *)this + 544;
  *((_OWORD *)this + 34) = 0u;
  *((_DWORD *)this + 140) = 1124007936;
  *((_OWORD *)this + 38) = 0u;
  *(_OWORD *)((char *)this + 596) = 0u;
  *(_OWORD *)((char *)this + 580) = 0u;
  *(_OWORD *)((char *)this + 564) = 0u;
  *((_QWORD *)this + 78) = (char *)this + 568;
  *((_QWORD *)this + 79) = (char *)this + 640;
  *((_OWORD *)this + 40) = 0u;
  *((_DWORD *)this + 164) = 1124007936;
  *((_OWORD *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 692) = 0u;
  *(_OWORD *)((char *)this + 676) = 0u;
  *(_OWORD *)((char *)this + 660) = 0u;
  *((_QWORD *)this + 90) = (char *)this + 664;
  *((_QWORD *)this + 91) = (char *)this + 736;
  *((_OWORD *)this + 46) = 0u;
  *((_DWORD *)this + 188) = 1124007936;
  *((_OWORD *)this + 50) = 0u;
  *(_OWORD *)((char *)this + 788) = 0u;
  *(_OWORD *)((char *)this + 772) = 0u;
  v12 = (int *)((char *)this + 756);
  *(_OWORD *)((char *)this + 756) = 0u;
  v150 = (char *)this + 760;
  *((_QWORD *)this + 102) = (char *)this + 760;
  v167 = (CAPE *)((char *)this + 832);
  *((_QWORD *)this + 103) = (char *)this + 832;
  *((_OWORD *)this + 52) = 0u;
  *((_DWORD *)this + 212) = 1124007936;
  *((_OWORD *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 884) = 0u;
  *(_OWORD *)((char *)this + 868) = 0u;
  v13 = (int *)((char *)this + 852);
  *(_OWORD *)((char *)this + 852) = 0u;
  v149 = (char *)this + 856;
  *((_QWORD *)this + 114) = (char *)this + 856;
  v166 = (CAPE *)((char *)this + 928);
  *((_QWORD *)this + 115) = (char *)this + 928;
  *((_OWORD *)this + 58) = 0u;
  *((_DWORD *)this + 236) = 1124007936;
  *((_OWORD *)this + 62) = 0u;
  *(_OWORD *)((char *)this + 980) = 0u;
  *(_OWORD *)((char *)this + 964) = 0u;
  *(_OWORD *)((char *)this + 948) = 0u;
  *((_QWORD *)this + 126) = (char *)this + 952;
  *((_QWORD *)this + 127) = (char *)this + 1024;
  *((_OWORD *)this + 64) = 0u;
  *((_DWORD *)this + 260) = 1124007936;
  *((_OWORD *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 1076) = 0u;
  *(_OWORD *)((char *)this + 1060) = 0u;
  *(_OWORD *)((char *)this + 1044) = 0u;
  *((_QWORD *)this + 138) = (char *)this + 1048;
  *((_QWORD *)this + 139) = (char *)this + 1120;
  *((_BYTE *)this + 1304) = 0;
  *((_DWORD *)this + 327) = 0;
  *((_DWORD *)this + 328) = 0;
  *((_OWORD *)this + 71) = 0u;
  *((_OWORD *)this + 70) = 0u;
  *(_QWORD *)((char *)this + 1316) = 0xC3FA0000447A0000LL;
  *((_DWORD *)this + 331) = 1140457472;
  *((_QWORD *)this + 166) = 0LL;
  *((_DWORD *)this + 334) = 1124007936;
  *(_OWORD *)((char *)this + 1384) = 0u;
  *(_OWORD *)((char *)this + 1372) = 0u;
  *(_OWORD *)((char *)this + 1356) = 0u;
  *(_OWORD *)((char *)this + 1340) = 0u;
  *((_QWORD *)this + 175) = (char *)this + 1344;
  *((_QWORD *)this + 176) = (char *)this + 1416;
  *(_OWORD *)((char *)this + 1416) = 0u;
  *((_DWORD *)this + 358) = 0;
  *((_DWORD *)this + 360) = 1124007936;
  *((_OWORD *)this + 93) = 0u;
  *(_OWORD *)((char *)this + 1476) = 0u;
  *(_OWORD *)((char *)this + 1460) = 0u;
  *(_OWORD *)((char *)this + 1444) = 0u;
  *((_QWORD *)this + 188) = (char *)this + 1448;
  *((_DWORD *)this + 386) = -1083771680;
  *((_BYTE *)this + 24) = a6 & 1;
  *((_QWORD *)this + 189) = (char *)this + 1520;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *(_DWORD *)this = a4;
  *((_DWORD *)this + 1) = a5;
  *((float *)this + 4) = a8;
  *((float *)this + 5) = a7;
  v165 = (char **)((char *)this + 56);
  v175 = (CAPE *)((char *)this + 464);
  v174 = (CAPE *)((char *)this + 560);
  v173 = (CAPE *)((char *)this + 752);
  v172 = (CAPE *)((char *)this + 848);
  v163 = (CAPE *)((char *)this + 944);
  v162 = (CAPE *)((char *)this + 1040);
  v14 = a3 / a4;
  v15 = a2 / a5;
  *((_OWORD *)this + 95) = 0u;
  *((_QWORD *)this + 192) = 0xBEDCCC8ABC28F3AALL;
  *((_QWORD *)this + 196) = 0LL;
  *((_OWORD *)this + 97) = 0u;
  v181 = 0;
  v161 = (CAPE *)((char *)this + 1336);
  v148 = (CAPE *)((char *)this + 80);
  cv::Mat_<int>::Mat_((__int64)v177, a2 / a5, a3 / a4, &v181);
  if ( v9 == v177 )
  {
    v18 = (int *)v164;
    if ( *(_QWORD *)&v177[56] )
    {
      v29 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v30 = __ldaxr(v29);
        v31 = v30 - 1;
      }
      while ( __stlxr(v31, v29) );
      if ( !v31 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v17 = *((_QWORD *)this + 17);
    v18 = (int *)v164;
    if ( v17 )
    {
      v19 = (unsigned int *)(v17 + 20);
      do
      {
        v20 = __ldaxr(v19);
        v21 = v20 - 1;
      }
      while ( __stlxr(v21, v19) );
      if ( !v21 )
        cv::Mat::deallocate(v148);
    }
    v22 = *((_DWORD *)this + 21);
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_QWORD *)this + 17) = 0LL;
    if ( v22 >= 1 )
    {
      v23 = *((_QWORD *)this + 18);
      v24 = 0LL;
      do
        *(_DWORD *)(v23 + 4 * v24++) = 0;
      while ( v24 < *v156 );
    }
    v25 = *(_DWORD *)&v177[4];
    v26 = *(_OWORD *)&v177[16];
    v27 = (cv *)*((_QWORD *)this + 19);
    *((_OWORD *)this + 5) = *(_OWORD *)v177;
    *((_OWORD *)this + 6) = v26;
    *((_OWORD *)this + 7) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 8) = *(_OWORD *)&v177[48];
    if ( v27 == v171 )
    {
      v28 = v25;
    }
    else
    {
      cv::fastFree(v27, v16);
      *((_QWORD *)this + 18) = v10;
      *((_QWORD *)this + 19) = v171;
      v28 = *(_DWORD *)&v177[4];
    }
    if ( v28 <= 2 )
    {
      v32 = v178[1];
      *((_QWORD *)this + 20) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 21) = *((_QWORD *)v32 + 1);
    }
    else
    {
      *((_OWORD *)this + 9) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v33 = v178[0];
    v34 = 0LL;
    do
      *((_DWORD *)v33 + v34++) = 0;
    while ( v34 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v16);
  LOBYTE(v181) = 0;
  cv::Mat_<unsigned char>::Mat_((__int64)v177, v15, v14, &v181);
  if ( v176 == (cv::Mat *)v177 )
  {
    v47 = v165;
    if ( *(_QWORD *)&v177[56] )
    {
      v48 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v49 = __ldaxr(v48);
        v50 = v49 - 1;
      }
      while ( __stlxr(v50, v48) );
      if ( !v50 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v36 = *((_QWORD *)this + 29);
    if ( v36 )
    {
      v37 = (unsigned int *)(v36 + 20);
      do
      {
        v38 = __ldaxr(v37);
        v39 = v38 - 1;
      }
      while ( __stlxr(v39, v37) );
      if ( !v39 )
        cv::Mat::deallocate(v176);
    }
    v40 = *((_DWORD *)this + 45);
    *((_QWORD *)this + 29) = 0LL;
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 13) = 0u;
    if ( v40 >= 1 )
    {
      v41 = *((_QWORD *)this + 30);
      v42 = 0LL;
      do
        *(_DWORD *)(v41 + 4 * v42++) = 0;
      while ( v42 < *v18 );
    }
    v43 = *(_DWORD *)&v177[4];
    v44 = *(_OWORD *)&v177[16];
    v45 = (cv *)*((_QWORD *)this + 31);
    *((_OWORD *)this + 11) = *(_OWORD *)v177;
    *((_OWORD *)this + 12) = v44;
    *((_OWORD *)this + 13) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 14) = *(_OWORD *)&v177[48];
    if ( v45 == v170 )
    {
      v46 = v43;
    }
    else
    {
      cv::fastFree(v45, v35);
      *((_QWORD *)this + 30) = v153;
      *((_QWORD *)this + 31) = v170;
      v46 = *(_DWORD *)&v177[4];
    }
    v47 = v165;
    if ( v46 <= 2 )
    {
      v51 = v178[1];
      *((_QWORD *)this + 32) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 33) = *((_QWORD *)v51 + 1);
    }
    else
    {
      *((_OWORD *)this + 15) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v52 = v178[0];
    v53 = 0LL;
    do
      *((_DWORD *)v52 + v53++) = 0;
    while ( v53 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v35);
  *(_DWORD *)v177 = 1124007936;
  v181 = v15;
  v182 = v14;
  memset(&v177[4], 0, 60);
  v178[0] = (cv *)&v177[8];
  v178[1] = (cv *)&v179;
  v179 = 0LL;
  v180 = 0LL;
  cv::Mat::create((cv::Mat *)v177, 2, &v181, 0);
  if ( v175 == (cv::Mat *)v177 )
  {
    if ( *(_QWORD *)&v177[56] )
    {
      v66 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v67 = __ldaxr(v66);
        v68 = v67 - 1;
      }
      while ( __stlxr(v68, v66) );
      if ( !v68 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v55 = *((_QWORD *)this + 65);
    if ( v55 )
    {
      v56 = (unsigned int *)(v55 + 20);
      do
      {
        v57 = __ldaxr(v56);
        v58 = v57 - 1;
      }
      while ( __stlxr(v58, v56) );
      if ( !v58 )
        cv::Mat::deallocate(v175);
    }
    v59 = *((_DWORD *)this + 117);
    *((_OWORD *)this + 30) = 0u;
    *((_OWORD *)this + 31) = 0u;
    *((_QWORD *)this + 65) = 0LL;
    if ( v59 >= 1 )
    {
      v60 = *((_QWORD *)this + 66);
      v61 = 0LL;
      do
        *(_DWORD *)(v60 + 4 * v61++) = 0;
      while ( v61 < *v155 );
    }
    v62 = *(_DWORD *)&v177[4];
    v63 = *(_OWORD *)&v177[16];
    v64 = (cv *)*((_QWORD *)this + 67);
    *((_OWORD *)this + 29) = *(_OWORD *)v177;
    *((_OWORD *)this + 30) = v63;
    *((_OWORD *)this + 31) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 32) = *(_OWORD *)&v177[48];
    if ( v64 == v169 )
    {
      v65 = v62;
    }
    else
    {
      cv::fastFree(v64, v54);
      *((_QWORD *)this + 67) = v169;
      *((_QWORD *)this + 66) = v152;
      v65 = *(_DWORD *)&v177[4];
    }
    if ( v65 <= 2 )
    {
      v69 = v178[1];
      *((_QWORD *)this + 68) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 69) = *((_QWORD *)v69 + 1);
    }
    else
    {
      *((_OWORD *)this + 33) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v70 = v178[0];
    v71 = 0LL;
    do
      *((_DWORD *)v70 + v71++) = 0;
    while ( v71 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v54);
  *(_DWORD *)v177 = 1124007936;
  v181 = v15;
  v182 = v14;
  memset(&v177[4], 0, 60);
  v178[0] = (cv *)&v177[8];
  v178[1] = (cv *)&v179;
  v179 = 0LL;
  v180 = 0LL;
  cv::Mat::create((cv::Mat *)v177, 2, &v181, 0);
  if ( v174 == (cv::Mat *)v177 )
  {
    if ( *(_QWORD *)&v177[56] )
    {
      v84 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v85 = __ldaxr(v84);
        v86 = v85 - 1;
      }
      while ( __stlxr(v86, v84) );
      if ( !v86 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v73 = *((_QWORD *)this + 77);
    if ( v73 )
    {
      v74 = (unsigned int *)(v73 + 20);
      do
      {
        v75 = __ldaxr(v74);
        v76 = v75 - 1;
      }
      while ( __stlxr(v76, v74) );
      if ( !v76 )
        cv::Mat::deallocate(v174);
    }
    v77 = *((_DWORD *)this + 141);
    *((_OWORD *)this + 36) = 0u;
    *((_OWORD *)this + 37) = 0u;
    *((_QWORD *)this + 77) = 0LL;
    if ( v77 >= 1 )
    {
      v78 = *((_QWORD *)this + 78);
      v79 = 0LL;
      do
        *(_DWORD *)(v78 + 4 * v79++) = 0;
      while ( v79 < *v154 );
    }
    v80 = *(_DWORD *)&v177[4];
    v81 = *(_OWORD *)&v177[16];
    v82 = (cv *)*((_QWORD *)this + 79);
    *((_OWORD *)this + 35) = *(_OWORD *)v177;
    *((_OWORD *)this + 36) = v81;
    *((_OWORD *)this + 37) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 38) = *(_OWORD *)&v177[48];
    if ( v82 == v168 )
    {
      v83 = v80;
    }
    else
    {
      cv::fastFree(v82, v72);
      *((_QWORD *)this + 79) = v168;
      *((_QWORD *)this + 78) = v151;
      v83 = *(_DWORD *)&v177[4];
    }
    if ( v83 <= 2 )
    {
      v87 = v178[1];
      *((_QWORD *)this + 80) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 81) = *((_QWORD *)v87 + 1);
    }
    else
    {
      *((_OWORD *)this + 39) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v88 = v178[0];
    v89 = 0LL;
    do
      *((_DWORD *)v88 + v89++) = 0;
    while ( v89 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v72);
  *(_DWORD *)v177 = 1124007936;
  v181 = v15;
  v182 = v14;
  memset(&v177[4], 0, 60);
  v178[0] = (cv *)&v177[8];
  v178[1] = (cv *)&v179;
  v179 = 0LL;
  v180 = 0LL;
  cv::Mat::create((cv::Mat *)v177, 2, &v181, 0);
  if ( v173 == (cv::Mat *)v177 )
  {
    if ( *(_QWORD *)&v177[56] )
    {
      v102 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v103 = __ldaxr(v102);
        v104 = v103 - 1;
      }
      while ( __stlxr(v104, v102) );
      if ( !v104 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v91 = *((_QWORD *)this + 101);
    if ( v91 )
    {
      v92 = (unsigned int *)(v91 + 20);
      do
      {
        v93 = __ldaxr(v92);
        v94 = v93 - 1;
      }
      while ( __stlxr(v94, v92) );
      if ( !v94 )
        cv::Mat::deallocate(v173);
    }
    v95 = *((_DWORD *)this + 189);
    *((_QWORD *)this + 101) = 0LL;
    *((_OWORD *)this + 48) = 0u;
    *((_OWORD *)this + 49) = 0u;
    if ( v95 >= 1 )
    {
      v96 = *((_QWORD *)this + 102);
      v97 = 0LL;
      do
        *(_DWORD *)(v96 + 4 * v97++) = 0;
      while ( v97 < *v12 );
    }
    v98 = *(_DWORD *)&v177[4];
    v99 = *(_OWORD *)&v177[16];
    v100 = (cv *)*((_QWORD *)this + 103);
    *((_OWORD *)this + 47) = *(_OWORD *)v177;
    *((_OWORD *)this + 48) = v99;
    *((_OWORD *)this + 49) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 50) = *(_OWORD *)&v177[48];
    if ( v100 == v167 )
    {
      v101 = v98;
    }
    else
    {
      cv::fastFree(v100, v90);
      *((_QWORD *)this + 103) = v167;
      *((_QWORD *)this + 102) = v150;
      v101 = *(_DWORD *)&v177[4];
    }
    if ( v101 <= 2 )
    {
      v105 = v178[1];
      *((_QWORD *)this + 104) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 105) = *((_QWORD *)v105 + 1);
    }
    else
    {
      *((_OWORD *)this + 51) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v106 = v178[0];
    v107 = 0LL;
    do
      *((_DWORD *)v106 + v107++) = 0;
    while ( v107 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v90);
  *(_DWORD *)v177 = 1124007936;
  v181 = v15;
  v182 = v14;
  memset(&v177[4], 0, 60);
  v178[0] = (cv *)&v177[8];
  v178[1] = (cv *)&v179;
  v179 = 0LL;
  v180 = 0LL;
  cv::Mat::create((cv::Mat *)v177, 2, &v181, 0);
  if ( v172 == (cv::Mat *)v177 )
  {
    if ( *(_QWORD *)&v177[56] )
    {
      v120 = (unsigned int *)(*(_QWORD *)&v177[56] + 20LL);
      do
      {
        v121 = __ldaxr(v120);
        v122 = v121 - 1;
      }
      while ( __stlxr(v122, v120) );
      if ( !v122 )
        cv::Mat::deallocate((cv::Mat *)v177);
    }
  }
  else
  {
    v109 = *((_QWORD *)this + 113);
    if ( v109 )
    {
      v110 = (unsigned int *)(v109 + 20);
      do
      {
        v111 = __ldaxr(v110);
        v112 = v111 - 1;
      }
      while ( __stlxr(v112, v110) );
      if ( !v112 )
        cv::Mat::deallocate(v172);
    }
    v113 = *((_DWORD *)this + 213);
    *((_QWORD *)this + 113) = 0LL;
    *((_OWORD *)this + 54) = 0u;
    *((_OWORD *)this + 55) = 0u;
    if ( v113 >= 1 )
    {
      v114 = *((_QWORD *)this + 114);
      v115 = 0LL;
      do
        *(_DWORD *)(v114 + 4 * v115++) = 0;
      while ( v115 < *v13 );
    }
    v116 = *(_DWORD *)&v177[4];
    v117 = *(_OWORD *)&v177[16];
    v118 = (cv *)*((_QWORD *)this + 115);
    *((_OWORD *)this + 53) = *(_OWORD *)v177;
    *((_OWORD *)this + 54) = v117;
    *((_OWORD *)this + 55) = *(_OWORD *)&v177[32];
    *((_OWORD *)this + 56) = *(_OWORD *)&v177[48];
    if ( v118 == v166 )
    {
      v119 = v116;
    }
    else
    {
      cv::fastFree(v118, v108);
      *((_QWORD *)this + 115) = v166;
      *((_QWORD *)this + 114) = v149;
      v119 = *(_DWORD *)&v177[4];
    }
    if ( v119 <= 2 )
    {
      v123 = v178[1];
      *((_QWORD *)this + 116) = *(_QWORD *)v178[1];
      *((_QWORD *)this + 117) = *((_QWORD *)v123 + 1);
    }
    else
    {
      *((_OWORD *)this + 57) = *(_OWORD *)v178;
      v178[0] = (cv *)&v177[8];
      v178[1] = (cv *)&v179;
    }
    *(_DWORD *)v177 = 1124007936;
    memset(&v177[4], 0, 60);
  }
  *(_QWORD *)&v177[56] = 0LL;
  memset(&v177[16], 0, 32);
  if ( *(int *)&v177[4] >= 1 )
  {
    v124 = v178[0];
    v125 = 0LL;
    do
      *((_DWORD *)v124 + v125++) = 0;
    while ( v125 < *(int *)&v177[4] );
  }
  if ( (__int64 *)v178[1] != &v179 )
    cv::fastFree(v178[1], v108);
  v126 = v15 * v14;
  if ( (int)(v15 * v14) >= 1 )
  {
    v127 = 0;
    do
    {
      v128 = operator new(0xC0uLL);
      *(_QWORD *)(v128 + 8) = 0LL;
      *(_QWORD *)(v128 + 16) = 0LL;
      *(_QWORD *)v128 = off_6E230;
      *(_QWORD *)(v128 + 184) = 0LL;
      *(_OWORD *)(v128 + 168) = 0u;
      *(_OWORD *)(v128 + 152) = 0u;
      *(_OWORD *)(v128 + 136) = 0u;
      *(_OWORD *)(v128 + 120) = 0u;
      *(_QWORD *)v177 = v128 + 24;
      *(_QWORD *)&v177[8] = v128;
      v129 = (_QWORD *)*((_QWORD *)this + 8);
      if ( (unsigned __int64)v129 >= *((_QWORD *)this + 9) )
      {
        std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg>>(v47, (__int64)v177);
        v130 = *(std::__shared_weak_count **)&v177[8];
        if ( *(_QWORD *)&v177[8] )
        {
          v131 = (unsigned __int64 *)(*(_QWORD *)&v177[8] + 8LL);
          do
            v132 = __ldaxr(v131);
          while ( __stlxr(v132 - 1, v131) );
          if ( !v132 )
          {
            (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v130 + 16LL))(v130);
            std::__shared_weak_count::__release_weak(v130);
          }
        }
      }
      else
      {
        *v129 = v128 + 24;
        v129[1] = v128;
        *(_OWORD *)v177 = 0uLL;
        *((_QWORD *)this + 8) = v129 + 2;
      }
      ++v127;
    }
    while ( v127 < v126 );
  }
  v133 = (_QWORD *)((char *)this + 1136);
  Eigen::PlainObjectBase<Eigen::Array<float,-1,1,0,-1,1>>::resize((__int64)this + 1136, a5 * a4, 1LL);
  v134 = *((_QWORD *)this + 143);
  v135 = v134 + 3;
  if ( v134 >= 0 )
    v135 = *((_QWORD *)this + 143);
  v136 = v135 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v134 >= 4 )
  {
    v137 = 0LL;
    v138 = 0LL;
    do
    {
      v138 += 4LL;
      v139 = (_QWORD *)(*v133 + v137);
      v137 += 16LL;
      *v139 = 0LL;
      v139[1] = 0LL;
    }
    while ( v138 < v136 );
  }
  if ( v136 < v134 )
    memset((void *)(*v133 + 4 * v136), 0, 4 * v134 - 16 * (v135 >> 2));
  *((_QWORD *)this + 144) = malloc(a3 * a2);
  *((_QWORD *)this + 145) = malloc(v126);
  *((_QWORD *)this + 146) = malloc(v126);
  cv::Mat::ones(v177, (cv::Mat *)((unsigned int)&dword_0 + 3), 3, 0, v140);
  (*(void (__fastcall **)(_QWORD, _BYTE *, cv::Mat *, __int64))(**(_QWORD **)v177 + 24LL))(
    *(_QWORD *)v177,
    v177,
    v163,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v177, v141);
  cv::Mat::ones(v177, (cv::Mat *)((unsigned int)&dword_0 + 3), 3, 0, v142);
  (*(void (__fastcall **)(_QWORD, _BYTE *, cv::Mat *, __int64))(**(_QWORD **)v177 + 24LL))(
    *(_QWORD *)v177,
    v177,
    v162,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v177, v143);
  **((_BYTE **)this + 132) = 0;
  *(_BYTE *)(*((_QWORD *)this + 132) + 2LL * **((_QWORD **)this + 139) + 2) = 0;
  *(_BYTE *)(*((_QWORD *)this + 132) + 2LL) = 0;
  *(_BYTE *)(*((_QWORD *)this + 132) + 2LL * **((_QWORD **)this + 139)) = 0;
  v144 = (Histogram *)operator new(0x40uLL);
  Histogram::Histogram(v144, 20);
  v146 = (Histogram *)*((_QWORD *)this + 166);
  *((_QWORD *)this + 166) = v144;
  if ( v146 )
  {
    Histogram::~Histogram(v146);
    operator delete(v146);
  }
  cv::Mat::zeros(v177, (cv::Mat *)v15, v14, 29, v145);
  (*(void (__fastcall **)(_QWORD, _BYTE *, cv::Mat *, __int64))(**(_QWORD **)v177 + 24LL))(
    *(_QWORD *)v177,
    v177,
    v161,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v177, v147);
}
// 49258: variable 'v16' is possibly undefined
// 493EC: variable 'v35' is possibly undefined
// 495C0: variable 'v54' is possibly undefined
// 49778: variable 'v72' is possibly undefined
// 4992C: variable 'v90' is possibly undefined
// 49AE0: variable 'v108' is possibly undefined
// 49D2C: variable 'v140' is possibly undefined
// 49D50: variable 'v141' is possibly undefined
// 49D64: variable 'v142' is possibly undefined
// 49D88: variable 'v143' is possibly undefined
// 49E04: variable 'v145' is possibly undefined
// 49E28: variable 'v147' is possibly undefined
// 0: using guessed type int dword_0;
// 28: using guessed type __int64;
// 6E230: using guessed type __int64 (__fastcall *[3])();

//----- (000000000004A988) ----------------------------------------------------
__int64 __fastcall cv::Mat_<int>::Mat_(__int64 a1, int a2, int a3, int *a4)
{
  int v6; // s0
  int v8[2]; // [xsp+8h] [xbp-58h] BYREF
  __int64 v9; // [xsp+10h] [xbp-50h]
  __int64 v10; // [xsp+18h] [xbp-48h]
  __int64 v11; // [xsp+20h] [xbp-40h]
  __int64 v12; // [xsp+28h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_DWORD *)a1 = 1124007936;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 64) = a1 + 8;
  *(_QWORD *)(a1 + 72) = a1 + 80;
  v8[0] = a2;
  v8[1] = a3;
  cv::Mat::create((cv::Mat *)a1, 2, v8, 4);
  v6 = *a4;
  v10 = 0LL;
  v11 = 0LL;
  v9 = 0LL;
  *(double *)v8 = (double)v6;
  return cv::Mat::operator=(a1, v8);
}
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);

//----- (000000000004AAC8) ----------------------------------------------------
__int64 __fastcall CAPE::set_extrinsic(__int64 result, _DWORD *a2, _DWORD *a3)
{
  *(_BYTE *)(result + 1304) = 1;
  *(_DWORD *)(result + 1176) = *a2;
  *(_DWORD *)(result + 1180) = a2[1];
  *(_DWORD *)(result + 1184) = a2[2];
  *(_DWORD *)(result + 1188) = a2[3];
  *(_DWORD *)(result + 1192) = a2[4];
  *(_DWORD *)(result + 1196) = a2[5];
  *(_DWORD *)(result + 1200) = a2[6];
  *(_DWORD *)(result + 1204) = a2[7];
  *(_DWORD *)(result + 1208) = a2[8];
  *(_DWORD *)(result + 1212) = a2[9];
  *(_DWORD *)(result + 1216) = a2[10];
  *(_DWORD *)(result + 1220) = a2[11];
  *(_DWORD *)(result + 1224) = a2[12];
  *(_DWORD *)(result + 1228) = a2[13];
  *(_DWORD *)(result + 1232) = a2[14];
  *(_DWORD *)(result + 1236) = a2[15];
  *(_DWORD *)(result + 1312) = *a3;
  *(_DWORD *)(result + 1316) = a3[1];
  *(_DWORD *)(result + 1320) = a3[2];
  *(_DWORD *)(result + 1324) = a3[3];
  return result;
}

//----- (000000000004AB74) ----------------------------------------------------
__int64 __fastcall CAPE::updateDefaultPlane(__int64 result, _DWORD *a2, float a3)
{
  int v3; // w8

  *(_DWORD *)(result + 1536) = *a2;
  *(_DWORD *)(result + 1540) = a2[1];
  v3 = a2[2];
  *(float *)(result + 1308) = a3;
  *(_DWORD *)(result + 1544) = v3;
  return result;
}

//----- (000000000004AB94) ----------------------------------------------------
void __usercall CAPE::process_modify_opt(
        int *a1@<X0>,
        _QWORD *a2@<X1>,
        unsigned int *a3@<X2>,
        __int64 a4@<X4>,
        __int64 a5@<X6>,
        __int64 a6@<X8>)
{
  long double v6; // q8
  __int64 v7; // x24
  int v8; // w8
  int v9; // w9
  int v10; // w25
  int v11; // w27
  unsigned __int64 v13; // x28
  unsigned __int64 v14; // x19
  _QWORD *v15; // x0
  unsigned __int64 v16; // x9
  _QWORD *v17; // x21
  char *v18; // x0
  char *v19; // x19
  char *v20; // x0
  char *v21; // x9
  unsigned __int64 v22; // x10
  _OWORD *v23; // x12
  unsigned __int64 v29; // x13
  __int64 v30; // x21
  __int64 v31; // x23
  __int64 v32; // x28
  float v33; // s10
  __int64 v34; // x26
  __int64 v35; // x24
  __int64 v36; // x27
  __int64 v37; // x20
  __int64 v38; // x19
  __int64 v39; // x22
  __int64 v40; // x8
  __int64 v41; // x10
  int v42; // w8
  float v43; // s0
  __int64 v44; // x9
  __int64 v45; // x9
  __int64 v46; // x11
  __int64 v47; // x9
  float v48; // s0
  float v49; // s0
  __time_t tv_sec; // x26
  __time_t v51; // x27
  __suseconds_t tv_usec; // x23
  __suseconds_t v53; // x25
  const char *v54; // x21
  size_t v55; // x0
  size_t v56; // x19
  char *v57; // x28
  unsigned __int64 v58; // x22
  signed __int64 v59; // x28
  char v60; // w19
  float v61; // s0
  unsigned __int64 v62; // x20
  _QWORD *v63; // x0
  unsigned __int64 v64; // x9
  _QWORD *v65; // x19
  char *v66; // x21
  double *v67; // x23
  __int64 *v68; // x24
  unsigned __int64 v69; // x20
  int v70; // w22
  char *v71; // x26
  __int64 v72; // x28
  double v73; // d9
  double v74; // d10
  char *v75; // x8
  __int64 v76; // x9
  _QWORD *v77; // x26
  unsigned __int64 v78; // x11
  unsigned __int64 v79; // x12
  __int64 v80; // x15
  bool v81; // w16
  bool *v82; // x14
  char v83; // w15
  __int64 v84; // x23
  int *v85; // x0
  unsigned __int64 v86; // x8
  int v87; // w20
  __int64 v88; // x9
  float v89; // s0
  int v90; // w10
  __int64 v91; // t1
  float v92; // s1
  __int64 *v93; // x9
  __int64 v94; // x8
  __int64 v95; // x27
  __int64 v96; // x9
  unsigned __int64 *v97; // x9
  unsigned __int64 v98; // x10
  float *v99; // x23
  signed __int64 v100; // x21
  int v101; // w20
  int *v102; // x0
  __int64 *v103; // x8
  __int64 v104; // x8
  unsigned __int64 *v105; // x8
  unsigned __int64 v106; // x9
  long double v107; // q0
  std::__shared_weak_count *v108; // x28
  unsigned __int64 *v109; // x8
  unsigned __int64 v110; // x9
  std::__shared_weak_count *v111; // x21
  _QWORD *v112; // x8
  __int64 v113; // x9
  unsigned __int64 *v114; // x8
  unsigned __int64 v115; // x9
  char *v116; // x11
  _DWORD *v117; // x9
  int v118; // w12
  __int64 v119; // x10
  __int64 v120; // x8
  unsigned __int64 v121; // x11
  __int64 v122; // x14
  _DWORD *v123; // x15
  _BYTE *v124; // x13
  unsigned __int64 *v125; // x8
  unsigned __int64 v126; // x9
  unsigned __int64 v127; // x19
  signed __int64 v128; // x22
  unsigned __int64 v129; // x21
  __int64 v130; // x0
  _DWORD *v131; // x9
  __int64 v132; // x10
  __int64 v133; // x24
  int v134; // w25
  __int64 v135; // x8
  __int64 v136; // x23
  char v137; // w9
  __int64 v138; // x28
  __int64 v139; // x20
  int v140; // w27
  __int64 v141; // x10
  __int64 v142; // x0
  float *v143; // x13
  float v144; // s0
  float v145; // s1
  double v146; // d0
  __int64 v147; // x8
  unsigned __int64 *v148; // x8
  unsigned __int64 v149; // x9
  long double v150; // q0
  std::__shared_weak_count *v151; // x19
  unsigned __int64 *v152; // x8
  unsigned __int64 v153; // x9
  __int64 v154; // x24
  signed __int64 v155; // x25
  signed __int64 v156; // x19
  __int64 v157; // x8
  int v158; // w9
  void **v159; // x8
  __int64 v160; // x9
  void *v161; // x1
  __int64 v162; // x20
  __int64 v163; // x19
  __int128 v164; // q1
  __int128 v165; // q1
  __int128 v166; // q2
  __int128 v167; // q3
  __int64 *v168; // x25
  __int64 v169; // x8
  unsigned int *v170; // x8
  unsigned int v171; // w9
  __int64 v172; // x8
  unsigned int *v173; // x8
  unsigned int v174; // w9
  unsigned int v175; // w9
  int v176; // w8
  __int64 v177; // x8
  __int64 v178; // x9
  __int64 v179; // x10
  int v180; // w8
  _QWORD *v181; // x10
  _QWORD *v182; // x8
  const char *v183; // x21
  size_t v184; // x0
  size_t v185; // x19
  char *v186; // x24
  unsigned __int64 v187; // x22
  char v188; // w19
  __int64 *v189; // x21
  __int64 *v190; // x19
  const char *v191; // x21
  size_t v192; // x0
  size_t v193; // x19
  char *v194; // x24
  const char *v195; // x21
  size_t v196; // x0
  size_t v197; // x19
  char *v198; // x24
  unsigned __int64 v199; // x22
  __int64 v200; // x0
  float *v201; // x20
  char v202; // w19
  unsigned __int64 v203; // x22
  __int64 v204; // x0
  char v205; // w19
  void **i; // x21
  void **v207; // x22
  __int64 v208; // x26
  __int64 v209; // x27
  float v210; // w10
  float v211; // w11
  float v212; // s0
  float v213; // s1
  float v214; // w9
  float v215; // w22
  float v216; // s2
  float v217; // s11
  float v218; // s12
  float v219; // s10
  float v220; // s3
  float v221; // s4
  float v222; // s0
  float v223; // w23
  float v224; // s8
  float v225; // s0
  float v226; // s2
  float v227; // s9
  float v228; // s14
  const char *v229; // x21
  size_t v230; // x0
  size_t v231; // x24
  char *v232; // x28
  float v233; // w20
  unsigned __int64 v234; // x22
  char v235; // w21
  float v236; // s13
  double v237; // d8
  float v238; // s9
  const char *v239; // x24
  size_t v240; // x0
  size_t v241; // x21
  char *v242; // x28
  float v243; // w20
  unsigned __int64 v244; // x22
  char v245; // w21
  unsigned __int64 v246; // x8
  const char *v247; // x21
  size_t v248; // x0
  size_t v249; // x19
  char *v250; // x24
  __int64 BestPlane; // x0
  float *v252; // x8
  float v253; // w25
  float v254; // w26
  float v255; // w27
  float v256; // w28
  __int64 v257; // x0
  const char *v258; // x21
  size_t v259; // x0
  size_t v260; // x19
  char *v261; // x23
  unsigned int valid; // w0
  const char *v263; // x23
  unsigned int v264; // w19
  size_t v265; // x0
  size_t v266; // x21
  char *v267; // x24
  unsigned __int64 v268; // x22
  __int64 v269; // x22
  char v270; // w19
  unsigned __int64 v271; // x22
  char v272; // w21
  const char *v273; // x23
  size_t v274; // x0
  size_t v275; // x21
  char *v276; // x24
  unsigned __int64 v277; // x22
  char v278; // w21
  char v279; // w0
  const char *v280; // x23
  char v281; // w19
  size_t v282; // x0
  size_t v283; // x21
  char *v284; // x24
  _BOOL4 v285; // w19
  int v286; // w27
  unsigned __int64 v287; // x22
  char v288; // w19
  const char *v289; // x21
  size_t v290; // x0
  size_t v291; // x19
  char *v292; // x24
  void *v293; // x0
  void *v294; // x1
  int v295; // w0
  const char *v296; // x24
  int v297; // w21
  size_t v298; // x0
  size_t v299; // x23
  char *v300; // x25
  unsigned __int64 v301; // x22
  __int64 v302; // x24
  char v303; // w23
  __int64 v304; // x23
  __int64 v305; // x22
  __int64 v306; // x20
  float v307; // s3
  float v308; // s2
  _DWORD *v309; // x19
  float v310; // s0
  unsigned int *v311; // x8
  unsigned int v312; // w9
  __int64 v313; // x8
  unsigned int *v314; // x8
  unsigned int v315; // w9
  unsigned int v316; // w9
  int v317; // w8
  __int64 v318; // x8
  __int64 v319; // x9
  __int64 v320; // x10
  const char *v321; // x21
  size_t v322; // x0
  size_t v323; // x19
  char *v324; // x22
  float v325; // s0
  void *v326; // x1
  int v327; // w8
  __int64 k; // x19
  __int64 v329; // x8
  unsigned int *v330; // x8
  unsigned int v331; // w9
  unsigned int v332; // w9
  int v333; // w8
  __int64 v334; // x8
  __int64 v335; // x9
  cv *v336; // x0
  unsigned __int64 v337; // x23
  void *v338; // x1
  char v339; // w19
  __int64 v340; // x19
  __int64 j; // x20
  __int64 v342; // x8
  unsigned int *v343; // x8
  unsigned int v344; // w9
  unsigned int v345; // w9
  int v346; // w8
  __int64 v347; // x8
  __int64 v348; // x9
  cv *v349; // x0
  int v350; // w8
  _QWORD *v351; // x10
  cv *v352; // x8
  const cv::Mat *v353; // x1
  __int128 v354; // q0
  __int128 v355; // q1
  __int64 v356; // x8
  unsigned int *v357; // x8
  unsigned int v358; // w9
  _QWORD *v359; // x8
  _QWORD *v360; // x10
  __int64 v361; // x8
  unsigned int *v362; // x8
  unsigned int v363; // w9
  unsigned int v364; // w9
  _BYTE *v365; // x8
  __int64 v366; // x9
  _QWORD *v367; // x20
  _QWORD *v368; // x21
  std::__shared_weak_count *v369; // x19
  unsigned __int64 *v370; // x8
  unsigned __int64 v371; // x9
  void *v372; // x0
  unsigned __int64 v373; // x22
  char v374; // w21
  unsigned __int64 v375; // x22
  __int64 v376; // x0
  __int64 v377; // x20
  char v378; // w19
  int v379; // w9
  _DWORD *v380; // x19
  unsigned int *v381; // x8
  unsigned int v382; // w9
  __int64 v383; // x8
  unsigned int *v384; // x8
  unsigned int v385; // w9
  unsigned int v386; // w9
  int v387; // w8
  __int64 v388; // x8
  __int64 v389; // x9
  __int64 v390; // x10
  __int64 *v391; // [xsp+20h] [xbp-780h]
  __int64 *v392; // [xsp+28h] [xbp-778h]
  unsigned int *v395; // [xsp+50h] [xbp-750h]
  int v396; // [xsp+58h] [xbp-748h]
  int dest; // [xsp+68h] [xbp-738h]
  unsigned __int64 v398; // [xsp+70h] [xbp-730h]
  void ***v399; // [xsp+70h] [xbp-730h]
  __int64 v400; // [xsp+78h] [xbp-728h]
  int v401; // [xsp+78h] [xbp-728h]
  cv::Mat *v402; // [xsp+80h] [xbp-720h]
  float v403; // [xsp+80h] [xbp-720h]
  float v405; // [xsp+A0h] [xbp-700h]
  int v406; // [xsp+B8h] [xbp-6E8h]
  int v407; // [xsp+B8h] [xbp-6E8h]
  float v408; // [xsp+B8h] [xbp-6E8h]
  float v410; // [xsp+C0h] [xbp-6E0h]
  __int64 v411; // [xsp+C8h] [xbp-6D8h]
  void *v412[3]; // [xsp+D8h] [xbp-6C8h] BYREF
  int v413; // [xsp+F0h] [xbp-6B0h] BYREF
  unsigned __int64 v414; // [xsp+F8h] [xbp-6A8h] BYREF
  size_t v415; // [xsp+100h] [xbp-6A0h]
  void *v416; // [xsp+108h] [xbp-698h]
  void *v417[3]; // [xsp+110h] [xbp-690h] BYREF
  int v418; // [xsp+128h] [xbp-678h] BYREF
  unsigned __int64 v419; // [xsp+130h] [xbp-670h] BYREF
  size_t v420; // [xsp+138h] [xbp-668h]
  void *v421; // [xsp+140h] [xbp-660h]
  char v422; // [xsp+148h] [xbp-658h] BYREF
  char v423[15]; // [xsp+149h] [xbp-657h] BYREF
  void *v424; // [xsp+158h] [xbp-648h]
  int v425; // [xsp+160h] [xbp-640h] BYREF
  unsigned __int64 v426; // [xsp+168h] [xbp-638h] BYREF
  size_t v427; // [xsp+170h] [xbp-630h]
  void *v428; // [xsp+178h] [xbp-628h]
  void *v429[3]; // [xsp+180h] [xbp-620h] BYREF
  int v430; // [xsp+198h] [xbp-608h] BYREF
  unsigned __int64 v431; // [xsp+1A0h] [xbp-600h] BYREF
  size_t v432; // [xsp+1A8h] [xbp-5F8h]
  void *v433; // [xsp+1B0h] [xbp-5F0h]
  void *v434[3]; // [xsp+1B8h] [xbp-5E8h] BYREF
  int v435; // [xsp+1D0h] [xbp-5D0h] BYREF
  unsigned __int64 v436; // [xsp+1D8h] [xbp-5C8h] BYREF
  size_t v437; // [xsp+1E0h] [xbp-5C0h]
  void *v438; // [xsp+1E8h] [xbp-5B8h]
  void *v439[3]; // [xsp+1F0h] [xbp-5B0h] BYREF
  int v440; // [xsp+208h] [xbp-598h] BYREF
  unsigned __int64 v441; // [xsp+210h] [xbp-590h] BYREF
  size_t v442; // [xsp+218h] [xbp-588h]
  void *v443; // [xsp+220h] [xbp-580h]
  void *v444[3]; // [xsp+228h] [xbp-578h] BYREF
  int v445; // [xsp+240h] [xbp-560h] BYREF
  unsigned __int64 v446; // [xsp+248h] [xbp-558h] BYREF
  size_t v447; // [xsp+250h] [xbp-550h]
  void *v448; // [xsp+258h] [xbp-548h]
  void *v449[3]; // [xsp+260h] [xbp-540h] BYREF
  int v450; // [xsp+278h] [xbp-528h] BYREF
  unsigned __int64 v451; // [xsp+280h] [xbp-520h] BYREF
  size_t v452; // [xsp+288h] [xbp-518h]
  void *v453; // [xsp+290h] [xbp-510h]
  void *v454[3]; // [xsp+298h] [xbp-508h] BYREF
  int v455; // [xsp+2B0h] [xbp-4F0h] BYREF
  unsigned __int64 v456; // [xsp+2B8h] [xbp-4E8h] BYREF
  size_t v457; // [xsp+2C0h] [xbp-4E0h]
  void *v458; // [xsp+2C8h] [xbp-4D8h]
  void *v459[3]; // [xsp+2D0h] [xbp-4D0h] BYREF
  int v460; // [xsp+2E8h] [xbp-4B8h] BYREF
  unsigned __int64 v461; // [xsp+2F0h] [xbp-4B0h] BYREF
  size_t v462; // [xsp+2F8h] [xbp-4A8h]
  void *v463; // [xsp+300h] [xbp-4A0h]
  void *v464[3]; // [xsp+308h] [xbp-498h] BYREF
  int v465; // [xsp+320h] [xbp-480h] BYREF
  unsigned __int64 v466; // [xsp+328h] [xbp-478h] BYREF
  size_t v467; // [xsp+330h] [xbp-470h]
  void *v468; // [xsp+338h] [xbp-468h]
  void *v469[3]; // [xsp+340h] [xbp-460h] BYREF
  int v470; // [xsp+358h] [xbp-448h] BYREF
  unsigned __int64 v471; // [xsp+360h] [xbp-440h] BYREF
  size_t v472; // [xsp+368h] [xbp-438h]
  void *v473; // [xsp+370h] [xbp-430h]
  void *v474[3]; // [xsp+378h] [xbp-428h] BYREF
  int v475; // [xsp+390h] [xbp-410h] BYREF
  unsigned __int64 v476; // [xsp+398h] [xbp-408h] BYREF
  size_t v477; // [xsp+3A0h] [xbp-400h]
  void *v478; // [xsp+3A8h] [xbp-3F8h]
  int v479; // [xsp+3B0h] [xbp-3F0h] BYREF
  int64x2_t *v480; // [xsp+3B8h] [xbp-3E8h]
  __int64 v481; // [xsp+3C0h] [xbp-3E0h]
  double v482; // [xsp+3C8h] [xbp-3D8h] BYREF
  __int64 v483; // [xsp+3D0h] [xbp-3D0h] BYREF
  unsigned __int64 *v484; // [xsp+3D8h] [xbp-3C8h]
  void *v485; // [xsp+3E0h] [xbp-3C0h] BYREF
  _DWORD *v486; // [xsp+3E8h] [xbp-3B8h]
  _DWORD *v487; // [xsp+3F0h] [xbp-3B0h]
  void *ptr; // [xsp+3F8h] [xbp-3A8h] BYREF
  __int64 v489; // [xsp+400h] [xbp-3A0h]
  __int64 v490; // [xsp+408h] [xbp-398h]
  __int64 v491; // [xsp+410h] [xbp-390h] BYREF
  unsigned __int64 *v492; // [xsp+418h] [xbp-388h]
  void *v493; // [xsp+420h] [xbp-380h] BYREF
  _QWORD *v494; // [xsp+428h] [xbp-378h]
  _QWORD *v495; // [xsp+430h] [xbp-370h]
  void *v496; // [xsp+438h] [xbp-368h]
  void *v497; // [xsp+440h] [xbp-360h]
  char *v498; // [xsp+448h] [xbp-358h]
  void *v499; // [xsp+450h] [xbp-350h] BYREF
  __int64 v500; // [xsp+458h] [xbp-348h]
  unsigned __int64 v501; // [xsp+460h] [xbp-340h]
  void *v502; // [xsp+468h] [xbp-338h] BYREF
  __int64 v503; // [xsp+470h] [xbp-330h]
  __int64 v504; // [xsp+478h] [xbp-328h]
  void *v505[3]; // [xsp+480h] [xbp-320h] BYREF
  int v506; // [xsp+498h] [xbp-308h] BYREF
  unsigned __int64 v507; // [xsp+4A0h] [xbp-300h] BYREF
  size_t v508; // [xsp+4A8h] [xbp-2F8h]
  void *v509; // [xsp+4B0h] [xbp-2F0h]
  void *v510; // [xsp+4B8h] [xbp-2E8h] BYREF
  char *v511; // [xsp+4C0h] [xbp-2E0h]
  char *v512; // [xsp+4C8h] [xbp-2D8h]
  struct timeval v513; // [xsp+4D0h] [xbp-2D0h] BYREF
  struct timeval tv; // [xsp+4E0h] [xbp-2C0h] BYREF
  void *v515; // [xsp+4F0h] [xbp-2B0h]
  void *v516; // [xsp+4F8h] [xbp-2A8h]
  char *v517; // [xsp+500h] [xbp-2A0h]
  void *v518; // [xsp+508h] [xbp-298h]
  __int64 v519; // [xsp+510h] [xbp-290h]
  unsigned __int64 v520; // [xsp+518h] [xbp-288h]
  _BYTE v521[64]; // [xsp+520h] [xbp-280h] BYREF
  _BYTE *v522; // [xsp+560h] [xbp-240h]
  cv *v523; // [xsp+568h] [xbp-238h]
  __int64 v524[2]; // [xsp+570h] [xbp-230h] BYREF
  int64x2_t v525; // [xsp+580h] [xbp-220h] BYREF
  __int128 v526; // [xsp+590h] [xbp-210h]
  float32x2_t v527; // [xsp+6E8h] [xbp-B8h] BYREF
  unsigned __int64 v528; // [xsp+6F0h] [xbp-B0h]

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v7 = (__int64)a1;
  v8 = a1[2];
  v9 = a1[3];
  v10 = *a1;
  v11 = a1[1];
  v525 = 0u;
  v526 = 0u;
  dest = v9 / v10;
  v396 = v8 / v11;
  v400 = (__int64)(a1 + 20);
  cv::Mat::operator=(a1 + 20, &v525);
  v525 = 0u;
  v526 = 0u;
  v402 = (cv::Mat *)(v7 + 176);
  cv::Mat::operator=(v7 + 176, &v525);
  v525 = 0u;
  v526 = 0u;
  cv::Mat::operator=(v7 + 272, &v525);
  v525 = 0u;
  v526 = 0u;
  cv::Mat::operator=(v7 + 368, &v525);
  memset(*(void **)(v7 + 1152), 0, *(int *)(v7 + 12) * (__int64)*(int *)(v7 + 8));
  v13 = v396 * dest;
  v519 = 0LL;
  v518 = 0LL;
  v520 = 0LL;
  if ( v396 * dest )
  {
    if ( (v13 & 0x80000000) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v14 = (unsigned __int64)(v396 * dest - 1LL) >> 6;
    v15 = (_QWORD *)operator new(8 * (v14 + 1));
    if ( (unsigned int)v13 >= 0x41 )
      v16 = (v13 - 1) >> 6;
    else
      v16 = 0LL;
    v17 = v15;
    v518 = v15;
    v520 = v14 + 1;
    v519 = v396 * dest;
    v15[v16] = 0LL;
    memset(v15, 0, 8 * (v13 >> 6));
    if ( (((_BYTE)v396 * (_BYTE)dest) & 0x3F) != 0 )
      v17[(unsigned __int64)(v396 * dest) >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -((v396 * dest) & 0x3F));
  }
  v527.n64_u64[0] = 0LL;
  v528 = 0LL;
  v516 = 0LL;
  v515 = 0LL;
  v517 = 0LL;
  if ( (_DWORD)v13 )
  {
    v18 = (char *)operator new(v13);
    v19 = &v18[v13];
    v515 = v18;
    v517 = &v18[v13];
    memset(v18, 1, v13);
    v516 = v19;
  }
  gettimeofday(&tv, 0LL);
  v511 = 0LL;
  v510 = 0LL;
  v512 = 0LL;
  if ( (_DWORD)v13 )
  {
    v20 = (char *)operator new(4 * v13);
    v21 = v20;
    v22 = v396 * dest;
    v511 = v20;
    v510 = v20;
    v512 = &v20[4 * v13];
    if ( (unsigned int)v13 < 8 )
      goto LABEL_604;
    v23 = v20 + 16;
    v21 = &v20[4 * (v13 & 0xFFFFFFFFFFFFFFF8LL)];
    v22 = v13 - (v13 & 0xFFFFFFFFFFFFFFF8LL);
    __asm { FMOV            V0.4S, #1.0 }
    v29 = v13 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      *(v23 - 1) = _Q0;
      *v23 = _Q0;
      v29 -= 8LL;
      v23 += 2;
    }
    while ( v29 );
    if ( (v13 & 0xFFFFFFFFFFFFFFF8LL) != v13 )
    {
LABEL_604:
      do
      {
        --v22;
        *(_DWORD *)v21 = 1065353216;
        v21 += 4;
      }
      while ( v22 );
    }
    v511 = &v20[4 * v13];
  }
  v398 = v396 * dest;
  v395 = a3;
  v411 = v7;
  if ( v396 >= 1 )
  {
    v30 = 0LL;
    v31 = 0LL;
    v32 = 4LL * v11 * v10;
    v33 = sqrt(1.0 - *(float *)(v7 + 20) * *(float *)(v7 + 20));
    v406 = v11 * v10;
    do
    {
      if ( dest >= 1 )
      {
        v34 = 0LL;
        v35 = 0LL;
        v36 = 0LL;
        v37 = 16 * v31;
        v38 = v32 * (v31 + 1) - 4;
        v39 = v32 * v31;
        do
        {
          *(_OWORD *)(*(_QWORD *)(v411 + 1352) + v30 * **(_QWORD **)(v411 + 1408) + v35) = xmmword_54FB0;
          PlaneSeg::updatePlaneSeg(
            *(_QWORD *)(*(_QWORD *)(v411 + 56) + v37 + v35),
            a2,
            v31 + v36,
            v406,
            *(_DWORD *)v411);
          v40 = *(_QWORD *)(*(_QWORD *)(v411 + 56) + v37 + v35);
          if ( *(int *)v40 >= 1 )
          {
            _ZF = *(_BYTE *)(v40 + 64) == 0;
            v41 = *(_QWORD *)(v40 + 44);
            v42 = *(_DWORD *)(v40 + 52);
            if ( _ZF )
              v43 = 0.0;
            else
              v43 = 1.0;
            v44 = *(_QWORD *)(v411 + 1352) + v30 * **(_QWORD **)(v411 + 1408) + v35;
            *(_QWORD *)v44 = v41;
            *(_DWORD *)(v44 + 8) = v42;
            *(float *)(v44 + 12) = v43;
            v40 = *(_QWORD *)(*(_QWORD *)(v411 + 56) + v37 + v35);
          }
          if ( *(_BYTE *)(v40 + 64) )
          {
            v45 = a2[1];
            v46 = *a2 + 4 * v45;
            v47 = *a2 + 8 * v45;
            v48 = *(float *)(*a2 + v38 + v34) - *(float *)(*a2 + v39 + v34);
            v49 = fmaxf(
                    sqrtf(
                      (float)((float)(v48 * v48)
                            + (float)((float)(*(float *)(v46 + v38 + v34) - *(float *)(v46 + v39 + v34))
                                    * (float)(*(float *)(v46 + v38 + v34) - *(float *)(v46 + v39 + v34))))
                    + (float)((float)(*(float *)(v47 + v38 + v34) - *(float *)(v47 + v39 + v34))
                            * (float)(*(float *)(v47 + v38 + v34) - *(float *)(v47 + v39 + v34))))
                  * v33,
                    20.0);
            if ( *(float *)(v411 + 16) < v49 )
              v49 = *(float *)(v411 + 16);
            *((float *)v510 + v31 + v36) = v49 * v49;
          }
          ++v36;
          v35 += 16LL;
          v34 += v32;
        }
        while ( v36 < dest );
        v7 = v411;
        v31 += v36;
      }
      ++v30;
    }
    while ( v30 < v396 );
  }
  gettimeofday(&v513, 0LL);
  tv_sec = v513.tv_sec;
  v51 = tv.tv_sec;
  tv_usec = v513.tv_usec;
  v53 = tv.tv_usec;
  v506 = dword_70088;
  if ( (word_70090 & 1) != 0 )
    v54 = (const char *)qword_700A0;
  else
    v54 = (char *)&word_70090 + 1;
  v509 = 0LL;
  v508 = 0LL;
  v507 = 0LL;
  v55 = strlen(v54);
  if ( v55 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v56 = v55;
  if ( v55 >= 0x17 )
  {
    v58 = (v55 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v57 = (char *)operator new(v58);
    v509 = v57;
    v507 = v58 | 1;
    v508 = v56;
    goto LABEL_41;
  }
  v57 = (char *)&v507 + 1;
  LOBYTE(v507) = 2 * v55;
  if ( v55 )
LABEL_41:
    memcpy(v57, v54, v56);
  v57[v56] = 0;
  v59 = v396 * dest;
  if ( (g3::logLevel(&v506) & 1) != 0 )
  {
    BYTE1(v505[2]) = 0;
    WORD1(v505[2]) = 0;
    HIDWORD(v505[2]) = 0;
    LOBYTE(v505[0]) = 30;
    strcpy((char *)v505 + 1, "feasibal_region");
    v60 = g3::logTag(v505);
    if ( ((__int64)v505[0] & 1) == 0 )
    {
      if ( (v507 & 1) == 0 )
        goto LABEL_45;
LABEL_48:
      operator delete(v509);
      if ( (v60 & 1) == 0 )
        goto LABEL_50;
      goto LABEL_49;
    }
    operator delete(v505[2]);
    if ( (v507 & 1) != 0 )
      goto LABEL_48;
  }
  else
  {
    v60 = 0;
    if ( (v507 & 1) != 0 )
      goto LABEL_48;
  }
LABEL_45:
  if ( (v60 & 1) != 0 )
  {
LABEL_49:
    LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
    v61 = (double)(tv_sec - v51) * 1000.0 + (double)(tv_usec - v53) / 1000.0;
    LogCapture::capturef((LogCapture *)&v525, "%s:%3fms\n", "Planar cell fitting time :", v61);
    LogCapture::~LogCapture((LogCapture *)&v525);
  }
LABEL_50:
  v503 = 0LL;
  v502 = 0LL;
  v504 = 0LL;
  Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1>>::resize((__int64)&v502, v398, 2LL);
  v500 = 0LL;
  v499 = 0LL;
  v501 = 0LL;
  if ( (_DWORD)v398 )
  {
    if ( (v398 & 0x80000000) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v62 = (v398 - 1) >> 6;
    v63 = (_QWORD *)operator new(8 * (v62 + 1));
    v501 = v62 + 1;
    if ( (unsigned int)v398 >= 0x41 )
      v64 = (v398 - 1) >> 6;
    else
      v64 = 0LL;
    v65 = v63;
    v499 = v63;
    v500 = v396 * dest;
    v63[v64] = 0LL;
    memset(v63, 0, 8 * (v398 >> 6));
    if ( (((_BYTE)v396 * (_BYTE)dest) & 0x3F) != 0 )
      v65[(unsigned __int64)(v396 * dest) >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -((v396 * dest) & 0x3F));
    v66 = (char *)operator new(4 * v398);
    v496 = v66;
    v498 = &v66[4 * v398];
    memset(v66, 0, 4 * v398);
    v67 = (double *)v502;
    v497 = v498;
    v68 = *(__int64 **)(v411 + 56);
    v69 = 0LL;
    v70 = 0;
    v53 = (unsigned int)(v396 * dest);
    v71 = (char *)v502 + 8 * v503;
    do
    {
      v72 = *v68;
      if ( *(_BYTE *)(*v68 + 64) )
      {
        *(double *)&v6 = *(float *)(v72 + 80);
        v73 = *(float *)(v72 + 84);
        v74 = sqrt(*(double *)&v6 * *(double *)&v6 + v73 * v73);
        v67[v69] = acos(-*(float *)(v72 + 88));
        *(double *)&v71[8 * v69] = atan2(*(double *)&v6 / v74, v73 / v74);
        ++v70;
        *(_QWORD *)((char *)v65 + ((v69 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v69;
        *(_DWORD *)&v66[4 * v69] = *(_DWORD *)(v72 + 56);
      }
      ++v69;
      v68 += 2;
    }
    while ( v53 != v69 );
    v7 = v411;
    v59 = v396 * dest;
    v407 = 1;
  }
  else
  {
    v70 = 0;
    v407 = 0;
    v497 = 0LL;
    v496 = 0LL;
    v498 = 0LL;
  }
  Histogram::initHistogram(*(_QWORD *)(v7 + 1328), (__int64 *)&v502, (__int64 *)&v499);
  v494 = 0LL;
  v493 = 0LL;
  v495 = 0LL;
  if ( (v407 & 1) != 0 )
  {
    v75 = (char *)v499;
    v76 = *(_QWORD *)(v7 + 1168);
    v77 = (_QWORD *)(v7 + 1168);
    if ( (unsigned int)v59 > 1 )
    {
      v79 = 0LL;
      v78 = (unsigned int)v59 & 0xFFFFFFFE;
      do
      {
        v80 = *(_QWORD *)&v75[(v79 >> 3) & 0x1FFFFFFFFFFFFFF8LL];
        v81 = (v80 & (1LL << (v79 & 0x3E))) != 0;
        _ZF = (v80 & (1LL << ((unsigned __int8)v79 + 1))) == 0;
        v82 = (bool *)(v76 + v79);
        v79 += 2LL;
        v83 = !_ZF;
        *v82 = v81;
        v82[1] = v83;
      }
      while ( v78 != v79 );
      if ( v78 == (unsigned int)v59 )
        goto LABEL_76;
    }
    else
    {
      v78 = 0LL;
    }
    do
    {
      *(_BYTE *)(v76 + v78) = (*(_QWORD *)&v75[(v78 >> 3) & 0x1FFFFFFFFFFFFFF8LL] & (1LL << v78)) != 0;
      ++v78;
    }
    while ( (unsigned int)v59 != v78 );
  }
  else
  {
    v77 = (_QWORD *)(v7 + 1168);
  }
LABEL_76:
  v84 = (unsigned int)v396;
  while ( v70 >= 1 )
  {
    Histogram::getPointsFromMostFrequentBin(*(Histogram **)(v7 + 1328), &v525);
    v85 = (int *)v525.n128_u64[0];
    v86 = (__int64)(v525.n128_u64[1] - v525.n128_u64[0]) >> 2;
    if ( v86 >= 3 )
    {
      v88 = *(_QWORD *)(v7 + 56);
      v89 = 2147500000.0;
      do
      {
        v91 = *v85++;
        v90 = v91;
        v92 = *(float *)(*(_QWORD *)(v88 + 16 * v91) + 60LL);
        if ( v92 < v89 )
        {
          v89 = v92;
          LODWORD(v53) = v90;
        }
        --v86;
      }
      while ( v86 );
      v93 = (__int64 *)(v88 + 16LL * (int)v53);
      v94 = *v93;
      v95 = v84;
      *(_QWORD *)v521 = *v93;
      v96 = v93[1];
      *(_QWORD *)&v521[8] = v96;
      if ( v96 )
      {
        v97 = (unsigned __int64 *)(v96 + 8);
        do
          v98 = __ldxr(v97);
        while ( __stxr(v98 + 1, v97) );
      }
      LODWORD(v6) = *(_DWORD *)(v94 + 92);
      v99 = (float *)(v94 + 80);
      memset(*(void **)(v7 + 1160), 0, v59);
      CAPE::RegionGrowing(
        v7,
        dest,
        v396,
        *(_QWORD *)(v7 + 1168),
        *(_QWORD *)(v7 + 1160),
        (_QWORD *)(v7 + 56),
        &v510,
        (int)v53 % dest,
        v6,
        (int)v53 / dest,
        v99);
      if ( v407 )
      {
        v84 = v95;
        v100 = 0LL;
        v101 = 0;
        do
        {
          if ( *(_BYTE *)(*(_QWORD *)(v7 + 1160) + v100) )
          {
            v102 = *(int **)v521;
            v103 = (__int64 *)(*(_QWORD *)(v7 + 56) + 16 * v100);
            v491 = *v103;
            v104 = v103[1];
            v492 = (unsigned __int64 *)v104;
            if ( v104 )
            {
              v105 = (unsigned __int64 *)(v104 + 8);
              do
                v106 = __ldxr(v105);
              while ( __stxr(v106 + 1, v105) );
            }
            *(float *)&v107 = PlaneSeg::expandSegment(v102, &v491);
            v108 = (std::__shared_weak_count *)v492;
            if ( v492 )
            {
              v109 = v492 + 1;
              do
                v110 = __ldaxr(v109);
              while ( __stlxr(v110 - 1, v109) );
              if ( !v110 )
              {
                (*(void (__fastcall **)(std::__shared_weak_count *, long double))(*(_QWORD *)v108 + 16LL))(v108, v107);
                std::__shared_weak_count::__release_weak(v108);
              }
            }
            Histogram::removePoint(*(_QWORD **)(v7 + 1328), v100);
            v59 = v396 * dest;
            ++v101;
            --v70;
            *(_BYTE *)(*v77 + v100) = 0;
          }
          ++v100;
        }
        while ( v100 < v59 );
        if ( v101 >= 2 )
        {
          PlaneSeg::fitPlane(*(PlaneSeg **)v521);
          if ( *(float *)(*(_QWORD *)v521 + 56LL) > 80.0 )
          {
            v112 = v494;
            if ( v494 == v495 )
            {
              std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg> const&>(
                (__int64)&v493,
                v521);
              v116 = (char *)v494;
            }
            else
            {
              *v494 = *(_QWORD *)v521;
              v113 = *(_QWORD *)&v521[8];
              v112[1] = *(_QWORD *)&v521[8];
              if ( v113 )
              {
                v114 = (unsigned __int64 *)(v113 + 8);
                do
                  v115 = __ldxr(v114);
                while ( __stxr(v115 + 1, v114) );
                v112 = v494;
              }
              v116 = (char *)(v112 + 2);
              v494 = v112 + 2;
            }
            if ( v396 >= 1 )
            {
              v117 = *(_DWORD **)(v7 + 96);
              v118 = 0;
              v119 = **(_QWORD **)(v7 + 152);
              v120 = 0LL;
              v121 = (unsigned __int64)(v116 - (_BYTE *)v493) >> 4;
              do
              {
                if ( dest >= 1 )
                {
                  v122 = (unsigned int)dest;
                  v123 = v117;
                  v124 = (_BYTE *)(*(_QWORD *)(v7 + 1160) + v118);
                  do
                  {
                    if ( *v124 )
                      *v123 = v121;
                    ++v124;
                    --v122;
                    ++v123;
                  }
                  while ( v122 );
                }
                ++v120;
                v118 += dest & ~(dest >> 31);
                v117 = (_DWORD *)((char *)v117 + v119);
              }
              while ( v120 != v95 );
            }
          }
          v87 = 0;
          v111 = *(std::__shared_weak_count **)&v521[8];
          if ( !*(_QWORD *)&v521[8] )
            goto LABEL_128;
        }
        else
        {
          v87 = 17;
          v111 = *(std::__shared_weak_count **)&v521[8];
          if ( !*(_QWORD *)&v521[8] )
          {
LABEL_128:
            v85 = (int *)v525.n128_u64[0];
            if ( !v525.n128_u64[0] )
              goto LABEL_81;
            goto LABEL_80;
          }
        }
      }
      else
      {
        v87 = 17;
        v84 = v95;
        v111 = *(std::__shared_weak_count **)&v521[8];
        if ( !*(_QWORD *)&v521[8] )
          goto LABEL_128;
      }
      v125 = (unsigned __int64 *)((char *)v111 + 8);
      do
        v126 = __ldaxr(v125);
      while ( __stlxr(v126 - 1, v125) );
      if ( v126 )
        goto LABEL_128;
      (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v111 + 16LL))(v111);
      std::__shared_weak_count::__release_weak(v111);
      v85 = (int *)v525.n128_u64[0];
      if ( !v525.n128_u64[0] )
        goto LABEL_81;
LABEL_80:
      v525.n128_u64[1] = (unsigned __int64)v85;
      operator delete(v85);
      goto LABEL_81;
    }
    v87 = 18;
    if ( v525.n128_u64[0] )
      goto LABEL_80;
LABEL_81:
    if ( v87 == 18 )
      break;
  }
  LOBYTE(v526) = 0;
  v127 = (char *)v494 - (_BYTE *)v493;
  v128 = (int)(((char *)v494 - (_BYTE *)v493) >> 4);
  v525.n128_u64[0] = v128;
  v525.n128_u64[1] = v128;
  Eigen::Matrix<bool,-1,-1,0,-1,-1>::Matrix<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>,Eigen::Matrix<bool,-1,-1,0,-1,-1>>>(
    (unsigned __int64 *)&ptr,
    &v525);
  v129 = v127 >> 4;
  CAPE::getConnectedComponents(v130, v400, (__int64 *)&ptr);
  v486 = 0LL;
  v485 = 0LL;
  v487 = 0LL;
  v525.n128_u32[0] = 0;
  if ( (int)(v127 >> 4) >= 1 )
  {
LABEL_136:
    std::vector<int>::__push_back_slow_path<int const&>((__int64)&v485, &v525);
    while ( 1 )
    {
      ++v525.n128_u32[0];
      if ( v525.n128_i32[0] >= (int)v129 )
        break;
      v131 = v486;
      if ( v486 == v487 )
        goto LABEL_136;
      *v486 = v525.n128_u32[0];
      v486 = v131 + 1;
    }
  }
  v132 = v489;
  if ( v489 >= 1 )
  {
    v133 = 0LL;
    v134 = 1;
    do
    {
      v135 = v490;
      v136 = v133++;
      if ( v490 > v133 )
      {
        v137 = 0;
        v138 = v134;
        v139 = v133;
        v140 = *((_DWORD *)v485 + v136);
        while ( 1 )
        {
          v141 = v136 + v132 * v139;
          if ( *((_BYTE *)ptr + v141) )
          {
            v142 = *((_QWORD *)v493 + 2 * v140);
            v143 = (float *)*((_QWORD *)v493 + 2 * v139);
            v144 = *(float *)(v142 + 84);
            v145 = *(float *)(v142 + 88);
            if ( (float)((float)((float)(*(float *)(v142 + 80) * v143[20]) + (float)(v144 * v143[21]))
                       + (float)(v145 * v143[22])) <= *(float *)(v411 + 20)
              || (v146 = (float)(*(float *)(v142 + 92)
                               + (float)((float)((float)(*(float *)(*((_QWORD *)v493 + 2 * v136) + 80LL) * v143[17])
                                               + (float)(v144 * v143[18]))
                                       + (float)(v145 * v143[19]))),
                  v146 * v146 >= *(float *)(v411 + 16)) )
            {
              *((_BYTE *)ptr + v141) = 0;
            }
            else
            {
              v483 = *((_QWORD *)v493 + 2 * v139);
              v147 = *((_QWORD *)v493 + 2 * v139 + 1);
              v484 = (unsigned __int64 *)v147;
              if ( v147 )
              {
                v148 = (unsigned __int64 *)(v147 + 8);
                do
                  v149 = __ldxr(v148);
                while ( __stxr(v149 + 1, v148) );
              }
              *(float *)&v150 = PlaneSeg::expandSegment((int *)v142, &v483);
              v151 = (std::__shared_weak_count *)v484;
              if ( v484 )
              {
                v152 = v484 + 1;
                do
                  v153 = __ldaxr(v152);
                while ( __stlxr(v153 - 1, v152) );
                if ( !v153 )
                {
                  (*(void (__fastcall **)(std::__shared_weak_count *, long double))(*(_QWORD *)v151 + 16LL))(v151, v150);
                  std::__shared_weak_count::__release_weak(v151);
                }
              }
              v137 = 1;
              *((_DWORD *)v485 + v139) = v140;
              v135 = v490;
            }
          }
          if ( v135 <= ++v138 )
            break;
          v132 = v489;
          v139 = v138;
        }
        if ( (v137 & 1) != 0 )
          PlaneSeg::fitPlane(*((PlaneSeg **)v493 + 2 * v140));
      }
      v132 = v489;
      ++v134;
    }
    while ( v489 > v133 );
  }
  if ( (int)v129 > 0 )
  {
    v154 = v411;
    v155 = 0LL;
    v399 = (void ***)(a4 + 8);
    while ( 1 )
    {
      v156 = v155;
      v157 = *((unsigned int *)v485 + v155);
      v158 = *((_DWORD *)v485 + v155);
      if ( v155 != v157 )
        goto LABEL_172;
      while ( v158 == (_DWORD)v157 )
      {
        ++v156;
        v159 = *(void ***)a4;
        v160 = *(_QWORD *)(a4 + 8);
        *(_DWORD *)v521 = -1056833530;
        *(_QWORD *)&v521[8] = &v482;
        *(_QWORD *)&v521[16] = 0x100000001LL;
        v482 = (double)(unsigned __int64)(1 - 0x30C30C30C30C30C3LL * ((v160 - (__int64)v159) >> 3));
        cv::operator==(&v525, v400, (double)(int)v156);
        v481 = 0LL;
        v479 = -1056571392;
        v480 = &v525;
        cv::Mat::setTo(v402, v521, &v479);
        cv::MatExpr::~MatExpr((cv::MatExpr *)&v525, v161);
        if ( v156 >= v128 )
          goto LABEL_169;
LABEL_164:
        v158 = *((_DWORD *)v485 + v156);
        LODWORD(v157) = *((_DWORD *)v485 + v155);
      }
      if ( ++v156 < v128 )
        goto LABEL_164;
LABEL_169:
      v162 = *(_QWORD *)(a4 + 8);
      v163 = *((_QWORD *)v493 + 2 * v155);
      if ( v162 == *(_QWORD *)(a4 + 16) )
      {
        std::vector<PlaneSeg>::__push_back_slow_path<PlaneSeg const&>((void ***)a4, *((_QWORD *)v493 + 2 * v155));
      }
      else
      {
        v164 = *(_OWORD *)(v163 + 16);
        *(_OWORD *)v162 = *(_OWORD *)v163;
        *(_OWORD *)(v162 + 16) = v164;
        v165 = *(_OWORD *)(v163 + 80);
        v166 = *(_OWORD *)(v163 + 32);
        v167 = *(_OWORD *)(v163 + 48);
        *(_OWORD *)(v162 + 64) = *(_OWORD *)(v163 + 64);
        *(_OWORD *)(v162 + 80) = v165;
        *(_OWORD *)(v162 + 32) = v166;
        *(_OWORD *)(v162 + 48) = v167;
        Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v162 + 96), (__int64 *)(v163 + 96));
        Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v162 + 120), (__int64 *)(v163 + 120));
        Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v162 + 144), (__int64 *)(v163 + 144));
        v154 = v411;
        *v399 += 21;
      }
LABEL_172:
      if ( ++v155 >= v128 )
      {
        v168 = (__int64 *)a4;
        goto LABEL_175;
      }
    }
  }
  v168 = (__int64 *)a4;
  v154 = v411;
  v399 = (void ***)(a4 + 8);
LABEL_175:
  *v395 = 1022611261 * ((unsigned __int64)(v168[1] - *v168) >> 3);
  if ( v402 != (cv::Mat *)a5 )
  {
    v169 = *(_QWORD *)(v154 + 232);
    if ( v169 )
    {
      v170 = (unsigned int *)(v169 + 20);
      do
        v171 = __ldaxr(v170);
      while ( __stlxr(v171 + 1, v170) );
    }
    v172 = *(_QWORD *)(a5 + 56);
    if ( v172 )
    {
      v173 = (unsigned int *)(v172 + 20);
      do
      {
        v174 = __ldaxr(v173);
        v175 = v174 - 1;
      }
      while ( __stlxr(v175, v173) );
      if ( !v175 )
        cv::Mat::deallocate((cv::Mat *)a5);
    }
    v176 = *(_DWORD *)(a5 + 4);
    *(_QWORD *)(a5 + 56) = 0LL;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    if ( v176 <= 0 )
    {
      *(_DWORD *)a5 = *(_DWORD *)v402;
    }
    else
    {
      v177 = *(_QWORD *)(a5 + 64);
      v178 = 0LL;
      do
      {
        *(_DWORD *)(v177 + 4 * v178) = 0;
        v179 = *(int *)(a5 + 4);
        ++v178;
      }
      while ( v178 < v179 );
      *(_DWORD *)a5 = *(_DWORD *)v402;
      if ( (int)v179 > 2 )
        goto LABEL_192;
    }
    v180 = *(_DWORD *)(v154 + 180);
    if ( v180 <= 2 )
    {
      *(_DWORD *)(a5 + 4) = v180;
      v181 = *(_QWORD **)(a5 + 72);
      *(_QWORD *)(a5 + 8) = *(_QWORD *)(v154 + 184);
      v182 = *(_QWORD **)(v154 + 248);
      *v181 = *v182;
      v181[1] = v182[1];
LABEL_193:
      *(_OWORD *)(a5 + 16) = *(_OWORD *)(v154 + 192);
      *(_OWORD *)(a5 + 32) = *(_OWORD *)(v154 + 208);
      *(_OWORD *)(a5 + 48) = *(_OWORD *)(v154 + 224);
      goto LABEL_194;
    }
LABEL_192:
    cv::Mat::copySize((cv::Mat *)a5, v402);
    goto LABEL_193;
  }
LABEL_194:
  if ( (word_70090 & 1) != 0 )
    v183 = (const char *)qword_700A0;
  else
    v183 = (char *)&word_70090 + 1;
  v475 = dword_70088;
  v478 = 0LL;
  v477 = 0LL;
  v476 = 0LL;
  v184 = strlen(v183);
  if ( v184 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v185 = v184;
  if ( v184 >= 0x17 )
  {
    v187 = (v184 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v186 = (char *)operator new(v187);
    v478 = v186;
    v476 = v187 | 1;
    v477 = v185;
    goto LABEL_202;
  }
  v186 = (char *)&v476 + 1;
  LOBYTE(v476) = 2 * v184;
  if ( v184 )
LABEL_202:
    memcpy(v186, v183, v185);
  v186[v185] = 0;
  if ( (g3::logLevel(&v475) & 1) != 0 )
  {
    BYTE1(v474[2]) = 0;
    WORD1(v474[2]) = 0;
    HIDWORD(v474[2]) = 0;
    LOBYTE(v474[0]) = 30;
    strcpy((char *)v474 + 1, "feasibal_region");
    v188 = g3::logTag(v474);
    if ( ((__int64)v474[0] & 1) == 0 )
    {
      if ( (v476 & 1) == 0 )
        goto LABEL_206;
LABEL_209:
      operator delete(v478);
      if ( (v188 & 1) != 0 )
        goto LABEL_207;
LABEL_210:
      v189 = (__int64 *)(v411 + 1552);
      v190 = (__int64 *)(v411 + 1560);
      goto LABEL_211;
    }
    operator delete(v474[2]);
    if ( (v476 & 1) != 0 )
      goto LABEL_209;
  }
  else
  {
    v188 = 0;
    if ( (v476 & 1) != 0 )
      goto LABEL_209;
  }
LABEL_206:
  if ( (v188 & 1) == 0 )
    goto LABEL_210;
LABEL_207:
  LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
  LogCapture::capturef(
    (LogCapture *)&v525,
    "### plane_base_.size:%d, d size:%d",
    -1171354717 * (unsigned int)((*(_QWORD *)(v411 + 1560) - *(_QWORD *)(v411 + 1552)) >> 4),
    *v395);
  v189 = (__int64 *)(v411 + 1552);
  v190 = (__int64 *)(v411 + 1560);
  LogCapture::~LogCapture((LogCapture *)&v525);
LABEL_211:
  v391 = v189;
  v392 = v190;
  if ( *v190 - *v189 == 176 && (int)*v395 >= 1 )
  {
    if ( (word_70090 & 1) != 0 )
      v191 = (const char *)qword_700A0;
    else
      v191 = (char *)&word_70090 + 1;
    v470 = dword_70088;
    v473 = 0LL;
    v472 = 0LL;
    v471 = 0LL;
    v192 = strlen(v191);
    if ( v192 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v193 = v192;
    if ( v192 >= 0x17 )
    {
      v203 = (v192 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v194 = (char *)operator new(v203);
      v473 = v194;
      v471 = v203 | 1;
      v472 = v193;
    }
    else
    {
      v194 = (char *)&v471 + 1;
      LOBYTE(v471) = 2 * v192;
      if ( !v192 )
      {
LABEL_238:
        v194[v193] = 0;
        v204 = g3::logLevel(&v470);
        if ( (v204 & 1) != 0 )
        {
          BYTE1(v469[2]) = 0;
          WORD1(v469[2]) = 0;
          HIDWORD(v469[2]) = 0;
          LOBYTE(v469[0]) = 30;
          strcpy((char *)v469 + 1, "feasibal_region");
          v204 = g3::logTag(v469);
          v205 = v204;
          if ( ((__int64)v469[0] & 1) == 0 )
          {
            if ( (v471 & 1) == 0 )
              goto LABEL_241;
LABEL_302:
            operator delete(v473);
            if ( (v205 & 1) == 0 )
              goto LABEL_304;
            goto LABEL_303;
          }
          operator delete(v469[2]);
          if ( (v471 & 1) != 0 )
            goto LABEL_302;
        }
        else
        {
          v205 = 0;
          if ( (v471 & 1) != 0 )
            goto LABEL_302;
        }
LABEL_241:
        if ( (v205 & 1) == 0 )
        {
LABEL_304:
          BestPlane = CAPE::getBestPlane(
                        (CAPE *)v204,
                        (const cv::Mat *)a5,
                        (const cv::Mat *)(*(_QWORD *)(v411 + 1552) + 40LL),
                        (const int *)v395);
          if ( (int)BestPlane >= 2 )
            CAPE::swapPlanes(BestPlane, v168, a5, 0LL, (int)BestPlane - 1);
          v252 = (float *)*v168;
          v253 = *(float *)(*v168 + 80);
          v254 = v252[21];
          v255 = v252[22];
          v256 = v252[23];
          v527.n64_u64[0] = __PAIR64__(LODWORD(v254), LODWORD(v253));
          v528 = __PAIR64__(LODWORD(v256), LODWORD(v255));
          v257 = CAPE::judgPlaneValid(
                   *(float *)(v411 + 1308),
                   0.087266,
                   5.0,
                   v411,
                   (float *)&v527,
                   (float *)(v411 + 1536));
          if ( (v257 & 1) != 0 )
          {
            if ( (word_70090 & 1) != 0 )
              v258 = (const char *)qword_700A0;
            else
              v258 = (char *)&word_70090 + 1;
            v450 = dword_70088;
            v453 = 0LL;
            v452 = 0LL;
            v451 = 0LL;
            v259 = strlen(v258);
            if ( v259 >= 0xFFFFFFFFFFFFFFF0LL )
              std::__basic_string_common<true>::__throw_length_error();
            v260 = v259;
            if ( v259 >= 0x17 )
            {
              v268 = (v259 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              v261 = (char *)operator new(v268);
              v453 = v261;
              v451 = v268 | 1;
              v452 = v260;
            }
            else
            {
              v261 = (char *)&v451 + 1;
              LOBYTE(v451) = 2 * v259;
              if ( !v259 )
              {
LABEL_327:
                v261[v260] = 0;
                v269 = a5;
                if ( (g3::logLevel(&v450) & 1) != 0 )
                {
                  BYTE1(v449[2]) = 0;
                  WORD1(v449[2]) = 0;
                  HIDWORD(v449[2]) = 0;
                  LOBYTE(v449[0]) = 30;
                  strcpy((char *)v449 + 1, "feasibal_region");
                  v270 = g3::logTag(v449);
                  if ( ((__int64)v449[0] & 1) == 0 )
                  {
                    if ( (v451 & 1) == 0 )
                      goto LABEL_330;
LABEL_340:
                    operator delete(v453);
                    if ( (v270 & 1) == 0 )
                    {
LABEL_367:
                      v264 = 1;
                      goto LABEL_368;
                    }
LABEL_341:
                    LogCapture::LogCapture(
                      (LogCapture *)&v525,
                      "feasibal_region",
                      (const LEVELS *)&dword_70088,
                      "",
                      6,
                      0LL);
                    LogCapture::capturef((LogCapture *)&v525, "## first plane judge valid!");
                    LogCapture::~LogCapture((LogCapture *)&v525);
                    goto LABEL_367;
                  }
                  operator delete(v449[2]);
                  if ( (v451 & 1) != 0 )
                    goto LABEL_340;
                }
                else
                {
                  v270 = 0;
                  if ( (v451 & 1) != 0 )
                    goto LABEL_340;
                }
LABEL_330:
                if ( (v270 & 1) == 0 )
                  goto LABEL_367;
                goto LABEL_341;
              }
            }
            memcpy(v261, v258, v260);
            goto LABEL_327;
          }
          *(_DWORD *)v521 = 0;
          valid = CAPE::judgeValidBasedImage(
                    (CAPE *)v257,
                    (const cv::Mat *)(*(_QWORD *)(v411 + 1552) + 40LL),
                    (const cv::Mat *)a5,
                    (unsigned int *)(*(_QWORD *)(v411 + 1552) + 136LL),
                    (unsigned int *)v521);
          if ( (word_70090 & 1) != 0 )
            v263 = (const char *)qword_700A0;
          else
            v263 = (char *)&word_70090 + 1;
          v264 = valid;
          v465 = dword_70088;
          v468 = 0LL;
          v467 = 0LL;
          v466 = 0LL;
          v265 = strlen(v263);
          if ( v265 >= 0xFFFFFFFFFFFFFFF0LL )
            std::__basic_string_common<true>::__throw_length_error();
          v266 = v265;
          if ( v265 >= 0x17 )
          {
            v271 = (v265 + 16) & 0xFFFFFFFFFFFFFFF0LL;
            v267 = (char *)operator new(v271);
            v468 = v267;
            v466 = v271 | 1;
            v467 = v266;
          }
          else
          {
            v267 = (char *)&v466 + 1;
            LOBYTE(v466) = 2 * v265;
            if ( !v265 )
            {
LABEL_334:
              v267[v266] = 0;
              if ( (g3::logLevel(&v465) & 1) != 0 )
              {
                BYTE1(v464[2]) = 0;
                WORD1(v464[2]) = 0;
                HIDWORD(v464[2]) = 0;
                LOBYTE(v464[0]) = 30;
                strcpy((char *)v464 + 1, "feasibal_region");
                v272 = g3::logTag(v464);
                if ( ((__int64)v464[0] & 1) == 0 )
                {
                  if ( (v466 & 1) == 0 )
                    goto LABEL_337;
LABEL_343:
                  operator delete(v468);
                  if ( (v272 & 1) == 0 )
                    goto LABEL_345;
                  goto LABEL_344;
                }
                operator delete(v464[2]);
                if ( (v466 & 1) != 0 )
                  goto LABEL_343;
              }
              else
              {
                v272 = 0;
                if ( (v466 & 1) != 0 )
                  goto LABEL_343;
              }
LABEL_337:
              if ( (v272 & 1) == 0 )
              {
LABEL_345:
                if ( (word_70090 & 1) != 0 )
                  v273 = (const char *)qword_700A0;
                else
                  v273 = (char *)&word_70090 + 1;
                v460 = dword_70088;
                v463 = 0LL;
                v462 = 0LL;
                v461 = 0LL;
                v274 = strlen(v273);
                if ( v274 >= 0xFFFFFFFFFFFFFFF0LL )
                  std::__basic_string_common<true>::__throw_length_error();
                v275 = v274;
                if ( v274 >= 0x17 )
                {
                  v277 = (v274 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                  v276 = (char *)operator new(v277);
                  v463 = v276;
                  v461 = v277 | 1;
                  v462 = v275;
                }
                else
                {
                  v276 = (char *)&v461 + 1;
                  LOBYTE(v461) = 2 * v274;
                  if ( !v274 )
                  {
LABEL_354:
                    v276[v275] = 0;
                    v269 = a5;
                    if ( (g3::logLevel(&v460) & 1) != 0 )
                    {
                      BYTE1(v459[2]) = 0;
                      WORD1(v459[2]) = 0;
                      HIDWORD(v459[2]) = 0;
                      LOBYTE(v459[0]) = 30;
                      strcpy((char *)v459 + 1, "feasibal_region");
                      v278 = g3::logTag(v459);
                      if ( ((__int64)v459[0] & 1) == 0 )
                      {
                        if ( (v461 & 1) == 0 )
                          goto LABEL_357;
LABEL_370:
                        operator delete(v463);
                        if ( (v278 & 1) != 0 )
                        {
LABEL_358:
                          LogCapture::LogCapture(
                            (LogCapture *)&v525,
                            "feasibal_region",
                            (const LEVELS *)&dword_70088,
                            "",
                            6,
                            0LL);
                          LogCapture::capturef(
                            (LogCapture *)&v525,
                            "## plane_n:%f,%f,%f; %f,%f,%f",
                            v253,
                            v254,
                            v255,
                            *(float *)(v411 + 1536),
                            *(float *)(v411 + 1540),
                            *(float *)(v411 + 1544));
                          LogCapture::~LogCapture((LogCapture *)&v525);
                          if ( !v264 )
                          {
LABEL_368:
                            v403 = -1.0;
                            v285 = v264 != 0;
                            LOBYTE(v286) = 1;
                            goto LABEL_397;
                          }
LABEL_359:
                          if ( v264 != 1 )
                            goto LABEL_367;
                          v279 = CAPE::judgPlaneValid(
                                   *(float *)(*(_QWORD *)(v411 + 1552) + 164LL),
                                   0.12566,
                                   25.0,
                                   v411,
                                   (float *)&v527,
                                   (float *)(*(_QWORD *)(v411 + 1552) + 140LL));
                          if ( (word_70090 & 1) != 0 )
                            v280 = (const char *)qword_700A0;
                          else
                            v280 = (char *)&word_70090 + 1;
                          v281 = v279;
                          v455 = dword_70088;
                          v458 = 0LL;
                          v457 = 0LL;
                          v456 = 0LL;
                          v282 = strlen(v280);
                          if ( v282 >= 0xFFFFFFFFFFFFFFF0LL )
                            std::__basic_string_common<true>::__throw_length_error();
                          v283 = v282;
                          if ( v282 >= 0x17 )
                          {
                            v373 = (v282 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                            v284 = (char *)operator new(v373);
                            v458 = v284;
                            v456 = v373 | 1;
                            v457 = v283;
                          }
                          else
                          {
                            v284 = (char *)&v456 + 1;
                            LOBYTE(v456) = 2 * v282;
                            if ( !v282 )
                              goto LABEL_542;
                          }
                          memcpy(v284, v280, v283);
LABEL_542:
                          v284[v283] = 0;
                          v269 = a5;
                          if ( (g3::logLevel(&v455) & 1) != 0 )
                          {
                            BYTE1(v454[2]) = 0;
                            WORD1(v454[2]) = 0;
                            HIDWORD(v454[2]) = 0;
                            LOBYTE(v454[0]) = 30;
                            strcpy((char *)v454 + 1, "feasibal_region");
                            v374 = g3::logTag(v454);
                            if ( ((__int64)v454[0] & 1) != 0 )
                              operator delete(v454[2]);
                          }
                          else
                          {
                            v374 = 0;
                          }
                          v264 = v281 & 1;
                          if ( (v456 & 1) != 0 )
                            operator delete(v458);
                          if ( (v374 & 1) != 0 )
                          {
                            LogCapture::LogCapture(
                              (LogCapture *)&v525,
                              "feasibal_region",
                              (const LEVELS *)&dword_70088,
                              "",
                              6,
                              0LL);
                            LogCapture::capturef((LogCapture *)&v525, "## image invalid and next plv: %d!", v264);
                            LogCapture::~LogCapture((LogCapture *)&v525);
                          }
                          goto LABEL_368;
                        }
LABEL_371:
                        if ( !v264 )
                          goto LABEL_368;
                        goto LABEL_359;
                      }
                      operator delete(v459[2]);
                      if ( (v461 & 1) != 0 )
                        goto LABEL_370;
                    }
                    else
                    {
                      v278 = 0;
                      if ( (v461 & 1) != 0 )
                        goto LABEL_370;
                    }
LABEL_357:
                    if ( (v278 & 1) != 0 )
                      goto LABEL_358;
                    goto LABEL_371;
                  }
                }
                memcpy(v276, v273, v275);
                goto LABEL_354;
              }
LABEL_344:
              LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
              LogCapture::capturef(
                (LogCapture *)&v525,
                "## plane_h:%f,dz:%f,image:%d",
                v256,
                *(float *)(v411 + 1308),
                v264);
              LogCapture::~LogCapture((LogCapture *)&v525);
              goto LABEL_345;
            }
          }
          memcpy(v267, v263, v266);
          goto LABEL_334;
        }
LABEL_303:
        LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
        LogCapture::capturef((LogCapture *)&v525, "### track");
        LogCapture::~LogCapture((LogCapture *)&v525);
        goto LABEL_304;
      }
    }
    memcpy(v194, v191, v193);
    goto LABEL_238;
  }
  if ( (word_70090 & 1) != 0 )
    v195 = (const char *)qword_700A0;
  else
    v195 = (char *)&word_70090 + 1;
  v445 = dword_70088;
  v448 = 0LL;
  v447 = 0LL;
  v446 = 0LL;
  v196 = strlen(v195);
  if ( v196 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v197 = v196;
  if ( v196 >= 0x17 )
  {
    v199 = (v196 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v198 = (char *)operator new(v199);
    v448 = v198;
    v446 = v199 | 1;
    v447 = v197;
    goto LABEL_230;
  }
  v198 = (char *)&v446 + 1;
  LOBYTE(v446) = 2 * v196;
  if ( v196 )
LABEL_230:
    memcpy(v198, v195, v197);
  v198[v197] = 0;
  v200 = g3::logLevel(&v445);
  v201 = (float *)v411;
  if ( (v200 & 1) == 0 )
  {
    v202 = 0;
    if ( (v446 & 1) != 0 )
      goto LABEL_244;
    goto LABEL_234;
  }
  BYTE1(v444[2]) = 0;
  WORD1(v444[2]) = 0;
  HIDWORD(v444[2]) = 0;
  LOBYTE(v444[0]) = 30;
  strcpy((char *)v444 + 1, "feasibal_region");
  v200 = g3::logTag(v444);
  v202 = v200;
  if ( ((__int64)v444[0] & 1) != 0 )
  {
    operator delete(v444[2]);
    if ( (v446 & 1) != 0 )
      goto LABEL_244;
LABEL_234:
    if ( (v202 & 1) == 0 )
      goto LABEL_246;
    goto LABEL_245;
  }
  if ( (v446 & 1) == 0 )
    goto LABEL_234;
LABEL_244:
  operator delete(v448);
  if ( (v202 & 1) != 0 )
  {
LABEL_245:
    LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v525, "### reinit");
    LogCapture::~LogCapture((LogCapture *)&v525);
  }
LABEL_246:
  CAPE::imageScore((CAPE *)v200, (const cv::Mat *)a5, (const int *)v395, (float32x4_t **)v521);
  v207 = (void **)*v168;
  i = (void **)v168[1];
  v403 = -1.0;
  if ( i == (void **)*v168 )
    goto LABEL_392;
  v401 = -1;
  v405 = 3.4028e38;
  v208 = 0LL;
  v209 = 0LL;
  do
  {
    v211 = *(float *)&v207[v208 + 10];
    v210 = *((float *)&v207[v208 + 10] + 1);
    v212 = v201[384];
    v213 = v201[385];
    v214 = *(float *)&v207[v208 + 11];
    v215 = *((float *)&v207[v208 + 11] + 1);
    v216 = v201[386];
    v217 = v211;
    v218 = v210;
    v219 = v214;
    v220 = sqrtf((float)((float)(v212 * v212) + (float)(v213 * v213)) + (float)(v216 * v216));
    v221 = sqrtf((float)((float)(v217 * v217) + (float)(v218 * v218)) + (float)(v219 * v219));
    v222 = (float)((float)(v214 / v221) * (float)(v216 / v220))
         + (float)((float)((float)(v211 / v221) * (float)(v212 / v220))
                 + (float)((float)(v210 / v221) * (float)(v213 / v220)));
    v223 = v214;
    v224 = 0.0;
    v408 = v211;
    v410 = v210;
    if ( fabsf(fabsf(v222) + -1.0) >= 0.0001 )
    {
      v225 = acosf(v222);
      if ( v225 > 1.57079633 )
      {
        v226 = 3.14159265 - v225;
        v225 = v226;
      }
      v224 = fabsf(v225);
    }
    v227 = v201[327];
    v228 = *(float *)(*(_QWORD *)v521 + 4 * v209 + 4);
    if ( (word_70090 & 1) != 0 )
      v229 = (const char *)qword_700A0;
    else
      v229 = (char *)&word_70090 + 1;
    v440 = dword_70088;
    v441 = 0LL;
    v442 = 0LL;
    v443 = 0LL;
    v230 = strlen(v229);
    if ( v230 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v231 = v230;
    if ( v230 >= 0x17 )
    {
      v233 = v215;
      v234 = (v230 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v232 = (char *)operator new(v234);
      v443 = v232;
      v441 = v234 | 1;
      v442 = v231;
      v215 = v233;
LABEL_262:
      memcpy(v232, v229, v231);
      goto LABEL_263;
    }
    v232 = (char *)&v441 + 1;
    LOBYTE(v441) = 2 * v230;
    if ( v230 )
      goto LABEL_262;
LABEL_263:
    v232[v231] = 0;
    if ( (g3::logLevel(&v440) & 1) != 0 )
    {
      LOBYTE(v439[0]) = 30;
      v439[2] = 0LL;
      strcpy((char *)v439 + 1, "feasibal_region");
      v235 = g3::logTag(v439);
      if ( ((__int64)v439[0] & 1) != 0 )
        operator delete(v439[2]);
    }
    else
    {
      v235 = 0;
    }
    v236 = vabds_f32(v227, v215);
    v237 = v224;
    if ( (v441 & 1) != 0 )
      operator delete(v443);
    v238 = v228 * 0.5 + (v237 / 0.035 + v236 / 15.0) * 0.5;
    if ( (v235 & 1) != 0 )
    {
      LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
      LogCapture::capturef(
        (LogCapture *)&v525,
        "### plane_h %zu:%f, dz:%f, angle:%f, score:%f ",
        v209,
        *(float *)(*(_QWORD *)a4 + v208 * 8 + 92),
        *(float *)(v411 + 1308),
        v237,
        v238);
      LogCapture::~LogCapture((LogCapture *)&v525);
    }
    if ( (word_70090 & 1) != 0 )
      v239 = (const char *)qword_700A0;
    else
      v239 = (char *)&word_70090 + 1;
    v435 = dword_70088;
    v436 = 0LL;
    v437 = 0LL;
    v438 = 0LL;
    v240 = strlen(v239);
    if ( v240 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v241 = v240;
    if ( v240 >= 0x17 )
    {
      v243 = v215;
      v244 = (v240 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v242 = (char *)operator new(v244);
      v437 = v241;
      v438 = v242;
      v436 = v244 | 1;
      v215 = v243;
LABEL_279:
      memcpy(v242, v239, v241);
      goto LABEL_280;
    }
    v242 = (char *)&v436 + 1;
    LOBYTE(v436) = 2 * v240;
    if ( v240 )
      goto LABEL_279;
LABEL_280:
    v242[v241] = 0;
    v201 = (float *)v411;
    if ( (g3::logLevel(&v435) & 1) != 0 )
    {
      LOBYTE(v434[0]) = 30;
      v434[2] = 0LL;
      strcpy((char *)v434 + 1, "feasibal_region");
      v245 = g3::logTag(v434);
      if ( ((__int64)v434[0] & 1) != 0 )
      {
        operator delete(v434[2]);
        if ( (v436 & 1) == 0 )
          goto LABEL_283;
      }
      else if ( (v436 & 1) == 0 )
      {
        goto LABEL_283;
      }
    }
    else
    {
      v245 = 0;
      if ( (v436 & 1) == 0 )
      {
LABEL_283:
        if ( (v245 & 1) == 0 )
          goto LABEL_288;
LABEL_287:
        LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
        LogCapture::capturef(
          (LogCapture *)&v525,
          "### plane_n %zu:%f,%f,%f; %f,%f,%f",
          v209,
          v217,
          v218,
          v219,
          *(float *)(v411 + 1536),
          *(float *)(v411 + 1540),
          *(float *)(v411 + 1544));
        LogCapture::~LogCapture((LogCapture *)&v525);
        goto LABEL_288;
      }
    }
    operator delete(v438);
    if ( (v245 & 1) != 0 )
      goto LABEL_287;
LABEL_288:
    v246 = v209 + 1;
    if ( v237 < 0.209433333 && v236 < 30.0 && v405 > v238 )
    {
      v403 = v228 * 0.5 + (v237 / 0.035 + v236 / 15.0) * 0.5;
      v401 = v209;
      v527.n64_u64[0] = __PAIR64__(LODWORD(v410), LODWORD(v408));
      v405 = v403;
      v528 = __PAIR64__(LODWORD(v215), LODWORD(v223));
    }
    v207 = *(void ***)a4;
    i = *(void ***)(a4 + 8);
    v208 += 21LL;
    ++v209;
  }
  while ( v246 < 0xCF3CF3CF3CF3CF3DLL * (((__int64)i - *(_QWORD *)a4) >> 3) );
  if ( v401 < 0 )
    goto LABEL_392;
  if ( (word_70090 & 1) != 0 )
    v247 = (const char *)qword_700A0;
  else
    v247 = (char *)&word_70090 + 1;
  v430 = dword_70088;
  v432 = 0LL;
  v433 = 0LL;
  v431 = 0LL;
  v248 = strlen(v247);
  if ( v248 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v249 = v248;
  if ( v248 >= 0x17 )
  {
    v287 = (v248 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v250 = (char *)operator new(v287);
    v432 = v249;
    v433 = v250;
    v431 = v287 | 1;
    goto LABEL_374;
  }
  v250 = (char *)&v431 + 1;
  LOBYTE(v431) = 2 * v248;
  if ( v248 )
LABEL_374:
    memcpy(v250, v247, v249);
  v250[v249] = 0;
  if ( (g3::logLevel(&v430) & 1) == 0 )
  {
    v288 = 0;
    if ( (v431 & 1) != 0 )
      goto LABEL_381;
    goto LABEL_378;
  }
  BYTE1(v429[2]) = 0;
  WORD1(v429[2]) = 0;
  HIDWORD(v429[2]) = 0;
  LOBYTE(v429[0]) = 30;
  strcpy((char *)v429 + 1, "feasibal_region");
  v288 = g3::logTag(v429);
  if ( ((__int64)v429[0] & 1) != 0 )
  {
    operator delete(v429[2]);
    if ( (v431 & 1) != 0 )
      goto LABEL_381;
LABEL_378:
    if ( (v288 & 1) != 0 )
      goto LABEL_382;
    goto LABEL_383;
  }
  if ( (v431 & 1) == 0 )
    goto LABEL_378;
LABEL_381:
  operator delete(v433);
  if ( (v288 & 1) != 0 )
  {
LABEL_382:
    LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v525, "### scoreMin:%f,idx:%d", v405, (unsigned int)v401);
    LogCapture::~LogCapture((LogCapture *)&v525);
  }
LABEL_383:
  if ( (CAPE::judgPlaneValid(*(float *)(v411 + 1308), 0.20944, 10.0, v411, (float *)&v527, (float *)(v411 + 1536)) & 1) == 0 )
  {
    v207 = *(void ***)a4;
LABEL_392:
    for ( i = *(void ***)(a4 + 8); v207 != i; PlaneSeg::~PlaneSeg(i) )
      i -= 21;
    v286 = 0;
    *v399 = v207;
    v293 = *(void **)v521;
    if ( !*(_QWORD *)v521 )
      goto LABEL_396;
LABEL_395:
    *(_QWORD *)&v521[8] = v293;
    operator delete(v293);
    goto LABEL_396;
  }
  if ( (word_70090 & 1) != 0 )
    v289 = (const char *)qword_700A0;
  else
    v289 = (char *)&word_70090 + 1;
  v425 = dword_70088;
  v427 = 0LL;
  v428 = 0LL;
  v426 = 0LL;
  v290 = strlen(v289);
  if ( v290 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v291 = v290;
  if ( v290 >= 0x17 )
  {
    v375 = (v290 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v292 = (char *)operator new(v375);
    v427 = v291;
    v428 = v292;
    v426 = v375 | 1;
    goto LABEL_553;
  }
  v292 = (char *)&v426 + 1;
  LOBYTE(v426) = 2 * v290;
  if ( v290 )
LABEL_553:
    memcpy(v292, v289, v291);
  v292[v291] = 0;
  v376 = g3::logLevel(&v425);
  if ( (v376 & 1) == 0 )
  {
    v377 = a5;
    v378 = 0;
    if ( (v426 & 1) != 0 )
      goto LABEL_561;
    goto LABEL_557;
  }
  v422 = 12;
  *(_QWORD *)&v423[7] = 0LL;
  v424 = 0LL;
  strcpy(v423, "region");
  v376 = g3::logTag(&v422);
  v377 = a5;
  v378 = v376;
  if ( (v422 & 1) != 0 )
  {
    operator delete(v424);
    if ( (v426 & 1) != 0 )
      goto LABEL_561;
LABEL_557:
    if ( (v378 & 1) == 0 )
      goto LABEL_562;
LABEL_558:
    LogCapture::LogCapture((LogCapture *)&v525, "region", (const LEVELS *)&dword_70088, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v525, "### best_plane(0-n):%d", (unsigned int)v401);
    LogCapture::~LogCapture((LogCapture *)&v525);
    if ( v401 >= 1 )
      goto LABEL_563;
    goto LABEL_564;
  }
  if ( (v426 & 1) == 0 )
    goto LABEL_557;
LABEL_561:
  operator delete(v428);
  if ( (v378 & 1) != 0 )
    goto LABEL_558;
LABEL_562:
  if ( v401 >= 1 )
LABEL_563:
    CAPE::swapPlanes(v376, (__int64 *)a4, v377, 0LL, v401);
LABEL_564:
  v286 = 1;
  v293 = *(void **)v521;
  if ( *(_QWORD *)v521 )
    goto LABEL_395;
LABEL_396:
  v269 = a5;
  v285 = v286;
LABEL_397:
  cv::operator==(&v525, v269, 1.0);
  *(_DWORD *)v521 = 1124007936;
  memset(&v521[4], 0, 60);
  v522 = &v521[8];
  v523 = (cv *)v524;
  v524[1] = 0LL;
  v524[0] = 0LL;
  (*(void (__fastcall **)(unsigned __int64, int64x2_t *, _BYTE *, __int64))(*(_QWORD *)v525.n128_u64[0] + 24LL))(
    v525.n128_u64[0],
    &v525,
    v521,
    0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v525, v294);
  *(_QWORD *)&v526 = 0LL;
  v525.n128_u32[0] = 16842752;
  v525.n128_u64[1] = (unsigned __int64)v521;
  v295 = cv::countNonZero(&v525);
  if ( (word_70090 & 1) != 0 )
    v296 = (const char *)qword_700A0;
  else
    v296 = (char *)&word_70090 + 1;
  v297 = v295;
  v418 = dword_70088;
  v420 = 0LL;
  v421 = 0LL;
  v419 = 0LL;
  v298 = strlen(v296);
  if ( v298 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v299 = v298;
  if ( v298 >= 0x17 )
  {
    v301 = (v298 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v300 = (char *)operator new(v301);
    v420 = v299;
    v421 = v300;
    v419 = v301 | 1;
    goto LABEL_405;
  }
  v300 = (char *)&v419 + 1;
  LOBYTE(v419) = 2 * v298;
  if ( v298 )
LABEL_405:
    memcpy(v300, v296, v299);
  v300[v299] = 0;
  v302 = v411;
  if ( (g3::logLevel(&v418) & 1) == 0 )
  {
    v303 = 0;
    if ( (v419 & 1) != 0 )
      goto LABEL_412;
    goto LABEL_409;
  }
  BYTE1(v417[2]) = 0;
  WORD1(v417[2]) = 0;
  HIDWORD(v417[2]) = 0;
  LOBYTE(v417[0]) = 30;
  strcpy((char *)v417 + 1, "feasibal_region");
  v303 = g3::logTag(v417);
  if ( ((__int64)v417[0] & 1) != 0 )
  {
    operator delete(v417[2]);
    if ( (v419 & 1) != 0 )
      goto LABEL_412;
LABEL_409:
    if ( (v303 & 1) != 0 )
      goto LABEL_413;
    goto LABEL_414;
  }
  if ( (v419 & 1) == 0 )
    goto LABEL_409;
LABEL_412:
  operator delete(v421);
  if ( (v303 & 1) != 0 )
  {
LABEL_413:
    LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
    LogCapture::capturef((LogCapture *)&v525, "### is_update:%d", v285);
    LogCapture::~LogCapture((LogCapture *)&v525);
  }
LABEL_414:
  v304 = *v392;
  v305 = *v391;
  v306 = *v392 - *v391;
  if ( !v285 )
  {
    if ( v306 != 176 )
    {
LABEL_483:
      *(_DWORD *)(v302 + 1432) = 0;
      goto LABEL_498;
    }
    ++*(_DWORD *)(v305 + 168);
    v415 = 0LL;
    v416 = 0LL;
    v413 = dword_70088;
    if ( (word_70090 & 1) != 0 )
      v321 = (const char *)qword_700A0;
    else
      v321 = (char *)&word_70090 + 1;
    v414 = 0LL;
    v322 = strlen(v321);
    if ( v322 >= 0xFFFFFFFFFFFFFFF0LL )
      std::__basic_string_common<true>::__throw_length_error();
    v323 = v322;
    if ( v322 >= 0x17 )
    {
      v337 = (v322 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v302 = v411;
      v324 = (char *)operator new(v337);
      v415 = v323;
      v416 = v324;
      v414 = v337 | 1;
    }
    else
    {
      v324 = (char *)&v414 + 1;
      LOBYTE(v414) = 2 * v322;
      if ( !v322 )
      {
LABEL_460:
        v324[v323] = 0;
        if ( (g3::logLevel(&v413) & 1) != 0 )
        {
          LOBYTE(v412[0]) = 30;
          strcpy((char *)v412 + 1, "feasibal_region");
          BYTE1(v412[2]) = 0;
          WORD1(v412[2]) = 0;
          HIDWORD(v412[2]) = 0;
          v339 = g3::logTag(v412);
          if ( ((__int64)v412[0] & 1) == 0 )
          {
            if ( (v414 & 1) == 0 )
              goto LABEL_463;
LABEL_466:
            operator delete(v416);
            if ( (v339 & 1) == 0 )
              goto LABEL_468;
            goto LABEL_467;
          }
          operator delete(v412[2]);
          if ( (v414 & 1) != 0 )
            goto LABEL_466;
        }
        else
        {
          v339 = 0;
          if ( (v414 & 1) != 0 )
            goto LABEL_466;
        }
LABEL_463:
        if ( (v339 & 1) == 0 )
        {
LABEL_468:
          v340 = *(_QWORD *)(v302 + 1552);
          if ( *(_DWORD *)(v340 + 168) >= 4u )
          {
            for ( j = *v392; j != v340; j -= 176LL )
            {
              v342 = *(_QWORD *)(j - 80);
              if ( v342 )
              {
                v343 = (unsigned int *)(v342 + 20);
                do
                {
                  v344 = __ldaxr(v343);
                  v345 = v344 - 1;
                }
                while ( __stlxr(v345, v343) );
                if ( !v345 )
                  cv::Mat::deallocate((cv::Mat *)(j - 136));
              }
              v346 = *(_DWORD *)(j - 132);
              *(_QWORD *)(j - 80) = 0LL;
              *(_OWORD *)(j - 104) = 0u;
              *(_OWORD *)(j - 120) = 0u;
              if ( v346 >= 1 )
              {
                v347 = *(_QWORD *)(j - 72);
                v348 = 0LL;
                do
                  *(_DWORD *)(v347 + 4 * v348++) = 0;
                while ( v348 < *(int *)(j - 132) );
              }
              v349 = *(cv **)(j - 64);
              if ( v349 != (cv *)(j - 56) )
                cv::fastFree(v349, v338);
            }
            LOBYTE(v286) = 0;
            *v392 = v340;
            goto LABEL_483;
          }
          goto LABEL_482;
        }
LABEL_467:
        LogCapture::LogCapture((LogCapture *)&v525, "feasibal_region", (const LEVELS *)&dword_70088, "", 6, 0LL);
        LogCapture::capturef(
          (LogCapture *)&v525,
          "### unsee_counts:%d",
          *(unsigned int *)(*(_QWORD *)(v302 + 1552) + 168LL));
        LogCapture::~LogCapture((LogCapture *)&v525);
        goto LABEL_468;
      }
    }
    memcpy(v324, v321, v323);
    goto LABEL_460;
  }
  if ( v306 == 176 )
  {
    *(_DWORD *)(v411 + 1432) = 0;
    v307 = *(float *)(v305 + 148);
    v308 = *(float *)&v528 * 0.6;
    *(float32x2_t *)(v305 + 140) = vadd_f32(
                                     vmul_f32(*(float32x2_t *)(v305 + 140), vdup_n_s32(0x3ECCCCCDu)),
                                     vmul_f32(v527, vdup_n_s32(0x3F19999Au)));
    *(float *)(v305 + 148) = (float)(v307 * 0.4) + v308;
    v309 = (_DWORD *)(v305 + 40);
    v310 = *((float *)&v528 + 1) * 0.599999994 + (float)(*(float *)(v305 + 164) * 0.4);
    *(float *)(v305 + 164) = v310;
    if ( (_BYTE *)(v305 + 40) != v521 )
    {
      if ( *(_QWORD *)&v521[56] )
      {
        v311 = (unsigned int *)(*(_QWORD *)&v521[56] + 20LL);
        do
          v312 = __ldaxr(v311);
        while ( __stlxr(v312 + 1, v311) );
      }
      v313 = *(_QWORD *)(v305 + 96);
      if ( v313 )
      {
        v314 = (unsigned int *)(v313 + 20);
        do
        {
          v315 = __ldaxr(v314);
          v316 = v315 - 1;
        }
        while ( __stlxr(v316, v314) );
        if ( !v316 )
          cv::Mat::deallocate((cv::Mat *)(v305 + 40));
      }
      v317 = *(_DWORD *)(v305 + 44);
      *(_QWORD *)(v305 + 96) = 0LL;
      *(_OWORD *)(v305 + 72) = 0u;
      *(_OWORD *)(v305 + 56) = 0u;
      if ( v317 <= 0 )
      {
        *v309 = *(_DWORD *)v521;
      }
      else
      {
        v318 = *(_QWORD *)(v305 + 104);
        v319 = 0LL;
        do
        {
          *(_DWORD *)(v318 + 4 * v319) = 0;
          v320 = *(int *)(v305 + 44);
          ++v319;
        }
        while ( v319 < v320 );
        *v309 = *(_DWORD *)v521;
        if ( (int)v320 > 2 )
          goto LABEL_495;
      }
      v350 = *(_DWORD *)&v521[4];
      if ( *(int *)&v521[4] > 2 )
        goto LABEL_495;
LABEL_494:
      *(_DWORD *)(v305 + 44) = v350;
      v351 = *(_QWORD **)(v305 + 112);
      *(_QWORD *)(v305 + 48) = *(_QWORD *)&v521[8];
      v352 = v523;
      *v351 = *(_QWORD *)v523;
      v351[1] = *((_QWORD *)v352 + 1);
LABEL_496:
      *(_OWORD *)(v305 + 56) = *(_OWORD *)&v521[16];
      *(_OWORD *)(v305 + 72) = *(_OWORD *)&v521[32];
      *(_OWORD *)(v305 + 88) = *(_OWORD *)&v521[48];
      v305 = *(_QWORD *)(v411 + 1552);
    }
    goto LABEL_497;
  }
  v325 = *(float *)(v411 + 1308);
  if ( v325 <= 20.0 )
    goto LABEL_457;
  if ( (CAPE::judgPlaneValid(v325, 0.20944, 10.0, v411, (float *)&v527, (float *)(v411 + 1536)) & 1) == 0 )
  {
LABEL_482:
    LOBYTE(v286) = 0;
    goto LABEL_483;
  }
  v327 = *(_DWORD *)(v411 + 1432);
  *(_DWORD *)(v411 + 1432) = v327 + 1;
  if ( v327 < 1 )
  {
LABEL_457:
    LOBYTE(v286) = 0;
    goto LABEL_498;
  }
  if ( v306 )
  {
    for ( k = v305 + 176; v304 != k; v304 -= 176LL )
    {
      v329 = *(_QWORD *)(v304 - 80);
      if ( v329 )
      {
        v330 = (unsigned int *)(v329 + 20);
        do
        {
          v331 = __ldaxr(v330);
          v332 = v331 - 1;
        }
        while ( __stlxr(v332, v330) );
        if ( !v332 )
          cv::Mat::deallocate((cv::Mat *)(v304 - 136));
      }
      v333 = *(_DWORD *)(v304 - 132);
      *(_QWORD *)(v304 - 80) = 0LL;
      *(_OWORD *)(v304 - 104) = 0u;
      *(_OWORD *)(v304 - 120) = 0u;
      if ( v333 >= 1 )
      {
        v334 = *(_QWORD *)(v304 - 72);
        v335 = 0LL;
        do
          *(_DWORD *)(v334 + 4 * v335++) = 0;
        while ( v335 < *(int *)(v304 - 132) );
      }
      v336 = *(cv **)(v304 - 64);
      if ( v336 != (cv *)(v304 - 56) )
        cv::fastFree(v336, v326);
    }
    *v392 = k;
  }
  else
  {
    std::vector<ground_filter::plane_base>::__append(v391, 1uLL);
  }
  v305 = *(_QWORD *)(v411 + 1552);
  v379 = v528;
  *(float32x2_t *)(v305 + 140) = v527;
  *(_DWORD *)(v305 + 148) = v379;
  v380 = (_DWORD *)(v305 + 40);
  *(_DWORD *)(v305 + 164) = HIDWORD(v528);
  if ( (_BYTE *)(v305 + 40) != v521 )
  {
    if ( *(_QWORD *)&v521[56] )
    {
      v381 = (unsigned int *)(*(_QWORD *)&v521[56] + 20LL);
      do
        v382 = __ldaxr(v381);
      while ( __stlxr(v382 + 1, v381) );
    }
    v383 = *(_QWORD *)(v305 + 96);
    if ( v383 )
    {
      v384 = (unsigned int *)(v383 + 20);
      do
      {
        v385 = __ldaxr(v384);
        v386 = v385 - 1;
      }
      while ( __stlxr(v386, v384) );
      if ( !v386 )
        cv::Mat::deallocate((cv::Mat *)(v305 + 40));
    }
    v387 = *(_DWORD *)(v305 + 44);
    *(_QWORD *)(v305 + 96) = 0LL;
    *(_OWORD *)(v305 + 72) = 0u;
    *(_OWORD *)(v305 + 56) = 0u;
    if ( v387 <= 0 )
    {
      *v380 = *(_DWORD *)v521;
    }
    else
    {
      v388 = *(_QWORD *)(v305 + 104);
      v389 = 0LL;
      do
      {
        *(_DWORD *)(v388 + 4 * v389) = 0;
        v390 = *(int *)(v305 + 44);
        ++v389;
      }
      while ( v389 < v390 );
      *v380 = *(_DWORD *)v521;
      if ( (int)v390 > 2 )
      {
LABEL_495:
        cv::Mat::copySize((cv::Mat *)(v305 + 40), (const cv::Mat *)v521);
        goto LABEL_496;
      }
    }
    v350 = *(_DWORD *)&v521[4];
    if ( *(int *)&v521[4] > 2 )
      goto LABEL_495;
    goto LABEL_494;
  }
LABEL_497:
  *(_DWORD *)(v305 + 136) = v297;
  LOBYTE(v286) = 1;
LABEL_498:
  v353 = (const cv::Mat *)(v302 + 1336);
  v354 = *(_OWORD *)(v302 + 1336);
  v355 = *(_OWORD *)(v302 + 1352);
  *(_OWORD *)a6 = v354;
  *(_OWORD *)(a6 + 16) = v355;
  *(_OWORD *)(a6 + 32) = *(_OWORD *)(v302 + 1368);
  *(_QWORD *)(a6 + 48) = *(_QWORD *)(v302 + 1384);
  v356 = *(_QWORD *)(v302 + 1392);
  *(_QWORD *)(a6 + 80) = 0LL;
  *(_QWORD *)(a6 + 64) = a6 + 8;
  *(_QWORD *)(a6 + 72) = a6 + 80;
  *(_QWORD *)(a6 + 56) = v356;
  *(_QWORD *)(a6 + 88) = 0LL;
  if ( !v356 )
  {
    if ( SDWORD1(v354) <= 2 )
      goto LABEL_502;
    goto LABEL_504;
  }
  v357 = (unsigned int *)(v356 + 20);
  do
    v358 = __ldaxr(v357);
  while ( __stlxr(v358 + 1, v357) );
  if ( *(int *)(v302 + 1340) > 2 )
  {
LABEL_504:
    *(_DWORD *)(a6 + 4) = 0;
    cv::Mat::copySize((cv::Mat *)a6, v353);
    goto LABEL_505;
  }
LABEL_502:
  v359 = *(_QWORD **)(v302 + 1408);
  v360 = *(_QWORD **)(a6 + 72);
  *v360 = *v359;
  v360[1] = v359[1];
LABEL_505:
  v361 = *(_QWORD *)&v521[56];
  *(_BYTE *)(a6 + 96) = v286;
  *(float *)(a6 + 100) = v403;
  if ( v361 )
  {
    v362 = (unsigned int *)(v361 + 20);
    do
    {
      v363 = __ldaxr(v362);
      v364 = v363 - 1;
    }
    while ( __stlxr(v364, v362) );
    if ( !v364 )
      cv::Mat::deallocate((cv::Mat *)v521);
  }
  *(_QWORD *)&v521[56] = 0LL;
  memset(&v521[16], 0, 32);
  if ( *(int *)&v521[4] >= 1 )
  {
    v365 = v522;
    v366 = 0LL;
    do
      *(_DWORD *)&v365[4 * v366++] = 0;
    while ( v366 < *(int *)&v521[4] );
  }
  if ( v523 != (cv *)v524 )
    cv::fastFree(v523, v353);
  if ( v485 )
  {
    v486 = v485;
    operator delete(v485);
  }
  free(ptr);
  v367 = v493;
  if ( v493 )
  {
    v368 = v494;
    if ( v494 == v493 )
    {
      v372 = v493;
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v369 = (std::__shared_weak_count *)*(v368 - 1);
          v368 -= 2;
          if ( v369 )
          {
            v370 = (unsigned __int64 *)((char *)v369 + 8);
            do
              v371 = __ldaxr(v370);
            while ( __stlxr(v371 - 1, v370) );
            if ( !v371 )
              break;
          }
          if ( v368 == v367 )
            goto LABEL_526;
        }
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v369 + 16LL))(v369);
        std::__shared_weak_count::__release_weak(v369);
      }
      while ( v368 != v367 );
LABEL_526:
      v372 = v493;
    }
    v494 = v367;
    operator delete(v372);
  }
  if ( v496 )
  {
    v497 = v496;
    operator delete(v496);
  }
  if ( v499 )
    operator delete(v499);
  free(v502);
  if ( v510 )
  {
    v511 = (char *)v510;
    operator delete(v510);
  }
  if ( v515 )
  {
    v516 = v515;
    operator delete(v515);
  }
  if ( v518 )
    operator delete(v518);
}
// 4B510: variable 'v6' is possibly undefined
// 4B5A4: variable 'v107' is possibly undefined
// 4B778: variable 'v130' is possibly undefined
// 4B938: variable 'v150' is possibly undefined
// 4BA60: variable 'v161' is possibly undefined
// 4C08C: variable 'v200' is possibly undefined
// 4C6B8: variable 'v204' is possibly undefined
// 4CEC8: variable 'v294' is possibly undefined
// 4D2DC: variable 'v326' is possibly undefined
// 4D480: variable 'v338' is possibly undefined
// 4D68C: variable 'v353' is possibly undefined
// 4D9D8: variable 'v376' is possibly undefined
// 12980: using guessed type __int64 __fastcall cv::Mat::operator=(_QWORD, _QWORD);
// 12A90: using guessed type _QWORD *__fastcall cv::operator==(_QWORD *__return_ptr, _QWORD, double);
// 12BE0: using guessed type LogCapture *__fastcall LogCapture::LogCapture(LogCapture *__hidden this, const char *, const LEVELS *, const char *, int, const char *);
// 13330: using guessed type __int64 __fastcall cv::Mat::setTo(_QWORD, _QWORD, _QWORD);
// 13470: using guessed type __int64 __fastcall g3::logLevel(_QWORD);
// 13730: using guessed type __int64 __fastcall g3::logTag(_QWORD);
// 138B0: using guessed type __int64 __fastcall cv::countNonZero(_QWORD);
// 54FB0: using guessed type __int128 xmmword_54FB0;
// 70088: using guessed type int dword_70088;
// 70090: using guessed type __int16 word_70090;
// 700A0: using guessed type __int64 qword_700A0;

//----- (000000000004E380) ----------------------------------------------------
__int64 __fastcall CAPE::RegionGrowing(
        __int64 result,
        unsigned int a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        _QWORD *a6,
        _QWORD *a7,
        unsigned int a8,
        long double a9,
        unsigned __int16 a10,
        float *a11)
{
  int v11; // w27
  unsigned __int64 v12; // x8
  __int64 v21; // x26
  __int64 v22; // x28
  __int64 v23; // x9
  float v24; // s1
  float v25; // s2
  double v26; // d0
  int v27; // [xsp+0h] [xbp-80h]
  unsigned int v28; // [xsp+10h] [xbp-70h]
  unsigned int v29; // [xsp+14h] [xbp-6Ch]
  int v30; // [xsp+28h] [xbp-58h]

  v11 = a10;
  v30 = (unsigned __int16)a2;
  v12 = a10 * (unsigned int)(unsigned __int16)a2 + (unsigned __int64)(unsigned __int16)a8;
  if ( *(_BYTE *)(a4 + v12) )
  {
    v29 = a8 - 1;
    v28 = a8 + 1;
    v21 = result;
    v22 = (unsigned __int16)a8;
    do
    {
      if ( *(_BYTE *)(a5 + v12) )
        break;
      v23 = *(_QWORD *)(*a6 + 16 * v12);
      v24 = a11[1];
      v25 = a11[2];
      if ( (float)((float)((float)(*a11 * *(float *)(v23 + 80)) + (float)(v24 * *(float *)(v23 + 84)))
                 + (float)(v25 * *(float *)(v23 + 88))) < *(float *)(v21 + 20) )
        break;
      v26 = (float)(*(float *)&a9
                  + (float)((float)((float)(*a11 * *(float *)(v23 + 68)) + (float)(v24 * *(float *)(v23 + 72)))
                          + (float)(v25 * *(float *)(v23 + 76))));
      if ( v26 * v26 > *(float *)(*a7 + 4 * v12) )
        break;
      LODWORD(a9) = *(_DWORD *)(v23 + 92);
      a11 = (float *)(v23 + 80);
      *(_BYTE *)(a5 + v12) = 1;
      if ( (_WORD)a8 )
      {
        LOWORD(v27) = v11;
        result = CAPE::RegionGrowing(v21, a2, a3, a4, a5, a6, a7, v29, a9, v27, v23 + 80);
      }
      if ( v30 - 1 > (int)v22 )
      {
        LOWORD(v27) = v11;
        result = CAPE::RegionGrowing(v21, a2, a3, a4, a5, a6, a7, v28, a9, v27, a11);
      }
      if ( (_WORD)v11 )
      {
        LOWORD(v27) = v11 - 1;
        result = CAPE::RegionGrowing(v21, a2, a3, a4, a5, a6, a7, a8, a9, v27, a11);
      }
      if ( (unsigned __int16)a3 - 1 <= v11 )
        break;
      v11 = (unsigned __int16)(v11 + 1);
      v12 = (unsigned int)(v11 * v30) + v22;
    }
    while ( *(_BYTE *)(a4 + v12) );
  }
  return result;
}
// 4E4E0: variable 'v27' is possibly undefined

//----- (000000000004E5A8) ----------------------------------------------------
void __fastcall Eigen::Matrix<bool,-1,-1,0,-1,-1>::Matrix<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>,Eigen::Matrix<bool,-1,-1,0,-1,-1>>>(
        unsigned __int64 *a1,
        _QWORD *a2)
{
  __int64 v4; // x22
  unsigned __int64 v5; // x23
  size_t v6; // x2
  void *v7; // x8
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x9
  unsigned __int64 v11; // x10
  const char *v12; // x8
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x9
  char *v15; // x10
  int8x16_t v16; // q0
  int8x16_t *v17; // x12
  unsigned __int64 v18; // x13
  std::bad_alloc *exception; // x19
  std::bad_alloc *v20; // x20
  void *v21[2]; // [xsp+0h] [xbp-40h] BYREF

  v21[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *a2;
  v5 = a2[1];
  v6 = v5 * *a2;
  if ( !v6 )
  {
    v7 = 0LL;
    v9 = a2[1];
    v8 = *a2;
    goto LABEL_6;
  }
  if ( posix_memalign(v21, 0x10uLL, v6) )
  {
    v21[0] = 0LL;
LABEL_22:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  v7 = v21[0];
  if ( !v21[0] )
    goto LABEL_22;
  v8 = *a2;
  v9 = a2[1];
LABEL_6:
  *a1 = (unsigned __int64)v7;
  a1[1] = v4;
  a1[2] = v5;
  if ( v8 && v9 && 0x7FFFFFFFFFFFFFFFLL / v9 < v8 )
  {
    v20 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(v20);
    __cxa_throw(
      v20,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  Eigen::PlainObjectBase<Eigen::Matrix<bool,-1,-1,0,-1,-1>>::resize((__int64)a1, v8, v9);
  v10 = a1[2] * a1[1];
  if ( v10 >= 1 )
  {
    v11 = *a1;
    v12 = (const char *)(a2 + 2);
    if ( (unsigned __int64)v10 < 0x20 || v11 < (unsigned __int64)a2 + 17 && (unsigned __int64)v12 < v11 + v10 )
    {
      v13 = 0LL;
LABEL_14:
      v14 = v10 - v13;
      v15 = (char *)(v11 + v13);
      do
      {
        --v14;
        *v15++ = *v12;
      }
      while ( v14 );
      return;
    }
    v16 = vld1q_dup_s8(v12);
    v13 = v10 & 0xFFFFFFFFFFFFFFE0LL;
    v17 = (int8x16_t *)(v11 + 16);
    v18 = v10 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v17[-1] = v16;
      *v17 = v16;
      v18 -= 32LL;
      v17 += 2;
    }
    while ( v18 );
    if ( v10 != v13 )
      goto LABEL_14;
  }
}

//----- (000000000004E74C) ----------------------------------------------------
void __fastcall CAPE::getConnectedComponents(__int64 a1, __int64 a2, __int64 *a3)
{
  int v3; // w15
  int *v4; // x10
  __int64 v5; // x8
  int v6; // w11
  __int64 v7; // x12
  __int64 v8; // x9
  __int64 v9; // x13
  int *v10; // x17
  __int64 v11; // x0
  __int64 v12; // x1
  int v13; // w3
  int v14; // w3
  __int64 v15; // x8
  __int64 v16; // x11
  __int64 v17; // x10
  __int64 v18; // x9
  int v19; // w12
  __int64 v20; // x13
  __int64 v21; // x14
  __int64 v22; // x17
  __int64 v23; // x16
  bool v24; // w17

  v3 = *(_DWORD *)(a2 + 8) - 1;
  if ( v3 <= 0 )
  {
    if ( a3[1] < 1 )
      return;
    goto LABEL_17;
  }
  v4 = *(int **)(a2 + 16);
  v5 = 0LL;
  v6 = *(_DWORD *)(a2 + 12) - 1;
  v7 = **(_QWORD **)(a2 + 72);
  v9 = *a3;
  v8 = a3[1];
  do
  {
    ++v5;
    if ( v6 >= 1 )
    {
      v10 = v4;
      v11 = (unsigned int)v6;
      do
      {
        v12 = *v10;
        if ( (int)v12 >= 1 )
        {
          v13 = v10[1];
          if ( v13 >= 1 && (_DWORD)v12 != v13 )
            *(_BYTE *)(v9 + v12 + v8 * (v13 - 1LL) - 1) = 1;
          v14 = *(int *)((char *)v10 + v7);
          if ( v14 >= 1 && (_DWORD)v12 != v14 )
            *(_BYTE *)(v9 + v12 + v8 * (v14 - 1LL) - 1) = 1;
        }
        --v11;
        ++v10;
      }
      while ( v11 );
    }
    v4 = (int *)((char *)v4 + v7);
  }
  while ( v5 != v3 );
  if ( v8 >= 1 )
  {
LABEL_17:
    v16 = a3[1];
    v15 = a3[2];
    v17 = *a3;
    v18 = 0LL;
    v19 = 1;
    do
    {
      v20 = v18++;
      if ( v15 > v18 )
      {
        v21 = v19;
        v22 = v18;
        do
        {
          v23 = v20 + v16 * v22;
          if ( *(_BYTE *)(v17 + v23) )
            v24 = 1;
          else
            v24 = *(_BYTE *)(v17 + v16 * v20 + v22) != 0;
          ++v21;
          *(_BYTE *)(v17 + v23) = v24;
          v22 = v21;
        }
        while ( v15 > v21 );
      }
      ++v19;
    }
    while ( v16 > v18 );
  }
}

//----- (000000000004E898) ----------------------------------------------------
__int64 __fastcall CAPE::getBestPlane(CAPE *this, const cv::Mat *a2, const cv::Mat *a3, const int *a4)
{
  __int64 v6; // x8
  __int64 v7; // x24
  size_t v8; // x22
  char *v9; // x0
  char *v10; // x24
  char *v11; // x19
  unsigned __int64 v12; // x9
  int v13; // w11
  unsigned __int64 v14; // x10
  int v15; // w14
  __int64 v16; // x14
  unsigned __int64 v17; // x15
  __int64 v18; // x16
  __int64 v19; // x17
  unsigned __int64 v20; // x0
  unsigned __int64 v21; // x9
  unsigned int v22; // w10
  unsigned int v23; // w20
  unsigned __int64 i; // x11
  unsigned int v25; // w12

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *a4;
  v7 = v6 + 1;
  if ( (_DWORD)v6 == -1 )
  {
    v11 = 0LL;
    v10 = 0LL;
    v12 = *((int *)a2 + 2);
    if ( !(_DWORD)v12 )
      goto LABEL_16;
    goto LABEL_4;
  }
  if ( (v7 & 0x80000000) != 0 )
    std::__vector_base_common<true>::__throw_length_error();
  v8 = 4 * v7;
  v9 = (char *)operator new(4 * v7);
  v10 = &v9[4 * v7];
  v11 = v9;
  memset(v9, 0, v8);
  v12 = *((int *)a2 + 2);
  if ( (_DWORD)v12 )
  {
LABEL_4:
    v13 = *((_DWORD *)a2 + 3);
    v14 = 0LL;
    v15 = v13;
    do
    {
      if ( v15 )
      {
        v16 = 0LL;
        v17 = 0LL;
        v18 = *((_QWORD *)a2 + 2) + **((_QWORD **)a2 + 9) * (int)v14;
        v19 = *((_QWORD *)a3 + 2) + **((_QWORD **)a3 + 9) * (int)v14;
        do
        {
          v20 = *(unsigned __int8 *)(v18 + (v16 >> 32));
          if ( *(_BYTE *)(v18 + (v16 >> 32)) && *(_BYTE *)(v19 + (v16 >> 32)) && v20 < (v10 - v11) >> 2 )
            ++*(_DWORD *)&v11[4 * v20];
          ++v17;
          v16 += 0x100000000LL;
        }
        while ( v17 < v13 );
        v15 = v13;
      }
      ++v14;
    }
    while ( v14 < v12 );
  }
LABEL_16:
  v21 = (v10 - v11) >> 2;
  if ( v21 < 2 )
  {
    v23 = 0;
    if ( !v11 )
      return v23;
    goto LABEL_24;
  }
  v22 = 0;
  v23 = 0;
  for ( i = 1LL; i < v21; ++i )
  {
    v25 = *(_DWORD *)&v11[4 * i];
    if ( v25 > v22 )
      v23 = i;
    if ( v25 > v22 )
      v22 = v25;
  }
  if ( v11 )
LABEL_24:
    operator delete(v11);
  return v23;
}

//----- (000000000004EA74) ----------------------------------------------------
__int64 __fastcall CAPE::swapPlanes(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // x24
  __int64 result; // x0
  unsigned __int64 v7; // x8
  __int64 v9; // x26
  __int128 v10; // q0
  __int128 v12; // q1
  __int128 v13; // q2
  __int128 v14; // q3
  int v17; // w11
  __int64 v18; // x12
  __int64 i; // x8
  __int64 v20; // x11
  __int64 v21; // x12
  int v22; // w14
  char v23; // w13
  __int128 v24[6]; // [xsp+0h] [xbp-F0h] BYREF
  void *v25; // [xsp+60h] [xbp-90h] BYREF
  void *ptr; // [xsp+78h] [xbp-78h] BYREF
  __int64 v27[4]; // [xsp+90h] [xbp-60h] BYREF

  v27[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = *a2;
  result = 0LL;
  v7 = 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3);
  if ( v7 > a4 && v7 > a5 )
  {
    v9 = v5 + 168 * a4;
    v10 = *(_OWORD *)(v9 + 16);
    v24[0] = *(_OWORD *)v9;
    v24[1] = v10;
    v12 = *(_OWORD *)(v9 + 80);
    v13 = *(_OWORD *)(v9 + 32);
    v14 = *(_OWORD *)(v9 + 48);
    v24[4] = *(_OWORD *)(v9 + 64);
    v24[5] = v12;
    v24[2] = v13;
    v24[3] = v14;
    Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)&v25, (__int64 *)(v9 + 96));
    Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)&ptr, (__int64 *)(v9 + 120));
    Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix(v27, (__int64 *)(v5 + 168 * a4 + 144));
    PlaneSeg::operator=(*a2 + 168 * a4, *a2 + 168 * a5);
    PlaneSeg::operator=(*a2 + 168 * a5, (__int64)v24);
    v17 = *(_DWORD *)(a3 + 8);
    if ( v17 >= 1 )
    {
      LODWORD(v18) = *(_DWORD *)(a3 + 12);
      for ( i = 0LL; i < v17; ++i )
      {
        if ( (int)v18 >= 1 )
        {
          v20 = 0LL;
          do
          {
            v21 = *(_QWORD *)(a3 + 16) + i * **(_QWORD **)(a3 + 72);
            v22 = *(unsigned __int8 *)(v21 + v20);
            v23 = a4 + 1;
            if ( v22 == (unsigned __int8)(a5 + 1) || (v23 = a5 + 1, v22 == (unsigned __int8)(a4 + 1)) )
              *(_BYTE *)(v21 + v20) = v23;
            v18 = *(int *)(a3 + 12);
            ++v20;
          }
          while ( v20 < v18 );
          v17 = *(_DWORD *)(a3 + 8);
        }
      }
    }
    PlaneSeg::~PlaneSeg((void **)v24);
    return 1LL;
  }
  return result;
}

//----- (000000000004EC4C) ----------------------------------------------------
__int64 __fastcall CAPE::judgPlaneValid(float a1, float a2, float a3, __int64 a4, float *a5, float *a6)
{
  float v6; // s11
  float v7; // s13
  float v10; // s1
  float v11; // s12
  float v13; // s2
  float v14; // s4
  float v15; // s5
  float v16; // s0
  float v18; // s1
  float v19; // s0
  float v20; // s1
  bool v21; // cc
  double v22; // d1
  char v23; // w9
  float v24; // s0
  float v25; // s1

  v6 = *a5;
  v7 = a5[1];
  v10 = a6[1];
  v11 = a5[2];
  v13 = a6[2];
  v14 = sqrtf((float)((float)(v6 * v6) + (float)(v7 * v7)) + (float)(v11 * v11));
  v15 = sqrtf((float)((float)(*a6 * *a6) + (float)(v10 * v10)) + (float)(v13 * v13));
  v16 = (float)((float)(v11 / v14) * (float)(v13 / v15))
      + (float)((float)((float)(*a5 / v14) * (float)(*a6 / v15)) + (float)((float)(v7 / v14) * (float)(v10 / v15)));
  v18 = 0.0;
  if ( fabsf(fabsf(v16) + -1.0) >= 0.0001 )
  {
    v19 = acosf(v16);
    if ( v19 > 1.57079633 )
    {
      v20 = 3.14159265 - v19;
      v19 = v20;
    }
    v18 = fabsf(v19);
  }
  v21 = v18 <= a2;
  v22 = v18;
  v23 = v21;
  v24 = fabsf((float)((float)(v6 * 0.0) + (float)(v7 * 0.0)) + (float)((float)(v11 * 0.0) + a5[3]));
  if ( v22 <= 0.025 )
    v25 = a3;
  else
    v25 = a3 + 10.0;
  return (unsigned __int8)v23 & (vabds_f32(v24, a1) <= v25);
}

//----- (000000000004EDAC) ----------------------------------------------------
__int64 __fastcall CAPE::judgeValidBasedImage(
        CAPE *this,
        const cv::Mat *a2,
        const cv::Mat *a3,
        unsigned int *a4,
        unsigned int *a5)
{
  void *v8; // x1
  unsigned int v9; // w0
  int v10; // w27
  void *v11; // x1
  void *v12; // x1
  unsigned int v13; // s8
  void *v14; // x1
  int v15; // w0
  void *v16; // x1
  int v17; // w9
  double v18; // d1
  double v19; // d0
  unsigned int v20; // w19
  __int64 v21; // x8
  unsigned int *v23; // x8
  unsigned int v24; // w9
  unsigned int v25; // w9
  _DWORD *v26; // x8
  __int64 v27; // x9
  unsigned int *v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w9
  _QWORD *v31; // x8
  __int64 v32; // x9
  unsigned int *v33; // x8
  unsigned int v34; // w9
  unsigned int v35; // w9
  _QWORD *v36; // x8
  __int64 v37; // x9
  _QWORD v39[8]; // [xsp+10h] [xbp-2F0h] BYREF
  _DWORD *v40; // [xsp+50h] [xbp-2B0h]
  cv *v41; // [xsp+58h] [xbp-2A8h]
  __int64 v42[2]; // [xsp+60h] [xbp-2A0h] BYREF
  _QWORD v43[8]; // [xsp+70h] [xbp-290h] BYREF
  _QWORD *v44; // [xsp+B0h] [xbp-250h]
  cv *v45; // [xsp+B8h] [xbp-248h]
  __int64 v46[2]; // [xsp+C0h] [xbp-240h] BYREF
  __int64 v47; // [xsp+D0h] [xbp-230h] BYREF
  _QWORD *v48; // [xsp+D8h] [xbp-228h]
  __int64 v49; // [xsp+E0h] [xbp-220h]
  _QWORD v50[8]; // [xsp+230h] [xbp-D0h] BYREF
  _QWORD *v51; // [xsp+270h] [xbp-90h]
  cv *v52; // [xsp+278h] [xbp-88h]
  __int64 v53[4]; // [xsp+280h] [xbp-80h] BYREF

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  cv::operator==(&v47, a3, 1.0);
  LODWORD(v50[0]) = 1124007936;
  memset((char *)v50 + 4, 0, 60);
  v51 = &v50[1];
  v52 = (cv *)v53;
  v53[0] = 0LL;
  v53[1] = 0LL;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v47 + 24LL))(v47, &v47, v50, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v47, v8);
  v48 = v50;
  v49 = 0LL;
  LODWORD(v47) = 16842752;
  v9 = cv::countNonZero(&v47);
  *a5 = v9;
  v10 = *a4 - v9;
  LODWORD(v43[0]) = 1124007936;
  memset((char *)v43 + 4, 0, 60);
  v44 = &v43[1];
  v45 = (cv *)v46;
  v46[0] = 0LL;
  v46[1] = 0LL;
  if ( v10 < 1 )
  {
    cv::operator-(&v47, v50, a2);
    (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v47 + 24LL))(
      v47,
      &v47,
      v43,
      0xFFFFFFFFLL);
    cv::MatExpr::~MatExpr((cv::MatExpr *)&v47, v12);
    a5 = a4;
  }
  else
  {
    cv::operator-(&v47, a2, v50);
    (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v47 + 24LL))(
      v47,
      &v47,
      v43,
      0xFFFFFFFFLL);
    cv::MatExpr::~MatExpr((cv::MatExpr *)&v47, v11);
  }
  v13 = *a5;
  cv::operator>(&v47, v43, 0.0);
  LODWORD(v39[0]) = 1124007936;
  memset((char *)v39 + 4, 0, 60);
  v40 = &v39[1];
  v41 = (cv *)v42;
  v42[0] = 0LL;
  v42[1] = 0LL;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v47 + 24LL))(v47, &v47, v39, 0xFFFFFFFFLL);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v47, v14);
  v48 = v39;
  v49 = 0LL;
  LODWORD(v47) = 16842752;
  v15 = cv::countNonZero(&v47);
  if ( v10 >= 0 )
    v17 = v10;
  else
    v17 = -v10;
  v18 = (float)(vabds_f32((float)v15, (float)v17) / (float)v13);
  if ( v18 <= 0.3 && (v19 = (float)((float)v15 / (float)(v40[1] * *v40)), v19 <= 0.4) )
  {
    if ( v19 < 0.01 && v18 < 0.02 )
      v20 = 2;
    else
      v20 = 1;
    v21 = v39[7];
    if ( !v39[7] )
      goto LABEL_22;
  }
  else
  {
    v20 = 0;
    v21 = v39[7];
    if ( !v39[7] )
      goto LABEL_22;
  }
  v23 = (unsigned int *)(v21 + 20);
  do
  {
    v24 = __ldaxr(v23);
    v25 = v24 - 1;
  }
  while ( __stlxr(v25, v23) );
  if ( !v25 )
    cv::Mat::deallocate((cv::Mat *)v39);
LABEL_22:
  v39[7] = 0LL;
  memset(&v39[2], 0, 32);
  if ( SHIDWORD(v39[0]) >= 1 )
  {
    v26 = v40;
    v27 = 0LL;
    do
      v26[v27++] = 0;
    while ( v27 < SHIDWORD(v39[0]) );
  }
  if ( v41 != (cv *)v42 )
    cv::fastFree(v41, v16);
  if ( v43[7] )
  {
    v28 = (unsigned int *)(v43[7] + 20LL);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while ( __stlxr(v30, v28) );
    if ( !v30 )
      cv::Mat::deallocate((cv::Mat *)v43);
  }
  v43[7] = 0LL;
  memset(&v43[2], 0, 32);
  if ( SHIDWORD(v43[0]) >= 1 )
  {
    v31 = v44;
    v32 = 0LL;
    do
      *((_DWORD *)v31 + v32++) = 0;
    while ( v32 < SHIDWORD(v43[0]) );
  }
  if ( v45 != (cv *)v46 )
    cv::fastFree(v45, v16);
  if ( v50[7] )
  {
    v33 = (unsigned int *)(v50[7] + 20LL);
    do
    {
      v34 = __ldaxr(v33);
      v35 = v34 - 1;
    }
    while ( __stlxr(v35, v33) );
    if ( !v35 )
      cv::Mat::deallocate((cv::Mat *)v50);
  }
  v50[7] = 0LL;
  memset(&v50[2], 0, 32);
  if ( SHIDWORD(v50[0]) >= 1 )
  {
    v36 = v51;
    v37 = 0LL;
    do
      *((_DWORD *)v36 + v37++) = 0;
    while ( v37 < SHIDWORD(v50[0]) );
  }
  if ( v52 != (cv *)v53 )
    cv::fastFree(v52, v16);
  return v20;
}
// 4EE4C: variable 'v8' is possibly undefined
// 4EED0: variable 'v11' is possibly undefined
// 4EF08: variable 'v12' is possibly undefined
// 4EF70: variable 'v14' is possibly undefined
// 4F074: variable 'v16' is possibly undefined
// 12A90: using guessed type _QWORD *__fastcall cv::operator==(_QWORD *__return_ptr, _QWORD, double);
// 13190: using guessed type _QWORD *__fastcall cv::operator-(_QWORD *__return_ptr, _QWORD, _QWORD);
// 13670: using guessed type _QWORD *__fastcall cv::operator>(_QWORD *__return_ptr, _QWORD, double);
// 138B0: using guessed type __int64 __fastcall cv::countNonZero(_QWORD);

//----- (000000000004F428) ----------------------------------------------------
void __usercall CAPE::imageScore(CAPE *this@<X0>, const cv::Mat *a2@<X1>, const int *a3@<X2>, float32x4_t **a4@<X8>)
{
  __int64 v6; // x8
  __int64 v7; // x28
  float32x4_t *v8; // x0
  float32x4_t *v9; // x26
  float32x4_t *v10; // x19
  uint32x4_t *v11; // x0
  char *v12; // x27
  uint32x4_t *v13; // x20
  uint32x4_t *v14; // x21
  uint32x4_t *v15; // x23
  uint32x4_t *v16; // x8
  int v17; // w13
  unsigned __int64 v18; // x12
  int32x2_t v19; // d0
  int32x2_t v20; // d1
  int v21; // w10
  int v22; // w9
  int v23; // w11
  unsigned __int64 v24; // x14
  int v25; // w2
  __int64 v26; // x2
  unsigned __int64 v27; // x3
  __int64 v28; // x4
  unsigned __int64 v29; // x5
  __int64 v30; // x5
  int v31; // w9
  unsigned __int64 v32; // x10
  int v33; // w9
  unsigned __int64 v34; // x11
  unsigned __int64 v35; // x9
  float32x4_t v36; // q2
  float32x4_t v37; // q3
  unsigned __int64 v44; // x12
  float32x4_t *v45; // x13
  uint32x4_t *v46; // x14
  uint32x4_t *v47; // x15
  uint32x4_t v48; // t1
  uint32x4_t v49; // q6
  uint32x4_t v50; // t1
  float32x4_t v51; // q6
  __int64 v52; // x11
  unsigned int v53; // s4
  unsigned int v54; // s5
  float v55; // s4

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *a3;
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  v7 = v6 + 1;
  if ( (_DWORD)v6 == -1 )
  {
    v12 = 0LL;
    v15 = 0LL;
    v9 = 0LL;
    v10 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    v16 = 0LL;
  }
  else
  {
    if ( (v7 & 0x80000000) != 0 )
      std::__vector_base_common<true>::__throw_length_error();
    v8 = (float32x4_t *)operator new(4 * v7);
    v9 = (float32x4_t *)((char *)v8 + 4 * v7);
    v10 = v8;
    *a4 = v8;
    a4[2] = v9;
    memset(v8, 0, 4 * v7);
    a4[1] = v9;
    v11 = (uint32x4_t *)operator new(4 * v7);
    v12 = (char *)v11 + 4 * v7;
    v13 = v11;
    memset(v11, 0, 4 * v7);
    v14 = (uint32x4_t *)operator new(4 * v7);
    memset(v14, 0, 4 * v7);
    v15 = v13;
    v16 = v14;
  }
  v17 = *((_DWORD *)a2 + 3);
  v18 = *((int *)a2 + 2);
  v19.n64_f64[0] = (double)v17 * 0.25;
  v20.n64_f64[0] = (double)v17 * 0.75;
  v21 = (int)v19.n64_f64[0];
  v22 = (int)v20.n64_f64[0];
  v23 = (int)((double)(int)v18 * 0.55);
  if ( (_DWORD)v18 )
  {
    v24 = 0LL;
    v25 = *((_DWORD *)a2 + 3);
    do
    {
      if ( v25 )
      {
        v26 = 0LL;
        v27 = 0LL;
        v28 = *((_QWORD *)a2 + 2) + **((_QWORD **)a2 + 9) * (int)v24;
        do
        {
          v29 = *(unsigned __int8 *)(v28 + (v26 >> 32));
          if ( *(_BYTE *)(v28 + (v26 >> 32)) )
          {
            if ( v29 < (v12 - (char *)v15) >> 2 )
            {
              v30 = v29;
              ++v16->n128_u32[v30];
              if ( v24 < v18 && v24 > v23 && v27 > v21 && v27 < v22 )
                ++v15->n128_u32[v30];
            }
          }
          ++v27;
          v26 += 0x100000000LL;
        }
        while ( v27 < v17 );
        v25 = v17;
      }
      ++v24;
    }
    while ( v24 < v18 );
  }
  if ( v9 != v10 )
  {
    v31 = 1 - v21 + v22;
    v32 = ((char *)v9 - (char *)v10) >> 2;
    v33 = v31 * (v18 + 1 - v23);
    if ( v32 <= 1 )
      v34 = 1LL;
    else
      v34 = ((char *)v9 - (char *)v10) >> 2;
    v19.n64_f32[0] = (float)v33;
    v20.n64_f32[0] = (float)(**((_DWORD **)a2 + 8) * *(_DWORD *)(*((_QWORD *)a2 + 8) + 4LL));
    if ( v34 <= 3 )
    {
      v35 = 0LL;
      do
      {
LABEL_28:
        v52 = v35;
        v53 = v16->n128_u32[v35];
        v54 = v15->n128_u32[v35++];
        v55 = (float)((float)v54 / v19.n64_f32[0]) + (float)((float)v53 / v20.n64_f32[0]);
        v10->n128_f32[v52] = 1.0 / (float)((float)(v55 * (float)(v55 * 5.0)) + 1.0);
      }
      while ( v32 > v35 );
      goto LABEL_29;
    }
    v35 = v34 & 0xFFFFFFFFFFFFFFFCLL;
    v36 = vdupq_lane_s32(v19, 0);
    v37 = vdupq_lane_s32(v20, 0);
    __asm
    {
      FMOV            V4.4S, #5.0
      FMOV            V5.4S, #1.0
    }
    v44 = v34 & 0xFFFFFFFFFFFFFFFCLL;
    v45 = v10;
    v46 = v16;
    v47 = v15;
    do
    {
      v48 = *v47++;
      v49 = v48;
      v50 = *v46++;
      v44 -= 4LL;
      v51 = vaddq_f32(vdivq_f32(vcvtq_f32_u32(v49), v36), vdivq_f32(vcvtq_f32_u32(v50), v37));
      *v45++ = vdivq_f32(_Q5, vaddq_f32(vmulq_f32(v51, vmulq_f32(v51, _Q4)), _Q5));
    }
    while ( v44 );
    if ( v34 != v35 )
      goto LABEL_28;
  }
LABEL_29:
  if ( v16 )
    operator delete(v14);
  if ( v15 )
    operator delete(v13);
}

//----- (000000000004F7FC) ----------------------------------------------------
float __fastcall CAPE::getVectorAngle(__int64 a1, float *a2, float *a3)
{
  float v3; // s1
  float v4; // s4
  float v5; // s2
  float v6; // s5
  float v7; // s6
  float v8; // s7
  float v9; // s0
  float v11; // s0
  float v12; // s1

  v3 = a2[1];
  v4 = a3[1];
  v5 = a2[2];
  v6 = a3[2];
  v7 = sqrtf((float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v5 * v5));
  v8 = sqrtf((float)((float)(*a3 * *a3) + (float)(v4 * v4)) + (float)(v6 * v6));
  v9 = (float)((float)((float)(*a2 / v7) * (float)(*a3 / v8)) + (float)((float)(v3 / v7) * (float)(v4 / v8)))
     + (float)((float)(v5 / v7) * (float)(v6 / v8));
  if ( fabsf(fabsf(v9) + -1.0) < 0.0001 )
    return 0.0;
  v11 = acosf(v9);
  if ( v11 > 1.57079633 )
  {
    v12 = 3.14159265 - v11;
    v11 = v12;
  }
  return fabsf(v11);
}

//----- (000000000004F8D0) ----------------------------------------------------
__int64 __fastcall PlaneSeg::operator=(__int64 a1, __int64 a2)
{
  __int128 v2; // q1
  __int128 v5; // q1
  __int128 v6; // q2
  __int128 v7; // q3
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 *v10; // x21
  __int64 v11; // x8
  __int64 v12; // x9
  signed __int64 v13; // x9
  __int64 v14; // x10
  signed __int64 v15; // x11
  __int64 v16; // x10
  __int64 v17; // x11
  __int64 v18; // x12
  __int64 v19; // x14
  __int64 v20; // x15
  __int128 *v21; // x14
  _OWORD *v22; // x15
  unsigned __int64 v23; // x16
  __int128 v24; // q0
  __int128 v25; // q1
  __int64 v26; // x12
  __int64 v27; // x8
  _DWORD *v28; // x9
  int *v29; // x10
  int v30; // t1
  __int64 v31; // x1
  __int64 v32; // x2
  __int64 *v33; // x21
  __int64 v34; // x8
  __int64 v35; // x9
  signed __int64 v36; // x9
  __int64 v37; // x10
  signed __int64 v38; // x11
  __int64 v39; // x10
  __int64 v40; // x11
  __int64 v41; // x12
  __int64 v42; // x14
  __int64 v43; // x15
  __int128 *v44; // x14
  _OWORD *v45; // x15
  unsigned __int64 v46; // x16
  __int128 v47; // q0
  __int128 v48; // q1
  __int64 v49; // x12
  __int64 v50; // x8
  _DWORD *v51; // x9
  int *v52; // x10
  int v53; // t1
  __int64 v54; // x1
  __int64 v55; // x2
  __int64 *v56; // x21
  __int64 v57; // x8
  __int64 v58; // x9
  signed __int64 v59; // x9
  __int64 v60; // x10
  signed __int64 v61; // x11
  __int64 v62; // x10
  __int64 v63; // x11
  __int64 v64; // x12
  __int64 v65; // x14
  __int64 v66; // x15
  __int128 *v67; // x14
  _OWORD *v68; // x15
  unsigned __int64 v69; // x16
  __int128 v70; // q0
  __int128 v71; // q1
  __int64 v72; // x12
  __int64 v73; // x8
  _DWORD *v74; // x9
  int *v75; // x10
  int v76; // t1
  std::bad_alloc *exception; // x19

  v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  v5 = *(_OWORD *)(a2 + 80);
  v6 = *(_OWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)(a1 + 48) = v7;
  v8 = *(_QWORD *)(a2 + 104);
  v9 = *(_QWORD *)(a2 + 112);
  if ( v8 && v9 && 0x7FFFFFFFFFFFFFFFLL / v9 < v8 )
    goto LABEL_53;
  v10 = (__int64 *)(a1 + 96);
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(a1 + 96, v8, v9);
  v11 = *(_QWORD *)(a1 + 112) * *(_QWORD *)(a1 + 104);
  v12 = v11 + 3;
  if ( v11 >= 0 )
    v12 = *(_QWORD *)(a1 + 112) * *(_QWORD *)(a1 + 104);
  v13 = v12 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v11 >= 4 )
  {
    v14 = 0LL;
    v15 = 0LL;
    do
    {
      v15 += 4LL;
      *(_OWORD *)(*v10 + v14) = *(_OWORD *)(*(_QWORD *)(a2 + 96) + v14);
      v14 += 16LL;
    }
    while ( v15 < v13 );
  }
  if ( v13 < v11 )
  {
    v16 = *(_QWORD *)(a2 + 96);
    v17 = *v10;
    v18 = v11 - v13;
    if ( (unsigned __int64)(v11 - v13) < 8 )
      goto LABEL_16;
    v19 = 4 * v13;
    if ( v17 + 4 * v13 < (unsigned __int64)(v16 + 4 * v11) && v16 + v19 < (unsigned __int64)(v17 + 4 * v11) )
      goto LABEL_16;
    v20 = v19 + 16;
    v13 += v18 & 0xFFFFFFFFFFFFFFF8LL;
    v21 = (__int128 *)(v16 + v19 + 16);
    v22 = (_OWORD *)(v17 + v20);
    v23 = v18 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v24 = *(v21 - 1);
      v25 = *v21;
      v21 += 2;
      v23 -= 8LL;
      *(v22 - 1) = v24;
      *v22 = v25;
      v22 += 2;
    }
    while ( v23 );
    if ( v18 != (v18 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_16:
      v26 = 4 * v13;
      v27 = v11 - v13;
      v28 = (_DWORD *)(v17 + 4 * v13);
      v29 = (int *)(v16 + v26);
      do
      {
        v30 = *v29++;
        --v27;
        *v28++ = v30;
      }
      while ( v27 );
    }
  }
  v31 = *(_QWORD *)(a2 + 128);
  v32 = *(_QWORD *)(a2 + 136);
  if ( v31 )
  {
    if ( v32 && 0x7FFFFFFFFFFFFFFFLL / v32 < v31 )
      goto LABEL_53;
  }
  v33 = (__int64 *)(a1 + 120);
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(a1 + 120, v31, v32);
  v34 = *(_QWORD *)(a1 + 136) * *(_QWORD *)(a1 + 128);
  v35 = v34 + 3;
  if ( v34 >= 0 )
    v35 = *(_QWORD *)(a1 + 136) * *(_QWORD *)(a1 + 128);
  v36 = v35 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v34 >= 4 )
  {
    v37 = 0LL;
    v38 = 0LL;
    do
    {
      v38 += 4LL;
      *(_OWORD *)(*v33 + v37) = *(_OWORD *)(*(_QWORD *)(a2 + 120) + v37);
      v37 += 16LL;
    }
    while ( v38 < v36 );
  }
  if ( v36 < v34 )
  {
    v39 = *(_QWORD *)(a2 + 120);
    v40 = *v33;
    v41 = v34 - v36;
    if ( (unsigned __int64)(v34 - v36) < 8 )
      goto LABEL_33;
    v42 = 4 * v36;
    if ( v40 + 4 * v36 < (unsigned __int64)(v39 + 4 * v34) && v39 + v42 < (unsigned __int64)(v40 + 4 * v34) )
      goto LABEL_33;
    v43 = v42 + 16;
    v36 += v41 & 0xFFFFFFFFFFFFFFF8LL;
    v44 = (__int128 *)(v39 + v42 + 16);
    v45 = (_OWORD *)(v40 + v43);
    v46 = v41 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v47 = *(v44 - 1);
      v48 = *v44;
      v44 += 2;
      v46 -= 8LL;
      *(v45 - 1) = v47;
      *v45 = v48;
      v45 += 2;
    }
    while ( v46 );
    if ( v41 != (v41 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_33:
      v49 = 4 * v36;
      v50 = v34 - v36;
      v51 = (_DWORD *)(v40 + 4 * v36);
      v52 = (int *)(v39 + v49);
      do
      {
        v53 = *v52++;
        --v50;
        *v51++ = v53;
      }
      while ( v50 );
    }
  }
  v54 = *(_QWORD *)(a2 + 152);
  v55 = *(_QWORD *)(a2 + 160);
  if ( v54 )
  {
    if ( v55 && 0x7FFFFFFFFFFFFFFFLL / v55 < v54 )
    {
LABEL_53:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
    }
  }
  v56 = (__int64 *)(a1 + 144);
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize(a1 + 144, v54, v55);
  v57 = *(_QWORD *)(a1 + 160) * *(_QWORD *)(a1 + 152);
  v58 = v57 + 3;
  if ( v57 >= 0 )
    v58 = *(_QWORD *)(a1 + 160) * *(_QWORD *)(a1 + 152);
  v59 = v58 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v57 >= 4 )
  {
    v60 = 0LL;
    v61 = 0LL;
    do
    {
      v61 += 4LL;
      *(_OWORD *)(*v56 + v60) = *(_OWORD *)(*(_QWORD *)(a2 + 144) + v60);
      v60 += 16LL;
    }
    while ( v61 < v59 );
  }
  if ( v59 < v57 )
  {
    v62 = *(_QWORD *)(a2 + 144);
    v63 = *v56;
    v64 = v57 - v59;
    if ( (unsigned __int64)(v57 - v59) < 8 )
      goto LABEL_50;
    v65 = 4 * v59;
    if ( v63 + 4 * v59 < (unsigned __int64)(v62 + 4 * v57) && v62 + v65 < (unsigned __int64)(v63 + 4 * v57) )
      goto LABEL_50;
    v66 = v65 + 16;
    v59 += v64 & 0xFFFFFFFFFFFFFFF8LL;
    v67 = (__int128 *)(v62 + v65 + 16);
    v68 = (_OWORD *)(v63 + v66);
    v69 = v64 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v70 = *(v67 - 1);
      v71 = *v67;
      v67 += 2;
      v69 -= 8LL;
      *(v68 - 1) = v70;
      *v68 = v71;
      v68 += 2;
    }
    while ( v69 );
    if ( v64 != (v64 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_50:
      v72 = 4 * v59;
      v73 = v57 - v59;
      v74 = (_DWORD *)(v63 + 4 * v59);
      v75 = (int *)(v62 + v72);
      do
      {
        v76 = *v75++;
        --v73;
        *v74++ = v76;
      }
      while ( v73 );
    }
  }
  return a1;
}

//----- (000000000004FC64) ----------------------------------------------------
double __fastcall CAPE::iou(__int64 a1, int *a2, int *a3)
{
  int v3; // w8
  int v4; // w9
  int v5; // w11
  int v6; // w12
  int v7; // w13
  int v8; // w14
  int v9; // w15
  int v10; // w16
  int v11; // w12
  int v12; // w13
  double v13; // d1
  int v14; // w8
  double v15; // d2
  int v16; // w8
  double v17; // d3
  int v18; // w8
  double v19; // d0

  v3 = *a2;
  v4 = a2[1];
  v5 = a3[1];
  v6 = a2[2];
  v7 = a2[3];
  v8 = a3[2];
  v9 = a3[3];
  v10 = v6 + *a2;
  if ( *a2 < *a3 )
    v3 = *a3;
  v11 = v7 * v6 + v9 * v8;
  v12 = v7 + v4;
  v13 = (double)v3;
  if ( v4 >= v5 )
    v14 = a2[1];
  else
    v14 = a3[1];
  v15 = (double)v14;
  if ( v8 + *a3 >= v10 )
    v16 = v10;
  else
    v16 = v8 + *a3;
  v17 = (double)v16;
  if ( v9 + v5 >= v12 )
    v18 = v12;
  else
    v18 = v9 + v5;
  v19 = fmax(v17 - v13, 0.0) * fmax((double)v18 - v15, 0.0);
  return v19 / ((double)v11 - v19);
}

//----- (000000000004FCE4) ----------------------------------------------------
void __fastcall CAPE::~CAPE(CAPE *this)
{
  void *v2; // x1
  __int64 v3; // x21
  __int64 i; // x22
  std::__shared_weak_count *v5; // x20
  unsigned __int64 *v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x20
  char *v9; // x21
  __int64 v10; // x8
  unsigned int *v11; // x8
  unsigned int v12; // w9
  unsigned int v13; // w9
  int v14; // w8
  __int64 v15; // x8
  __int64 v16; // x9
  cv *v17; // x0
  char *v18; // x0
  __int64 v19; // x8
  unsigned int *v20; // x8
  unsigned int v21; // w9
  unsigned int v22; // w9
  int v23; // w8
  __int64 v24; // x8
  __int64 v25; // x9
  cv *v26; // x0
  __int64 v27; // x8
  unsigned int *v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w9
  __int64 v31; // x8
  __int64 v32; // x9
  cv *v33; // x0
  Histogram *v34; // x20
  void *v35; // x1
  __int64 v36; // x8
  unsigned int *v37; // x8
  unsigned int v38; // w9
  unsigned int v39; // w9
  int v40; // w8
  __int64 v41; // x8
  __int64 v42; // x9
  cv *v43; // x0
  __int64 v44; // x8
  unsigned int *v45; // x8
  unsigned int v46; // w9
  unsigned int v47; // w9
  int v48; // w8
  __int64 v49; // x8
  __int64 v50; // x9
  cv *v51; // x0
  __int64 v52; // x8
  unsigned int *v53; // x8
  unsigned int v54; // w9
  unsigned int v55; // w9
  int v56; // w8
  __int64 v57; // x8
  __int64 v58; // x9
  cv *v59; // x0
  __int64 v60; // x8
  unsigned int *v61; // x8
  unsigned int v62; // w9
  unsigned int v63; // w9
  int v64; // w8
  __int64 v65; // x8
  __int64 v66; // x9
  cv *v67; // x0
  __int64 v68; // x8
  unsigned int *v69; // x8
  unsigned int v70; // w9
  unsigned int v71; // w9
  int v72; // w8
  __int64 v73; // x8
  __int64 v74; // x9
  cv *v75; // x0
  __int64 v76; // x8
  unsigned int *v77; // x8
  unsigned int v78; // w9
  unsigned int v79; // w9
  int v80; // w8
  __int64 v81; // x8
  __int64 v82; // x9
  cv *v83; // x0
  __int64 v84; // x8
  unsigned int *v85; // x8
  unsigned int v86; // w9
  unsigned int v87; // w9
  int v88; // w8
  __int64 v89; // x8
  __int64 v90; // x9
  cv *v91; // x0
  __int64 v92; // x8
  unsigned int *v93; // x8
  unsigned int v94; // w9
  unsigned int v95; // w9
  int v96; // w8
  __int64 v97; // x8
  __int64 v98; // x9
  cv *v99; // x0
  __int64 v100; // x8
  unsigned int *v101; // x8
  unsigned int v102; // w9
  unsigned int v103; // w9
  int v104; // w8
  __int64 v105; // x8
  __int64 v106; // x9
  cv *v107; // x0
  __int64 v108; // x8
  unsigned int *v109; // x8
  unsigned int v110; // w9
  unsigned int v111; // w9
  int v112; // w8
  __int64 v113; // x8
  __int64 v114; // x9
  cv *v115; // x0
  __int64 v116; // x8
  unsigned int *v117; // x8
  unsigned int v118; // w9
  unsigned int v119; // w9
  int v120; // w8
  __int64 v121; // x8
  __int64 v122; // x9
  cv *v123; // x0
  __int64 v124; // x21
  __int64 v125; // x22
  std::__shared_weak_count *v126; // x20
  unsigned __int64 *v127; // x8
  unsigned __int64 v128; // x9
  void *v129; // x0
  void *v130; // x0

  free(*((void **)this + 144));
  free(*((void **)this + 145));
  free(*((void **)this + 146));
  v3 = *((_QWORD *)this + 7);
  for ( i = *((_QWORD *)this + 8); i != v3; i -= 16LL )
  {
    v5 = *(std::__shared_weak_count **)(i - 8);
    if ( v5 )
    {
      v6 = (unsigned __int64 *)((char *)v5 + 8);
      do
        v7 = __ldaxr(v6);
      while ( __stlxr(v7 - 1, v6) );
      if ( !v7 )
      {
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v5 + 16LL))(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  v8 = (char *)*((_QWORD *)this + 194);
  *((_QWORD *)this + 8) = v3;
  if ( v8 )
  {
    v9 = (char *)*((_QWORD *)this + 195);
    if ( v9 == v8 )
    {
      v18 = v8;
    }
    else
    {
      do
      {
        v10 = *((_QWORD *)v9 - 10);
        if ( v10 )
        {
          v11 = (unsigned int *)(v10 + 20);
          do
          {
            v12 = __ldaxr(v11);
            v13 = v12 - 1;
          }
          while ( __stlxr(v13, v11) );
          if ( !v13 )
            cv::Mat::deallocate((cv::Mat *)(v9 - 136));
        }
        v14 = *((_DWORD *)v9 - 33);
        *((_QWORD *)v9 - 10) = 0LL;
        *(_OWORD *)(v9 - 104) = 0u;
        *(_OWORD *)(v9 - 120) = 0u;
        if ( v14 >= 1 )
        {
          v15 = *((_QWORD *)v9 - 9);
          v16 = 0LL;
          do
            *(_DWORD *)(v15 + 4 * v16++) = 0;
          while ( v16 < *((int *)v9 - 33) );
        }
        v17 = (cv *)*((_QWORD *)v9 - 8);
        if ( v17 != (cv *)(v9 - 56) )
          cv::fastFree(v17, v2);
        v9 -= 176;
      }
      while ( v9 != v8 );
      v18 = (char *)*((_QWORD *)this + 194);
    }
    *((_QWORD *)this + 195) = v8;
    operator delete(v18);
  }
  v19 = *((_QWORD *)this + 187);
  if ( v19 )
  {
    v20 = (unsigned int *)(v19 + 20);
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while ( __stlxr(v22, v20) );
    if ( !v22 )
      cv::Mat::deallocate((CAPE *)((char *)this + 1440));
  }
  v23 = *((_DWORD *)this + 361);
  *((_QWORD *)this + 187) = 0LL;
  *((_OWORD *)this + 92) = 0u;
  *((_OWORD *)this + 91) = 0u;
  if ( v23 >= 1 )
  {
    v24 = *((_QWORD *)this + 188);
    v25 = 0LL;
    do
      *(_DWORD *)(v24 + 4 * v25++) = 0;
    while ( v25 < *((int *)this + 361) );
  }
  v26 = (cv *)*((_QWORD *)this + 189);
  if ( v26 != (CAPE *)((char *)this + 1520) )
    cv::fastFree(v26, v2);
  v27 = *((_QWORD *)this + 174);
  if ( v27 )
  {
    v28 = (unsigned int *)(v27 + 20);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while ( __stlxr(v30, v28) );
    if ( !v30 )
      cv::Mat::deallocate((CAPE *)((char *)this + 1336));
  }
  *((_QWORD *)this + 174) = 0LL;
  *(_OWORD *)((char *)this + 1368) = 0u;
  *(_OWORD *)((char *)this + 1352) = 0u;
  if ( *((int *)this + 335) >= 1 )
  {
    v31 = *((_QWORD *)this + 175);
    v32 = 0LL;
    do
      *(_DWORD *)(v31 + 4 * v32++) = 0;
    while ( v32 < *((int *)this + 335) );
  }
  v33 = (cv *)*((_QWORD *)this + 176);
  if ( v33 != (CAPE *)((char *)this + 1416) )
    cv::fastFree(v33, v2);
  v34 = (Histogram *)*((_QWORD *)this + 166);
  *((_QWORD *)this + 166) = 0LL;
  if ( v34 )
  {
    Histogram::~Histogram(v34);
    operator delete(v34);
  }
  free(*((void **)this + 142));
  v36 = *((_QWORD *)this + 137);
  if ( v36 )
  {
    v37 = (unsigned int *)(v36 + 20);
    do
    {
      v38 = __ldaxr(v37);
      v39 = v38 - 1;
    }
    while ( __stlxr(v39, v37) );
    if ( !v39 )
      cv::Mat::deallocate((CAPE *)((char *)this + 1040));
  }
  v40 = *((_DWORD *)this + 261);
  *((_QWORD *)this + 137) = 0LL;
  *((_OWORD *)this + 67) = 0u;
  *((_OWORD *)this + 66) = 0u;
  if ( v40 >= 1 )
  {
    v41 = *((_QWORD *)this + 138);
    v42 = 0LL;
    do
      *(_DWORD *)(v41 + 4 * v42++) = 0;
    while ( v42 < *((int *)this + 261) );
  }
  v43 = (cv *)*((_QWORD *)this + 139);
  if ( v43 != (CAPE *)((char *)this + 1120) )
    cv::fastFree(v43, v35);
  v44 = *((_QWORD *)this + 125);
  if ( v44 )
  {
    v45 = (unsigned int *)(v44 + 20);
    do
    {
      v46 = __ldaxr(v45);
      v47 = v46 - 1;
    }
    while ( __stlxr(v47, v45) );
    if ( !v47 )
      cv::Mat::deallocate((CAPE *)((char *)this + 944));
  }
  v48 = *((_DWORD *)this + 237);
  *((_QWORD *)this + 125) = 0LL;
  *((_OWORD *)this + 60) = 0u;
  *((_OWORD *)this + 61) = 0u;
  if ( v48 >= 1 )
  {
    v49 = *((_QWORD *)this + 126);
    v50 = 0LL;
    do
      *(_DWORD *)(v49 + 4 * v50++) = 0;
    while ( v50 < *((int *)this + 237) );
  }
  v51 = (cv *)*((_QWORD *)this + 127);
  if ( v51 != (CAPE *)((char *)this + 1024) )
    cv::fastFree(v51, v35);
  v52 = *((_QWORD *)this + 113);
  if ( v52 )
  {
    v53 = (unsigned int *)(v52 + 20);
    do
    {
      v54 = __ldaxr(v53);
      v55 = v54 - 1;
    }
    while ( __stlxr(v55, v53) );
    if ( !v55 )
      cv::Mat::deallocate((CAPE *)((char *)this + 848));
  }
  v56 = *((_DWORD *)this + 213);
  *((_QWORD *)this + 113) = 0LL;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  if ( v56 >= 1 )
  {
    v57 = *((_QWORD *)this + 114);
    v58 = 0LL;
    do
      *(_DWORD *)(v57 + 4 * v58++) = 0;
    while ( v58 < *((int *)this + 213) );
  }
  v59 = (cv *)*((_QWORD *)this + 115);
  if ( v59 != (CAPE *)((char *)this + 928) )
    cv::fastFree(v59, v35);
  v60 = *((_QWORD *)this + 101);
  if ( v60 )
  {
    v61 = (unsigned int *)(v60 + 20);
    do
    {
      v62 = __ldaxr(v61);
      v63 = v62 - 1;
    }
    while ( __stlxr(v63, v61) );
    if ( !v63 )
      cv::Mat::deallocate((CAPE *)((char *)this + 752));
  }
  v64 = *((_DWORD *)this + 189);
  *((_QWORD *)this + 101) = 0LL;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  if ( v64 >= 1 )
  {
    v65 = *((_QWORD *)this + 102);
    v66 = 0LL;
    do
      *(_DWORD *)(v65 + 4 * v66++) = 0;
    while ( v66 < *((int *)this + 189) );
  }
  v67 = (cv *)*((_QWORD *)this + 103);
  if ( v67 != (CAPE *)((char *)this + 832) )
    cv::fastFree(v67, v35);
  v68 = *((_QWORD *)this + 89);
  if ( v68 )
  {
    v69 = (unsigned int *)(v68 + 20);
    do
    {
      v70 = __ldaxr(v69);
      v71 = v70 - 1;
    }
    while ( __stlxr(v71, v69) );
    if ( !v71 )
      cv::Mat::deallocate((CAPE *)((char *)this + 656));
  }
  v72 = *((_DWORD *)this + 165);
  *((_QWORD *)this + 89) = 0LL;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  if ( v72 >= 1 )
  {
    v73 = *((_QWORD *)this + 90);
    v74 = 0LL;
    do
      *(_DWORD *)(v73 + 4 * v74++) = 0;
    while ( v74 < *((int *)this + 165) );
  }
  v75 = (cv *)*((_QWORD *)this + 91);
  if ( v75 != (CAPE *)((char *)this + 736) )
    cv::fastFree(v75, v35);
  v76 = *((_QWORD *)this + 77);
  if ( v76 )
  {
    v77 = (unsigned int *)(v76 + 20);
    do
    {
      v78 = __ldaxr(v77);
      v79 = v78 - 1;
    }
    while ( __stlxr(v79, v77) );
    if ( !v79 )
      cv::Mat::deallocate((CAPE *)((char *)this + 560));
  }
  v80 = *((_DWORD *)this + 141);
  *((_QWORD *)this + 77) = 0LL;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  if ( v80 >= 1 )
  {
    v81 = *((_QWORD *)this + 78);
    v82 = 0LL;
    do
      *(_DWORD *)(v81 + 4 * v82++) = 0;
    while ( v82 < *((int *)this + 141) );
  }
  v83 = (cv *)*((_QWORD *)this + 79);
  if ( v83 != (CAPE *)((char *)this + 640) )
    cv::fastFree(v83, v35);
  v84 = *((_QWORD *)this + 65);
  if ( v84 )
  {
    v85 = (unsigned int *)(v84 + 20);
    do
    {
      v86 = __ldaxr(v85);
      v87 = v86 - 1;
    }
    while ( __stlxr(v87, v85) );
    if ( !v87 )
      cv::Mat::deallocate((CAPE *)((char *)this + 464));
  }
  v88 = *((_DWORD *)this + 117);
  *((_QWORD *)this + 65) = 0LL;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  if ( v88 >= 1 )
  {
    v89 = *((_QWORD *)this + 66);
    v90 = 0LL;
    do
      *(_DWORD *)(v89 + 4 * v90++) = 0;
    while ( v90 < *((int *)this + 117) );
  }
  v91 = (cv *)*((_QWORD *)this + 67);
  if ( v91 != (CAPE *)((char *)this + 544) )
    cv::fastFree(v91, v35);
  v92 = *((_QWORD *)this + 53);
  if ( v92 )
  {
    v93 = (unsigned int *)(v92 + 20);
    do
    {
      v94 = __ldaxr(v93);
      v95 = v94 - 1;
    }
    while ( __stlxr(v95, v93) );
    if ( !v95 )
      cv::Mat::deallocate((CAPE *)((char *)this + 368));
  }
  v96 = *((_DWORD *)this + 93);
  *((_QWORD *)this + 53) = 0LL;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  if ( v96 >= 1 )
  {
    v97 = *((_QWORD *)this + 54);
    v98 = 0LL;
    do
      *(_DWORD *)(v97 + 4 * v98++) = 0;
    while ( v98 < *((int *)this + 93) );
  }
  v99 = (cv *)*((_QWORD *)this + 55);
  if ( v99 != (CAPE *)((char *)this + 448) )
    cv::fastFree(v99, v35);
  v100 = *((_QWORD *)this + 41);
  if ( v100 )
  {
    v101 = (unsigned int *)(v100 + 20);
    do
    {
      v102 = __ldaxr(v101);
      v103 = v102 - 1;
    }
    while ( __stlxr(v103, v101) );
    if ( !v103 )
      cv::Mat::deallocate((CAPE *)((char *)this + 272));
  }
  v104 = *((_DWORD *)this + 69);
  *((_QWORD *)this + 41) = 0LL;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  if ( v104 >= 1 )
  {
    v105 = *((_QWORD *)this + 42);
    v106 = 0LL;
    do
      *(_DWORD *)(v105 + 4 * v106++) = 0;
    while ( v106 < *((int *)this + 69) );
  }
  v107 = (cv *)*((_QWORD *)this + 43);
  if ( v107 != (CAPE *)((char *)this + 352) )
    cv::fastFree(v107, v35);
  v108 = *((_QWORD *)this + 29);
  if ( v108 )
  {
    v109 = (unsigned int *)(v108 + 20);
    do
    {
      v110 = __ldaxr(v109);
      v111 = v110 - 1;
    }
    while ( __stlxr(v111, v109) );
    if ( !v111 )
      cv::Mat::deallocate((CAPE *)((char *)this + 176));
  }
  v112 = *((_DWORD *)this + 45);
  *((_QWORD *)this + 29) = 0LL;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  if ( v112 >= 1 )
  {
    v113 = *((_QWORD *)this + 30);
    v114 = 0LL;
    do
      *(_DWORD *)(v113 + 4 * v114++) = 0;
    while ( v114 < *((int *)this + 45) );
  }
  v115 = (cv *)*((_QWORD *)this + 31);
  if ( v115 != (CAPE *)((char *)this + 256) )
    cv::fastFree(v115, v35);
  v116 = *((_QWORD *)this + 17);
  if ( v116 )
  {
    v117 = (unsigned int *)(v116 + 20);
    do
    {
      v118 = __ldaxr(v117);
      v119 = v118 - 1;
    }
    while ( __stlxr(v119, v117) );
    if ( !v119 )
      cv::Mat::deallocate((CAPE *)((char *)this + 80));
  }
  v120 = *((_DWORD *)this + 21);
  *((_QWORD *)this + 17) = 0LL;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  if ( v120 >= 1 )
  {
    v121 = *((_QWORD *)this + 18);
    v122 = 0LL;
    do
      *(_DWORD *)(v121 + 4 * v122++) = 0;
    while ( v122 < *((int *)this + 21) );
  }
  v123 = (cv *)*((_QWORD *)this + 19);
  if ( v123 != (CAPE *)((char *)this + 160) )
    cv::fastFree(v123, v35);
  v124 = *((_QWORD *)this + 7);
  if ( v124 )
  {
    v125 = *((_QWORD *)this + 8);
    if ( v125 == v124 )
    {
      v129 = (void *)*((_QWORD *)this + 7);
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v126 = *(std::__shared_weak_count **)(v125 - 8);
          v125 -= 16LL;
          if ( v126 )
          {
            v127 = (unsigned __int64 *)((char *)v126 + 8);
            do
              v128 = __ldaxr(v127);
            while ( __stlxr(v128 - 1, v127) );
            if ( !v128 )
              break;
          }
          if ( v125 == v124 )
            goto LABEL_165;
        }
        (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v126 + 16LL))(v126);
        std::__shared_weak_count::__release_weak(v126);
      }
      while ( v125 != v124 );
LABEL_165:
      v129 = (void *)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 8) = v124;
    operator delete(v129);
  }
  v130 = (void *)*((_QWORD *)this + 4);
  if ( v130 )
  {
    *((_QWORD *)this + 5) = v130;
    operator delete(v130);
  }
}
// 4FDE8: variable 'v2' is possibly undefined
// 4FF90: variable 'v35' is possibly undefined

//----- (00000000000504D0) ----------------------------------------------------
void __fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix(__int64 *a1, __int64 *a2)
{
  __int64 v4; // x1
  __int64 v5; // x2
  __int64 v6; // x8
  __int64 v7; // x9
  signed __int64 v8; // x9
  __int64 v9; // x10
  signed __int64 v10; // x11
  __int64 v11; // x10
  __int64 v12; // x11
  __int64 v13; // x12
  __int64 v14; // x14
  __int64 v15; // x15
  __int128 *v16; // x14
  _OWORD *v17; // x15
  unsigned __int64 v18; // x16
  __int128 v19; // q0
  __int128 v20; // q1
  __int64 v21; // x12
  __int64 v22; // x8
  _DWORD *v23; // x9
  int *v24; // x10
  int v25; // t1
  std::bad_alloc *exception; // x20

  Eigen::DenseStorage<float,-1,-1,-1,0>::DenseStorage(a1, a2[2] * a2[1], a2[1], a2[2]);
  v4 = a2[1];
  v5 = a2[2];
  if ( v4 && v5 && 0x7FFFFFFFFFFFFFFFLL / v5 < v4 )
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize((__int64)a1, v4, v5);
  v6 = a1[2] * a1[1];
  v7 = v6 + 3;
  if ( v6 >= 0 )
    v7 = a1[2] * a1[1];
  v8 = v7 & 0xFFFFFFFFFFFFFFFCLL;
  if ( v6 >= 4 )
  {
    v9 = 0LL;
    v10 = 0LL;
    do
    {
      v10 += 4LL;
      *(_OWORD *)(*a1 + v9) = *(_OWORD *)(*a2 + v9);
      v9 += 16LL;
    }
    while ( v10 < v8 );
  }
  if ( v8 < v6 )
  {
    v11 = *a2;
    v12 = *a1;
    v13 = v6 - v8;
    if ( (unsigned __int64)(v6 - v8) < 8 )
      goto LABEL_16;
    v14 = 4 * v8;
    if ( v12 + 4 * v8 < (unsigned __int64)(v11 + 4 * v6) && v11 + v14 < (unsigned __int64)(v12 + 4 * v6) )
      goto LABEL_16;
    v15 = v14 + 16;
    v8 += v13 & 0xFFFFFFFFFFFFFFF8LL;
    v16 = (__int128 *)(v11 + v14 + 16);
    v17 = (_OWORD *)(v12 + v15);
    v18 = v13 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v19 = *(v16 - 1);
      v20 = *v16;
      v16 += 2;
      v18 -= 8LL;
      *(v17 - 1) = v19;
      *v17 = v20;
      v17 += 2;
    }
    while ( v18 );
    if ( v13 != (v13 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_16:
      v21 = 4 * v8;
      v22 = v6 - v8;
      v23 = (_DWORD *)(v12 + 4 * v8);
      v24 = (int *)(v11 + v21);
      do
      {
        v25 = *v24++;
        --v22;
        *v23++ = v25;
      }
      while ( v22 );
    }
  }
}

//----- (0000000000050644) ----------------------------------------------------
_QWORD *__fastcall Eigen::DenseStorage<float,-1,-1,-1,0>::DenseStorage(
        _QWORD *result,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4)
{
  _QWORD *v6; // x21
  __int64 v7; // x22
  void *v8; // x8
  _BOOL4 v9; // w9
  std::bad_alloc *exception; // x19
  void *v11[2]; // [xsp+0h] [xbp-40h] BYREF

  v6 = result;
  v11[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v8 = 0LL;
    goto LABEL_9;
  }
  if ( a2 >> 62 )
    goto LABEL_6;
  v7 = 4 * a2;
  result = (_QWORD *)posix_memalign(v11, 0x10uLL, 4 * a2);
  if ( (_DWORD)result )
  {
    v8 = 0LL;
    v9 = 1;
    v11[0] = 0LL;
    if ( !v7 )
      goto LABEL_9;
  }
  else
  {
    v8 = v11[0];
    v9 = v11[0] == 0LL;
    if ( !v7 )
      goto LABEL_9;
  }
  if ( v9 )
  {
LABEL_6:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
LABEL_9:
  *v6 = v8;
  v6[1] = a3;
  v6[2] = a4;
  return result;
}

//----- (0000000000050720) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace(void **a1)
{
  *a1 = off_6E230;
  PlaneSeg::~PlaneSeg(a1 + 3);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)a1);
}
// 6E230: using guessed type __int64 (__fastcall *off_6E230[3])();

//----- (0000000000050754) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::~__shared_ptr_emplace(void **a1)
{
  *a1 = off_6E230;
  PlaneSeg::~PlaneSeg(a1 + 3);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)a1);
  operator delete(a1);
}
// 6E230: using guessed type __int64 (__fastcall *off_6E230[3])();

//----- (0000000000050790) ----------------------------------------------------
void __fastcall std::__shared_ptr_emplace<PlaneSeg>::__on_zero_shared(__int64 a1)
{
  PlaneSeg::~PlaneSeg((void **)(a1 + 24));
}

//----- (000000000005079C) ----------------------------------------------------
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg>>(
        char **a1,
        __int64 a2)
{
  __int64 v3; // x22
  __int64 v5; // x9
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x23
  __int64 v8; // x0
  char *v9; // x10
  char *v10; // x8
  char *v11; // x11
  char *v12; // x21
  unsigned __int64 v13; // x12
  char *v14; // x10
  __int128 v15; // t1
  char *v16; // x20
  std::__shared_weak_count *v17; // x19
  unsigned __int64 *v18; // x8
  unsigned __int64 v19; // x9

  v3 = (a1[1] - *a1) >> 4;
  if ( (unsigned __int64)(v3 + 1) >> 60 )
    std::__vector_base_common<true>::__throw_length_error();
  v5 = a1[2] - *a1;
  if ( (unsigned __int64)(v5 >> 4) > 0x7FFFFFFFFFFFFFELL )
  {
    v7 = 0xFFFFFFFFFFFFFFFLL;
LABEL_10:
    v8 = operator new(16 * v7);
    goto LABEL_11;
  }
  v6 = v5 >> 3;
  if ( v6 >= v3 + 1 )
    v7 = v6;
  else
    v7 = v3 + 1;
  if ( v7 )
  {
    if ( v7 >> 60 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v8 = 0LL;
LABEL_11:
  v9 = (char *)(v8 + 16 * v3);
  *(_OWORD *)v9 = *(_OWORD *)a2;
  v10 = v9 + 16;
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  v12 = *a1;
  v11 = a1[1];
  if ( v11 == *a1 )
  {
    v16 = *a1;
  }
  else
  {
    v13 = v3 + ~((unsigned __int64)(v11 - 16 - v12) >> 4);
    v14 = v9 - 16;
    do
    {
      v15 = *((_OWORD *)v11 - 1);
      v11 -= 16;
      *(_OWORD *)v14 = v15;
      v14 -= 16;
      *(_QWORD *)v11 = 0LL;
      *((_QWORD *)v11 + 1) = 0LL;
    }
    while ( v12 != v11 );
    v16 = *a1;
    v12 = a1[1];
    v9 = (char *)(v8 + 16 * v13);
  }
  *a1 = v9;
  a1[1] = v10;
  a1[2] = (char *)(v8 + 16 * v7);
  while ( v12 != v16 )
  {
    while ( 1 )
    {
      v17 = (std::__shared_weak_count *)*((_QWORD *)v12 - 1);
      v12 -= 16;
      if ( v17 )
      {
        v18 = (unsigned __int64 *)((char *)v17 + 8);
        do
          v19 = __ldaxr(v18);
        while ( __stlxr(v19 - 1, v18) );
        if ( !v19 )
          break;
      }
      if ( v12 == v16 )
        goto LABEL_24;
    }
    (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v17 + 16LL))(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_24:
  if ( v16 )
    operator delete(v16);
}

//----- (0000000000050914) ----------------------------------------------------
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // x22
  size_t v7; // x22
  void *v8; // x8
  _BOOL4 v9; // w9
  std::bad_alloc *exception; // x19
  void *v11[2]; // [xsp+0h] [xbp-40h] BYREF

  v11[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 && a3 && 0x7FFFFFFFFFFFFFFFLL / a3 < a2 )
  {
LABEL_10:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  v6 = a3 * a2;
  if ( *(_QWORD *)(a1 + 16) * *(_QWORD *)(a1 + 8) != a3 * a2 )
  {
    free(*(void **)a1);
    if ( v6 )
    {
      if ( v6 >> 61 )
        goto LABEL_10;
      v7 = 8 * v6;
      if ( posix_memalign(v11, 0x10uLL, v7) )
      {
        v8 = 0LL;
        v9 = 1;
        v11[0] = 0LL;
        if ( v7 )
          goto LABEL_9;
      }
      else
      {
        v8 = v11[0];
        v9 = v11[0] == 0LL;
        if ( v7 )
        {
LABEL_9:
          if ( v9 )
            goto LABEL_10;
        }
      }
    }
    else
    {
      v8 = 0LL;
    }
    *(_QWORD *)a1 = v8;
  }
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
}

//----- (0000000000050A24) ----------------------------------------------------
void __fastcall std::vector<std::shared_ptr<PlaneSeg>>::__push_back_slow_path<std::shared_ptr<PlaneSeg> const&>(
        __int64 a1,
        _QWORD *a2)
{
  char *v2; // x19
  char *v3; // x22
  __int64 v5; // x23
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x24
  __int64 v10; // x0
  _QWORD *v11; // x9
  __int64 v12; // x8
  unsigned __int64 *v13; // x8
  unsigned __int64 v14; // x10
  _QWORD *v15; // x10
  unsigned __int64 v16; // x9
  _OWORD *v17; // x11
  __int128 v18; // t1
  std::__shared_weak_count *v19; // x20
  unsigned __int64 *v20; // x8
  unsigned __int64 v21; // x9

  v2 = *(char **)a1;
  v3 = *(char **)(a1 + 8);
  v5 = (__int64)&v3[-*(_QWORD *)a1] >> 4;
  if ( (unsigned __int64)(v5 + 1) >> 60 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 4) > 0x7FFFFFFFFFFFFFELL )
  {
    v9 = 0xFFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = operator new(16 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 3;
  if ( v8 >= v5 + 1 )
    v9 = v8;
  else
    v9 = v5 + 1;
  if ( v9 )
  {
    if ( v9 >> 60 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = (_QWORD *)(v10 + 16 * v5);
  *v11 = *a2;
  v12 = a2[1];
  v11[1] = v12;
  if ( v12 )
  {
    v13 = (unsigned __int64 *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while ( __stxr(v14 + 1, v13) );
    v2 = *(char **)a1;
    v3 = *(char **)(a1 + 8);
  }
  v15 = v11 + 2;
  if ( v3 != v2 )
  {
    v16 = v5 + ~((unsigned __int64)(v3 - 16 - v2) >> 4);
    v17 = (_OWORD *)(v10 + 16 * v5 - 16);
    do
    {
      v18 = *((_OWORD *)v3 - 1);
      v3 -= 16;
      *v17-- = v18;
      *(_QWORD *)v3 = 0LL;
      *((_QWORD *)v3 + 1) = 0LL;
    }
    while ( v2 != v3 );
    v2 = *(char **)a1;
    v3 = *(char **)(a1 + 8);
    v11 = (_QWORD *)(v10 + 16 * v16);
  }
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v15;
  *(_QWORD *)(a1 + 16) = v10 + 16 * v9;
  while ( v3 != v2 )
  {
    while ( 1 )
    {
      v19 = (std::__shared_weak_count *)*((_QWORD *)v3 - 1);
      v3 -= 16;
      if ( v19 )
      {
        v20 = (unsigned __int64 *)((char *)v19 + 8);
        do
          v21 = __ldaxr(v20);
        while ( __stlxr(v21 - 1, v20) );
        if ( !v21 )
          break;
      }
      if ( v3 == v2 )
        goto LABEL_27;
    }
    (*(void (__fastcall **)(std::__shared_weak_count *))(*(_QWORD *)v19 + 16LL))(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_27:
  if ( v2 )
    operator delete(v2);
}

//----- (0000000000050BB4) ----------------------------------------------------
void __fastcall Eigen::PlainObjectBase<Eigen::Matrix<bool,-1,-1,0,-1,-1>>::resize(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x22
  void *v7; // x8
  std::bad_alloc *exception; // x19
  void *v9[2]; // [xsp+0h] [xbp-40h] BYREF

  v9[1] = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 && a3 && 0x7FFFFFFFFFFFFFFFLL / a3 < a2 )
    goto LABEL_13;
  v6 = a3 * a2;
  if ( *(_QWORD *)(a1 + 16) * *(_QWORD *)(a1 + 8) != a3 * a2 )
  {
    free(*(void **)a1);
    if ( v6 )
    {
      if ( posix_memalign(v9, 0x10uLL, a3 * a2) )
      {
        v9[0] = 0LL;
        goto LABEL_13;
      }
      v7 = v9[0];
      if ( !v9[0] )
      {
LABEL_13:
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        std::bad_alloc::bad_alloc(exception);
        __cxa_throw(
          exception,
          (struct type_info *)&`typeinfo for'std::bad_alloc,
          (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
      }
    }
    else
    {
      v7 = 0LL;
    }
    *(_QWORD *)a1 = v7;
  }
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
}

//----- (0000000000050CA0) ----------------------------------------------------
void __fastcall std::vector<PlaneSeg>::__push_back_slow_path<PlaneSeg const&>(void ***a1, __int64 a2)
{
  unsigned __int64 v2; // x26
  unsigned __int64 v3; // x25
  __int64 v6; // x19
  __int128 v7; // q1
  __int64 v8; // x21
  __int128 v9; // q1
  __int128 v10; // q2
  __int128 v11; // q3
  void **v12; // x22
  void **v13; // x27
  void **v14; // x26
  void **v15; // x25
  void **v16; // x24
  __int128 v17; // q1
  __int128 v18; // q1
  __int128 v19; // q2
  __int128 v20; // q3
  void **v21; // x19

  v2 = 0xCF3CF3CF3CF3CF3DLL * (a1[1] - *a1);
  v3 = 0x186186186186186LL;
  if ( v2 + 1 > 0x186186186186186LL )
    std::__vector_base_common<true>::__throw_length_error();
  if ( 0xCF3CF3CF3CF3CF3DLL * (a1[2] - *a1) > 0xC30C30C30C30C2LL
    || (0x9E79E79E79E79E7ALL * (a1[2] - *a1) >= v2 + 1 ? (v3 = 0x9E79E79E79E79E7ALL * (a1[2] - *a1)) : (v3 = v2 + 1), v3) )
  {
    v6 = operator new(168 * v3);
  }
  else
  {
    v6 = 0LL;
  }
  v7 = *(_OWORD *)(a2 + 16);
  v8 = v6 + 168 * v2;
  *(_OWORD *)v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v7;
  v9 = *(_OWORD *)(a2 + 80);
  v10 = *(_OWORD *)(a2 + 32);
  v11 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v8 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 80) = v9;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = v11;
  Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v8 + 96), (__int64 *)(a2 + 96));
  Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v8 + 120), (__int64 *)(a2 + 120));
  Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)(v8 + 144), (__int64 *)(a2 + 144));
  v12 = *a1;
  v13 = a1[1];
  v14 = (void **)(v6 + 168 * v3);
  v15 = (void **)(v8 + 168);
  if ( v13 == *a1 )
  {
    *a1 = (void **)v8;
    a1[1] = v15;
    a1[2] = v14;
    if ( v12 )
LABEL_14:
      operator delete(v12);
  }
  else
  {
    v16 = (void **)v8;
    do
    {
      v17 = *(_OWORD *)(v13 - 21);
      *(_OWORD *)(v16 - 19) = *(_OWORD *)(v13 - 19);
      *(_OWORD *)(v16 - 21) = v17;
      v18 = *(_OWORD *)(v13 - 13);
      v19 = *(_OWORD *)(v13 - 15);
      v20 = *(_OWORD *)(v13 - 17);
      *(_OWORD *)(v16 - 11) = *(_OWORD *)(v13 - 11);
      *(_OWORD *)(v16 - 13) = v18;
      *(_OWORD *)(v16 - 15) = v19;
      *(_OWORD *)(v16 - 17) = v20;
      Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)v16 - 9, (__int64 *)v13 - 9);
      Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)v16 - 6, (__int64 *)v13 - 6);
      Eigen::Matrix<float,-1,-1,0,-1,-1>::Matrix((__int64 *)v16 - 3, (__int64 *)v13 - 3);
      v13 -= 21;
      v16 -= 21;
    }
    while ( v12 != v13 );
    v12 = *a1;
    v21 = a1[1];
    *a1 = v16;
    a1[1] = v15;
    a1[2] = v14;
    while ( v12 != v21 )
    {
      v21 -= 21;
      PlaneSeg::~PlaneSeg(v21);
    }
    if ( v12 )
      goto LABEL_14;
  }
}

//----- (0000000000050F44) ----------------------------------------------------
void __fastcall std::vector<ground_filter::plane_base>::__append(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x10
  unsigned __int64 v4; // x20
  __int64 v6; // x23
  __int64 v7; // x24
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x10
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 v12; // x9
  __int64 v13; // x11
  unsigned __int64 v14; // x12
  __int64 v15; // x10
  __int64 v16; // x20
  __int64 v17; // x23
  __int64 v18; // x8
  __int64 v19; // [xsp+0h] [xbp-60h] BYREF
  __int64 v20; // [xsp+8h] [xbp-58h]
  __int64 v21; // [xsp+10h] [xbp-50h]
  __int64 v22; // [xsp+18h] [xbp-48h]
  _QWORD *v23; // [xsp+20h] [xbp-40h]
  __int64 v24; // [xsp+28h] [xbp-38h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = a1[1];
  v3 = a1[2];
  v4 = a2;
  if ( 0x2E8BA2E8BA2E8BA3LL * ((v3 - v2) >> 4) >= a2 )
  {
    do
    {
      *(_QWORD *)(v2 + 104) = v2 + 48;
      *(_DWORD *)(v2 + 40) = 1124007936;
      *(_OWORD *)(v2 + 88) = 0uLL;
      *(_OWORD *)(v2 + 76) = 0uLL;
      *(_OWORD *)(v2 + 60) = 0uLL;
      *(_OWORD *)(v2 + 44) = 0uLL;
      *(_QWORD *)(v2 + 128) = 0LL;
      *(_QWORD *)(v2 + 136) = 0LL;
      *(_QWORD *)(v2 + 120) = 0LL;
      *(_DWORD *)(v2 + 144) = 0;
      *(_DWORD *)(v2 + 32) = 0;
      *(_OWORD *)v2 = 0uLL;
      *(_OWORD *)(v2 + 16) = 0uLL;
      *(_OWORD *)(v2 + 148) = xmmword_54780;
      *(_DWORD *)(v2 + 168) = 0;
      *(_QWORD *)(v2 + 112) = v2 + 120;
      --v4;
      v2 = a1[1] + 176;
      a1[1] = v2;
    }
    while ( v4 );
    return;
  }
  v6 = 0x2E8BA2E8BA2E8BA3LL * ((v2 - *a1) >> 4);
  v7 = 0x1745D1745D1745DLL;
  if ( v6 + a2 > 0x1745D1745D1745DLL )
    std::__vector_base_common<true>::__throw_length_error();
  v8 = 0x2E8BA2E8BA2E8BA3LL * ((v3 - *a1) >> 4);
  if ( v8 >= 0xBA2E8BA2E8BA2ELL )
  {
    v22 = 0LL;
    v23 = a1 + 2;
  }
  else
  {
    v9 = 2 * v8;
    if ( v9 >= v6 + a2 )
      v7 = v9;
    else
      v7 = v6 + a2;
    v22 = 0LL;
    v23 = a1 + 2;
    if ( !v7 )
    {
      v10 = 0LL;
      goto LABEL_13;
    }
  }
  v10 = operator new(176 * v7);
LABEL_13:
  v11 = v10 + 176 * v6;
  v12 = v10 + 176 * v7;
  v13 = v11 + 104;
  v14 = v4;
  v21 = v11;
  v22 = v12;
  v19 = v10;
  v20 = v11;
  do
  {
    *(_QWORD *)v13 = v13 - 56;
    *(_DWORD *)(v13 - 64) = 1124007936;
    *(_OWORD *)(v13 - 16) = 0uLL;
    *(_OWORD *)(v13 - 28) = 0uLL;
    *(_OWORD *)(v13 - 44) = 0uLL;
    *(_OWORD *)(v13 - 60) = 0uLL;
    *(_QWORD *)(v13 + 24) = 0LL;
    *(_QWORD *)(v13 + 32) = 0LL;
    *(_QWORD *)(v13 + 16) = 0LL;
    *(_DWORD *)(v13 + 40) = 0;
    --v14;
    *(_DWORD *)(v13 - 72) = 0;
    *(_OWORD *)(v13 - 88) = 0uLL;
    *(_OWORD *)(v13 - 104) = 0uLL;
    *(_OWORD *)(v13 + 44) = xmmword_54780;
    *(_DWORD *)(v13 + 64) = 0;
    *(_QWORD *)(v13 + 8) = v13 + 16;
    v13 += 176LL;
  }
  while ( v14 );
  v15 = v11 + 176 * v4;
  v21 = v15;
  v17 = *a1;
  v16 = a1[1];
  if ( v16 != *a1 )
  {
    do
    {
      v16 -= 176LL;
      ground_filter::plane_base::plane_base(v11 - 176, v16);
      v11 = v20 - 176;
      v20 -= 176LL;
    }
    while ( v17 != v16 );
    v17 = *a1;
    v16 = a1[1];
    v15 = v21;
    v12 = v22;
  }
  *a1 = v11;
  a1[1] = v15;
  v20 = v17;
  v21 = v16;
  v18 = a1[2];
  a1[2] = v12;
  v22 = v18;
  v19 = v17;
  std::__split_buffer<ground_filter::plane_base>::~__split_buffer((__int64)&v19, (void *)a2);
}
// 51180: variable 'a2' is possibly undefined
// 54780: using guessed type __int128 xmmword_54780;

//----- (00000000000511CC) ----------------------------------------------------
void __fastcall std::__split_buffer<ground_filter::plane_base>::~__split_buffer(__int64 a1, void *a2)
{
  __int64 v2; // x20
  __int64 i; // x21
  __int64 v5; // x8
  unsigned int *v6; // x8
  unsigned int v7; // w9
  unsigned int v8; // w9
  int v9; // w8
  __int64 v10; // x8
  __int64 v11; // x9
  cv *v12; // x0

  v2 = *(_QWORD *)(a1 + 8);
  for ( i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16) )
  {
    *(_QWORD *)(a1 + 16) = i - 176;
    v5 = *(_QWORD *)(i - 80);
    if ( v5 )
    {
      v6 = (unsigned int *)(v5 + 20);
      do
      {
        v7 = __ldaxr(v6);
        v8 = v7 - 1;
      }
      while ( __stlxr(v8, v6) );
      if ( !v8 )
        cv::Mat::deallocate((cv::Mat *)(i - 136));
    }
    v9 = *(_DWORD *)(i - 132);
    *(_QWORD *)(i - 80) = 0LL;
    *(_OWORD *)(i - 104) = 0u;
    *(_OWORD *)(i - 120) = 0u;
    if ( v9 >= 1 )
    {
      v10 = *(_QWORD *)(i - 72);
      v11 = 0LL;
      do
        *(_DWORD *)(v10 + 4 * v11++) = 0;
      while ( v11 < *(int *)(i - 132) );
    }
    v12 = *(cv **)(i - 64);
    if ( v12 != (cv *)(i - 56) )
      cv::fastFree(v12, a2);
  }
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
}
// 51288: variable 'a2' is possibly undefined

//----- (00000000000512A4) ----------------------------------------------------
void __fastcall Histogram::Histogram(Histogram *this, int a2)
{
  int v2; // [xsp+4h] [xbp-1Ch] BYREF
  __int64 v3; // [xsp+8h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 12) = a2;
  *((_DWORD *)this + 13) = a2 * a2;
  v2 = 0;
  std::vector<int>::assign((float32x4_t **)this, (unsigned int)(a2 * a2), (const float *)&v2);
}

//----- (000000000005134C) ----------------------------------------------------
float32x4_t *__fastcall std::vector<int>::assign(float32x4_t **a1, unsigned __int64 a2, const float *a3)
{
  __int64 v4; // x8
  float32x4_t *result; // x0
  unsigned __int64 v8; // x9
  bool v9; // cf
  __int64 v10; // x8
  unsigned __int64 v11; // x8
  char **v12; // x20
  unsigned __int64 v13; // t1
  unsigned __int64 v14; // x9
  unsigned __int64 v15; // x10
  char *v16; // x11
  __int64 v17; // x22
  char *v18; // x9
  unsigned __int64 v19; // x10
  float32x4_t v20; // q0
  float32x4_t *v21; // x14
  unsigned __int64 v22; // x15
  unsigned __int64 v23; // x9
  _DWORD *v24; // x10
  unsigned __int64 v25; // x11
  char *v26; // x9
  float32x4_t v27; // q0
  float32x4_t *v28; // x13
  unsigned __int64 v29; // x14
  float32x4_t v30; // q0
  float32x4_t *v31; // x12
  unsigned __int64 v32; // x13

  v4 = (__int64)a1[2];
  result = *a1;
  if ( a2 > (v4 - (__int64)result) >> 2 )
  {
    if ( result )
    {
      a1[1] = result;
      operator delete(result);
      v4 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }
    if ( a2 >> 62 )
LABEL_9:
      std::__vector_base_common<true>::__throw_length_error();
    if ( (unsigned __int64)(v4 >> 2) > 0x1FFFFFFFFFFFFFFELL )
    {
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else
    {
      v8 = v4 >> 1;
      v9 = v4 >> 1 >= a2;
      v10 = a2;
      if ( v9 )
      {
        v10 = v8;
        if ( v8 >> 62 )
          goto LABEL_9;
      }
    }
    v17 = 4 * v10;
    result = (float32x4_t *)operator new(4 * v10);
    a1[1] = result;
    a1[2] = (float32x4_t *)((char *)result + v17);
    v18 = (char *)result;
    v19 = a2;
    *a1 = result;
    if ( a2 >= 8 )
    {
      if ( result >= (float32x4_t *)((char *)a3 + 1) || (char *)result + 4 * a2 <= (char *)a3 )
      {
        v30 = vld1q_dup_f32(a3);
        v18 = (char *)result + 4 * (a2 & 0xFFFFFFFFFFFFFFF8LL);
        v19 = a2 - (a2 & 0xFFFFFFFFFFFFFFF8LL);
        v31 = result + 1;
        v32 = a2 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v31[-1] = v30;
          *v31 = v30;
          v32 -= 8LL;
          v31 += 2;
        }
        while ( v32 );
        if ( (a2 & 0xFFFFFFFFFFFFFFF8LL) == a2 )
          goto LABEL_42;
      }
      else
      {
        v18 = (char *)result;
        v19 = a2;
      }
    }
    do
    {
      --v19;
      *(float *)v18 = *a3;
      v18 += 4;
    }
    while ( v19 );
LABEL_42:
    v26 = (char *)result + 4 * a2;
    v12 = (char **)(a1 + 1);
    goto LABEL_43;
  }
  v13 = (unsigned __int64)a1[1];
  v12 = (char **)(a1 + 1);
  v11 = v13;
  v14 = (__int64)(v13 - (_QWORD)result) >> 2;
  if ( v14 >= a2 )
    v15 = a2;
  else
    v15 = v14;
  if ( v15 )
  {
    if ( v15 < 8 )
    {
      v16 = (char *)result;
      do
      {
LABEL_26:
        --v15;
        *(float *)v16 = *a3;
        v16 += 4;
      }
      while ( v15 );
      goto LABEL_27;
    }
    if ( (char *)a3 + 1 > (char *)result )
    {
      v16 = (char *)result;
      if ( (char *)result + 4 * v15 > (char *)a3 )
        goto LABEL_26;
    }
    v20 = vld1q_dup_f32(a3);
    v16 = (char *)result + 4 * (v15 & 0xFFFFFFFFFFFFFFF8LL);
    v21 = result + 1;
    v22 = v15 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v21[-1] = v20;
      *v21 = v20;
      v22 -= 8LL;
      v21 += 2;
    }
    while ( v22 );
    v15 -= v15 & 0xFFFFFFFFFFFFFFF8LL;
    if ( v15 )
      goto LABEL_26;
  }
LABEL_27:
  if ( v14 < a2 )
  {
    v23 = a2 - v14;
    if ( v23 >= 8 )
    {
      if ( (unsigned __int64)a3 + 1 <= v11 || (v24 = (_DWORD *)v11, v25 = v23, v11 + 4 * v23 <= (unsigned __int64)a3) )
      {
        v27 = vld1q_dup_f32(a3);
        v24 = (_DWORD *)(v11 + 4 * (v23 & 0xFFFFFFFFFFFFFFF8LL));
        v25 = v23 - (v23 & 0xFFFFFFFFFFFFFFF8LL);
        v28 = (float32x4_t *)(v11 + 16);
        v29 = v23 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v28[-1] = v27;
          *v28 = v27;
          v29 -= 8LL;
          v28 += 2;
        }
        while ( v29 );
        if ( v23 == (v23 & 0xFFFFFFFFFFFFFFF8LL) )
          goto LABEL_37;
      }
    }
    else
    {
      v24 = (_DWORD *)v11;
      v25 = v23;
    }
    do
    {
      --v25;
      *v24++ = *(_DWORD *)a3;
    }
    while ( v25 );
LABEL_37:
    v26 = (char *)(v11 + 4 * v23);
    goto LABEL_43;
  }
  v26 = (char *)result + 4 * a2;
LABEL_43:
  *v12 = v26;
  return result;
}

//----- (0000000000051598) ----------------------------------------------------
float32x4_t *__fastcall Histogram::initHistogram(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 v5; // x24
  unsigned __int64 v6; // x1
  float32x4_t *result; // x0
  __int64 v9; // x10
  __int64 v10; // x9
  unsigned __int64 v11; // x8
  __int64 v12; // x11
  int v13; // w13
  double v14; // d2
  int v15; // w14
  int v16; // w15
  int v17; // w13
  int v18; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v19; // [xsp+8h] [xbp-38h]

  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a2[1];
  v6 = *(int *)(a1 + 52);
  *(_DWORD *)(a1 + 56) = v5;
  v18 = 0;
  std::vector<int>::assign((float32x4_t **)a1, v6, (const float *)&v18);
  v18 = -1;
  result = std::vector<int>::assign((float32x4_t **)(a1 + 24), (int)v5, (const float *)&v18);
  if ( (int)v5 >= 1 )
  {
    v9 = *a2;
    v10 = *a3;
    v11 = 0LL;
    v12 = *a2 + 8 * a2[1];
    do
    {
      if ( (*(_QWORD *)(v10 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) & (1LL << v11)) != 0 )
      {
        v13 = *(_DWORD *)(a1 + 48);
        v14 = (double)(v13 - 1);
        v15 = (int)(*(double *)(v9 + 8 * v11) * v14 / 3.14);
        if ( v15 < 1 )
          v16 = 0;
        else
          v16 = (int)((*(double *)(v12 + 8 * v11) + 3.14) * v14 / 6.28);
        v17 = v15 + v16 * v13;
        if ( v17 < *(_DWORD *)(a1 + 52) && (v17 & 0x80000000) == 0 )
        {
          *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v11) = v17;
          ++*(_DWORD *)(*(_QWORD *)a1 + 4LL * v17);
        }
      }
      ++v11;
    }
    while ( (unsigned int)v5 != v11 );
  }
  return result;
}

//----- (00000000000516E8) ----------------------------------------------------
void __usercall Histogram::getPointsFromMostFrequentBin(Histogram *this@<X0>, int64x2_t *a2@<X8>)
{
  __int64 v4; // x23
  unsigned __int64 v5; // x0
  __int64 v6; // x8
  __int64 v7; // x10
  int v8; // w9
  int v9; // w22
  int v10; // w12
  int v11; // w8
  int *v12; // x9
  int v13; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v14; // [xsp+8h] [xbp-38h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  a2->n128_u64[1] = 0LL;
  a2[1].n128_u64[0] = 0LL;
  a2->n128_u64[0] = 0LL;
  v4 = *((int *)this + 14);
  if ( (_DWORD)v4 )
  {
    if ( (v4 & 0x80000000) != 0 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v5 = operator new(4 * v4);
    *a2 = vdupq_n_s64(v5);
    a2[1].n128_u64[0] = v5 + 4 * v4;
  }
  v6 = *((int *)this + 13);
  if ( (int)v6 >= 1 )
  {
    v7 = 0LL;
    v8 = 0;
    v9 = -1;
    do
    {
      v10 = *(_DWORD *)(*(_QWORD *)this + 4 * v7);
      if ( v10 > v8 )
        v9 = v7;
      ++v7;
      if ( v10 > v8 )
        v8 = v10;
    }
    while ( v7 < v6 );
    if ( v8 > 0 )
    {
      v13 = 0;
      if ( (int)v4 >= 1 )
      {
        v11 = 0;
        do
        {
          if ( *(_DWORD *)(*((_QWORD *)this + 3) + 4LL * v11) == v9 )
          {
            v12 = (int *)a2->n128_u64[1];
            if ( (unsigned __int64)v12 >= a2[1].n128_u64[0] )
            {
              std::vector<int>::__emplace_back_slow_path<int &>((__int64)a2, &v13);
            }
            else
            {
              *v12 = v11;
              a2->n128_u64[1] = (unsigned __int64)(v12 + 1);
            }
          }
          v11 = v13 + 1;
          v13 = v11;
        }
        while ( v11 < *((_DWORD *)this + 14) );
      }
    }
  }
}

//----- (0000000000051834) ----------------------------------------------------
_QWORD *__fastcall Histogram::removePoint(_QWORD *this, int a2)
{
  __int64 v2; // x8
  __int64 v3; // x9

  v2 = this[3];
  v3 = 4LL * a2;
  --*(_DWORD *)(*this + 4LL * *(int *)(v2 + v3));
  *(_DWORD *)(v2 + v3) = -1;
  return this;
}

//----- (0000000000051860) ----------------------------------------------------
void __fastcall Histogram::~Histogram(Histogram *this)
{
  void *v2; // x0
  void *v3; // x0

  v2 = (void *)*((_QWORD *)this + 3);
  if ( v2 )
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if ( *(_QWORD *)this )
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

//----- (00000000000518A4) ----------------------------------------------------
void __fastcall std::vector<int>::__emplace_back_slow_path<int &>(__int64 a1, _DWORD *a2)
{
  void *v2; // x20
  signed __int64 v4; // x21
  unsigned __int64 v5; // x8
  __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x25
  char *v10; // x23
  char *v11; // x24
  _DWORD *v12; // x24

  v2 = *(void **)a1;
  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v5 = (v4 >> 2) + 1;
  if ( v5 >> 62 )
    std::__vector_base_common<true>::__throw_length_error();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ( (unsigned __int64)(v7 >> 2) > 0x1FFFFFFFFFFFFFFELL )
  {
    v9 = 0x3FFFFFFFFFFFFFFFLL;
LABEL_10:
    v10 = (char *)operator new(4 * v9);
    goto LABEL_11;
  }
  v8 = v7 >> 1;
  if ( v8 >= v5 )
    v9 = v8;
  else
    v9 = (v4 >> 2) + 1;
  if ( v9 )
  {
    if ( v9 >> 62 )
      sub_20E70("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    goto LABEL_10;
  }
  v10 = 0LL;
LABEL_11:
  v11 = &v10[4 * (v4 >> 2)];
  *(_DWORD *)v11 = *a2;
  v12 = v11 + 4;
  if ( v4 >= 1 )
    memcpy(v10, v2, v4);
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = &v10[4 * v9];
  if ( v2 )
    operator delete(v2);
}

//----- (000000000005199C) ----------------------------------------------------
__int64 __fastcall PlaneSeg::updatePlaneSeg(
        __int64 result,
        float a2,
        float a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        _DWORD *a8,
        __int64 a9,
        int a10,
        char a11)
{
  float v11; // w8
  float v12; // w9
  float v13; // w10
  float v14; // s1
  int v15; // w8

  if ( (a11 & 1) != 0 )
  {
    *(_BYTE *)(result + 64) = 1;
    *(_DWORD *)(result + 20) = *(_DWORD *)a9;
    *(_DWORD *)(result + 32) = *(_DWORD *)(a9 + 4);
    *(_DWORD *)(result + 36) = *(_DWORD *)(a9 + 8);
    *(_DWORD *)(result + 24) = *(_DWORD *)(a9 + 12);
    *(_DWORD *)(result + 40) = *(_DWORD *)(a9 + 16);
    *(_DWORD *)(result + 28) = *(_DWORD *)(a9 + 20);
    v11 = *(float *)(a9 + 24);
    *(float *)(result + 8) = v11;
    v12 = *(float *)(a9 + 28);
    *(float *)(result + 12) = v12;
    v13 = *(float *)(a9 + 32);
    *(_DWORD *)result = a10;
    *(float *)(result + 56) = a3;
    *(float *)(result + 60) = a2;
    *(float *)(result + 16) = v13;
    *(_DWORD *)(result + 80) = *a8;
    v14 = v11 / (float)a10;
    *(_DWORD *)(result + 84) = a8[1];
    *(_DWORD *)(result + 88) = a8[2];
    v15 = a8[3];
    *(float *)(result + 68) = v14;
    *(float *)(result + 72) = v12 / (float)a10;
    *(float *)(result + 76) = v13 / (float)a10;
    *(_DWORD *)(result + 92) = v15;
  }
  else
  {
    *(_BYTE *)(result + 64) = 0;
  }
  return result;
}

//----- (0000000000051A4C) ----------------------------------------------------
float __fastcall getValueOfsubMatrix(_QWORD *a1, int a2, int a3, int a4, int a5)
{
  float result; // s0

  result = 0.0;
  if ( a4 <= a2 && a5 <= a3 )
    return *(float *)(*a1 + 4LL * (a5 + a4 * a3));
  return result;
}

//----- (0000000000051A70) ----------------------------------------------------
void __fastcall PlaneSeg::updatePlaneSeg(__int64 a1, _QWORD *a2, int a3, int a4, int a5)
{
  unsigned __int64 StatusReg; // x25
  int v6; // w8
  __int64 v7; // x9
  int v8; // w20
  __int64 v9; // x28
  float **v11; // x24
  __int64 v14; // x27
  __int64 v15; // x8
  __int64 v17; // x8
  __int64 v18; // x9
  __int64 v19; // x8
  float32x4_t **v20; // x20
  __int64 v21; // x8
  __int64 v22; // x9
  float32x4_t **v23; // x21
  float v24; // s0
  float32x2_t v25; // d1
  __int64 v26; // x11
  float32x4_t *v27; // x8
  __int64 v28; // x10
  __int64 v29; // x9
  int8x16_t v30; // q1
  signed __int64 v31; // x9
  float32x4_t v32; // q2
  signed __int64 v33; // x10
  float32x4_t *v34; // x12
  __int64 v35; // x13
  float32x4_t v36; // q3
  float32x4_t v37; // q4
  __int64 v38; // x10
  float *v39; // x8
  float v40; // t1
  float v41; // w9
  __int64 v42; // x10
  float *v43; // x8
  float v44; // t1
  __int64 v45; // x8
  __int64 v46; // x9
  __int64 v47; // x9
  float32x4_t *v48; // x8
  __int64 v49; // x12
  __int64 v50; // x10
  int8x16_t v51; // q0
  signed __int64 v52; // x10
  float32x4_t v53; // q2
  signed __int64 v54; // x12
  float32x4_t *v55; // x13
  __int64 v56; // x14
  float32x4_t v57; // q3
  float32x4_t v58; // q4
  float32x2_t v59; // d0
  __int64 v60; // x12
  float *v61; // x8
  float v62; // t1
  float v63; // w10
  __int64 v64; // x12
  float *v65; // x8
  float v66; // t1
  __int64 v67; // x10
  __int64 v68; // x12
  __int64 v69; // x8
  float *v70; // x13
  __int64 v71; // x15
  __int64 v72; // x14
  int8x16_t v73; // q2
  signed __int64 v74; // x14
  float32x4_t v75; // q3
  signed __int64 v76; // x15
  float32x4_t *v77; // x16
  __int64 v78; // x17
  float32x4_t v79; // q4
  float32x4_t v80; // q5
  float32x2_t v81; // d2
  float v82; // s2
  __int64 v83; // x15
  float *v84; // x13
  float v85; // t1
  __int64 v86; // x14
  float v87; // w14
  __int64 v88; // x15
  float *v89; // x13
  float v90; // t1
  float *v91; // x13
  __int64 v92; // x16
  unsigned __int64 v93; // x15
  int64x2_t v94; // q3
  unsigned __int64 *v95; // x0
  int64x2_t v96; // q4
  int8x16_t v97; // q5
  unsigned __int64 v98; // x14
  float32x2_t v99; // d6
  float32x2_t v100; // d7
  unsigned __int64 v101; // d6
  unsigned __int64 v102; // d7
  int8x16_t v103; // off
  int8x16_t v104; // q6
  unsigned __int64 v105; // x16
  float *v106; // x15
  float v107; // t1
  __int64 v108; // x0
  __int64 v109; // x1
  __int64 i; // x2
  unsigned __int64 v111; // x4
  int64x2_t v112; // q3
  int64x2_t v113; // q4
  unsigned __int64 v114; // x14
  unsigned __int64 *v115; // x3
  float32x2_t v116; // d5
  float32x2_t v117; // d6
  int8x16_t v118; // q7
  unsigned __int64 v119; // d5
  unsigned __int64 v120; // d6
  int8x16_t v121; // off
  int8x16_t v122; // q5
  float *v123; // x3
  unsigned __int64 v124; // x4
  float v125; // t1
  int v126; // w10
  double v127; // d0
  __int64 v128; // d2
  float32x4_t *v129; // x10
  int v130; // w12
  int v131; // w12
  int v132; // w14
  float v133; // s2
  float v134; // s1
  __int64 v135; // x14
  bool v136; // nf
  float v137; // s0
  float v138; // s1
  float32x4_t *v139; // x12
  __int64 v140; // x14
  __int64 v141; // x13
  signed __int64 v142; // x13
  int8x16_t v143; // q1
  signed __int64 v144; // x14
  float32x4_t v145; // q2
  float32x4_t *v146; // x15
  __int64 v147; // x16
  float32x4_t v148; // q3
  float32x4_t v149; // q4
  float32x2_t v150; // d1
  __int64 v151; // x11
  float *v152; // x12
  float v153; // t1
  __int64 v154; // x11
  float *v155; // x12
  float v156; // t1
  float32x4_t *v157; // x11
  __int64 v158; // x13
  __int64 v159; // x12
  signed __int64 v160; // x12
  int8x16_t v161; // q0
  signed __int64 v162; // x13
  float32x4_t v163; // q1
  float32x4_t *v164; // x14
  __int64 v165; // x15
  float32x4_t v166; // q2
  float32x4_t v167; // q3
  float32x2_t v168; // d0
  __int64 v169; // x13
  float *v170; // x11
  float v171; // t1
  __int64 v172; // x12
  float *v173; // x11
  float v174; // t1
  float v175; // s0
  float v176; // s1
  __int64 v177; // x12
  __int64 v178; // x11
  signed __int64 v179; // x11
  int8x16_t v180; // q1
  signed __int64 v181; // x12
  float32x4_t v182; // q2
  float32x4_t *v183; // x13
  __int64 v184; // x14
  float32x4_t v185; // q3
  float32x4_t v186; // q4
  float32x2_t v187; // d1
  __int64 v188; // x12
  float *v189; // x11
  float v190; // t1
  __int64 v191; // x11
  float *v192; // x12
  float v193; // t1
  float32x4_t *v194; // x11
  __int64 v195; // x14
  __int64 v196; // x13
  float32x4_t *v197; // x12
  signed __int64 v198; // x13
  int8x16_t v199; // q0
  signed __int64 v200; // x14
  float32x4_t v201; // q1
  float32x4_t *v202; // x15
  float32x4_t *v203; // x16
  __int64 v204; // x17
  float32x4_t v205; // q3
  float32x4_t v206; // q5
  float32x2_t v207; // d0
  __int64 v208; // x9
  __int64 v209; // x13
  float *v210; // x12
  float *v211; // x11
  float v212; // t1
  float v213; // s1
  float v214; // t1
  __int64 v215; // x9
  float *v216; // x12
  float *v217; // x11
  float v218; // t1
  float v219; // s1
  float v220; // t1
  float32x4_t *v221; // x13
  __int64 v222; // x9
  unsigned __int64 v223; // x12
  __int64 v224; // x14
  signed __int64 v225; // x11
  signed __int64 v226; // x9
  int8x16_t v227; // q0
  float32x4_t v228; // q1
  float32x4_t *v229; // x14
  float32x4_t *v230; // x15
  __int64 v231; // x16
  float32x4_t v232; // q3
  float32x4_t v233; // q5
  float32x2_t v234; // d0
  float v235; // s0
  __int64 v236; // x14
  float *v237; // x15
  float *v238; // x13
  float v239; // t1
  float v240; // s1
  float v241; // t1
  float v242; // s0
  __int64 v243; // x14
  float *v244; // x15
  float *v245; // x13
  float v246; // t1
  float v247; // s1
  float v248; // t1
  float32x4_t *v249; // x13
  int8x16_t v250; // q0
  float32x4_t v251; // q1
  float32x4_t *v252; // x12
  float32x4_t *v253; // x14
  __int64 v254; // x15
  float32x4_t v255; // q3
  float32x4_t v256; // q5
  float32x2_t v257; // d0
  __int64 v258; // x11
  __int64 v259; // x8
  float *v260; // x9
  float *v261; // x10
  float v262; // t1
  float v263; // s1
  float v264; // t1
  __int64 v265; // x8
  float *v266; // x9
  float *v267; // x10
  float v268; // t1
  float v269; // s1
  float v270; // t1
  float *v271; // x8
  int v272; // w8
  double v273; // d1
  __int64 v274; // [xsp+0h] [xbp-80h] BYREF
  __int64 v275; // [xsp+8h] [xbp-78h]
  __int64 v276; // [xsp+10h] [xbp-70h]
  _QWORD *v277; // [xsp+18h] [xbp-68h]
  __int64 v278; // [xsp+20h] [xbp-60h]
  __int64 v279; // [xsp+28h] [xbp-58h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a3 % a5 )
    v6 = 2;
  else
    v6 = 4;
  v279 = *(_QWORD *)(StatusReg + 40);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a4 / v6;
  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_BYTE *)(a1 + 64) = 1;
  v7 = a2[1];
  v8 = a4 * a3;
  v9 = a4 * a3;
  v11 = (float **)(a1 + 96);
  v14 = a4;
  v15 = *a2 + 4 * (v9 + 2 * v7);
  v276 = 1LL;
  v277 = a2;
  v274 = v15;
  v275 = a4;
  v278 = v7;
  Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(
    (_QWORD *)(a1 + 96),
    &v274);
  v17 = *a2;
  v18 = a2[1];
  v276 = 1LL;
  v277 = a2;
  v19 = v17 + 4LL * v8;
  v20 = (float32x4_t **)(a1 + 120);
  v274 = v19;
  v275 = v14;
  v278 = v18;
  Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(
    (_QWORD *)(a1 + 120),
    &v274);
  v22 = *a2;
  v21 = a2[1];
  v276 = 1LL;
  v277 = a2;
  v23 = (float32x4_t **)(a1 + 144);
  v274 = v22 + 4 * (v21 + v9);
  v275 = v14;
  v278 = v21;
  Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(
    (_QWORD *)(a1 + 144),
    &v274);
  v24 = 0.0;
  v25.n64_u32[0] = 0;
  v26 = *(_QWORD *)(a1 + 136) * *(_QWORD *)(a1 + 128);
  if ( v26 )
  {
    v27 = *v20;
    if ( v26 >= 0 )
      v28 = *(_QWORD *)(a1 + 136) * *(_QWORD *)(a1 + 128);
    else
      v28 = v26 + 7;
    if ( v26 >= 0 )
      v29 = *(_QWORD *)(a1 + 136) * *(_QWORD *)(a1 + 128);
    else
      v29 = v26 + 3;
    if ( (unsigned __int64)(v26 + 3) < 7 )
    {
      v41 = v27->n128_f32[0];
      if ( v26 < 2 )
      {
        v25.n64_u32[0] = v27->n128_u32[0];
      }
      else
      {
        v42 = v26 - 1;
        v43 = &v27->n128_f32[1];
        do
        {
          v44 = *v43++;
          --v42;
          v25.n64_f32[0] = v44 + v41;
          v41 = v44 + v41;
        }
        while ( v42 );
      }
    }
    else
    {
      v30 = *v27;
      v31 = v29 & 0xFFFFFFFFFFFFFFFCLL;
      if ( v26 >= 8 )
      {
        v32 = v27[1];
        v33 = v28 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v26 >= 16 )
        {
          v34 = v27 + 3;
          v35 = 8LL;
          do
          {
            v36 = v34[-1];
            v37 = *v34;
            v35 += 8LL;
            v34 += 2;
            v30 = vaddq_f32(v30, v36);
            v32 = vaddq_f32(v32, v37);
          }
          while ( v35 < v33 );
        }
        v30 = vaddq_f32(v32, v30);
        if ( v31 > v33 )
          v30 = vaddq_f32(v30, *(float32x4_t *)((char *)v27 + 4 * v33));
      }
      v25.n64_u64[0] = vpadd_f32((float32x2_t)v30.n128_u64[0], (float32x2_t)vextq_s8(v30, v30, 8uLL).n128_u64[0]).n64_u64[0];
      v25.n64_u32[0] = vpadd_f32(v25, v25).n64_u32[0];
      if ( v31 < v26 )
      {
        v38 = v26 - v31;
        v39 = (float *)v27 + v31;
        do
        {
          v40 = *v39++;
          --v38;
          v25.n64_f32[0] = v25.n64_f32[0] + v40;
        }
        while ( v38 );
      }
    }
  }
  v45 = *(_QWORD *)(a1 + 152);
  v46 = *(_QWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 8) = v25.n64_u32[0];
  v47 = v46 * v45;
  if ( v47 )
  {
    v48 = *v23;
    if ( v47 >= 0 )
      v49 = v47;
    else
      v49 = v47 + 7;
    if ( v47 >= 0 )
      v50 = v47;
    else
      v50 = v47 + 3;
    if ( (unsigned __int64)(v47 + 3) < 7 )
    {
      v63 = v48->n128_f32[0];
      if ( v47 < 2 )
      {
        v24 = v48->n128_f32[0];
      }
      else
      {
        v64 = v47 - 1;
        v65 = &v48->n128_f32[1];
        do
        {
          v66 = *v65++;
          --v64;
          v24 = v66 + v63;
          v63 = v66 + v63;
        }
        while ( v64 );
      }
    }
    else
    {
      v51 = *v48;
      v52 = v50 & 0xFFFFFFFFFFFFFFFCLL;
      if ( v47 >= 8 )
      {
        v53 = v48[1];
        v54 = v49 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v47 >= 16 )
        {
          v55 = v48 + 3;
          v56 = 8LL;
          do
          {
            v57 = v55[-1];
            v58 = *v55;
            v56 += 8LL;
            v55 += 2;
            v51 = vaddq_f32(v51, v57);
            v53 = vaddq_f32(v53, v58);
          }
          while ( v56 < v54 );
        }
        v51 = vaddq_f32(v53, v51);
        if ( v52 > v54 )
          v51 = vaddq_f32(v51, *(float32x4_t *)((char *)v48 + 4 * v54));
      }
      v59.n64_u64[0] = vpadd_f32((float32x2_t)v51.n128_u64[0], (float32x2_t)vextq_s8(v51, v51, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v24) = vpadd_f32(v59, v59).n64_u32[0];
      if ( v52 < v47 )
      {
        v60 = v47 - v52;
        v61 = (float *)v48 + v52;
        do
        {
          v62 = *v61++;
          --v60;
          v24 = v24 + v62;
        }
        while ( v60 );
      }
    }
  }
  v67 = *(_QWORD *)(a1 + 104);
  v68 = *(_QWORD *)(a1 + 112);
  *(float *)(a1 + 12) = v24;
  v69 = v68 * v67;
  if ( !(v68 * v67) )
  {
    LODWORD(v86) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    v82 = 0.0;
    goto LABEL_94;
  }
  v70 = *v11;
  if ( v69 >= 0 )
    v71 = v68 * v67;
  else
    v71 = v69 + 7;
  if ( v69 >= 0 )
    v72 = v68 * v67;
  else
    v72 = v69 + 3;
  if ( (unsigned __int64)(v69 + 3) < 7 )
  {
    v87 = *v70;
    if ( v69 < 2 )
    {
      v82 = *v70;
      *(float *)(a1 + 16) = v87;
      goto LABEL_75;
    }
    v88 = v69 - 1;
    v89 = v70 + 1;
    do
    {
      v90 = *v89++;
      --v88;
      v82 = v90 + v87;
      v87 = v90 + v87;
    }
    while ( v88 );
  }
  else
  {
    v73 = *(int8x16_t *)v70;
    v74 = v72 & 0xFFFFFFFFFFFFFFFCLL;
    if ( v69 >= 8 )
    {
      v75 = *(float32x4_t *)(v70 + 4);
      v76 = v71 & 0xFFFFFFFFFFFFFFF8LL;
      if ( v69 >= 16 )
      {
        v77 = (float32x4_t *)(v70 + 12);
        v78 = 8LL;
        do
        {
          v79 = v77[-1];
          v80 = *v77;
          v78 += 8LL;
          v77 += 2;
          v73 = vaddq_f32(v73, v79);
          v75 = vaddq_f32(v75, v80);
        }
        while ( v78 < v76 );
      }
      v73 = vaddq_f32(v75, v73);
      if ( v74 > v76 )
        v73 = vaddq_f32(v73, *(float32x4_t *)&v70[v76]);
    }
    v81.n64_u64[0] = vpadd_f32((float32x2_t)v73.n128_u64[0], (float32x2_t)vextq_s8(v73, v73, 8uLL).n128_u64[0]).n64_u64[0];
    LODWORD(v82) = vpadd_f32(v81, v81).n64_u32[0];
    if ( v74 < v69 )
    {
      v83 = v69 - v74;
      v84 = &v70[v74];
      do
      {
        v85 = *v84++;
        --v83;
        v82 = v82 + v85;
      }
      while ( v83 );
    }
  }
  *(float *)(a1 + 16) = v82;
  if ( !v69 )
  {
    LODWORD(v86) = 0;
    goto LABEL_94;
  }
LABEL_75:
  v91 = *v11;
  v86 = **v11 > 0.0;
  if ( v67 < 2 )
    goto LABEL_83;
  v92 = v67 - 1;
  if ( (unsigned __int64)(v67 - 1) <= 3 )
  {
    v93 = 1LL;
LABEL_81:
    v105 = v67 - v93;
    v106 = &v91[v93];
    do
    {
      v107 = *v106++;
      --v105;
      v86 += v107 > 0.0;
    }
    while ( v105 );
    goto LABEL_83;
  }
  v94 = 0uLL;
  v95 = (unsigned __int64 *)(v91 + 3);
  v93 = v92 & 0xFFFFFFFFFFFFFFFCLL | 1;
  v96 = (int64x2_t)(**v11 > 0.0);
  v97 = vdupq_n_s64(1uLL);
  v98 = v92 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v99.n64_u64[0] = *(v95 - 1);
    v100.n64_u64[0] = *v95;
    v98 -= 4LL;
    v95 += 2;
    v101 = vcgtz_f32(v99).n64_u64[0];
    v102 = vcgtz_f32(v100).n64_u64[0];
    v103.n128_u64[0] = (unsigned int)v101;
    v103.n128_u64[1] = HIDWORD(v101);
    v104 = v103;
    v103.n128_u64[0] = (unsigned int)v102;
    v103.n128_u64[1] = HIDWORD(v102);
    v96 = vaddq_s64(v96, vandq_s8(v104, v97));
    v94 = vaddq_s64(v94, vandq_s8(v103, v97));
  }
  while ( v98 );
  v86 = vaddvq_s64(vaddq_s64(v94, v96));
  if ( v92 != (v92 & 0xFFFFFFFFFFFFFFFCLL) )
    goto LABEL_81;
LABEL_83:
  if ( v68 >= 2 )
  {
    v108 = v67;
    v109 = (__int64)&v91[v67 + 2];
    for ( i = 1LL; i != v68; ++i )
    {
      if ( v67 >= 1 )
      {
        if ( (unsigned __int64)v67 > 3 )
        {
          v112 = 0uLL;
          v113 = (int64x2_t)(unsigned __int64)v86;
          v114 = v67 & 0xFFFFFFFFFFFFFFFCLL;
          v115 = (unsigned __int64 *)v109;
          do
          {
            v116.n64_u64[0] = *(v115 - 1);
            v117.n64_u64[0] = *v115;
            v118 = vdupq_n_s64(1uLL);
            v114 -= 4LL;
            v115 += 2;
            v119 = vcgtz_f32(v116).n64_u64[0];
            v120 = vcgtz_f32(v117).n64_u64[0];
            v121.n128_u64[0] = (unsigned int)v119;
            v121.n128_u64[1] = HIDWORD(v119);
            v122 = v121;
            v121.n128_u64[0] = (unsigned int)v120;
            v121.n128_u64[1] = HIDWORD(v120);
            v113 = vaddq_s64(v113, vandq_s8(v122, v118));
            v112 = vaddq_s64(v112, vandq_s8(v121, v118));
          }
          while ( v114 );
          v86 = vaddvq_s64(vaddq_s64(v112, v113));
          v111 = v67 & 0xFFFFFFFFFFFFFFFCLL;
          if ( v67 == (v67 & 0xFFFFFFFFFFFFFFFCLL) )
            goto LABEL_93;
        }
        else
        {
          v111 = 0LL;
        }
        v123 = &v91[v111 + v108];
        v124 = v67 - v111;
        do
        {
          v125 = *v123++;
          --v124;
          v86 += v125 > 0.0;
        }
        while ( v124 );
      }
LABEL_93:
      v109 += 4 * v67;
      v108 += v67;
    }
  }
LABEL_94:
  v126 = *(_DWORD *)(a1 + 4);
  v25.n64_f32[1] = v24;
  v127 = v82;
  *(double *)&v128 = (double)(int)v86 + 0.000001;
  *(float *)&v127 = v127 / *(double *)&v128;
  *(_DWORD *)a1 = v86;
  *(float32x2_t *)(a1 + 44) = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(v25), vdupq_lane_s64(v128, 0)));
  *(_DWORD *)(a1 + 52) = LODWORD(v127);
  if ( v126 > (int)v86 )
  {
LABEL_228:
    *(_BYTE *)(a1 + 64) = 0;
    return;
  }
  v129 = (float32x4_t *)*v11;
  if ( a5 >= 0 )
    v130 = a5;
  else
    v130 = a5 + 1;
  v131 = v130 >> 1;
  v132 = v131 + a5;
  if ( v131 + a5 < a4 - v131 )
  {
    v133 = v129->n128_f32[v131];
    v134 = v129->n128_f32[v132];
    if ( v133 < v134 )
      v133 = v129->n128_f32[v132];
    v135 = a5 + (__int64)v132;
    if ( v134 <= 0.0 )
    {
LABEL_106:
      while ( v135 < a4 - v131 )
      {
        v134 = v129->n128_f32[v135];
        v135 += a5;
        if ( v134 > 0.0 )
          goto LABEL_104;
      }
    }
    else
    {
LABEL_104:
      v136 = vabds_f32(v134, v133) < 100.0;
      v133 = v134;
      if ( v136 )
        goto LABEL_106;
    }
  }
  v137 = 0.0;
  v138 = 0.0;
  if ( v26 )
  {
    v139 = *v20;
    if ( v26 >= 0 )
      v140 = v26;
    else
      v140 = v26 + 7;
    if ( v26 >= 0 )
      v141 = v26;
    else
      v141 = v26 + 3;
    if ( (unsigned __int64)(v26 + 3) < 7 )
    {
      v138 = v139->n128_f32[0] * v139->n128_f32[0];
      if ( v26 >= 2 )
      {
        v154 = v26 - 1;
        v155 = &v139->n128_f32[1];
        do
        {
          v156 = *v155++;
          --v154;
          v138 = v138 + (float)(v156 * v156);
        }
        while ( v154 );
      }
    }
    else
    {
      v142 = v141 & 0xFFFFFFFFFFFFFFFCLL;
      v143 = vmulq_f32(*v139, *v139);
      if ( v26 >= 8 )
      {
        v144 = v140 & 0xFFFFFFFFFFFFFFF8LL;
        v145 = vmulq_f32(v139[1], v139[1]);
        if ( v26 >= 16 )
        {
          v146 = v139 + 3;
          v147 = 8LL;
          do
          {
            v148 = v146[-1];
            v149 = *v146;
            v147 += 8LL;
            v146 += 2;
            v143 = vaddq_f32(v143, vmulq_f32(v148, v148));
            v145 = vaddq_f32(v145, vmulq_f32(v149, v149));
          }
          while ( v147 < v144 );
        }
        v143 = vaddq_f32(v145, v143);
        if ( v142 > v144 )
          v143 = vaddq_f32(
                   v143,
                   vmulq_f32(*(float32x4_t *)((char *)v139 + 4 * v144), *(float32x4_t *)((char *)v139 + 4 * v144)));
      }
      v150.n64_u64[0] = vpadd_f32((float32x2_t)v143.n128_u64[0], (float32x2_t)vextq_s8(v143, v143, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v138) = vpadd_f32(v150, v150).n64_u32[0];
      if ( v142 < v26 )
      {
        v151 = v26 - v142;
        v152 = (float *)v139 + v142;
        do
        {
          v153 = *v152++;
          --v151;
          v138 = v138 + (float)(v153 * v153);
        }
        while ( v151 );
      }
    }
  }
  *(float *)(a1 + 20) = v138;
  if ( v47 )
  {
    v157 = *v23;
    if ( v47 >= 0 )
      v158 = v47;
    else
      v158 = v47 + 7;
    if ( v47 >= 0 )
      v159 = v47;
    else
      v159 = v47 + 3;
    if ( (unsigned __int64)(v47 + 3) < 7 )
    {
      v137 = v157->n128_f32[0] * v157->n128_f32[0];
      if ( v47 >= 2 )
      {
        v172 = v47 - 1;
        v173 = &v157->n128_f32[1];
        do
        {
          v174 = *v173++;
          --v172;
          v137 = v137 + (float)(v174 * v174);
        }
        while ( v172 );
      }
    }
    else
    {
      v160 = v159 & 0xFFFFFFFFFFFFFFFCLL;
      v161 = vmulq_f32(*v157, *v157);
      if ( v47 >= 8 )
      {
        v162 = v158 & 0xFFFFFFFFFFFFFFF8LL;
        v163 = vmulq_f32(v157[1], v157[1]);
        if ( v47 >= 16 )
        {
          v164 = v157 + 3;
          v165 = 8LL;
          do
          {
            v166 = v164[-1];
            v167 = *v164;
            v165 += 8LL;
            v164 += 2;
            v161 = vaddq_f32(v161, vmulq_f32(v166, v166));
            v163 = vaddq_f32(v163, vmulq_f32(v167, v167));
          }
          while ( v165 < v162 );
        }
        v161 = vaddq_f32(v163, v161);
        if ( v160 > v162 )
          v161 = vaddq_f32(
                   v161,
                   vmulq_f32(*(float32x4_t *)((char *)v157 + 4 * v162), *(float32x4_t *)((char *)v157 + 4 * v162)));
      }
      v168.n64_u64[0] = vpadd_f32((float32x2_t)v161.n128_u64[0], (float32x2_t)vextq_s8(v161, v161, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v137) = vpadd_f32(v168, v168).n64_u32[0];
      if ( v160 < v47 )
      {
        v169 = v47 - v160;
        v170 = (float *)v157 + v160;
        do
        {
          v171 = *v170++;
          --v169;
          v137 = v137 + (float)(v171 * v171);
        }
        while ( v169 );
      }
    }
  }
  *(float *)(a1 + 24) = v137;
  v175 = 0.0;
  v176 = 0.0;
  if ( v69 )
  {
    if ( v69 >= 0 )
      v177 = v69;
    else
      v177 = v69 + 7;
    if ( v69 >= 0 )
      v178 = v69;
    else
      v178 = v69 + 3;
    if ( (unsigned __int64)(v69 + 3) < 7 )
    {
      v176 = v129->n128_f32[0] * v129->n128_f32[0];
      if ( v69 >= 2 )
      {
        v191 = v69 - 1;
        v192 = &v129->n128_f32[1];
        do
        {
          v193 = *v192++;
          --v191;
          v176 = v176 + (float)(v193 * v193);
        }
        while ( v191 );
      }
    }
    else
    {
      v179 = v178 & 0xFFFFFFFFFFFFFFFCLL;
      v180 = vmulq_f32(*v129, *v129);
      if ( v69 >= 8 )
      {
        v181 = v177 & 0xFFFFFFFFFFFFFFF8LL;
        v182 = vmulq_f32(v129[1], v129[1]);
        if ( v69 >= 16 )
        {
          v183 = v129 + 3;
          v184 = 8LL;
          do
          {
            v185 = v183[-1];
            v186 = *v183;
            v184 += 8LL;
            v183 += 2;
            v180 = vaddq_f32(v180, vmulq_f32(v185, v185));
            v182 = vaddq_f32(v182, vmulq_f32(v186, v186));
          }
          while ( v184 < v181 );
        }
        v180 = vaddq_f32(v182, v180);
        if ( v179 > v181 )
          v180 = vaddq_f32(
                   v180,
                   vmulq_f32(*(float32x4_t *)((char *)v129 + 4 * v181), *(float32x4_t *)((char *)v129 + 4 * v181)));
      }
      v187.n64_u64[0] = vpadd_f32((float32x2_t)v180.n128_u64[0], (float32x2_t)vextq_s8(v180, v180, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v176) = vpadd_f32(v187, v187).n64_u32[0];
      if ( v179 < v69 )
      {
        v188 = v69 - v179;
        v189 = (float *)v129 + v179;
        do
        {
          v190 = *v189++;
          --v188;
          v176 = v176 + (float)(v190 * v190);
        }
        while ( v188 );
      }
    }
  }
  *(float *)(a1 + 28) = v176;
  if ( v47 )
  {
    v194 = *v20;
    if ( v47 >= 0 )
      v195 = v47;
    else
      v195 = v47 + 7;
    if ( v47 >= 0 )
      v196 = v47;
    else
      v196 = v47 + 3;
    if ( (unsigned __int64)(v47 + 3) < 7 )
    {
      v175 = v194->n128_f32[0] * (*v23)->n128_f32[0];
      if ( v47 >= 2 )
      {
        v215 = v47 - 1;
        v216 = &(*v23)->n128_f32[1];
        v217 = &v194->n128_f32[1];
        do
        {
          v218 = *v217++;
          v219 = v218;
          v220 = *v216++;
          --v215;
          v175 = v175 + (float)(v219 * v220);
        }
        while ( v215 );
      }
    }
    else
    {
      v197 = *v23;
      v198 = v196 & 0xFFFFFFFFFFFFFFFCLL;
      v199 = vmulq_f32(*v194, **v23);
      if ( v47 >= 8 )
      {
        v200 = v195 & 0xFFFFFFFFFFFFFFF8LL;
        v201 = vmulq_f32(v194[1], v197[1]);
        if ( v47 >= 16 )
        {
          v202 = v197 + 3;
          v203 = v194 + 3;
          v204 = 8LL;
          do
          {
            v205 = v202[-1];
            v206 = *v202;
            v204 += 8LL;
            v202 += 2;
            v199 = vaddq_f32(v199, vmulq_f32(v203[-1], v205));
            v201 = vaddq_f32(v201, vmulq_f32(*v203, v206));
            v203 += 2;
          }
          while ( v204 < v200 );
        }
        v199 = vaddq_f32(v201, v199);
        if ( v198 > v200 )
          v199 = vaddq_f32(
                   v199,
                   vmulq_f32(*(float32x4_t *)((char *)v194 + 4 * v200), *(float32x4_t *)((char *)v197 + 4 * v200)));
      }
      v207.n64_u64[0] = vpadd_f32((float32x2_t)v199.n128_u64[0], (float32x2_t)vextq_s8(v199, v199, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v175) = vpadd_f32(v207, v207).n64_u32[0];
      if ( v198 < v47 )
      {
        v208 = v47 - v198;
        v209 = 4 * v198;
        v210 = (float *)((char *)v197 + v209);
        v211 = (float *)((char *)v194 + v209);
        do
        {
          v212 = *v211++;
          v213 = v212;
          v214 = *v210++;
          --v208;
          v175 = v175 + (float)(v213 * v214);
        }
        while ( v208 );
      }
    }
  }
  *(float *)(a1 + 32) = v175;
  if ( v69 )
  {
    v221 = *v20;
    v222 = v69 + 7;
    v223 = v69 + 3;
    if ( v69 < 0 )
    {
      v224 = v69 + 3;
    }
    else
    {
      v222 = v69;
      v224 = v69;
    }
    v225 = v222 & 0xFFFFFFFFFFFFFFF8LL;
    v226 = v224 & 0xFFFFFFFFFFFFFFFCLL;
    if ( v223 < 7 )
    {
      v235 = v221->n128_f32[0] * v129->n128_f32[0];
      if ( v69 < 2 )
      {
        v271 = *(float **)(a1 + 144);
        *(float *)(a1 + 36) = v235;
        v242 = *v271 * v129->n128_f32[0];
        goto LABEL_226;
      }
      v243 = v69 - 1;
      v244 = &v129->n128_f32[1];
      v245 = &v221->n128_f32[1];
      do
      {
        v246 = *v245++;
        v247 = v246;
        v248 = *v244++;
        --v243;
        v235 = v235 + (float)(v247 * v248);
      }
      while ( v243 );
    }
    else
    {
      v227 = vmulq_f32(*v221, *v129);
      if ( v69 >= 8 )
      {
        v228 = vmulq_f32(v221[1], v129[1]);
        if ( v69 >= 16 )
        {
          v229 = v129 + 3;
          v230 = v221 + 3;
          v231 = 8LL;
          do
          {
            v232 = v229[-1];
            v233 = *v229;
            v231 += 8LL;
            v229 += 2;
            v227 = vaddq_f32(v227, vmulq_f32(v230[-1], v232));
            v228 = vaddq_f32(v228, vmulq_f32(*v230, v233));
            v230 += 2;
          }
          while ( v231 < v225 );
        }
        v227 = vaddq_f32(v228, v227);
        if ( v226 > v225 )
          v227 = vaddq_f32(
                   v227,
                   vmulq_f32(*(float32x4_t *)((char *)v221 + 4 * v225), *(float32x4_t *)((char *)v129 + 4 * v225)));
      }
      v234.n64_u64[0] = vpadd_f32((float32x2_t)v227.n128_u64[0], (float32x2_t)vextq_s8(v227, v227, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v235) = vpadd_f32(v234, v234).n64_u32[0];
      if ( v226 < v69 )
      {
        v236 = v69 - v226;
        v237 = (float *)v129 + v226;
        v238 = (float *)v221 + v226;
        do
        {
          v239 = *v238++;
          v240 = v239;
          v241 = *v237++;
          --v236;
          v235 = v235 + (float)(v240 * v241);
        }
        while ( v236 );
      }
    }
    v249 = *(float32x4_t **)(a1 + 144);
    *(float *)(a1 + 36) = v235;
    if ( v223 < 7 )
    {
      v242 = v249->n128_f32[0] * v129->n128_f32[0];
      if ( v69 >= 2 )
      {
        v265 = v69 - 1;
        v266 = &v129->n128_f32[1];
        v267 = &v249->n128_f32[1];
        do
        {
          v268 = *v267++;
          v269 = v268;
          v270 = *v266++;
          --v265;
          v242 = v242 + (float)(v269 * v270);
        }
        while ( v265 );
      }
    }
    else
    {
      v250 = vmulq_f32(*v249, *v129);
      if ( v69 >= 8 )
      {
        v251 = vmulq_f32(v249[1], v129[1]);
        if ( v69 >= 16 )
        {
          v252 = v129 + 3;
          v253 = v249 + 3;
          v254 = 8LL;
          do
          {
            v255 = v252[-1];
            v256 = *v252;
            v254 += 8LL;
            v252 += 2;
            v250 = vaddq_f32(v250, vmulq_f32(v253[-1], v255));
            v251 = vaddq_f32(v251, vmulq_f32(*v253, v256));
            v253 += 2;
          }
          while ( v254 < v225 );
        }
        v250 = vaddq_f32(v251, v250);
        if ( v226 > v225 )
          v250 = vaddq_f32(
                   v250,
                   vmulq_f32(*(float32x4_t *)((char *)v249 + 4 * v225), *(float32x4_t *)((char *)v129 + 4 * v225)));
      }
      v257.n64_u64[0] = vpadd_f32((float32x2_t)v250.n128_u64[0], (float32x2_t)vextq_s8(v250, v250, 8uLL).n128_u64[0]).n64_u64[0];
      LODWORD(v242) = vpadd_f32(v257, v257).n64_u32[0];
      if ( v226 < v69 )
      {
        v258 = 4 * v226;
        v259 = v69 - v226;
        v260 = (float *)v129 + v226;
        v261 = (float *)((char *)v249 + v258);
        do
        {
          v262 = *v261++;
          v263 = v262;
          v264 = *v260++;
          --v259;
          v242 = v242 + (float)(v263 * v264);
        }
        while ( v259 );
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 0;
    v242 = 0.0;
  }
LABEL_226:
  v272 = *(unsigned __int8 *)(a1 + 64);
  *(float *)(a1 + 40) = v242;
  if ( v272 )
  {
    PlaneSeg::fitPlane((PlaneSeg *)a1);
    v273 = *(float *)(a1 + 76) * 0.000001425 * *(float *)(a1 + 76) + 10.0;
    if ( v273 * v273 < *(float *)(a1 + 60) )
      goto LABEL_228;
  }
}

//----- (0000000000052798) ----------------------------------------------------
_QWORD *__fastcall Eigen::Matrix<float,-1,-1,0,-1,-1>::operator=<Eigen::Block<Eigen::Matrix<float,-1,-1,0,-1,-1>,-1,-1,false>>(
        _QWORD *a1,
        __int64 *a2)
{
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v6; // x8
  __int64 v7; // x11
  __int64 v8; // x9
  __int64 v9; // x13
  __int64 v10; // x10
  __int64 v11; // x12
  __int64 v12; // x2
  __int128 *v13; // x3
  _OWORD *v14; // x4
  unsigned __int64 v15; // x5
  __int128 v16; // q0
  __int128 v17; // q1
  signed __int64 v18; // x14
  __int64 v19; // x16
  __int64 v20; // x17
  __int64 v21; // x0
  __int64 v22; // x1
  __int64 v23; // x3
  __int64 v24; // x2
  __int64 v25; // x3
  _DWORD *v26; // x17
  int *v27; // x16
  __int64 v28; // x0
  int v29; // t1
  signed __int64 v30; // x16
  __int64 v31; // x17
  __int128 v32; // q0
  __int64 v33; // x0
  __int64 v34; // x17
  __int64 v35; // x0
  __int64 v36; // x1
  __int64 v37; // x2
  unsigned __int64 v38; // x15
  __int64 v39; // x5
  __int128 *v40; // x14
  _OWORD *v41; // x4
  unsigned __int64 v42; // x5
  __int128 v43; // q0
  __int128 v44; // q1
  _DWORD *v45; // x14
  int *v46; // x15
  __int64 v47; // x16
  int v48; // t1
  __int64 v49; // x13
  __int64 v50; // x14
  std::bad_alloc *exception; // x19

  v3 = a2[1];
  v4 = a2[2];
  if ( v3 && v4 && 0x7FFFFFFFFFFFFFFFLL / v4 < v3 )
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    std::bad_alloc::bad_alloc(exception);
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::bad_alloc,
      (void (__fastcall *)(void *))&std::bad_alloc::~bad_alloc);
  }
  Eigen::PlainObjectBase<Eigen::Matrix<float,-1,-1,0,-1,-1>>::resize((__int64)a1, v3, v4);
  v6 = a1[2];
  if ( v6 >= 1 )
  {
    v7 = a1[1];
    v8 = 0LL;
    v9 = 0LL;
    v10 = 0LL;
    v11 = -*((_BYTE *)a1 + 8) & 3;
    do
    {
      v18 = (v7 - v9) & 0xFFFFFFFFFFFFFFFCLL;
      if ( v9 >= 1 )
      {
        v19 = *a2;
        v20 = a2[4];
        v21 = *a1;
        v22 = a1[1];
        if ( (unsigned __int64)v9 > 7
          && ((v23 = v22 * 4 * v10, v24 = v20 * 4 * v10, v21 + v23 >= (unsigned __int64)(v19 + 4 * v9 + v24))
           || v19 + v24 >= (unsigned __int64)(v21 + 4 * v9 + v23)) )
        {
          v12 = v9 & 0x7FFFFFFFFFFFFFF8LL;
          v13 = (__int128 *)(v19 + v20 * v8 + 16);
          v14 = (_OWORD *)(v21 + v22 * v8 + 16);
          v15 = v9 & 0xFFFFFFFFFFFFFFF8LL;
          do
          {
            v16 = *(v13 - 1);
            v17 = *v13;
            v13 += 2;
            v15 -= 8LL;
            *(v14 - 1) = v16;
            *v14 = v17;
            v14 += 2;
          }
          while ( v15 );
          if ( v9 == v12 )
            goto LABEL_17;
        }
        else
        {
          v12 = 0LL;
        }
        v25 = v12 + v20 * v10;
        v26 = (_DWORD *)(v21 + 4 * (v12 + v22 * v10));
        v27 = (int *)(v19 + 4 * v25);
        v28 = v9 - v12;
        do
        {
          v29 = *v27++;
          --v28;
          *v26++ = v29;
        }
        while ( v28 );
      }
LABEL_17:
      v30 = v18 + v9;
      v31 = v9;
      if ( v18 >= 1 )
      {
        do
        {
          v32 = *(_OWORD *)(*a2 + 4 * (v31 + v10 * a2[4]));
          v33 = v31 + v10 * a1[1];
          v31 += 4LL;
          *(_OWORD *)(*a1 + 4 * v33) = v32;
        }
        while ( v31 < v30 );
      }
      if ( v30 < v7 )
      {
        v34 = *a2;
        v35 = a2[4];
        v36 = *a1;
        v37 = a1[1];
        v38 = v7 - v9 - v18;
        if ( v38 <= 7
          || v36 + 4 * (v9 + v37 * v10 + v18) < (unsigned __int64)(v34 + 4 * (v7 + v35 * v10))
          && v34 + 4 * (v9 + v35 * v10 + v18) < (unsigned __int64)(v36 + 4 * (v7 + v37 * v10)) )
        {
          goto LABEL_26;
        }
        v39 = v36 + 4 * (v9 + v37 * v10 + v18);
        v30 += v38 & 0xFFFFFFFFFFFFFFF8LL;
        v40 = (__int128 *)(v34 + 4 * (v9 + v35 * v10 + v18) + 16);
        v41 = (_OWORD *)(v39 + 16);
        v42 = v38 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v43 = *(v40 - 1);
          v44 = *v40;
          v42 -= 8LL;
          v40 += 2;
          *(v41 - 1) = v43;
          *v41 = v44;
          v41 += 2;
        }
        while ( v42 );
        if ( v38 != (v38 & 0xFFFFFFFFFFFFFFF8LL) )
        {
LABEL_26:
          v45 = (_DWORD *)(v36 + 4 * (v30 + v37 * v10));
          v46 = (int *)(v34 + 4 * (v30 + v35 * v10));
          v47 = v7 - v30;
          do
          {
            v48 = *v46++;
            --v47;
            *v45++ = v48;
          }
          while ( v47 );
        }
      }
      v49 = v9 + v11;
      v50 = v49 + 3;
      if ( v49 >= 0 )
        v50 = v49;
      v9 = v49 - (v50 & 0xFFFFFFFFFFFFFFFCLL);
      ++v10;
      if ( v7 < v9 )
        v9 = v7;
      v8 += 4LL;
    }
    while ( v10 != v6 );
  }
  return a1;
}
// 527FC: mask 0xFFFFFFFFFFFFFFF8 is shortened because x13.8 <= 0x7FFFFFFFFFFFFFFF

//----- (0000000000052A3C) ----------------------------------------------------
float __fastcall PlaneSeg::fitPlane(PlaneSeg *this)
{
  float v2; // s1
  float v3; // s2
  float v4; // s3
  float v5; // s4
  float v6; // s5
  float v7; // s6
  float v8; // s0
  float v9; // s16
  float v10; // s7
  float v11; // s0
  float v12; // s7
  float v13; // s18
  float v14; // s20
  float v15; // s21
  float v16; // s1
  float v17; // s3
  float v18; // s5
  float v19; // w8
  unsigned __int32 v20; // w9
  float v21; // s1
  float v22; // s5
  float v23; // s0
  float v24; // s2
  float v25; // s4
  float v26; // s3
  float v27; // s3
  float v28; // s1
  float result; // s0
  char v30[8]; // [xsp+8h] [xbp-58h] BYREF
  float32x2_t v31; // [xsp+10h] [xbp-50h] BYREF
  float v32; // [xsp+18h] [xbp-48h]
  int v33[4]; // [xsp+38h] [xbp-28h] BYREF
  __int64 v34; // [xsp+48h] [xbp-18h]

  v34 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *((float *)this + 2);
  v3 = *((float *)this + 3);
  v4 = *((float *)this + 4);
  v5 = *((float *)this + 5);
  v6 = *((float *)this + 8);
  v7 = *((float *)this + 9);
  v8 = (float)*(int *)this;
  v9 = v3 / v8;
  v10 = v2 / v8;
  v11 = v4 / v8;
  *((float *)this + 17) = v10;
  *((float *)this + 18) = v9;
  v12 = v2 * v10;
  v13 = v2 * v11;
  v14 = v4 * v11;
  v15 = *((float *)this + 10);
  v16 = v6 - (float)(v2 * v9);
  v17 = *((float *)this + 6);
  v18 = *((float *)this + 7);
  *((float *)this + 19) = v11;
  gte::NISymmetricEigensolver3x3<float>::operator()(
    (__int64)v30,
    1,
    (__int64)v33,
    &v31,
    v5 - v12,
    v16,
    v7 - v13,
    v17 - (float)(v3 * v9),
    v15 - (float)(v3 * v11),
    v18 - v14);
  v20 = v31.n64_u32[1];
  v19 = v32;
  v22 = v31.n64_f32[1];
  v21 = v31.n64_f32[0];
  v23 = *(float *)v33;
  v24 = *(float *)&v33[1];
  v25 = v32;
  v26 = (float)((float)(v31.n64_f32[0] * *((float *)this + 17)) + (float)(*((float *)this + 18) * v31.n64_f32[1]))
      + (float)(*((float *)this + 19) * v32);
  *((float *)this + 23) = -v26;
  if ( v26 >= 0.0 )
  {
    v21 = -v21;
    *((float *)this + 21) = -v22;
    *((float *)this + 22) = -v25;
    *((float *)this + 23) = v26;
  }
  else
  {
    *((_DWORD *)this + 21) = v20;
    *((float *)this + 22) = v19;
  }
  v27 = *(float *)this;
  *((float *)this + 20) = v21;
  v28 = v24 / v23;
  result = v23 / (float)SLODWORD(v27);
  *((float *)this + 14) = v28;
  *((float *)this + 15) = result;
  return result;
}
// 52A3C: using guessed type char var_58[8];

//----- (0000000000052B68) ----------------------------------------------------
float __fastcall PlaneSeg::expandSegment(int *a1, __int64 *a2)
{
  __int64 v2; // x8
  float v3; // w9
  float result; // s0

  v2 = *a2;
  v3 = *(float *)a1;
  *(float32x4_t *)(a1 + 2) = vaddq_f32(*(float32x4_t *)(*a2 + 8), *(float32x4_t *)(a1 + 2));
  *(float32x4_t *)(a1 + 6) = vaddq_f32(*(float32x4_t *)(v2 + 24), *(float32x4_t *)(a1 + 6));
  result = *(float *)(v2 + 40) + *((float *)a1 + 10);
  *((float *)a1 + 10) = result;
  *a1 = LODWORD(v3) + *(_DWORD *)v2;
  return result;
}

//----- (0000000000052BB0) ----------------------------------------------------
long double __fastcall PlaneSeg::clearPoints(PlaneSeg *this)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 10) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  return result;
}

//----- (0000000000052BC8) ----------------------------------------------------
void __fastcall gte::NISymmetricEigensolver3x3<float>::operator()(
        __int64 a1,
        int a2,
        __int64 a3,
        float32x2_t *a4,
        float a5,
        float a6,
        float a7,
        float a8,
        float a9,
        float a10)
{
  float v10; // s6
  float v11; // s7
  float v12; // s16
  float v13; // s17
  float v14; // s7
  float v15; // s17
  unsigned __int64 StatusReg; // x24
  float v17; // s13
  float v20; // s12
  float v21; // s11
  float v22; // s16
  float v23; // s17
  float v24; // s0
  float v26; // s4
  float v27; // s5
  float v28; // s8
  float v29; // s4
  float v30; // s5
  float v31; // s9
  float *v32; // x8
  float v33; // s0
  float v35; // s14
  float v36; // s15
  float v37; // s0
  float v38; // s10
  float v39; // s0
  float v40; // s0
  float v41; // s6
  float v42; // s7
  float *v43; // x25
  unsigned __int32 *v44; // x26
  int32x2_t v45; // d6
  float v46; // s0
  float v47; // s1
  float v48; // s2
  float v49; // s4
  float v50; // s5
  float v51; // s3
  float v52; // s1
  float v53; // s2
  int32x2_t v54; // d6
  float v55; // s0
  float v56; // s3
  float v57; // s1
  float v58; // s2
  float v59; // s4
  float v60; // s5
  float v61; // s0
  float v62; // s1
  float v63; // s2
  __int64 v64; // x10
  __int64 v65; // x9
  __int64 v66; // x8
  int v67; // w11
  __int64 v68; // x13
  __int64 v69; // x15
  __int128 v70; // q0
  __int128 v71; // q1
  int v72; // w13
  char *v73; // x15
  unsigned __int32 v74; // w16
  unsigned __int64 v75; // x15
  char *v76; // x10
  unsigned __int64 v77; // x10
  int v78; // w9
  char *v79; // x8
  unsigned __int32 v80; // w9
  unsigned __int64 v81; // x8
  float v82; // s1
  float v83; // [xsp+Ch] [xbp-D4h]
  float v84; // [xsp+10h] [xbp-D0h]
  float v85; // [xsp+14h] [xbp-CCh]
  float v86; // [xsp+18h] [xbp-C8h]
  int v87; // [xsp+1Ch] [xbp-C4h] BYREF
  __int128 v88[2]; // [xsp+20h] [xbp-C0h] BYREF
  int v89; // [xsp+40h] [xbp-A0h]
  __int64 v90; // [xsp+48h] [xbp-98h] BYREF
  int v91; // [xsp+50h] [xbp-90h]
  __int64 v92; // [xsp+58h] [xbp-88h]

  v10 = fabsf(a5);
  v11 = fabsf(a6);
  v12 = fabsf(a7);
  v13 = fabsf(a8);
  if ( v10 < v11 )
    v10 = v11;
  v14 = fabsf(a9);
  if ( v12 < v13 )
    v12 = v13;
  v15 = fabsf(a10);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( v14 < v15 )
    v14 = v15;
  if ( v10 < v12 )
    v10 = v12;
  if ( v10 >= v14 )
    v17 = v10;
  else
    v17 = v14;
  v92 = *(_QWORD *)(StatusReg + 40);
  if ( v17 == 0.0 )
  {
    *(_QWORD *)a3 = 0LL;
    *(_DWORD *)(a3 + 8) = 0;
    *(_OWORD *)a4->n64_u64 = xmmword_54780;
    *(_OWORD *)a4[2].n64_u64 = xmmword_54780;
    a4[4].n64_u32[0] = 1065353216;
  }
  else
  {
    v20 = (float)(1.0 / v17) * a6;
    v21 = (float)(1.0 / v17) * a7;
    v22 = (float)(1.0 / v17) * a5;
    v23 = (float)(1.0 / v17) * a9;
    v24 = (float)(v23 * v23) + (float)((float)(v20 * v20) + (float)(v21 * v21));
    v26 = (float)(1.0 / v17) * a8;
    if ( v24 <= 0.0 )
    {
      *(float *)a3 = v22;
      v43 = (float *)(a3 + 8);
      *(float *)(a3 + 4) = v26;
      v44 = (unsigned __int32 *)(a3 + 4);
      *(_OWORD *)a4->n64_u64 = xmmword_54780;
      *(_OWORD *)a4[2].n64_u64 = xmmword_54780;
      a4[4].n64_u32[0] = 1065353216;
    }
    else
    {
      v27 = (float)(1.0 / v17) * a10;
      v28 = (float)(v27 + (float)(v22 + v26)) / 3.0;
      v85 = (float)(1.0 / v17) * a8;
      v86 = v22;
      v29 = v26 - v28;
      v83 = v27;
      v84 = v23;
      v30 = v27 - v28;
      v31 = sqrtf(
              (float)((float)(v24 + v24)
                    + (float)((float)(v30 * v30)
                            + (float)((float)((float)(v22 - v28) * (float)(v22 - v28)) + (float)(v29 * v29))))
            / 6.0);
      LODWORD(v90) = -1082130432;
      v32 = (float *)&v90;
      *(float *)v88 = (float)((float)((float)(v21 * (float)((float)(v20 * v23) - (float)(v21 * v29)))
                                    + (float)((float)((float)(v22 - v28)
                                                    * (float)((float)(v29 * v30) - (float)(v23 * v23)))
                                            - (float)(v20 * (float)((float)(v20 * v30) - (float)(v23 * v21)))))
                            / (float)(v31 * (float)(v31 * v31)))
                    * 0.5;
      if ( *(float *)v88 >= -1.0 )
        v32 = (float *)v88;
      v33 = *v32;
      v87 = 1065353216;
      if ( v33 > 1.0 )
        v32 = (float *)&v87;
      *(float *)v88 = *v32;
      v35 = *(float *)v88;
      v36 = acosf(*(float *)v88) / 3.0;
      v37 = cosf(v36);
      v38 = v37 + v37;
      v39 = cosf(v36 + 2.0944);
      v40 = v39 + v39;
      v41 = v28 + (float)(v31 * v40);
      v42 = v28 + (float)(v31 * v38);
      *(float *)a3 = v41;
      v43 = (float *)(a3 + 8);
      *(float *)(a3 + 4) = v28 - (float)(v31 * (float)(v38 + v40));
      v44 = (unsigned __int32 *)(a3 + 4);
      *(float *)(a3 + 8) = v42;
      if ( v35 >= 0.0 )
      {
        gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(
          v86,
          v20,
          v21,
          v85,
          v84,
          v83,
          v42,
          a1,
          (float *)&a4[3]);
        v54.n64_u32[0] = *v44;
        gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(
          v86,
          v20,
          v21,
          v85,
          v84,
          v83,
          v54,
          a1,
          (float *)&a4[3],
          (float *)&a4[1] + 1);
        v56 = a4[1].n64_f32[1];
        v55 = a4[2].n64_f32[0];
        v57 = a4[3].n64_f32[1];
        v58 = a4[4].n64_f32[0];
        v59 = a4[2].n64_f32[1];
        v60 = a4[3].n64_f32[0];
        a4->n64_f32[0] = (float)(v55 * v58) - (float)(v59 * v57);
        a4->n64_f32[1] = (float)(v59 * v60) - (float)(v58 * v56);
        a4[1].n64_f32[0] = (float)(v57 * v56) - (float)(v55 * v60);
      }
      else
      {
        gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(v86, v20, v21, v85, v84, v83, v41, a1, (float *)a4);
        v45.n64_u32[0] = *v44;
        gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(
          v86,
          v20,
          v21,
          v85,
          v84,
          v83,
          v45,
          a1,
          (float *)a4,
          (float *)&a4[1] + 1);
        v46 = a4->n64_f32[1];
        v47 = a4[2].n64_f32[0];
        v48 = a4[2].n64_f32[1];
        v49 = a4[1].n64_f32[0];
        v50 = a4[1].n64_f32[1];
        v51 = v47 * a4->n64_f32[0];
        v52 = (float)(v46 * v48) - (float)(v49 * v47);
        v53 = (float)(v49 * v50) - (float)(v48 * a4->n64_f32[0]);
        a4[3].n64_f32[0] = v52;
        a4[3].n64_f32[1] = v53;
        a4[4].n64_f32[0] = v51 - (float)(v46 * v50);
      }
    }
    v61 = v17 * *(float *)a3;
    *(float *)a3 = v61;
    v62 = v17 * *(float *)v44;
    *(float *)v44 = v62;
    v63 = v17 * *v43;
    *v43 = v63;
    if ( a2 )
    {
      if ( v61 >= v62 )
      {
        if ( v63 >= v62 )
        {
          if ( v63 >= v61 )
          {
            v64 = 0LL;
            v67 = 0;
            v66 = 1LL;
            v65 = 2LL;
          }
          else
          {
            v65 = 0LL;
            v66 = 1LL;
            v64 = 2LL;
            v67 = 1;
          }
        }
        else
        {
          v65 = 0LL;
          v67 = 0;
          v66 = 2LL;
          v64 = 1LL;
        }
      }
      else if ( v63 >= v61 )
      {
        v66 = 0LL;
        if ( v63 >= v62 )
        {
          v64 = 1LL;
          v65 = 2LL;
          v67 = 1;
        }
        else
        {
          v67 = 0;
          v65 = 1LL;
          v64 = 2LL;
        }
      }
      else
      {
        v64 = 0LL;
        v65 = 1LL;
        v66 = 2LL;
        v67 = 1;
      }
      v68 = *(_QWORD *)a3;
      if ( a2 == -1 )
        v69 = v65;
      else
        v69 = v66;
      v91 = *(_DWORD *)(a3 + 8);
      v90 = v68;
      v70 = *(_OWORD *)a4->n64_u64;
      v71 = *(_OWORD *)a4[2].n64_u64;
      v72 = *((_DWORD *)&v90 + v69);
      if ( a2 != -1 )
        v66 = v65;
      v89 = a4[4].n64_i32[0];
      v88[0] = v70;
      v88[1] = v71;
      *(_DWORD *)a3 = v72;
      v73 = (char *)v88 + 12 * v69;
      v74 = *((_DWORD *)v73 + 2);
      v75 = *(_QWORD *)v73;
      a4[1].n64_u32[0] = v74;
      a4->n64_u64[0] = v75;
      LODWORD(v75) = *((_DWORD *)&v90 + v64);
      v76 = (char *)v88 + 12 * v64;
      *v44 = v75;
      LODWORD(v75) = *((_DWORD *)v76 + 2);
      v77 = *(_QWORD *)v76;
      a4[2].n64_u32[1] = v75;
      *(unsigned __int64 *)((char *)a4[1].n64_u64 + 4) = v77;
      v78 = *((_DWORD *)&v90 + v66);
      v79 = (char *)v88 + 12 * v66;
      *(_DWORD *)v43 = v78;
      v80 = *((_DWORD *)v79 + 2);
      v81 = *(_QWORD *)v79;
      a4[4].n64_u32[0] = v80;
      a4[3].n64_u64[0] = v81;
      if ( v67 == (a2 == -1) )
      {
        v82 = -a4[4].n64_f32[0];
        a4[3].n64_u64[0] = vneg_f32(a4[3]).n64_u64[0];
        a4[4].n64_f32[0] = v82;
      }
    }
  }
}
// 52E7C: variable 'v45' is possibly undefined
// 52F40: variable 'v54' is possibly undefined
// 54780: using guessed type __int128 xmmword_54780;

//----- (00000000000530FC) ----------------------------------------------------
void __fastcall PlaneSeg::~PlaneSeg(void **this)
{
  free(this[18]);
  free(this[15]);
  free(this[12]);
}

//----- (000000000005312C) ----------------------------------------------------
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector0(
        float a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        float a7,
        __int64 a8,
        float *a9)
{
  float v9; // s0
  float v10; // s3
  float v11; // s5
  float v12; // s6
  float v13; // s16
  float v14; // s17
  float v15; // s18
  float v16; // s2
  float v17; // s20
  float v18; // s21
  float v19; // s22
  float v20; // s19
  float v21; // s4
  float v22; // s3
  float v23; // s0
  float v24; // s1
  float v25; // s7
  float v26; // s6
  float v27; // s2
  float v28; // s5
  float v29; // s4
  float v30; // s3
  float v31; // s16
  float v32; // s18
  float v33; // s17
  float v34; // s19
  int v35; // w8
  float v36; // s3
  float v37; // s4
  float v38; // s2
  float v39; // s0
  float v40; // s0
  float v41; // s1

  v9 = a1 - a7;
  v10 = a4 - a7;
  v11 = a6 - a7;
  v12 = a2 * a5;
  v13 = a2 * a3;
  v14 = a3 * a5;
  v15 = a3 * a3;
  v16 = v10 * a3;
  v17 = v10 * v9;
  v18 = v11 * a2;
  v19 = v11 * v9;
  v20 = a5 * a5;
  v21 = v9 * a5;
  v22 = v10 * v11;
  v23 = v12 - v16;
  v24 = v17 - (float)(a2 * a2);
  v25 = v18 - v14;
  v26 = v15 - v19;
  v27 = v13 - v21;
  v28 = v21 - v13;
  v29 = v22 - v20;
  v30 = v14 - v18;
  v31 = (float)(v24 * v24) + (float)((float)(v23 * v23) + (float)(v27 * v27));
  v32 = (float)(v28 * v28) + (float)((float)(v25 * v25) + (float)(v26 * v26));
  v33 = (float)(v23 * v23) + (float)((float)(v29 * v29) + (float)(v30 * v30));
  if ( v32 <= v31 )
    v34 = (float)(v24 * v24) + (float)((float)(v23 * v23) + (float)(v27 * v27));
  else
    v34 = (float)(v28 * v28) + (float)((float)(v25 * v25) + (float)(v26 * v26));
  v35 = v32 > v31;
  if ( v33 > v34 )
    v35 = 2;
  if ( v35 == 1 )
  {
    v40 = 1.0 / sqrtf(v32);
    v37 = v25 * v40;
    v38 = v26 * v40;
    v39 = v28 * v40;
  }
  else if ( v35 )
  {
    v41 = 1.0 / sqrtf(v33);
    v37 = v29 * v41;
    v38 = v30 * v41;
    v39 = v23 * v41;
  }
  else
  {
    v36 = 1.0 / sqrtf(v31);
    v37 = v23 * v36;
    v38 = v27 * v36;
    v39 = v24 * v36;
  }
  *a9 = v37;
  a9[1] = v38;
  a9[2] = v39;
}

//----- (0000000000053240) ----------------------------------------------------
void __fastcall gte::NISymmetricEigensolver3x3<float>::ComputeEigenvector1(
        float a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        int32x2_t a7,
        __int64 a8,
        float *a9,
        float *a10)
{
  float v10; // s18
  float v11; // s19
  float v12; // s20
  float v13; // s7
  float v14; // s17
  float v15; // s7
  float v16; // s16
  float v17; // s7
  float v18; // s23
  float v19; // s24
  float v20; // s25
  float32x2_t v21; // d26
  float v22; // s18
  float32x2_t v23; // d21
  float v24; // s19
  float32x2_t v25; // d20
  float32x2_t v26; // d22
  float32x2_t v27; // d0
  float32x2_t v28; // d1
  float32x2_t v29; // d2
  float v30; // s5
  float32x2_t v31; // d2
  unsigned __int64 v32; // d4
  float v33; // s0
  unsigned __int64 v34; // d1
  float v35; // s2
  float v36; // s4
  float v37; // s1
  float v38; // s3
  float v39; // s0
  float v40; // s1
  float v41; // s0

  v10 = *a9;
  v11 = a9[1];
  v12 = a9[2];
  if ( fabsf(*a9) <= fabsf(v11) )
  {
    v17 = 1.0 / sqrtf((float)(v11 * v11) + (float)(v12 * v12));
    v16 = v12 * v17;
    v15 = -(float)(v11 * v17);
    v14 = 0.0;
  }
  else
  {
    v13 = 1.0 / sqrtf((float)(v10 * v10) + (float)(v12 * v12));
    v14 = -(float)(v12 * v13);
    v15 = v10 * v13;
    v16 = 0.0;
  }
  v18 = v10 * v15;
  v19 = v10 * v16;
  v20 = v11 * v14;
  v21.n64_f32[0] = v14;
  v22 = (float)(v11 * v15) - (float)(v16 * v12);
  v23.n64_f32[0] = v16;
  v24 = (float)(v14 * v12) - v18;
  v25.n64_f32[0] = v15;
  v26.n64_u64[0] = vdup_lane_s32(a7, 0).n64_u64[0];
  v21.n64_f32[1] = v22;
  v23.n64_f32[1] = v24;
  v25.n64_f32[1] = v19 - v20;
  v27.n64_u64[0] = vadd_f32(vadd_f32(vmul_n_f32(v21, a1), vmul_n_f32(v23, a2)), vmul_n_f32(v25, a3)).n64_u64[0];
  v28.n64_u64[0] = vadd_f32(vadd_f32(vmul_n_f32(v21, a2), vmul_n_f32(v23, a4)), vmul_n_f32(v25, a5)).n64_u64[0];
  v29.n64_u64[0] = vadd_f32(vadd_f32(vmul_n_f32(v21, a3), vmul_n_f32(v23, a5)), vmul_n_f32(v25, a6)).n64_u64[0];
  v30 = vmuls_lane_f32(v15, v29, 1);
  v31.n64_u64[0] = vadd_f32(vmul_f32(v25, v29), vadd_f32(vmul_f32(v21, v27), vmul_f32(v23, v28))).n64_u64[0];
  v32 = vabd_f32(v31, v26).n64_u64[0];
  v33 = v30 + (float)(vmuls_lane_f32(v14, v27, 1) + vmuls_lane_f32(v16, v28, 1));
  v34 = vsub_f32(v31, v26).n64_u64[0];
  v35 = fabsf(v33);
  if ( *(float *)&v32 >= *((float *)&v32 + 1) )
  {
    if ( *(float *)&v32 >= v35 )
      v38 = *(float *)&v32;
    else
      v38 = v35;
    if ( v38 > 0.0 )
    {
      if ( *(float *)&v32 >= v35 )
      {
        v37 = v33 / *(float *)&v34;
        goto LABEL_20;
      }
      v39 = *(float *)&v34 / v33;
LABEL_18:
      v40 = 1.0 / sqrtf((float)(v39 * v39) + 1.0);
      v41 = v39 * v40;
LABEL_21:
      v14 = (float)(v14 * v40) - (float)(v22 * v41);
      v16 = (float)(v16 * v40) - (float)(v24 * v41);
      v15 = (float)(v15 * v40) - (float)((float)(v19 - v20) * v41);
    }
  }
  else
  {
    if ( *((float *)&v32 + 1) >= v35 )
      v36 = *((float *)&v32 + 1);
    else
      v36 = v35;
    if ( v36 > 0.0 )
    {
      if ( *((float *)&v32 + 1) < v35 )
      {
        v37 = *((float *)&v34 + 1) / v33;
LABEL_20:
        v41 = 1.0 / sqrtf((float)(v37 * v37) + 1.0);
        v40 = v37 * v41;
        goto LABEL_21;
      }
      v39 = v33 / *((float *)&v34 + 1);
      goto LABEL_18;
    }
  }
  *a10 = v14;
  a10[1] = v16;
  a10[2] = v15;
}

//----- (0000000000053414) ----------------------------------------------------
unsigned __int64 __fastcall std::__next_prime(unsigned __int64 this)
{
  unsigned int *v1; // x8
  unsigned __int64 v2; // x9
  unsigned __int64 v3; // x10
  unsigned int *v4; // x11
  unsigned int *v5; // x11
  unsigned int v6; // t1
  unsigned __int64 result; // x0
  unsigned __int64 v8; // x9
  __int64 v9; // x13
  unsigned __int64 v10; // x12
  unsigned int *v11; // x11
  unsigned __int64 v12; // x14
  unsigned int *v13; // x15
  unsigned int *v14; // x15
  unsigned int v15; // t1
  __int64 v16; // x11
  __int64 v17; // x13
  unsigned __int64 v18; // x14
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x15
  unsigned __int64 v21; // x16
  unsigned __int64 v22; // x16
  unsigned __int64 v23; // x16
  unsigned __int64 v24; // x16
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x16
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x16
  unsigned __int64 v30; // x16
  unsigned __int64 v31; // x16
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x16
  unsigned __int64 v35; // x16
  unsigned __int64 v36; // x16
  unsigned __int64 v37; // x16
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x16
  unsigned __int64 v40; // x16
  unsigned __int64 v41; // x16
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x16
  unsigned __int64 v44; // x16
  unsigned __int64 v45; // x16
  unsigned __int64 v46; // x16
  unsigned __int64 v47; // x16
  unsigned __int64 v48; // x16
  unsigned __int64 v49; // x16
  unsigned __int64 v50; // x16
  unsigned __int64 v51; // x16
  unsigned __int64 v52; // x16
  unsigned __int64 v53; // x16
  unsigned __int64 v54; // x16
  unsigned __int64 v55; // x16
  unsigned __int64 v56; // x16
  unsigned __int64 v57; // x16
  unsigned __int64 v58; // x16
  unsigned __int64 v59; // x16
  unsigned __int64 v60; // x16
  unsigned __int64 v61; // x16
  unsigned __int64 v62; // x16
  unsigned __int64 v63; // x16
  unsigned __int64 v64; // x16
  unsigned __int64 v65; // x16
  unsigned __int64 v66; // x14
  unsigned __int64 v67; // x15
  unsigned __int64 v68; // x16
  unsigned __int64 v69; // x13
  std::runtime_error *exception; // x19

  if ( this > 0xD3 )
  {
    if ( this >= 0xFFFFFFFFFFFFFFC6LL )
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_53B70(exception, "__next_prime overflow");
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::overflow_error,
        (void (__fastcall *)(void *))&std::overflow_error::~overflow_error);
    }
    v8 = this / 0xD2;
    v9 = 210 * (this / 0xD2);
    v10 = 48LL;
    v11 = dword_5526C;
    do
    {
      v12 = v10 >> 1;
      v13 = &v11[v10 >> 1];
      v15 = *v13;
      v14 = v13 + 1;
      v10 += ~(v10 >> 1);
      if ( this % 0xD2 > v15 )
        v11 = v14;
      else
        v10 = v12;
    }
    while ( v10 );
    v16 = v11 - dword_5526C;
LABEL_19:
    result = v9 + dword_5526C[v16];
    v17 = 5LL;
    while ( 1 )
    {
      v18 = dword_551AC[v17];
      if ( result / v18 < v18 )
        break;
      if ( result == result / v18 * v18 )
      {
LABEL_15:
        if ( v16 == 47 )
        {
          ++v8;
          v16 = 0LL;
        }
        else
        {
          ++v16;
        }
        v9 = 210 * v8;
        goto LABEL_19;
      }
      if ( (unsigned __int64)++v17 >= 0x2F )
      {
        v19 = 211LL;
        while ( result / v19 >= v19 )
        {
          if ( result == result / v19 * v19 )
            goto LABEL_15;
          v20 = result / (v19 + 10);
          if ( v20 < v19 + 10 )
            break;
          if ( result == v20 * (v19 + 10) )
            goto LABEL_15;
          v21 = result / (v19 + 12);
          if ( v21 < v19 + 12 )
            break;
          if ( result == v21 * (v19 + 12) )
            goto LABEL_15;
          v22 = result / (v19 + 16);
          if ( v22 < v19 + 16 )
            break;
          if ( result == v22 * (v19 + 16) )
            goto LABEL_15;
          v23 = result / (v19 + 18);
          if ( v23 < v19 + 18 )
            break;
          if ( result == v23 * (v19 + 18) )
            goto LABEL_15;
          v24 = result / (v19 + 22);
          if ( v24 < v19 + 22 )
            break;
          if ( result == v24 * (v19 + 22) )
            goto LABEL_15;
          v25 = result / (v19 + 28);
          if ( v25 < v19 + 28 )
            break;
          if ( result == v25 * (v19 + 28) )
            goto LABEL_15;
          v26 = result / (v19 + 30);
          if ( v26 < v19 + 30 )
            break;
          if ( result == v26 * (v19 + 30) )
            goto LABEL_15;
          v27 = result / (v19 + 36);
          if ( v27 < v19 + 36 )
            break;
          if ( result == v27 * (v19 + 36) )
            goto LABEL_15;
          v28 = result / (v19 + 40);
          if ( v28 < v19 + 40 )
            break;
          if ( result == v28 * (v19 + 40) )
            goto LABEL_15;
          v29 = result / (v19 + 42);
          if ( v29 < v19 + 42 )
            break;
          if ( result == v29 * (v19 + 42) )
            goto LABEL_15;
          v30 = result / (v19 + 46);
          if ( v30 < v19 + 46 )
            break;
          if ( result == v30 * (v19 + 46) )
            goto LABEL_15;
          v31 = result / (v19 + 52);
          if ( v31 < v19 + 52 )
            break;
          if ( result == v31 * (v19 + 52) )
            goto LABEL_15;
          v32 = result / (v19 + 58);
          if ( v32 < v19 + 58 )
            break;
          if ( result == v32 * (v19 + 58) )
            goto LABEL_15;
          v33 = result / (v19 + 60);
          if ( v33 < v19 + 60 )
            break;
          if ( result == v33 * (v19 + 60) )
            goto LABEL_15;
          v34 = result / (v19 + 66);
          if ( v34 < v19 + 66 )
            break;
          if ( result == v34 * (v19 + 66) )
            goto LABEL_15;
          v35 = result / (v19 + 70);
          if ( v35 < v19 + 70 )
            break;
          if ( result == v35 * (v19 + 70) )
            goto LABEL_15;
          v36 = result / (v19 + 72);
          if ( v36 < v19 + 72 )
            break;
          if ( result == v36 * (v19 + 72) )
            goto LABEL_15;
          v37 = result / (v19 + 78);
          if ( v37 < v19 + 78 )
            break;
          if ( result == v37 * (v19 + 78) )
            goto LABEL_15;
          v38 = result / (v19 + 82);
          if ( v38 < v19 + 82 )
            break;
          if ( result == v38 * (v19 + 82) )
            goto LABEL_15;
          v39 = result / (v19 + 88);
          if ( v39 < v19 + 88 )
            break;
          if ( result == v39 * (v19 + 88) )
            goto LABEL_15;
          v40 = result / (v19 + 96);
          if ( v40 < v19 + 96 )
            break;
          if ( result == v40 * (v19 + 96) )
            goto LABEL_15;
          v41 = result / (v19 + 100);
          if ( v41 < v19 + 100 )
            break;
          if ( result == v41 * (v19 + 100) )
            goto LABEL_15;
          v42 = result / (v19 + 102);
          if ( v42 < v19 + 102 )
            break;
          if ( result == v42 * (v19 + 102) )
            goto LABEL_15;
          v43 = result / (v19 + 106);
          if ( v43 < v19 + 106 )
            break;
          if ( result == v43 * (v19 + 106) )
            goto LABEL_15;
          v44 = result / (v19 + 108);
          if ( v44 < v19 + 108 )
            break;
          if ( result == v44 * (v19 + 108) )
            goto LABEL_15;
          v45 = result / (v19 + 112);
          if ( v45 < v19 + 112 )
            break;
          if ( result == v45 * (v19 + 112) )
            goto LABEL_15;
          v46 = result / (v19 + 120);
          if ( v46 < v19 + 120 )
            break;
          if ( result == v46 * (v19 + 120) )
            goto LABEL_15;
          v47 = result / (v19 + 126);
          if ( v47 < v19 + 126 )
            break;
          if ( result == v47 * (v19 + 126) )
            goto LABEL_15;
          v48 = result / (v19 + 130);
          if ( v48 < v19 + 130 )
            break;
          if ( result == v48 * (v19 + 130) )
            goto LABEL_15;
          v49 = result / (v19 + 136);
          if ( v49 < v19 + 136 )
            break;
          if ( result == v49 * (v19 + 136) )
            goto LABEL_15;
          v50 = result / (v19 + 138);
          if ( v50 < v19 + 138 )
            break;
          if ( result == v50 * (v19 + 138) )
            goto LABEL_15;
          v51 = result / (v19 + 142);
          if ( v51 < v19 + 142 )
            break;
          if ( result == v51 * (v19 + 142) )
            goto LABEL_15;
          v52 = result / (v19 + 148);
          if ( v52 < v19 + 148 )
            break;
          if ( result == v52 * (v19 + 148) )
            goto LABEL_15;
          v53 = result / (v19 + 150);
          if ( v53 < v19 + 150 )
            break;
          if ( result == v53 * (v19 + 150) )
            goto LABEL_15;
          v54 = result / (v19 + 156);
          if ( v54 < v19 + 156 )
            break;
          if ( result == v54 * (v19 + 156) )
            goto LABEL_15;
          v55 = result / (v19 + 162);
          if ( v55 < v19 + 162 )
            break;
          if ( result == v55 * (v19 + 162) )
            goto LABEL_15;
          v56 = result / (v19 + 166);
          if ( v56 < v19 + 166 )
            break;
          if ( result == v56 * (v19 + 166) )
            goto LABEL_15;
          v57 = result / (v19 + 168);
          if ( v57 < v19 + 168 )
            break;
          if ( result == v57 * (v19 + 168) )
            goto LABEL_15;
          v58 = result / (v19 + 172);
          if ( v58 < v19 + 172 )
            break;
          if ( result == v58 * (v19 + 172) )
            goto LABEL_15;
          v59 = result / (v19 + 178);
          if ( v59 < v19 + 178 )
            break;
          if ( result == v59 * (v19 + 178) )
            goto LABEL_15;
          v60 = result / (v19 + 180);
          if ( v60 < v19 + 180 )
            break;
          if ( result == v60 * (v19 + 180) )
            goto LABEL_15;
          v61 = result / (v19 + 186);
          if ( v61 < v19 + 186 )
            break;
          if ( result == v61 * (v19 + 186) )
            goto LABEL_15;
          v62 = result / (v19 + 190);
          if ( v62 < v19 + 190 )
            break;
          if ( result == v62 * (v19 + 190) )
            goto LABEL_15;
          v63 = result / (v19 + 192);
          if ( v63 < v19 + 192 )
            break;
          if ( result == v63 * (v19 + 192) )
            goto LABEL_15;
          v64 = result / (v19 + 196);
          if ( v64 < v19 + 196 )
            break;
          if ( result == v64 * (v19 + 196) )
            goto LABEL_15;
          v65 = result / (v19 + 198);
          v66 = v19 + 198;
          if ( v65 < v19 + 198 )
            break;
          if ( result == v65 * (v19 + 198) )
            goto LABEL_15;
          v67 = v19 + 208;
          v68 = result / (v19 + 208);
          v69 = v19 + 208;
          if ( v68 < v66 + 10 )
            break;
          v19 = v69 + 2;
          if ( result == v68 * v67 )
            goto LABEL_15;
        }
        return result;
      }
    }
  }
  else
  {
    v1 = dword_551AC;
    v2 = 48LL;
    do
    {
      v3 = v2 >> 1;
      v4 = &v1[v2 >> 1];
      v6 = *v4;
      v5 = v4 + 1;
      v2 += ~(v2 >> 1);
      if ( v6 < this )
        v1 = v5;
      else
        v2 = v3;
    }
    while ( v2 );
    return *v1;
  }
  return result;
}
// 551AC: using guessed type unsigned int dword_551AC[24];
// 5526C: using guessed type unsigned int dword_5526C[24];

//----- (0000000000053B70) ----------------------------------------------------
__int64 __fastcall sub_53B70(std::runtime_error *a1, const char *a2)
{
  __int64 result; // x0

  result = std::runtime_error::runtime_error(a1, a2);
  *(_QWORD *)a1 = (char *)&`vtable for'std::overflow_error + 16;
  return result;
}

//----- (0000000000053BA0) ----------------------------------------------------
__int64 __fastcall std::random_device::random_device(_DWORD *a1, __int64 a2)
{
  const char *v4; // x0
  __int64 result; // x0
  unsigned int v6; // w20
  const char *v7; // x2
  char *v8; // x1
  __int64 v9[2]; // [xsp+0h] [xbp-40h] BYREF
  void *v10; // [xsp+10h] [xbp-30h]
  __int64 v11; // [xsp+18h] [xbp-28h]

  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v4 = *(const char **)(a2 + 16);
  else
    v4 = (const char *)(a2 + 1);
  result = open(v4, 0);
  *a1 = result;
  if ( (result & 0x80000000) != 0 )
  {
    v6 = *(_DWORD *)__errno();
    std::operator+<char>("random_device failed to open ", (unsigned __int8 *)a2, v9);
    if ( (v9[0] & 1) != 0 )
      LODWORD(v8) = (_DWORD)v10;
    else
      v8 = (char *)v9 + 1;
    std::__throw_system_error((std::__ndk1 *)v6, (int)v8, v7);
  }
  return result;
}
// 53C44: variable 'v7' is possibly undefined
// 12CC0: using guessed type __int64 __errno(void);

//----- (0000000000053C68) ----------------------------------------------------
__int64 *__usercall std::operator+<char>@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, __int64 *a3@<X8>)
{
  size_t v6; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x22
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24
  void *v12; // x1
  unsigned __int64 v14; // x25

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  v6 = strlen(a1);
  v7 = *a2;
  if ( (v7 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v7 >> 1;
  v9 = v8 + v6;
  if ( v8 + v6 >= 0xFFFFFFFFFFFFFFF0LL )
    std::__basic_string_common<true>::__throw_length_error();
  v10 = v6;
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * v6;
    v11 = (char *)a3 + 1;
    if ( !v6 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v14 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v11 = (void *)operator new(v14);
  a3[1] = v10;
  a3[2] = (__int64)v11;
  *a3 = v14 | 1;
  if ( v10 )
LABEL_7:
    memcpy(v11, a1, v10);
LABEL_8:
  *((_BYTE *)v11 + v10) = 0;
  if ( (v7 & 1) != 0 )
    v12 = (void *)*((_QWORD *)a2 + 2);
  else
    v12 = a2 + 1;
  return std::string::append(a3, v12, v8);
}

//----- (0000000000053D64) ----------------------------------------------------
void __fastcall std::random_device::~random_device(std::random_device *this)
{
  close(*(_DWORD *)this);
}

//----- (0000000000053D80) ----------------------------------------------------
__int64 __fastcall std::random_device::operator()(int *a1)
{
  unsigned int *p_buf; // x20
  size_t v3; // x21
  ssize_t v4; // x0
  const char *v5; // x2
  std::__ndk1 *v6; // x0
  const char *v7; // x2
  unsigned int buf; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v10; // [xsp+8h] [xbp-28h]

  p_buf = &buf;
  v3 = 4LL;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  do
  {
    while ( 1 )
    {
      v4 = read(*a1, p_buf, v3);
      if ( v4 != -1 )
        break;
      v6 = (std::__ndk1 *)*(unsigned int *)__errno();
      if ( (_DWORD)v6 != 4 )
        goto LABEL_9;
    }
    if ( !v4 )
    {
      v6 = (std::__ndk1 *)std::__throw_system_error(
                            (std::__ndk1 *)((unsigned int)&word_3C + 1),
                            (int)"random_device got EOF",
                            v5);
LABEL_9:
      std::__throw_system_error(v6, (int)"random_device got an unexpected error", v7);
    }
    v3 -= v4;
    p_buf = (unsigned int *)((char *)p_buf + v4);
  }
  while ( v3 );
  return buf;
}
// 53DE8: conditional instruction was optimized away because x21.8!=0
// 53E20: variable 'v5' is possibly undefined
// 53E2C: variable 'v7' is possibly undefined
// 3C: using guessed type __int16 word_3C;
// 12CC0: using guessed type __int64 __errno(void);

//----- (0000000000053E34) ----------------------------------------------------
double __fastcall std::random_device::entropy(std::random_device *this)
{
  return 0.0;
}

// nfuncs=840 queued=516 decompiled=516 lumina nreq=0 worse=0 better=0
// ALL OK, 516 function(s) have been successfully decompiled
